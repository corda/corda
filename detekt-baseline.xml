<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ClassNaming:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge.ArtemisState$AMQP_STARTED : ArtemisState</ID>
    <ID>ClassNaming:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge.ArtemisState$AMQP_STARTING : ArtemisState</ID>
    <ID>ClassNaming:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge.ArtemisState$AMQP_STOPPED : ArtemisState</ID>
    <ID>ClassNaming:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge.ArtemisState$STOPPED_AMQP_START_SCHEDULED : ArtemisState</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$FINALISING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$SIGNING_TX : Step</ID>
    <ID>ClassNaming:BlobWriter.kt$_Li_</ID>
    <ID>ClassNaming:BlobWriter.kt$_Mis_</ID>
    <ID>ClassNaming:BlobWriter.kt$_i_</ID>
    <ID>ClassNaming:BlobWriter.kt$_i_is__</ID>
    <ID>ClassNaming:BlobWriter.kt$_is_</ID>
    <ID>ClassNaming:BuyerFlow.kt$BuyerFlow$STARTING_BUY : Step</ID>
    <ID>ClassNaming:CompositeMemberCompositeSchemaToClassCarpenterTests.kt$I_</ID>
    <ID>ClassNaming:CordaServiceTest.kt$CordaServiceTest.DummyServiceFlow.Companion$TEST_STEP : Step</ID>
    <ID>ClassNaming:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer.Companion$AWAITING_REQUEST : Step</ID>
    <ID>ClassNaming:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer.Companion$SENDING_TOP_UP_ISSUE_REQUEST : Step</ID>
    <ID>ClassNaming:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$outer</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$EXTRACTING_VAULT_STATES : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$ID_OTHER_NODES : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$OTHER_TX_COMPONENTS : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$SENDING_AND_RECEIVING_DATA : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$SIGS_GATHERING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_BUILDING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_SIGNING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_VERIFICATION : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$VERIFYING_SIGS : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$ResponderFlow.Companion$RECEIVING_AND_SENDING_DATA : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$ExceptionFlow$START_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$InitiatedReceiveFlow$RECEIVED_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$InitiatedReceiveFlow$START_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$ReceiveFlow$RECEIVED_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$ReceiveFlow$START_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$AsyncRetryFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$InitiatedFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$InitiatorFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$RetryFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$ThrowingFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:GenericsTests.kt$GenericsTests$cl : ClassLoader</ID>
    <ID>ClassNaming:GenericsTests.kt$GenericsTests$implementsGenericInterfaceI&lt;out T&gt;</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Receive.Companion$RECEIVING_CERTIFICATES : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Receive.Companion$RECEIVING_IDENTITIES : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Send.Companion$SYNCING_IDENTITIES : Step</ID>
    <ID>ClassNaming:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow.Companion$EVOLVING_STATES_TX : Step</ID>
    <ID>ClassNaming:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow.Companion$GENERATING_INITIAL_TX : Step</ID>
    <ID>ClassNaming:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow.Companion$SENDING_RESULTS : Step</ID>
    <ID>ClassNaming:NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.kt$NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:SellerFlow.kt$SellerFlow.Companion$SELF_ISSUING : Step</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testBoolean</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testDouble</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testFloat</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testShort</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$AWAITING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$GENERATING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$SIGNING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$VERIFYING_IDENTITY : Step</ID>
    <ID>ClassNaming:TestCommsFlow.kt$TestCommsFlowInitiator$RECIEVED_ALL : Step</ID>
    <ID>ClassNaming:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests.AbstractTimedFlow.Companion$STEP_1 : Step</ID>
    <ID>ClassNaming:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests.AbstractTimedFlow.Companion$STEP_2 : Step</ID>
    <ID>ClassNaming:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests.AbstractTimedFlow.Companion$STEP_3 : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$SENDING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary.Companion$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$AWAITING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$VERIFYING_AND_SIGNING : Step</ID>
    <ID>ComplexCondition:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$c.isWhitespace() || c.isJavaIdentifierPart() || c.isJavaIdentifierStart() || c == '.' || c == ',' || c == '?' || c == '*'</ID>
    <ID>ComplexCondition:Address.kt$Address.Companion$parts.size != 2 || parts[0].isBlank() || parts[1].isBlank() || parts[1].toIntOrNull() == null</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$!that.javaClass.name.endsWith("ObjectField") || arrayValue != null || that.field.type == java.lang.String::class.java || value == null</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$(checkpointId != null) || ((clazz.name == instrumentClassname) &amp;&amp; (input.total() &gt;= minimumSize) &amp;&amp; (input.total() &lt;= maximumSize))</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$(checkpointId != null) || ((obj.javaClass.name == instrumentClassname) &amp;&amp; (output.total() &gt;= minimumSize) &amp;&amp; (output.total() &lt;= maximumSize))</ID>
    <ID>ComplexCondition:ConfigUtilities.kt$value is Temporal || value is NetworkHostAndPort || value is CordaX500Name || value is Path || value is URL || value is UUID || value is X500Principal</ID>
    <ID>ComplexCondition:CordaClassResolver.kt$CordaClassResolver$type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))</ID>
    <ID>ComplexCondition:DbScriptRunner.kt$ListPopulator$(continueOnError || dropStatement &amp;&amp; ignoreFailedDrops) || createUser</ID>
    <ID>ComplexCondition:DeserializationInput.kt$DeserializationInput$type != TypeIdentifier.UnknownType.getLocalType() &amp;&amp; serializer.type != type &amp;&amp; with(serializer.type) { !isSubClassOf(type) &amp;&amp; !materiallyEquivalentTo(type) }</ID>
    <ID>ComplexCondition:FloatControlListenerService.kt$FloatControlListenerService$amqpControlServer == null || activeConnectionInfo == null || forwardLegalName == null || forwardAddress == null || !stateHelper.active</ID>
    <ID>ComplexCondition:FlowMessaging.kt$FlowMessagingImpl$(exception is KryoException || exception is NotSerializableException) &amp;&amp; message is ExistingSessionMessage &amp;&amp; message.payload is ErrorSessionMessage</ID>
    <ID>ComplexCondition:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$it != null &amp;&amp; (it is FlowLogic&lt;*&gt; || it is FlowStateMachine&lt;*&gt; || it is Fiber&lt;*&gt; || it is SerializeAsToken)</ID>
    <ID>ComplexCondition:Hooker.kt$Hooker$className.startsWith("java") || className.startsWith("sun") || className.startsWith("javassist") || className.startsWith("kotlin")</ID>
    <ID>ComplexCondition:InternalUtils.kt$it.type == this &amp;&amp; it.isPublic &amp;&amp; it.isStatic &amp;&amp; it.isFinal</ID>
    <ID>ComplexCondition:Main.kt$Main$(hostname != null) &amp;&amp; (port != null) &amp;&amp; (username != null) &amp;&amp; (password != null)</ID>
    <ID>ComplexCondition:Schema.kt$obj == null || obj is DescribedType || obj is Binary || forGenericType(type).run { isPrimitive(this) || this == TopType }</ID>
    <ID>ComplexCondition:TopLevelTransition.kt$TopLevelTransition$currentState.isTransactionTracked &amp;&amp; checkpoint.flowState is FlowState.Started &amp;&amp; checkpoint.flowState.flowIORequest is FlowIORequest.WaitForLedgerCommit &amp;&amp; checkpoint.flowState.flowIORequest.hash == event.transaction.id</ID>
    <ID>ComplexCondition:WireTransaction.kt$WireTransaction$notary != null &amp;&amp; (inputs.isNotEmpty() || references.isNotEmpty() || timeWindow != null)</ID>
    <ID>ComplexMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>ComplexMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun onSocketConnected(connected: Boolean)</ID>
    <ID>ComplexMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>ComplexMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any)</ID>
    <ID>ComplexMethod:AMQPClient.kt$AMQPClient.ClientChannelInitializer$override fun initChannel(ch: SocketChannel)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingRawType$override fun accept(c: Char)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifiers.kt$AMQPTypeIdentifiers$fun nameForType(typeIdentifier: TypeIdentifier): String</ID>
    <ID>ComplexMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>ComplexMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$@Synchronized protected fun draw(moveUp: Boolean, error: Throwable? = null)</ID>
    <ID>ComplexMethod:AbstractNode.kt$AbstractNode$open fun start(): S</ID>
    <ID>ComplexMethod:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>ComplexMethod:ActionExecutorImpl.kt$ActionExecutorImpl$@Suspendable override fun executeAction(fiber: FlowFiber, action: Action)</ID>
    <ID>ComplexMethod:AggregatedListTest.kt$AggregatedListTest$@Test fun removeWorks()</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$private fun set(key: K, value: V, logWarning: Boolean, store: (K, V) -&gt; V?): Boolean</ID>
    <ID>ComplexMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$private fun doActivity()</ID>
    <ID>ComplexMethod:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>ComplexMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>ComplexMethod:BackChainResolutionSampler.kt$BackChainResolutionSampler$override fun createFlowInvoke(rpcProxy: CordaRPCOps, testContext: JavaSamplerContext): BaseFlowSampler.FlowInvoke&lt;*&gt;</ID>
    <ID>ComplexMethod:BackChainResolutionSampler.kt$BackChainResolutionSampler$override fun setupTest(rpcProxy: CordaRPCOps, testContext: JavaSamplerContext)</ID>
    <ID>ComplexMethod:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>ComplexMethod:BullyLeader.kt$BullyLeaderClient$private fun messageEvent(message: LeaderMessage)</ID>
    <ID>ComplexMethod:BullyLeader.kt$BullyLeaderClient$private fun timerEvent()</ID>
    <ID>ComplexMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Clients Randomly do Things`()</ID>
    <ID>ComplexMethod:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CashSelectionOracleImpl.kt$CashSelectionOracleImpl$override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun prettyStatsTree(indent: Int, statsInfo: StatsInfo, identityInfo: IdentityInfo, builder: StringBuilder)</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>ComplexMethod:CheckpointDumper.kt$CheckpointDumper$fun dump()</ID>
    <ID>ComplexMethod:CheckpointDumper.kt$CheckpointDumper$private fun FlowIORequest&lt;*&gt;.toSuspendedOn(suspendedTimestamp: Instant, now: Instant): SuspendedOn</ID>
    <ID>ComplexMethod:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>ComplexMethod:CollectSignaturesFlow.kt$CollectSignaturesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Command visibility tests`()</ID>
    <ID>ComplexMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we create a listener for a *nested* list. Note that 'indexMap' doesn't need to be adjusted on any // of these changes as the indices of nested lists don't change, just their contents. private fun createListener(wrapped: WrappedObservableList&lt;A&gt;): ListChangeListener&lt;A&gt;</ID>
    <ID>ComplexMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$// For Iterables figure out the type parameter and apply the same logic as above on the individual elements. private fun Iterable&lt;*&gt;.toConfigIterable(field: Field): Iterable&lt;Any?&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: ManagedCryptoService? = null)</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN") // Reflect over the fields of the receiver and generate a value Map that can use to create Config object. private fun Any.toConfigMap(): Map&lt;String, Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType): Collection&lt;Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Collection&lt;Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType): Any?</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Any?</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun convertValue(value: Any): Any</ID>
    <ID>ComplexMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>ComplexMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>ComplexMethod:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>ComplexMethod:CordaCliWrapper.kt$fun CordaCliWrapper.start(args: Array&lt;String&gt;)</ID>
    <ID>ComplexMethod:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>ComplexMethod:CordaRPCClient.kt$CordaRPCClientConfiguration$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `shutdown command stops the node`()</ID>
    <ID>ComplexMethod:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$override fun runProgram(): Int</ID>
    <ID>ComplexMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private fun doFindCustomSerializer(clazz: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>ComplexMethod:DbScriptRunner.kt$ListPopulator$override fun populate(connection: Connection)</ID>
    <ID>ComplexMethod:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$override fun start()</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNodeInternal(config: NodeConfig, webAddress: NetworkHostAndPort, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters, bytemanPort: Int? = null): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startRegisteredNode(name: CordaX500Name, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters, p2pAddress: NetworkHostAndPort = portAllocation.nextHostAndPort(), bytemanPort: Int? = null): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl.Companion$private fun startOutOfProcessNode( config: NodeConfig, quasarJarPath: String, debugPort: Int?, bytemanJarPath: String?, bytemanPort: Int?, overriddenSystemProperties: Map&lt;String, String&gt;, maximumHeapSize: String, logLevelOverride: String?, vararg extraCmdLineFlag: String ): Process</ID>
    <ID>ComplexMethod:EnterpriseCashSelectionSQLServerImpl.kt$EnterpriseCashSelectionSQLServerImpl$override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:Expect.kt$ fun &lt;S, E : Any&gt; S.genericExpectEvents( isStrict: Boolean = true, stream: S.((E) -&gt; Unit) -&gt; Unit, expectCompose: () -&gt; ExpectCompose&lt;E&gt; )</ID>
    <ID>ComplexMethod:ExternalSourceRevocationChecker.kt$ExternalSourceRevocationChecker$ @Throws(CertPathValidatorException::class) private fun checkApprovedCRLs(cert: X509Certificate, approvedCRLs: Set&lt;X509CRL&gt;)</ID>
    <ID>ComplexMethod:FilterServiceTest.kt$FilterServiceTest$@Test fun `Basic function tests`()</ID>
    <ID>ComplexMethod:FilterServiceTest.kt$FilterServiceTest$@Test fun `Rejection tests`()</ID>
    <ID>ComplexMethod:FinalityFlow.kt$FinalityFlow$@Suspendable @Throws(NotaryException::class) override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:FirewallStartup.kt$FirewallStartup$ override fun runProgram(): Int</ID>
    <ID>ComplexMethod:FlattenedList.kt$FlattenedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out ObservableValue&lt;out A&gt;&gt;)</ID>
    <ID>ComplexMethod:FloatControlListenerService.kt$FloatControlListenerService$private fun onControlMessage(receivedMessage: ReceivedMessage)</ID>
    <ID>ComplexMethod:FlowMonitor.kt$FlowMonitor$private fun warningMessageForFlowWaitingOnIo(request: FlowIORequest&lt;*&gt;, flow: FlowStateMachineImpl&lt;*&gt;, now: Instant): String</ID>
    <ID>ComplexMethod:FlowRunner.kt$FlowRunner$private fun run()</ID>
    <ID>ComplexMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$ @Suspendable private fun processEventsUntilFlowIsResumed(isDbTransactionOpenOnEntry: Boolean, isDbTransactionOpenOnExit: Boolean): Any?</ID>
    <ID>ComplexMethod:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$@Test fun `client with highest priority becomes leader`()</ID>
    <ID>ComplexMethod:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$private fun generateRpcSslCertificates(conf: NodeConfiguration)</ID>
    <ID>ComplexMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationInMultipleContextsDoesntColideGenericTypes()</ID>
    <ID>ComplexMethod:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$@Throws(CertificateRequestException::class) override fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>ComplexMethod:HibernateConfiguration.kt$HibernateConfiguration$private fun makeSessionFactoryForSchemas(schemas: Set&lt;MappedSchema&gt;): SessionFactory</ID>
    <ID>ComplexMethod:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider$ fun createEntityManagerFactory(dataSource: DataSource, dataSourceProperties: Properties, databaseConfig: StandaloneJPANotaryDatabaseConfig, maxBatchSize: Int): EntityManagerFactory</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$override fun parseCriteria(criteria: AttachmentQueryCriteria.AttachmentsQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.VaultQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun &lt;O, R&gt; parseAggregateFunction(root: Root&lt;O&gt;, expression: CriteriaExpression.AggregateFunctionExpression&lt;O, R&gt;): Expression&lt;out Any?&gt;?</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun parse(sorting: Sort)</ID>
    <ID>ComplexMethod:Hooker.kt$Hooker$private fun instrumentBehaviour(method: CtBehavior, methodHooks: MethodHooks): List&lt;Method&gt;</ID>
    <ID>ComplexMethod:IRS.kt$InterestRateSwap.CommonLeg$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:IRS.kt$InterestRateSwap.FloatingLeg$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$ private fun maybeAbbreviateGenericType(type: Type, extraRecognisedPackage: String): String</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps)</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: CordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>ComplexMethod:JPAUniquenessProvider.kt$JPAUniquenessProvider$private fun processRequest(session: Session, request: CommitRequest, allConflicts: MutableMap&lt;StateRef, StateConsumptionDetails&gt;, toCommit: MutableList&lt;CommitRequest&gt;): UniquenessProvider.Result</ID>
    <ID>ComplexMethod:Kryo.kt$ImmutableClassSerializer$override fun read(kryo: Kryo, input: Input, type: Class&lt;T&gt;): T</ID>
    <ID>ComplexMethod:Kryo.kt$ImmutableClassSerializer$override fun write(kryo: Kryo, output: Output, obj: T)</ID>
    <ID>ComplexMethod:Launcher.kt$Launcher.Companion$internal fun prepareJMeterArguments(cmdLine: LauncherCommandLine): JMeterArgsPlus</ID>
    <ID>ComplexMethod:LoadTest.kt$LoadTest$fun run(nodes: Nodes, parameters: RunParameters, random: SplittableRandom)</ID>
    <ID>ComplexMethod:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>ComplexMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForClass(type: Class&lt;*&gt;, typeIdentifier: TypeIdentifier, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>ComplexMethod:LoginView.kt$LoginView$tailrec fun login(): NodeMonitorModel?</ID>
    <ID>ComplexMethod:LoopbackBridgeTest.kt$LoopbackBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>ComplexMethod:Main.kt$Node$fun dumpDag(f: File)</ID>
    <ID>ComplexMethod:Main.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>ComplexMethod:MainView.kt$MainView$fun initializeControls()</ID>
    <ID>ComplexMethod:MappedList.kt$MappedList$override fun sourceChanged(change: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:MerkleTransaction.kt$FilteredTransaction.Companion$ private fun filterWithFun(wtx: WireTransaction, filtering: Predicate&lt;Any&gt;): List&lt;FilteredComponentGroup&gt;</ID>
    <ID>ComplexMethod:MessagingExecutor.kt$MessagingExecutor$fun start()</ID>
    <ID>ComplexMethod:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$private fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>ComplexMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>ComplexMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun bootstrap( directory: Path, cordappJars: List&lt;Path&gt;, copyCordapps: CopyCordapps, fromCordform: Boolean, networkParametersOverrides: NetworkParametersOverrides = NetworkParametersOverrides() )</ID>
    <ID>ComplexMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun createNodeDirectoriesIfNeeded(directory: Path, fromCordform: Boolean): Boolean</ID>
    <ID>ComplexMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun updateNetworkMapCache(): Duration</ID>
    <ID>ComplexMethod:NetworkParametersReader.kt$NetworkParametersReader$fun read(): NetworkParametersAndSigned</ID>
    <ID>ComplexMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>ComplexMethod:NetworkStatusCollector.kt$NetworkStatusCollector$override fun collect(report: Report)</ID>
    <ID>ComplexMethod:NewTransaction.kt$NewTransaction$fun show(window: Window)</ID>
    <ID>ComplexMethod:NewTransaction.kt$NewTransaction$private fun newTransactionDialog(window: Window)</ID>
    <ID>ComplexMethod:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>ComplexMethod:Node.kt$Node$override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters)</ID>
    <ID>ComplexMethod:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$private fun makeUpdates(batch: Iterable&lt;CoreTransaction&gt;, statesToRecord: StatesToRecord, previouslySeen: Boolean): List&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$private fun saveStates(session: Session, states: Map&lt;StateRef, StateAndRef&lt;ContractState&gt;&gt;, now: Instant, produced: Boolean)</ID>
    <ID>ComplexMethod:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>ComplexMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun stop()</ID>
    <ID>ComplexMethod:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$override fun addNodes(nodes: List&lt;NodeInfo&gt;)</ID>
    <ID>ComplexMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrint(arr: Arrangement)</ID>
    <ID>ComplexMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBigDecimal(per: Perceivable&lt;BigDecimal&gt;)</ID>
    <ID>ComplexMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBoolean(per: Perceivable&lt;Boolean&gt;)</ID>
    <ID>ComplexMethod:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$@Synchronized private fun setLeadership(newValue: Boolean)</ID>
    <ID>ComplexMethod:Program.kt$ConfigObfuscatorCli$override fun runProgram(): Int</ID>
    <ID>ComplexMethod:ProxyUtils.kt$ProxyUtils$fun fromConfig(proxyConfig: ProxyConfig): ProxySettings</ID>
    <ID>ComplexMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$@JvmStatic fun premain(argumentsString: String?, instrumentation: Instrumentation)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun attemptReconnect()</ID>
    <ID>ComplexMethod:RPCServer.kt$RPCServer$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>ComplexMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;?): Any?</ID>
    <ID>ComplexMethod:RegistrationTool.kt$RegistrationTool$// Make sure the nodes don't have conflicting crypto service configurations private fun validateNodeHsmConfigs(configFiles: List&lt;Path&gt;)</ID>
    <ID>ComplexMethod:RegistrationTool.kt$RegistrationTool$override fun runTool()</ID>
    <ID>ComplexMethod:RemoteTypeCarpenter.kt$SchemaBuildingRemoteTypeCarpenter$override fun carpent(typeInformation: RemoteTypeInformation): Type</ID>
    <ID>ComplexMethod:ReplayedList.kt$ReplayedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:RpcReconnectTests.kt$RpcReconnectTests$ @Test fun `test that the RPC client is able to reconnect and proceed after node failure, restart, or connection reset`()</ID>
    <ID>ComplexMethod:RunOnceService.kt$RunOnceService$fun start()</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$private fun doRunMigration( run: Boolean, outputWriter: Writer?, check: Boolean, existingCheckpoints: Boolean? = null, statusLogger: Logger? = null )</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$private fun getLiquibaseDatabase(conn: JdbcConnection): Database</ID>
    <ID>ComplexMethod:SendTransactionFlow.kt$DataVendingFlow$@Suspendable override fun call(): Void?</ID>
    <ID>ComplexMethod:ShellCmdLineOptions.kt$ShellCmdLineOptions$private fun toConfigFile(): Config</ID>
    <ID>ComplexMethod:ShellCmdLineOptions.kt$ShellConfigurationFile.ShellConfigFile$fun toShellConfiguration(): ShellConfiguration</ID>
    <ID>ComplexMethod:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ComplexMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>ComplexMethod:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$private fun processRequest(request: CommitRequest, allConflicts: MutableMap&lt;StateRef, StateConsumptionDetails&gt;, toCommit: MutableList&lt;CommitRequest&gt;, entityManager: EntityManager): UniquenessProvider.Result</ID>
    <ID>ComplexMethod:StartedFlowTransition.kt$StartedFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>ComplexMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun collectRelevantErrorsToThrow(flowIORequest: FlowIORequest&lt;*&gt;, checkpoint: Checkpoint): List&lt;Throwable&gt;</ID>
    <ID>ComplexMethod:StateMachineViewer.kt$StateMachineViewer$private fun &lt;T&gt; makeResultVBox(vbox: VBox, result: T)</ID>
    <ID>ComplexMethod:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>ComplexMethod:SwapData.kt$SwapData$private fun getSwapConvention(name: String): FixedIborSwapConvention</ID>
    <ID>ComplexMethod:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>ComplexMethod:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>ComplexMethod:TopLevelTransition.kt$TopLevelTransition$override fun transition(): TransitionResult</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ComplexMethod:TransactionUtils.kt$ fun createComponentGroups(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?): List&lt;ComponentGroup&gt;</ID>
    <ID>ComplexMethod:TypeIdentifier.kt$TypeIdentifier.Companion$ fun forGenericType(type: Type, resolutionContext: Type = type): TypeIdentifier</ID>
    <ID>ComplexMethod:TypeModellingFingerPrinter.kt$FingerPrintingState$// For a type we haven't seen before, determine the correct path depending on the type of type it is. private fun fingerprintNewType(type: LocalTypeInformation)</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$fun &lt;T&gt; replaceStartEnd(p: Perceivable&lt;T&gt;, start: Instant, end: Instant): Perceivable&lt;T&gt;</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$fun evalBigDecimal(tx: LedgerTransaction, expr: Perceivable&lt;BigDecimal&gt;): BigDecimal</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$fun evalBoolean(tx: LedgerTransaction, expr: Perceivable&lt;Boolean&gt;): Boolean</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>ComplexMethod:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>ComplexMethod:Util.kt$fun replaceParty(arrangement: Arrangement, from: Party, to: Party): Arrangement</ID>
    <ID>ComplexMethod:WebServer.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>ComplexMethod:main.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>EmptyCatchBlock:BridgeSmokeTest.kt$BridgeSmokeTest${ }</ID>
    <ID>EmptyCatchBlock:BridgeTestHelper.kt${ }</ID>
    <ID>EmptyCatchBlock:BullyLeaderTest.kt$BullyLeaderTest${ }</ID>
    <ID>EmptyCatchBlock:ClockUtilsTest.kt$ClockUtilsTest${ }</ID>
    <ID>EmptyCatchBlock:JPAUniquenessProvider.kt$JPAUniquenessProvider${ }</ID>
    <ID>EmptyCatchBlock:MySQLUniquenessProvider.kt$MySQLUniquenessProvider${ }</ID>
    <ID>EmptyCatchBlock:NodeTerminalView.kt$NodeTerminalView${}</ID>
    <ID>EmptyCatchBlock:ObservablesTests.kt$ObservablesTests${ }</ID>
    <ID>EmptyCatchBlock:RPCClientProxyHandler.kt$RPCClientProxyHandler${}</ID>
    <ID>EmptyCatchBlock:RPCStabilityTests.kt$RPCStabilityTests${}</ID>
    <ID>EmptyCatchBlock:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests${ }</ID>
    <ID>EmptyCatchBlock:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider${ }</ID>
    <ID>EmptyCatchBlock:TransactionCallbackTest.kt$TransactionCallbackTest${ }</ID>
    <ID>EmptyCatchBlock:WebServer.kt$WebServer${ }</ID>
    <ID>EmptyClassBlock:BridgeReceiverService.kt$BridgeReceiverService : ServiceLifecycleSupport</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$BaseInterface</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$BaseInterface2</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$ConcreteClassWithEmptyConstructor : BaseInterface</ID>
    <ID>EmptyClassBlock:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$ConcreteClassWithNonEmptyConstructor : BaseInterface2</ID>
    <ID>EmptyClassBlock:CordaRPCClient.kt$CordaRPCClient$Companion</ID>
    <ID>EmptyClassBlock:ServiceStateTest.kt$ServiceStateTest$ServiceC : ServiceStateSupport</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$AsyncRetryFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$RetryFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$ThrowingFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowWorker.kt$FlowWorkerMessage$()</ID>
    <ID>EmptyDefaultConstructor:TestAuditService.kt$TestAuditService$()</ID>
    <ID>EmptyDefaultConstructor:TestServiceBase.kt$TestServiceBase$()</ID>
    <ID>EmptyDefaultConstructor:main.kt$Pinger$()</ID>
    <ID>EmptyElseBlock:CordaCliWrapper.kt${ }</ID>
    <ID>EmptyFunctionBlock:AMQPPrimitiveSerializer.kt$AMQPPrimitiveSerializer${ }</ID>
    <ID>EmptyFunctionBlock:AbstractNode.kt$FlowStarterImpl.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration${ }</ID>
    <ID>EmptyFunctionBlock:AzureContainerPusher.kt$AzureContainerPusher.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:BFTSmartNotaryService.kt$BFTSmartNotaryService${ }</ID>
    <ID>EmptyFunctionBlock:BackChainResolutionSampler.kt$BackChainResolutionSampler${ }</ID>
    <ID>EmptyFunctionBlock:BackpressureHandlingTest.kt$BackpressureHandlingTest.TestNotaryService${}</ID>
    <ID>EmptyFunctionBlock:BridgeSmokeTest.kt$BridgeSmokeTest${ }</ID>
    <ID>EmptyFunctionBlock:CheckpointDumperTest.kt$CheckpointDumperTest.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests.TestOpsImpl${}</ID>
    <ID>EmptyFunctionBlock:CommsContracts.kt$CommsTestContract${ }</ID>
    <ID>EmptyFunctionBlock:ComposableTypePropertySerializer.kt$AMQPCharPropertyWriteStategy${}</ID>
    <ID>EmptyFunctionBlock:ComposableTypePropertySerializer.kt$AMQPPropertyWriteStrategy${}</ID>
    <ID>EmptyFunctionBlock:ConnectionManager.kt$&lt;no name provided&gt;.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2${}</ID>
    <ID>EmptyFunctionBlock:CorDappCustomSerializer.kt$CorDappCustomSerializer${}</ID>
    <ID>EmptyFunctionBlock:CordaClassResolverTests.kt$CustomSerializable${ }</ID>
    <ID>EmptyFunctionBlock:CordaClassResolverTests.kt$DefaultSerializableSerializer${ }</ID>
    <ID>EmptyFunctionBlock:CordaMigration.kt$CordaMigration${ }</ID>
    <ID>EmptyFunctionBlock:CordaPersistence.kt$NoOpSubscriber${}</ID>
    <ID>EmptyFunctionBlock:CustomNotaryTest.kt$CustomNotaryTest.CustomNotaryService${}</ID>
    <ID>EmptyFunctionBlock:CustomSerializer.kt$CustomSerializer.CustomSerializerImp${}</ID>
    <ID>EmptyFunctionBlock:DBCheckpointStorageTests.kt$DBCheckpointStorageTests.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:DummyDealContract.kt$DummyDealContract${}</ID>
    <ID>EmptyFunctionBlock:DummyStates.kt$DoNothingContract${}</ID>
    <ID>EmptyFunctionBlock:EmptyFlow.kt$EmptyFlow${ }</ID>
    <ID>EmptyFunctionBlock:FiberMonitor.kt$FiberMonitor${ }</ID>
    <ID>EmptyFunctionBlock:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest.DummyExecutor${}</ID>
    <ID>EmptyFunctionBlock:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest.EmptyFlow${}</ID>
    <ID>EmptyFunctionBlock:FlowWorker.kt$FlowWorker.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:GroupAMoreTests.kt$GroupAMoreTests${ }</ID>
    <ID>EmptyFunctionBlock:GroupATests.kt$GroupATests${ }</ID>
    <ID>EmptyFunctionBlock:GroupBTests.kt$GroupBTests${ }</ID>
    <ID>EmptyFunctionBlock:HibernateEntityManagerFactoryProvider.kt$PersistenceOptions${ }</ID>
    <ID>EmptyFunctionBlock:InMemoryTransactionVerifierService.kt$InMemoryTransactionVerifierService${}</ID>
    <ID>EmptyFunctionBlock:Instances.kt$SignatureFactory${}</ID>
    <ID>EmptyFunctionBlock:InteractiveShellIntegrationTest.kt$FlowForCheckpointDumpingResponder.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:InteractiveShellIntegrationTest.kt$MyContract${}</ID>
    <ID>EmptyFunctionBlock:IrsDemoWebApplicationTests.kt$IrsDemoWebApplicationTests${ }</ID>
    <ID>EmptyFunctionBlock:JPANotaryService.kt$JPANotaryService${ }</ID>
    <ID>EmptyFunctionBlock:JshHelper.kt$&lt;no name provided&gt;.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:LaunchSpaceshipFlow.kt$LaunchSpaceshipFlow${ }</ID>
    <ID>EmptyFunctionBlock:LaunchSpaceshipFlow.kt$LaunchSpaceshipFlowCorrect${ }</ID>
    <ID>EmptyFunctionBlock:LocalTypeModelTests.kt$LocalTypeModelTests.&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:MyCustomNotaryService.kt$MyCustomValidatingNotaryService${}</ID>
    <ID>EmptyFunctionBlock:NoOpTestDatabaseContext.kt$NoOpTestDatabaseContext${}</ID>
    <ID>EmptyFunctionBlock:NotaryFunctionalSamplers.kt$NotariseDoubleSpendSampler${ }</ID>
    <ID>EmptyFunctionBlock:NotaryFunctionalSamplers.kt$NotariseDuplicateTransactionSampler${ }</ID>
    <ID>EmptyFunctionBlock:NotaryTestContracts.kt$NotaryTestContract${ }</ID>
    <ID>EmptyFunctionBlock:NullContract.kt$NullContract${}</ID>
    <ID>EmptyFunctionBlock:ObjectBuilder.kt$ConstructorBasedObjectBuilder${}</ID>
    <ID>EmptyFunctionBlock:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ReceiveSplitMessagesFlow.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:PersistentIdentityMigration.kt$PersistentIdentityMigration${ }</ID>
    <ID>EmptyFunctionBlock:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable${ }</ID>
    <ID>EmptyFunctionBlock:PlatformSecureRandom.kt$LinuxSecureRandomSpi${}</ID>
    <ID>EmptyFunctionBlock:Samplers.kt$CashIssueAndPaySampler${ }</ID>
    <ID>EmptyFunctionBlock:Samplers.kt$CashIssueSampler${ }</ID>
    <ID>EmptyFunctionBlock:Samplers.kt$CashPaySampler${ }</ID>
    <ID>EmptyFunctionBlock:Samplers.kt$EmptyFlowSampler${ }</ID>
    <ID>EmptyFunctionBlock:Samplers.kt$LinearStateBatchNotariseSampler${ }</ID>
    <ID>EmptyFunctionBlock:Samplers.kt$TxResolutionSampler${ }</ID>
    <ID>EmptyFunctionBlock:SchedulingContract.kt$SchedulingContract${ }</ID>
    <ID>EmptyFunctionBlock:SerializationOutputTests.kt$SerializationOutputTests.&lt;no name provided&gt;${ }</ID>
    <ID>EmptyFunctionBlock:SerializationOutputTests.kt$SerializationOutputTests.FooContract${ }</ID>
    <ID>EmptyFunctionBlock:StandaloneJPANotaryService.kt$StandaloneJPANotaryService${ }</ID>
    <ID>EmptyFunctionBlock:TestObservableContext.kt$TestObservableContext${ }</ID>
    <ID>EmptyFunctionBlock:TimedFlowTests.kt$TimedFlowTests.TestNotaryService${}</ID>
    <ID>EmptyFunctionBlock:TransactionSerializationTests.kt$TransactionSerializationTests.TestCash${ }</ID>
    <ID>EmptyFunctionBlock:TransitionExecutorImpl.kt$TransitionExecutorImpl${}</ID>
    <ID>EmptyFunctionBlock:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract${}</ID>
    <ID>EmptyFunctionBlock:UniqueDummyLinearContract.kt$UniqueDummyLinearContract${}</ID>
    <ID>EmptyFunctionBlock:UniquenessProviderTests.kt$StandaloneJPAUniquenessProviderFactory${ }</ID>
    <ID>EmptyFunctionBlock:UniquenessProviderTests.kt$UniquenessProviderFactory${}</ID>
    <ID>EmptyFunctionBlock:Utils.kt$&lt;no name provided&gt;${}</ID>
    <ID>EmptyFunctionBlock:VaultQueryTests.kt$VaultQueryTestsBase.MyContractClass${}</ID>
    <ID>EmptyFunctionBlock:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.ContractImpl${}</ID>
    <ID>EmptyFunctionBlock:VaultUpdateTests.kt$VaultUpdateTests.DummyContract${ }</ID>
    <ID>EmptyFunctionBlock:WebServerPluginRegistry.kt$WebServerPluginRegistry${}</ID>
    <ID>EmptyIfBlock:ContentSignerBuilder.kt$ContentSignerBuilder.SignatureOutputStream$if (alreadySigned) throw IllegalStateException("Cannot write to already signed object")</ID>
    <ID>EmptyKtFile:KryoHook.kt$.KryoHook.kt</ID>
    <ID>EmptyKtFile:RPCOpsWithContext.kt$.RPCOpsWithContext.kt</ID>
    <ID>EnumNaming:CliParser.kt$CliParser.Companion.NotaryHealthCheckCommand$start</ID>
    <ID>EnumNaming:CliParser.kt$CliParser.Companion.NotaryHealthCheckCommand$startAll</ID>
    <ID>EnumNaming:CliParser.kt$CliParser.Companion.NotaryHealthCheckCommand$stop</ID>
    <ID>EnumNaming:CliParser.kt$CliParser.Companion.NotaryHealthCheckCommand$stopAll</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$exception</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$exited</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$loggedIn</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$haNodeRpcAddress : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$haNodeRpcPassword : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$haNodeRpcUserName : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$normalNodeRpcAddress : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$normalNodeRpcPassword : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$normalNodeRpcUserName : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$MandatoryCommandLineArguments$scenarioType : MandatoryCommandLineArguments</ID>
    <ID>EnumNaming:Main.kt$OptionalCommandLineArguments$iterationsCount : OptionalCommandLineArguments</ID>
    <ID>EqualsWithHashCodeExist:IRSUtils.kt$FixedRate : Rate</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$DONE : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$STARTING : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$UNSTARTED : Step</ID>
    <ID>EqualsWithHashCodeExist:Utils.kt$StateRefHere</ID>
    <ID>ExplicitGarbageCollectionCall:MemUtils.kt$gc()</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(0, maxFaultyReplicas(n)) }</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(1, maxFaultyReplicas(n)) }</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(2, maxFaultyReplicas(n)) }</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(n, maxFaultyReplicas(n) + minCorrectReplicas(n)) }</ID>
    <ID>ForEachOnRange:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$forEach { logger.info("Iteration #$it") createFlowWorkerAndPerformTest(infraA, signedNetworkParameters, it).first.stop() issueCash(infraB, nodeBFlowWorkerHub, it) }</ID>
    <ID>ForEachOnRange:HibernateConfigurationTest.kt$HibernateConfigurationTest$forEach { consumeCash(it.DOLLARS) }</ID>
    <ID>ForEachOnRange:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$forEach { instance.successfulConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionSuccess", it.toDirection()) }</ID>
    <ID>ForEachOnRange:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$forEach { instance.terminatedConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionClose", it.toDirection()) }</ID>
    <ID>ForEachOnRange:VaultQueryTests.kt$VaultQueryTestsBase$forEach { val newAllStates = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, criteria = criteria).states assertThat(newAllStates.groupBy(StateAndRef&lt;*&gt;::ref)).hasSameSizeAs(allStates) assertThat(newAllStates).containsExactlyElementsOf(allStates) }</ID>
    <ID>ForEachOnRange:VaultQueryTests.kt$VaultQueryTestsBase$forEach { vaultFiller.fillWithSomeTestLinearStates(1, linearNumber = it.toLong(), linearString = it.toString()) }</ID>
    <ID>ForbiddenComment:AbstractAttachment.kt$AbstractAttachment$// TODO: read file size information from metadata instead of loading the data.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: future implementation to retrieve contract states from a Vault BLOB store</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: make parameters configurable when we get CorDapp configuration.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: revisit the back off strategy for contended spending.</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode$// TODO: Use configuration to indicate composite key should be used instead of public key for the identity.</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode$// TODO: We need a good way of handling "nice to have" shutdown events, especially those that deal with the</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode.&lt;no name provided&gt;$// TODO: Exponential backoff? It should reach max interval of eventHorizon/2.</ID>
    <ID>ForbiddenComment:AbstractScenarioRunner.kt$AbstractScenarioRunner$// TODO: start a daemon thread which will talk to HA Node and installs termination schedule to it</ID>
    <ID>ForbiddenComment:AbstractScenarioRunner.kt$AbstractScenarioRunner$// TODO: stop the daemon and dispose any other resources</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: This step should not be necessary, as signatures are re-checked in verifyRequiredSignatures.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: use keys from the keyManagementService instead</ID>
    <ID>ForbiddenComment:AffinityExecutor.kt$AffinityExecutor$// TODO: Rename this to executeWithResult</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: AutoCloseable::class.java.name,</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.io.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.lang.reflect.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.net.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: blacklistedClasses += type.name // add it, so checking is faster next time we encounter this class.</ID>
    <ID>ForbiddenComment:Arrangement.kt$Obligation$// TODO: should be replaced with something that uses Corda assets and/or cash?</ID>
    <ID>ForbiddenComment:Arrangement.kt$Obligation$// TODO: should only be allowed to transfer non-negative amounts</ID>
    <ID>ForbiddenComment:Arrangement.kt$RollOut$// TODO: fixing offset</ID>
    <ID>ForbiddenComment:Arrangement.kt$RollOut$// TODO: think about payment offset (ie. settlement) - probably it doesn't belong on a distributed ledger</ID>
    <ID>ForbiddenComment:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion$// TODO: we might want to make this value configurable.</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$// TODO: Implement a discovery engine that can trigger builds of new connections when another node registers? (later)</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$// TODO: Verify that nobody can connect to us and fiddle with our config over the socket due to the secman.</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Define and document the configuration of the bft-smart cluster.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Potentially update the bft-smart API for our use case or rebuild client and server from lower level building</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Support cluster membership changes. This requires reading about reconfiguration of bft-smart clusters and</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: Hopefully we only need to wait for the client's initial connection to the cluster, and this method can be moved to some startup code.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: Investigate ConcurrentModificationException in this method.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: for now we treat all errors as equal, compare by error type as well</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: is it safe use the last message for sender/session/sequence info</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: only return an aggregate if the majority of signatures are replies</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: return an error reported by the majority and not just the first one</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.CordaServiceReplica$// TODO: At the cluster level, join all Sender/Receiver threads.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Replica$// TODO:</ID>
    <ID>ForbiddenComment:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow$// TODO: here we assume that all error will be the same, but there might be invalid onces from mailicious nodes</ID>
    <ID>ForbiddenComment:BackChainResolutionSampler.kt$BackChainResolutionSampler$// TODO: Check parameter consistency</ID>
    <ID>ForbiddenComment:BankOfCordaClientApi.kt$BankOfCordaClientApi$// TODO: privileged security controls required</ID>
    <ID>ForbiddenComment:BankOfCordaClientApi.kt$BankOfCordaClientApi$// TODO: security controls required</ID>
    <ID>ForbiddenComment:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit</ID>
    <ID>ForbiddenComment:BridgeAMQPListenerServiceImpl.kt$BridgeAMQPListenerServiceImpl.&lt;no name provided&gt;$//TODO: No password for delegated keystore. Refactor this?</ID>
    <ID>ForbiddenComment:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$// TODO: allow enter password interactively?</ID>
    <ID>ForbiddenComment:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$// TODO: get keystore public data from crypto service? or from config?</ID>
    <ID>ForbiddenComment:Cash.kt$Cash$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:CashExitFlow.kt$CashExitFlow$// TODO: Is it safe to drop participants we don't know how to contact? Does not knowing how to contact them</ID>
    <ID>ForbiddenComment:CashPaymentFlow.kt$AbstractCashPaymentFlow$// TODO: Have some way of restricting this to states the caller controls</ID>
    <ID>ForbiddenComment:CashPaymentFlow.kt$CashPaymentFlow$// TODO: Have some way of restricting this to states the caller controls</ID>
    <ID>ForbiddenComment:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$// TODO: this needs to use a bulk call</ID>
    <ID>ForbiddenComment:CashScenarioRunner.kt$CashScenarioRunner$// TODO: Potentially implement paging validation logic for bigger data sets.</ID>
    <ID>ForbiddenComment:CashViewer.kt$CashViewer$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:CashViewer.kt$CashViewer.StateRowGraphic$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:CertRole.kt$CertRole$// TODO: Link to the specification once it has a permanent URL</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Generate equals/hashCode.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Generics.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Sandbox the generated code when a security manager is in use.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Support annotations.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: isFoo getter patterns for booleans (this is what Kotlin generates)</ID>
    <ID>ForbiddenComment:ClassWhitelists.kt$GlobalTransientClassWhiteList$// TODO: Need some concept of from which class loader</ID>
    <ID>ForbiddenComment:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$// TODO: Test that timeouts work</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow$// TODO: AbstractStateReplacementFlow needs updating to use this flow.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow.Companion$// TODO: Make the progress tracker adapt to the number of counterparties to collect from.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$SignTransactionFlow$// TODO: We should have a faster way of verifying we own a single key</ID>
    <ID>ForbiddenComment:CollectionSerializer.kt$CollectionSerializer$// TODO: Can we verify the entries in the list?</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Consider how to handle the case of mistaken issuances, or other need to patch.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Generalise the notion of an owned instrument into a superclass/supercontract. Consider composition vs inheritance.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Think about how to evolve contracts over time with new commands.</ID>
    <ID>ForbiddenComment:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$// TODO: Consider moving these two steps below into generateIssue.</ID>
    <ID>ForbiddenComment:CommercialPaperTests.kt$// TODO: The generate functions aren't tested by these tests: add them.</ID>
    <ID>ForbiddenComment:CompatibilityTest.kt$CompatibilityTest$// TODO: If this type of testing gets momentum, we can create a mini-framework that rides through list of files</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey$// TODO: replace with the more extensive, but slower, checkValidity() test.</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.Companion$// TODO: node.encoded.sequence() might be expensive, consider a faster deterministic compareTo implementation</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.NodeAndWeight$// TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal.</ID>
    <ID>ForbiddenComment:CompositeKeyTests.kt$CompositeKeyTests$// TODO: Look into a DSL for building multi-level composite keys if that becomes a common use case</ID>
    <ID>ForbiddenComment:ConfigSections.kt$CryptoServiceConfigSpec$// TODO: Need to consolidate above and this one</ID>
    <ID>ForbiddenComment:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: check transaction size is within limits</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: copy across encumbrances when performing contract upgrades</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: exclude encumbrance states from this check</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: relax this constraint once upgrading encumbered states is supported.</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: if there are encumbrance states in the inputs, just copy them across without modifying</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: re-map encumbrance pointers</ID>
    <ID>ForbiddenComment:CordaClassResolver.kt$CordaClassResolver$// TODO: Later we can support annotations on attachment classes and spin up a proxy via bytecode that we know is harmless.</ID>
    <ID>ForbiddenComment:CordaClassResolver.kt$CordaClassResolver$// TODO: come up with a more efficient way. e.g. segregate the name space by class loader.</ID>
    <ID>ForbiddenComment:CordaModuleWizardStep.kt$CordaModuleWizardPanel$//TODO: row("Package Name:") { packageName(CCFlags.growX, CCFlags.pushX) }</ID>
    <ID>ForbiddenComment:CordaRPCClient.kt$CordaRPCClientConfiguration$// TODO: acquire this value from Network Map when supported.</ID>
    <ID>ForbiddenComment:CordaTemplateProvider.kt$CordaTemplateProvider$// TODO: Provide java template.</ID>
    <ID>ForbiddenComment:Cordapp.kt$Cordapp.Info.ContractAndWorkflow$// TODO: future work in Gradle cordapp plugins to enforce separation of Contract and Workflow classes into separate jars</ID>
    <ID>ForbiddenComment:CordappImpl.kt$CordappImpl$// TODO: Also add [SchedulableFlow] as a Cordapp class</ID>
    <ID>ForbiddenComment:CordappProviderImpl.kt$CordappProviderImpl$// TODO: Use better supported APIs in Java 9</ID>
    <ID>ForbiddenComment:CordappProviderImplTests.kt$CordappProviderImplTests.Companion$// TODO: Cordapp name should differ from the JAR name</ID>
    <ID>ForbiddenComment:CoreFlowHandlers.kt$NotaryChangeHandler$// TODO: Right now all nodes will automatically approve the notary change. We need to figure out if stricter controls are necessary.</ID>
    <ID>ForbiddenComment:CrossCashTest.kt$CrossCashState$// TODO: Alternative: We may possibly reduce the complexity of the search even further using some form of</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: Check if non-ECC keys satisfy params (i.e. approved/valid RSA modulus size).</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change the val name to a more descriptive one as it's now confusing and looks like a Key type.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change val name to SPHINCS256_SHA512. This will break backwards compatibility.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: perform all cryptographic operations via Crypto.</ID>
    <ID>ForbiddenComment:CryptoUtils.kt$// TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`.</ID>
    <ID>ForbiddenComment:CustomSerializer.kt$CustomSerializer.SubClass$// TODO: should this be a custom serializer at all, or should it just be a plain AMQPSerializer?</ID>
    <ID>ForbiddenComment:CustomSerializer.kt$CustomSerializer.SubClass$// TODO: should this be empty or contain the schema of the super?</ID>
    <ID>ForbiddenComment:DbTransactionsResolver.kt$DbTransactionsResolver$// TODO: This approach has two problems. Analyze and resolve them:</ID>
    <ID>ForbiddenComment:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$// TODO: re-organise registrations into logical groups before v1.0</ID>
    <ID>ForbiddenComment:DigitalSignatureWithCert.kt$// TODO: Rename this to DigitalSignature.WithCert once we're happy for it to be public API. The methods will need documentation</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl$// TODO: Derive name from the full picked name, don't just wrap the common name</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl$//TODO: remove this once we can bundle quasar properly.</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl.Companion$// TODO: There is pending work to fix this issue without custom blacklisting. See: https://r3-cev.atlassian.net/browse/CORDA-2164.</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl.LocalNetworkMap$// TODO: this object will copy NodeInfo files from started nodes to other nodes additional-node-infos/</ID>
    <ID>ForbiddenComment:DummyFungibleContract.kt$DummyFungibleContract$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit</ID>
    <ID>ForbiddenComment:EncodingUtils.kt$// TODO: follow the crypto-conditions ASN.1 spec, some changes are needed to be compatible with the condition</ID>
    <ID>ForbiddenComment:Envelope.kt$Envelope$// TODO: don't recognise a type descriptor.</ID>
    <ID>ForbiddenComment:Envelope.kt$Envelope$// TODO: make the schema parsing lazy since mostly schemas will have been seen before and we only need it if we</ID>
    <ID>ForbiddenComment:Explorer.kt$Explorer$// TODO: Remove this code when serialisation has been upgraded.</ID>
    <ID>ForbiddenComment:ExternalBrokerTests.kt$ExternalBrokertests$// TODO: Investigate why node will hang without the sleep after broker restart.</ID>
    <ID>ForbiddenComment:ExternalBrokerTests.kt$ExternalBrokertests$// TODO: un-ignore when node will be changed to no longer die on artemis connection loss</ID>
    <ID>ForbiddenComment:FetchDataFlow.kt$FetchDataFlow$// TODO: Support "large message" response streaming so response sizes are not limited by RAM.</ID>
    <ID>ForbiddenComment:FiberUtils.kt$// TODO: This method uses a built-in Quasar function to make a map of all ThreadLocals. This is probably inefficient, but the only API readily available.</ID>
    <ID>ForbiddenComment:FixingFlow.kt$FixingFlow.Fixer$// TODO: this is in no way secure and will be replaced by general session initiation logic in the future</ID>
    <ID>ForbiddenComment:FlowIORequest.kt$FlowIORequest.ForceCheckpoint$// TODO: consider using an empty FlowAsyncOperation instead</ID>
    <ID>ForbiddenComment:FlowLogicRef.kt$FlowLogicRef$// TODO: align this with the existing [FlowRef] in the bank-side API (probably replace some of the API classes)</ID>
    <ID>ForbiddenComment:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$// TODO: Replace with a per app classloader/cordapp provider/cordapp loader - this will do for now</ID>
    <ID>ForbiddenComment:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$// TODO: This is used via RPC but it's probably better if we pass in argument names and values explicitly</ID>
    <ID>ForbiddenComment:FlowWorkerPartitioner.kt$FlowWorkerPartitioner$// TODO: Determine which is the latest, could happen if partition from last leader didn't get deleted.</ID>
    <ID>ForbiddenComment:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$// TODO: consider adding a password strength policy.</ID>
    <ID>ForbiddenComment:GuiUtilities.kt$// TODO: This is a temporary fix for the UI to show the correct issuer identity, this will break when we start randomizing keys. More work is needed here when the identity work is done.</ID>
    <ID>ForbiddenComment:HABrokerFailoverTest.kt$HABrokerFailoverTest$// TODO: Investigate why node's artemis client can't failover to out of process slave artemis server.</ID>
    <ID>ForbiddenComment:HibernateConfiguration.kt$HibernateConfiguration$// TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session</ID>
    <ID>ForbiddenComment:IRS.kt$FloatingRatePaymentEvent$// TODO: Should an uncalculated amount return a zero ? null ? etc.</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap$// TODO: Confirm: would someone really enter a swap with a negative fixed rate?</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap$// TODO: further tests</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.Commands.Mature$// Trade has matured; no more actions. Cleanup. // TODO: Do we need this?</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.State$// TODO: Jexl is purely for prototyping. It may be replaced</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.State$// TODO: Whatever we do use must be secure and sandboxed</ID>
    <ID>ForbiddenComment:IRSTests.kt$// TODO: How I want it to look</ID>
    <ID>ForbiddenComment:IRSTests.kt$// TODO: this seems to fail quite dramatically</ID>
    <ID>ForbiddenComment:IRSUtils.kt$// TODO: For further discussion.</ID>
    <ID>ForbiddenComment:IRSUtils.kt$RatioUnit$// TODO: Discuss this type</ID>
    <ID>ForbiddenComment:IdempotentFlow.kt$TimedFlow$// TODO: allow specifying retry settings per flow</ID>
    <ID>ForbiddenComment:IdenticonRenderer.kt$IdenticonRenderer$// TODO: support transparency.</ID>
    <ID>ForbiddenComment:IdentityService.kt$IdentityService$// TODO: This should be done via the network map cache, which is the authoritative source of well known identities</ID>
    <ID>ForbiddenComment:IdentitySyncFlow.kt$IdentitySyncFlow.Send$// TODO: Can this be triggered automatically from [SendTransactionFlow]?</ID>
    <ID>ForbiddenComment:IdentitySyncFlow.kt$IdentitySyncFlow.Send$// TODO: Consider if this too restrictive - we perhaps should be checking the name on the signing certificate in the certificate path instead</ID>
    <ID>ForbiddenComment:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$// TODO: Generate certificate with an EdDSA key rather than ECDSA</ID>
    <ID>ForbiddenComment:InitialRegistrationCli.kt$InitialRegistration$// TODO: Move node identity generation logic from node to registration helper.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Add a command to view last N lines/tail/control log4j2 loggers.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Add command history.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Command completion.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Configure default renderers, send objects down the pipeline, add support for xml output format.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Do something sensible with commands that return a future.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Fix up the 'dashboard' command which has some rendering issues.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Get rid of the 'java' command, it's kind of worthless.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Make it notice new shell commands added after the node started.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Resurrect or reimplement the mail plugin.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Review or fix the JVM commands which have bitrotted and some are useless.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$InteractiveShell$// TODO: A default renderer could be used, instead of an object mapper. See: http://www.crashub.org/1.3/reference.html#_renderers</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$InteractiveShell$// TODO: This utility is generally useful and might be better moved to the node class, or an RPC, if we can commit to making it stable API.</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Add inline back when a new Kotlin version is released and check if the java.lang.VerifyError</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future.</ID>
    <ID>ForbiddenComment:IrsDemoClientApi.kt$IRSDemoClientApi$// TODO: Add uploading of files to the HTTP API</ID>
    <ID>ForbiddenComment:JPAUniquenessProvider.kt$JPAUniquenessProvider$// TODO: test vs. MySQLUniquenessProvider</ID>
    <ID>ForbiddenComment:KeyStoreConfigHelpers.kt$// TODO: X509Utilities.validateCertificateChain()</ID>
    <ID>ForbiddenComment:Kryo.kt$PublicKeySerializer$// TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser.</ID>
    <ID>ForbiddenComment:Launcher.kt$// TODO: --base-directory is specific of the Node app, it should be controllable by a config property</ID>
    <ID>ForbiddenComment:LegalNameValidator.kt$LegalNameValidator.Rule.Companion$// TODO: Implement confusable character detection if we add more scripts.</ID>
    <ID>ForbiddenComment:LinearStateScenarioRunner.kt$LinearStateScenarioRunner$// TODO: Potentially implement paging validation logic for bigger data sets.</ID>
    <ID>ForbiddenComment:LoadGenerator.kt$LoadGenerator$// TODO: dynamically load adapter</ID>
    <ID>ForbiddenComment:LocalTypeInformationBuilder.kt$// TODO: Revisit this when Kotlin issue is fixed.</ID>
    <ID>ForbiddenComment:LoggingBuyerFlow.kt$LoggingBuyerFlow$// TODO: This is potentially very expensive, and requires transaction details we may no longer have once</ID>
    <ID>ForbiddenComment:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$// TODO: refactor MDC support, duplicated in AMQPBridgeManager.</ID>
    <ID>ForbiddenComment:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$// TODO: don't reinsert notarisation request on retry</ID>
    <ID>ForbiddenComment:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.Companion$// TODO: optimize table schema for InnoDB</ID>
    <ID>ForbiddenComment:NetParams.kt$NetParamsSigner$// TODO: not supported</ID>
    <ID>ForbiddenComment:NetworkBootstrapper.kt$NetworkBootstrapper$// TODO: pass a commandline parameter to the bootstrapper instead. Better yet, a notary config map</ID>
    <ID>ForbiddenComment:NetworkMapCacheTest.kt$NetworkMapCacheTest$// TODO: Should have a test case with anonymous lookup</ID>
    <ID>ForbiddenComment:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$//TODO: Remove sleep in unit test.</ID>
    <ID>ForbiddenComment:Node.kt$Node.Companion$// TODO: make this configurable.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: PLT-147: The attachment should be randomised to prevent brute force guessing and thus privacy leaks.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: Switch to a two-phase insert so we can handle attachments larger than RAM.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: this is racey. ENT-2870</ID>
    <ID>ForbiddenComment:NodeConfigurationImpl.kt$NodeConfigurationImpl$// TODO: There are two implications here:</ID>
    <ID>ForbiddenComment:NodeInfoConstants.kt$// TODO: Add to Corda node.conf to allow customisation</ID>
    <ID>ForbiddenComment:NodeInfoWatcher.kt$NodeInfoWatcher$// TODO: Use NIO watch service instead?</ID>
    <ID>ForbiddenComment:NodeInterestRates.kt$NodeInterestRates.FixContainer$// TODO: the calendar data needs to be specified for every fix type in the input string</ID>
    <ID>ForbiddenComment:NodeInterestRates.kt$NodeInterestRates.UnknownFix$// TODO: can we split into two? Fix not available (retryable/transient) and unknown (permanent)</ID>
    <ID>ForbiddenComment:NodeSchemaServiceTest.kt$NodeSchemaServiceTest$// TODO: driver limitation: cannot restrict CorDapps that get automatically created by default,</ID>
    <ID>ForbiddenComment:NodeTerminalView.kt$NodeTerminalView$// TODO: Remove this special case once Rick's serialisation work means we can deserialise states that weren't on our own classpath.</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: Optimise this.</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: Perhaps these can be stored in a batch?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: This is a catch-all solution. But why is the default pageNumber set to be -1 in the first place?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: This is expensive - is there another way?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: improve typing of returned other results</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: revisit (use single instance of parser for all queries)</ID>
    <ID>ForbiddenComment:NodeVaultServiceTest.kt$NodeVaultServiceTest$// TODO: Unit test linear state relevancy checks</ID>
    <ID>ForbiddenComment:NodeWebServer.kt$NodeWebServer$// TODO: Redesign</ID>
    <ID>ForbiddenComment:NotaryChangeFlow.kt$NotaryChangeFlow$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:NotaryChangeTests.kt$NotaryChangeTests$// TODO: Add more test cases once we have a general flow/service exception handling mechanism:</ID>
    <ID>ForbiddenComment:NotaryChangeTests.kt$NotaryChangeTests$// TODO: Re-enable the test when parameter currentness checks are in place, ENT-2666.</ID>
    <ID>ForbiddenComment:NotaryError.kt$StateConsumptionDetails$// TODO: include notary timestamp?</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: This is not required any more once our AMQP serialization supports turning off object referencing.</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: [CORDA-2274] Perform full transaction verification once verification caching is enabled.</ID>
    <ID>ForbiddenComment:NotaryRegistrationTool.kt$NotaryRegistrationTool$// TODO: Update NetworkRegistrationHelper to allow specifying a legal name for the CSR</ID>
    <ID>ForbiddenComment:NotaryServiceFlow.kt$NotaryServiceFlow.Companion$// TODO: Determine an appropriate limit and also enforce in the network parameters and the transaction builder.</ID>
    <ID>ForbiddenComment:NotaryUtils.kt$// TODO: if requestSignature was generated over an old version of NotarisationRequest, we need to be able to</ID>
    <ID>ForbiddenComment:OGUtils.kt$// TODO: Do this correctly</ID>
    <ID>ForbiddenComment:ObligationUtils.kt$ObligationUtils$// TODO: A much better (but more complex) solution would be to have two iterators, one for obligations,</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: Check that re-running this on the same transaction multiple times does the right thing.</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions exiting inputs from</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions spending inputs from</ID>
    <ID>ForbiddenComment:OracleUtils.kt$// TODO: we would ordinarily convert clock to same time zone as the index/source would announce in</ID>
    <ID>ForbiddenComment:ParametersUtilities.kt$// TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer</ID>
    <ID>ForbiddenComment:Perceivable.kt$// TODO: fix should have implied default date and perhaps tenor when used in a rollOut template</ID>
    <ID>ForbiddenComment:Perceivable.kt$Interest$// todo: holidays</ID>
    <ID>ForbiddenComment:PersistentStateService.kt$PersistentStateService$// TODO: Manage version evolution of the schemas via additional tooling.</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$//TODO: Change import namespaces vega -&gt; ....</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$PortfolioApi$// TODO: Stop using localdate.now</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$PortfolioApi$// TODO: enhancement to Vault Query to check for any participant in participants attribute</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: Expose the concept of errors.</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: It'd be helpful if this class was at least partly thread safe.</ID>
    <ID>ForbiddenComment:ProviderMap.kt$// TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider.</ID>
    <ID>ForbiddenComment:PublicKeySerializer.kt$PublicKeySerializer$// TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser.</ID>
    <ID>ForbiddenComment:RPCStabilityTests.kt$RPCStabilityTests$// TODO: This is ignored because Artemis slow consumers are broken. I'm not deleting it in case we can get the feature fixed.</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$// TODO: read &amp; put entries in batches</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Commands.CommitTransaction$// TODO: Cluster membership changes need testing.</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Commands.CommitTransaction$// TODO: I'm wondering if we should support resizing notary clusters, or if we could require users to</ID>
    <ID>ForbiddenComment:RaftUniquenessProvider.kt$RaftUniquenessProvider$// TODO: use local transport for client-server communications</ID>
    <ID>ForbiddenComment:RatesFixFlow.kt$RatesFixFlow$// TODO: Kick to a user confirmation / ui flow if it's out of bounds instead of raising an exception.</ID>
    <ID>ForbiddenComment:RatesFixFlow.kt$RatesFixFlow.FixQueryFlow$// TODO: add deadline to receive</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$// TODO: This could be done in parallel with other fetches for extra speed.</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// TODO: this operation should not require an explicit transaction</ID>
    <ID>ForbiddenComment:RestrictedEntityManager.kt$RestrictedEntityManager$// TODO: Figure out which other methods on EntityManager need to be blocked?</ID>
    <ID>ForbiddenComment:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$// assertEquals(2.POUNDS, bankBProxy.getCashBalances()[GBP]) TODO: Investigate race condition, this condition sometimes passes and sometimes not</ID>
    <ID>ForbiddenComment:ScheduledActivityObserver.kt$ScheduledActivityObserver.Companion$// TODO: Beware we are calling dynamically loaded contract code inside here.</ID>
    <ID>ForbiddenComment:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$// TODO: the queries below are not atomic so we need to allow enough time for the scheduler to finish. Would be better to query scheduler.</ID>
    <ID>ForbiddenComment:SendTransactionFlow.kt$DataVendingFlow$// Security TODO: Check for abnormally large or malformed data requests</ID>
    <ID>ForbiddenComment:SerializationHelper.kt$// TODO: surely we check it is concrete at this point with no TypeVariables</ID>
    <ID>ForbiddenComment:SerializationOutputTests.kt$SerializationOutputTests$// TODO: Generic interfaces / superclasses</ID>
    <ID>ForbiddenComment:SerializationOutputTests.kt$SerializationOutputTests$// TODO: add some schema assertions to check correctly formed.</ID>
    <ID>ForbiddenComment:SerializationScheme.kt$SerializationFactoryImpl$// TODO: This is read-mostly. Probably a faster implementation to be found.</ID>
    <ID>ForbiddenComment:ServiceHub.kt$ServicesForResolution$// TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load</ID>
    <ID>ForbiddenComment:ServiceHubCoreInternal.kt$ServiceHubCoreInternal$// TODO: This should really be called ServiceHubInternal but that name is already taken by net.corda.node.services.api.ServiceHubInternal.</ID>
    <ID>ForbiddenComment:ServiceHubInternal.kt$WritableTransactionStorage$// TODO: Throw an exception if trying to add a transaction with fewer signatures than an existing entry.</ID>
    <ID>ForbiddenComment:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// TODO: check only one (or until one is resolved successfully), max recursive invocations check?</ID>
    <ID>ForbiddenComment:SharedMemoryIncremental.kt$SharedMemoryIncremental$// TODO: Do we really need 16 bytes? Given that we care about Int it should be enough to have 4</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We could probably optimise the below by</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We need a much better way of structuring this data.</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: allow non-blocking verification.</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Receiver$// TODO: The attachments need to be added somewhere</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Receiver$// TODO: handle failures</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: In the real world, this would be tolerance aware for different types</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: The attachments need to be added somewhere</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: handle failures</ID>
    <ID>ForbiddenComment:SinglePartyNotaryService.kt$SinglePartyNotaryService$// TODO: Log the request here. Benchmarking shows that logging is expensive and we might get better performance</ID>
    <ID>ForbiddenComment:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$// TODO: don't reinsert notarisation request on retry</ID>
    <ID>ForbiddenComment:StateMachineManagerUtils.kt$//TODO: instead of replacing the progress tracker after constructing the flow logic, we should inject it during fiber deserialization</ID>
    <ID>ForbiddenComment:Structures.kt$MoveCommand$// TODO: Replace Class here with a general contract constraints object</ID>
    <ID>ForbiddenComment:SwapData.kt$SwapData$// TODO: Fix below to be correct - change tenor and reference data</ID>
    <ID>ForbiddenComment:SwapDataView.kt$// TODO: Should be able to display an array ?</ID>
    <ID>ForbiddenComment:Tests.kt$TestSource$// TODO: turn into an actual test; currently used for debugging without having to build the tool</ID>
    <ID>ForbiddenComment:ThrowableSerializer.kt$ThrowableSerializer$// TODO: This will need reworking when we have multiple class loaders</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$// TODO: Add support for making recursive resolution optional if it becomes an issue.</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$//TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$// TODO: Implement the contract sandbox loading of the contract attachments</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$//TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: we could avoid deserialising unrelated signers.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException$// TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$// TODO: add reference to documentation</ID>
    <ID>ForbiddenComment:TransactionViewer.kt$TransactionViewer.ContractStatesView$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:TransformTypes.kt$TransformTypes$// TODO: annotated with some annotation</ID>
    <ID>ForbiddenComment:TransformTypes.kt$TransformTypes$// TODO: it would be awesome to auto build this list by scanning for transform annotations themselves</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Also, the term Deal is used here where we might prefer Agreement.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Make this flow more generic.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: The subclasses should probably be broken out into individual flows rather than making this an ever expanding collection of subclasses.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow$// TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer.RECORDING$// TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// FIXME: Knowledge of confidential identities is lost on node shutdown, so Bob's node now refuses to sign the</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// TODO: Verify that the result was inserted into the transaction database.</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: calendar + rolling conventions</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: look into schedule for final dates</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: not sure this is necessary??</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: think about multi layered rollouts</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: we may have to save original start date in order to roll out correctly</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract.Commands.Split$// todo: Who should sign this?</ID>
    <ID>ForbiddenComment:UnspentStatesCache.kt$UnspentStatesCache$// TODO: When a client notarises a transaction with a large index in the state ref, we allocate a lot of memory.</ID>
    <ID>ForbiddenComment:VaultFiller.kt$VaultFiller$// TODO: need to make all FungibleAsset commands (issue, move, exit) generic</ID>
    <ID>ForbiddenComment:VaultSchema.kt$VaultSchemaV1.VaultStates$// TODO: create a distinct table to hold serialized state data (once DBTransactionStore is encrypted)</ID>
    <ID>ForbiddenComment:VaultWithCashTest.kt$// TODO: Move this to the cash contract tests once mock services are further split up.</ID>
    <ID>ForbiddenComment:WebServerConfig.kt$WebServerConfig$// TODO: remove this once config format is updated</ID>
    <ID>ForbiddenComment:WebServerConfig.kt$WebServerConfig$// TODO: replace with credentials supplied by a user</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: prevent notary field from being set if there are no inputs and no time-window.</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: revisit once Deterministic JVM code updated</ID>
    <ID>ForbiddenComment:X509Utilities.kt$CertificateType.LEGAL_IDENTITY$// TODO: Identity certs should have tight name constraints on child certificates</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_client_certificate_untrusted_to_server()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_no_ssl_on_client_side_and_ssl_on_server_side()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_ssl_disabled()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_ssl_enabled()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun CheckCashIssueAndPaymentFlow()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun CheckCashIssueAndPaymentNoSelection()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashExitFlow()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashIssueAndDoubleAnonymousPayment()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashIssueAndDoublePayment()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashIssueAndDuplicateAnonymousPayment()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashIssueAndDuplicatePayment()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashIssueFlowAndPayAnonymousKnownStates()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashIssueFlowAndPayKnownStates()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestCashPaymentFlow()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestEmptyFlow()</ID>
    <ID>FunctionNaming:CheckTestFlows.kt$CheckAllTheTestFlows$@Test fun TestLinearBatchNotarisationFlow()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Boolean()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun CordaX500Name()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Double()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Enum()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Instant()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Int()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun LocalDate()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Long()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun NetworkHostAndPort()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun ObfuscatedListOfString()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun ObfuscatedString()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Path()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Set()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun String()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun URL()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun UUID()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun X500Principal()</ID>
    <ID>FunctionNaming:ContractFunctions.kt$// building an fx swap using abstract swap fun fx_swap2(expiry: String, notional: Long, strike: Double, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>FunctionNaming:ContractFunctions.kt$fun fx_swap(expiry: String, notional: BigDecimal, strike: BigDecimal, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Double, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Int, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Long, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:FlowHookContainer.kt$FlowHookContainer$@JvmStatic @Hook("io.netty.util.internal.InternalThreadLocalMap", passThis = true, position = HookPosition.After) fun InternalThreadLocalMap( internalThreadLocalMap: Any )</ID>
    <ID>FunctionNaming:FlowHookContainer.kt$FlowHookContainer$@JvmStatic @Hook("net.corda.nodeapi.internal.persistence.DatabaseTransaction", passThis = true, position = HookPosition.After) fun DatabaseTransaction( transaction: Any, isolation: Int, threadLocal: Any, transactionBoundaries: Any, cordaPersistence: Any )</ID>
    <ID>FunctionNaming:InteractiveShell.kt$InteractiveShell$private fun _startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null)</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun AnonymousParty()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun ByteSequence()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun CertPath()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun Command()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun CompositeKey()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun CordaX500Name()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun DigitalSignature()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun DigitalSignatureWithCert()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun Instant()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun NetworkHostAndPort()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun PrivacySalt()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun PublicKey()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun SerializedBytes()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun SignatureMetadata()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun TransactionSignature()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun TransactionState()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun UUID()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun X500Principal()</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _transaction(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: T.() -&gt; EnforceVerifyOrFail): WireTransaction</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _tweak(dsl: LedgerDSLInterpreter&lt;T&gt;.() -&gt; Unit)</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _unverifiedTransaction(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: T.() -&gt; Unit): WireTransaction</ID>
    <ID>FunctionNaming:NamedCacheTest.kt$NamedCacheTest$@Test fun TestCheckCacheName()</ID>
    <ID>FunctionNaming:NodeHandleTests.kt$NodeHandleTests$@Test fun object_defined_functions_are_static_for_node_rpc_ops()</ID>
    <ID>FunctionNaming:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:PasswordTest.kt$PasswordTest$@Test fun constructor_and_getters()</ID>
    <ID>FunctionNaming:PasswordTest.kt$PasswordTest$@Test fun toString_is_masked()</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allSteps(level: Int = 0): List&lt;Pair&lt;Int, Step&gt;&gt;</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun absent_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun absent_value_of_list_type_with_single_element_and_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun absent_value_of_list_type_with_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_value_of_list_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_value_of_list_type_with_default_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_with_default_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_present_value_of_list_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_present_value_with_correct_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_present_value_with_wrong_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_of_list_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_of_list_type_with_single_element_and_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_of_list_type_with_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_with_correct_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_with_wrong_type()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun absent_list_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun absent_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun absent_value_in_nested_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun integer_numeric_type_when_floating_expected_works()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun invalid_mapped_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun list_type_when_declared_single()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun missing_list_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun missing_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun missing_value_in_nested_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun nested_property_without_schema_does_not_validate()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun single_type_when_declared_list()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun valid_mapped_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun whole_list_validation_invalid_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun whole_list_validation_valid_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_element_type_for_list()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_floating_numeric_type_when_integer_expected()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_type()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_type_in_nested_property()</ID>
    <ID>FunctionNaming:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$@Test fun showcase_flows_as_closures()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_does_not_show_sensitive_values()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_list_does_not_show_sensitive_values()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_nested_properties()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_unknown_properties()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_unknown_properties_non_strict()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_wrong_nested_properties()</ID>
    <ID>FunctionNaming:SerializationOutput.kt$SerializationOutput$internal fun &lt;T : Any&gt; _serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun chained_delegated_properties_are_not_added_multiple_times()</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun parse_list_aggregation()</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun validate_list_aggregation()</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun validate_with_domain_specific_errors()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun args_to_config()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_override_config_from_file()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_to_config_from_file()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun empty_args_to_cmd_options()</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String,String&gt;)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _tweak(dsl: TransactionDSLInterpreter.() -&gt; EnforceVerifyOrFail): EnforceVerifyOrFail</ID>
    <ID>FunctionNaming:UtilsTest.kt$UtilsTest$@Test fun serialize_deserialize_configuration()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTests$ @Test fun trackCashStates_unconsumed()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_all()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_consumed()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun unconsumedCashStatesForSpending_single_issuer_reference()</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _trackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_configuration()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_key()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_metadata()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_value()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_present()</ID>
    <ID>FunctionNaming:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$@Test fun correct_parsing_function_is_used_for_present_version()</ID>
    <ID>FunctionNaming:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$@Test fun default_value_is_used_for_absent_version()</ID>
    <ID>LargeClass:AMQPBridgeManager.kt$AMQPBridgeManager$AMQPBridge</ID>
    <ID>LargeClass:AMQPBridgeTest.kt$AMQPBridgeTest</ID>
    <ID>LargeClass:AMQPChannelHandler.kt$AMQPChannelHandler : ChannelDuplexHandler</ID>
    <ID>LargeClass:ANSIProgressRenderer.kt$ANSIProgressRenderer</ID>
    <ID>LargeClass:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>LargeClass:ActionExecutorImpl.kt$ActionExecutorImpl : ActionExecutor</ID>
    <ID>LargeClass:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>LargeClass:ArtemisConfigurationTool.kt$ArtemisConfigurationTool : HAToolBase</ID>
    <ID>LargeClass:ArtemisMessagingTest.kt$ArtemisMessagingTest</ID>
    <ID>LargeClass:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest</ID>
    <ID>LargeClass:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests</ID>
    <ID>LargeClass:AuthDBTests.kt$AuthDBTests : NodeBasedTest</ID>
    <ID>LargeClass:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService : CryptoService</ID>
    <ID>LargeClass:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest</ID>
    <ID>LargeClass:BCCryptoServiceTests.kt$BCCryptoServiceTests</ID>
    <ID>LargeClass:BackChainResolutionSampler.kt$BackChainResolutionSampler : DualNodeBaseFlowSampler</ID>
    <ID>LargeClass:BootstrapperView.kt$BootstrapperView : View</ID>
    <ID>LargeClass:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl : BridgeArtemisConnectionServiceServiceStateSupport</ID>
    <ID>LargeClass:BridgeControlListener.kt$BridgeControlListener : AutoCloseable</ID>
    <ID>LargeClass:BridgeHSMTest.kt$BridgeHSMTest : IntegrationTest</ID>
    <ID>LargeClass:BridgeIntegrationTest.kt$BridgeIntegrationTest</ID>
    <ID>LargeClass:BridgeSmokeTest.kt$BridgeSmokeTest</ID>
    <ID>LargeClass:BullyLeader.kt$BullyLeaderClient : ZkLeader</ID>
    <ID>LargeClass:BullyLeaderTest.kt$BullyLeaderTest</ID>
    <ID>LargeClass:Cap.kt$Cap</ID>
    <ID>LargeClass:CashTests.kt$CashTests</ID>
    <ID>LargeClass:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests</ID>
    <ID>LargeClass:CheckpointAgent.kt$CheckpointHook : ClassFileTransformer</ID>
    <ID>LargeClass:CheckpointDumper.kt$CheckpointDumper</ID>
    <ID>LargeClass:ClassCarpenter.kt$ClassCarpenterImpl : ClassCarpenter</ID>
    <ID>LargeClass:ClassCarpenterTest.kt$ClassCarpenterTest</ID>
    <ID>LargeClass:ClockUtilsTest.kt$ClockUtilsTest</ID>
    <ID>LargeClass:CompatibleTransactionTests.kt$CompatibleTransactionTests</ID>
    <ID>LargeClass:CompositeKeyTests.kt$CompositeKeyTests</ID>
    <ID>LargeClass:ConcatenatedList.kt$ConcatenatedList&lt;A&gt; : TransformationList</ID>
    <ID>LargeClass:ConfigObfuscatorTest.kt$ConfigObfuscatorTest</ID>
    <ID>LargeClass:ConfigParsingTest.kt$ConfigParsingTest</ID>
    <ID>LargeClass:ConfigTest.kt$ConfigTest</ID>
    <ID>LargeClass:ConnectionStateMachine.kt$ConnectionStateMachine : BaseHandler</ID>
    <ID>LargeClass:ConstraintsPropagationTests.kt$ConstraintsPropagationTests</ID>
    <ID>LargeClass:CordaClassResolverTests.kt$CordaClassResolverTests</ID>
    <ID>LargeClass:CordaRPCClientTest.kt$CordaRPCClientTest : NodeBasedTest</ID>
    <ID>LargeClass:CordaRPCOpsImpl.kt$CordaRPCOpsImpl : InternalCordaRPCOpsAutoCloseable</ID>
    <ID>LargeClass:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest</ID>
    <ID>LargeClass:CordaRPCProxyClient.kt$CordaRPCProxyClient : CordaRPCOps</ID>
    <ID>LargeClass:CordaRpcWorkerOps.kt$CordaRpcWorkerOps : CordaRPCOps</ID>
    <ID>LargeClass:CordaX500NameTest.kt$CordaX500NameTest</ID>
    <ID>LargeClass:CordappConstraintsTests.kt$CordappConstraintsTests : IntegrationTest</ID>
    <ID>LargeClass:Crypto.kt$Crypto</ID>
    <ID>LargeClass:CryptoServiceSpec.kt$CryptoServiceSpec</ID>
    <ID>LargeClass:CryptoUtilsTest.kt$CryptoUtilsTest</ID>
    <ID>LargeClass:DBTransactionStorageTests.kt$DBTransactionStorageTests</ID>
    <ID>LargeClass:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest : AmqpCarpenterBase</ID>
    <ID>LargeClass:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests : AmqpCarpenterBase</ID>
    <ID>LargeClass:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests</ID>
    <ID>LargeClass:Driver.kt$DriverParameters</ID>
    <ID>LargeClass:DriverDSLImpl.kt$DriverDSLImpl : InternalDriverDSL</ID>
    <ID>LargeClass:DriverDSLImpl.kt$DriverDSLImpl$Companion</ID>
    <ID>LargeClass:EdDSATests.kt$EdDSATests</ID>
    <ID>LargeClass:EnumEvolvabilityTests.kt$EnumEvolvabilityTests</ID>
    <ID>LargeClass:EvolvabilityTests.kt$EvolvabilityTests</ID>
    <ID>LargeClass:ExternalBrokerTests.kt$ExternalBrokertests : IntegrationTest</ID>
    <ID>LargeClass:FilterServiceTest.kt$FilterServiceTest</ID>
    <ID>LargeClass:FloatControlListenerService.kt$FloatControlListenerService : FloatControlServiceServiceStateSupport</ID>
    <ID>LargeClass:FlowFrameworkTests.kt$FlowFrameworkTests</ID>
    <ID>LargeClass:FlowHookContainer.kt$FlowHookContainer</ID>
    <ID>LargeClass:FlowLogic.kt$FlowLogic&lt;out T&gt;</ID>
    <ID>LargeClass:FlowStateMachineImpl.kt$FlowStateMachineImpl&lt;R&gt; : FiberFlowStateMachineFlowFiber</ID>
    <ID>LargeClass:FlowWorkerServiceHub.kt$FlowWorkerServiceHub : ServiceHubInternalSingletonSerializeAsToken</ID>
    <ID>LargeClass:FlowWorkerTest.kt$FlowWorkerTest</ID>
    <ID>LargeClass:GenericsTests.kt$GenericsTests</ID>
    <ID>LargeClass:HibernateConfigurationTest.kt$HibernateConfigurationTest</ID>
    <ID>LargeClass:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser : AbstractQueryCriteriaParserIQueryCriteriaParser</ID>
    <ID>LargeClass:HibernateStatistics.kt$DelegatingStatisticsService : StatisticsService</ID>
    <ID>LargeClass:IRS.kt$IRS</ID>
    <ID>LargeClass:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>LargeClass:IRSTests.kt$IRSTests</ID>
    <ID>LargeClass:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest</ID>
    <ID>LargeClass:InteractiveShell.kt$InteractiveShell</ID>
    <ID>LargeClass:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest : IntegrationTest</ID>
    <ID>LargeClass:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest</ID>
    <ID>LargeClass:InternalMockNetwork.kt$InternalMockNetwork : AutoCloseable</ID>
    <ID>LargeClass:JPAUniquenessProvider.kt$JPAUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>LargeClass:JacksonSupportTest.kt$JacksonSupportTest</ID>
    <ID>LargeClass:JarScanningCordappLoader.kt$JarScanningCordappLoader : CordappLoaderTemplate</ID>
    <ID>LargeClass:KryoTests.kt$KryoTests</ID>
    <ID>LargeClass:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>LargeClass:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests</ID>
    <ID>LargeClass:LocalSerializerFactory.kt$DefaultLocalSerializerFactory : LocalSerializerFactory</ID>
    <ID>LargeClass:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>LargeClass:LoopbackBridgeTest.kt$LoopbackBridgeTest</ID>
    <ID>LargeClass:MockNodeMessagingService.kt$MockNodeMessagingService : SingletonSerializeAsTokenMessagingService</ID>
    <ID>LargeClass:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>LargeClass:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests : IntegrationTest</ID>
    <ID>LargeClass:MySQLUniquenessProvider.kt$MySQLUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>LargeClass:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests</ID>
    <ID>LargeClass:Network.kt$Network : CordaView</ID>
    <ID>LargeClass:NetworkBootstrapper.kt$NetworkBootstrapper : NetworkBootstrapperWithOverridableParameters</ID>
    <ID>LargeClass:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests</ID>
    <ID>LargeClass:NetworkBootstrapperTest.kt$NetworkBootstrapperTest</ID>
    <ID>LargeClass:NetworkBuilder.kt$NetworkBuilderImpl : NetworkBuilder</ID>
    <ID>LargeClass:NetworkMapUpdater.kt$NetworkMapUpdater : AutoCloseable</ID>
    <ID>LargeClass:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest</ID>
    <ID>LargeClass:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest</ID>
    <ID>LargeClass:NetworkRegistrationHelper.kt$NetworkRegistrationHelper</ID>
    <ID>LargeClass:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest</ID>
    <ID>LargeClass:NewTransaction.kt$NewTransaction : Fragment</ID>
    <ID>LargeClass:Node.kt$Node : AbstractNode</ID>
    <ID>LargeClass:NodeAttachmentService.kt$NodeAttachmentService : AttachmentStorageInternalSingletonSerializeAsToken</ID>
    <ID>LargeClass:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest</ID>
    <ID>LargeClass:NodeConfigurationImpl.kt$NodeConfigurationImpl : NodeConfiguration</ID>
    <ID>LargeClass:NodeConfigurationImplTest.kt$NodeConfigurationImplTest</ID>
    <ID>LargeClass:NodeInterestRatesTest.kt$NodeInterestRatesTest</ID>
    <ID>LargeClass:NodeStartup.kt$NodeStartup : NodeStartupLogging</ID>
    <ID>LargeClass:NodeTabView.kt$NodeTabView : Fragment</ID>
    <ID>LargeClass:NodeTerminalView.kt$NodeTerminalView : Fragment</ID>
    <ID>LargeClass:NodeVaultService.kt$NodeVaultService : SingletonSerializeAsTokenVaultServiceInternal</ID>
    <ID>LargeClass:NodeVaultServiceTest.kt$NodeVaultServiceTest</ID>
    <ID>LargeClass:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests</ID>
    <ID>LargeClass:OGSwapPricingExample.kt$SwapPricingExample</ID>
    <ID>LargeClass:ObligationUtils.kt$ObligationUtils</ID>
    <ID>LargeClass:ObservablesTests.kt$ObservablesTests</ID>
    <ID>LargeClass:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>LargeClass:PartialMerkleTreeTest.kt$PartialMerkleTreeTest</ID>
    <ID>LargeClass:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests</ID>
    <ID>LargeClass:PersistentNetworkMapCache.kt$PersistentNetworkMapCache : NetworkMapCacheInternalSingletonSerializeAsToken</ID>
    <ID>LargeClass:PortfolioApi.kt$PortfolioApi</ID>
    <ID>LargeClass:PrettyPrint.kt$PrettyPrint</ID>
    <ID>LargeClass:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch : Closeable</ID>
    <ID>LargeClass:ProgressTrackerTest.kt$ProgressTrackerTest</ID>
    <ID>LargeClass:PropertyTest.kt$PropertyTest</ID>
    <ID>LargeClass:PropertyValidationTest.kt$PropertyValidationTest</ID>
    <ID>LargeClass:ProtonWrapperTests.kt$ProtonWrapperTests</ID>
    <ID>LargeClass:QueryCriteriaUtils.kt$Builder</ID>
    <ID>LargeClass:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>LargeClass:RPCDriver.kt$RPCDriverDSL : InternalDriverDSL</ID>
    <ID>LargeClass:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest</ID>
    <ID>LargeClass:RPCServer.kt$RPCServer&lt;OPS : RPCOps&gt;</ID>
    <ID>LargeClass:RPCStabilityTests.kt$RPCStabilityTests</ID>
    <ID>LargeClass:RegistrationTool.kt$RegistrationTool : HAToolBase</ID>
    <ID>LargeClass:RegistrationToolTest.kt$RegistrationToolTest</ID>
    <ID>LargeClass:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest</ID>
    <ID>LargeClass:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL : InternalDriverDSL</ID>
    <ID>LargeClass:RpcReconnectTests.kt$RpcReconnectTests : IntegrationTest</ID>
    <ID>LargeClass:RpcWorkerServiceHub.kt$RpcWorkerServiceHub : ServiceHubInternalSingletonSerializeAsToken</ID>
    <ID>LargeClass:RunOnceServiceTest.kt$RunOnceServiceTest</ID>
    <ID>LargeClass:SchemaMigration.kt$SchemaMigration</ID>
    <ID>LargeClass:SerializationOutputTests.kt$SerializationOutputTests</ID>
    <ID>LargeClass:ServiceStateTest.kt$ServiceStateTest</ID>
    <ID>LargeClass:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>LargeClass:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>LargeClass:SocksTests.kt$SocksTests</ID>
    <ID>LargeClass:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest</ID>
    <ID>LargeClass:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>LargeClass:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests</ID>
    <ID>LargeClass:StartedFlowTransition.kt$StartedFlowTransition : Transition</ID>
    <ID>LargeClass:StateMachineViewer.kt$StateMachineViewer : CordaView</ID>
    <ID>LargeClass:StatusTransitionsTest.kt$StatusTransitionsTest</ID>
    <ID>LargeClass:TLSAuthenticationTests.kt$TLSAuthenticationTests</ID>
    <ID>LargeClass:TestLauncherHelpers.kt$TestLauncherHelpers</ID>
    <ID>LargeClass:ToggleFieldTest.kt$ToggleFieldTest</ID>
    <ID>LargeClass:TopLevelTransition.kt$TopLevelTransition : Transition</ID>
    <ID>LargeClass:TransactionBuilder.kt$TransactionBuilder</ID>
    <ID>LargeClass:TransactionEncumbranceTests.kt$TransactionEncumbranceTests</ID>
    <ID>LargeClass:TransactionTests.kt$TransactionTests</ID>
    <ID>LargeClass:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>LargeClass:TunnelControlTest.kt$TunnelControlTest</ID>
    <ID>LargeClass:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService : BridgeReceiverServiceServiceStateSupport</ID>
    <ID>LargeClass:TutorialTestDSL.kt$TutorialTestDSL</ID>
    <ID>LargeClass:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests</ID>
    <ID>LargeClass:UniquenessProviderTests.kt$UniquenessProviderTests</ID>
    <ID>LargeClass:UniversalContract.kt$UniversalContract : Contract</ID>
    <ID>LargeClass:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests</ID>
    <ID>LargeClass:VaultFiller.kt$VaultFiller</ID>
    <ID>LargeClass:VaultQueryTests.kt$VaultQueryTests : VaultQueryTestsBaseVaultQueryParties</ID>
    <ID>LargeClass:VaultQueryTests.kt$VaultQueryTestsBase : VaultQueryParties</ID>
    <ID>LargeClass:VaultStateMigrationTest.kt$VaultStateMigrationTest</ID>
    <ID>LargeClass:VaultWithCashTest.kt$VaultWithCashTest</ID>
    <ID>LargeClass:WireTransaction.kt$WireTransaction : TraversableTransaction</ID>
    <ID>LargeClass:X509Utilities.kt$X509Utilities</ID>
    <ID>LargeClass:X509UtilitiesTest.kt$X509UtilitiesTest</ID>
    <ID>LargeClass:ZkClientTest.kt$ZkClientTests</ID>
    <ID>LongMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>LongMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun onSocketConnected(connected: Boolean)</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test @Ignore("Run only manually to check the throughput of the AMQP bridge") fun `AMQP full bridge throughput`()</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test fun `test healthcheck and normal messages`()</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$private fun createAMQPServer(maxMessageSize: Int = MAX_MESSAGE_SIZE, echoPhrase: String? = null): AMQPServer</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$private fun createArtemis(sourceQueueName: String?, crlCheckSoftFail: Boolean = true): Triple&lt;ArtemisMessagingServer, ArtemisMessagingClient, BridgeManager&gt;</ID>
    <ID>LongMethod:AMQPBridgeTest.kt$AMQPBridgeTest$private fun createArtemisReceiver(targetAdress: NetworkHostAndPort, workingDir: String): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any)</ID>
    <ID>LongMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise)</ID>
    <ID>LongMethod:AMQPChannelHandler.kt$AMQPChannelHandler$private fun handleSuccessfulHandshake(ctx: ChannelHandlerContext)</ID>
    <ID>LongMethod:AMQPClient.kt$AMQPClient.ClientChannelInitializer$override fun initChannel(ch: SocketChannel)</ID>
    <ID>LongMethod:AMQPExceptionsTests.kt$AMQPExceptionsTests$// However, if its a shiny new AMQPNotSerializable one, we have cool new toys, so // lets make sure those are set @Test fun catchAMQPNotSerializable()</ID>
    <ID>LongMethod:AMQPListenerTest.kt$AMQPListenerTest$@Test fun `Bad certificate audit check`()</ID>
    <ID>LongMethod:AMQPListenerTest.kt$AMQPListenerTest$@Test fun `Basic AMPQListenerService lifecycle test`()</ID>
    <ID>LongMethod:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel$ fun interpret(serializationSchemas: SerializationSchemas): Map&lt;TypeDescriptor, RemoteTypeInformation&gt;</ID>
    <ID>LongMethod:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$@Test fun `round-trip some types through AMQP serialisations`()</ID>
    <ID>LongMethod:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$private fun registerCustomSerializers(context: SerializationContext, factory: SerializerFactory)</ID>
    <ID>LongMethod:AMQPServer.kt$AMQPServer.ServerChannelInitializer$override fun initChannel(ch: SocketChannel)</ID>
    <ID>LongMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Create a new tree of steps that also holds a reference to the parent of each step. This is required to uniquely identify each step // (assuming that each step label is unique at a given level). private fun transformTree(inputTree: List&lt;InputTreeStep&gt;): List&lt;ProgressStep&gt;</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$fun printingBody()</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$private fun renderInternal(flowProgressHandle: FlowProgressHandle&lt;*&gt;?)</ID>
    <ID>LongMethod:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$override fun setup()</ID>
    <ID>LongMethod:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$@Test fun `number of cached factories must be bounded by maxFactories`()</ID>
    <ID>LongMethod:AbstractCashSelection.kt$AbstractCashSelection$ @Suspendable fun unconsumedCashStatesForSpending(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet()): List&lt;StateAndRef&lt;Cash.State&gt;&gt;</ID>
    <ID>LongMethod:AbstractCashSelection.kt$AbstractCashSelection$private fun attemptSpend(services: ServiceHub, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;): Boolean</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$ private fun loadNotaryClusterIdentity(serviceLegalName: CordaX500Name): Pair&lt;PartyAndCertificate, KeyPair&gt;</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$ private fun obtainIdentity(): Pair&lt;PartyAndCertificate, KeyPair&gt;</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$fun &lt;T : SerializeAsToken&gt; installCordaService(serviceClass: Class&lt;T&gt;): T</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$open fun start(): S</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun createAndStoreLegalIdentity(alias: String): PartyAndCertificate</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun updateNodeInfo(identity: PartyAndCertificate, identityKeyPair: KeyPair, publish: Boolean): Triple&lt;MutableSet&lt;KeyPair&gt;, NodeInfoAndSigned, PartyAndCertificate?&gt;</ID>
    <ID>LongMethod:AbstractNode.kt$AbstractNode$private fun validateKeyStores(): X509Certificate</ID>
    <ID>LongMethod:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$@Test fun `node registration with one node backed by HSM`()</ID>
    <ID>LongMethod:AbstractRPCTest.kt$AbstractRPCTest$inline fun &lt;reified I : RPCOps&gt; RPCDriverDSL.testProxy( ops: I, rpcUser: User = rpcTestUser, clientConfiguration: CordaRPCClientConfiguration = CordaRPCClientConfiguration.DEFAULT, serverConfiguration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, queueDrainTimeout: Duration = 5.seconds ): TestProxy&lt;I&gt;</ID>
    <ID>LongMethod:AbstractScenarioRunner.kt$AbstractScenarioRunner.Companion$@JvmStatic protected fun establishRpcConnection(endpoint: NetworkHostAndPort, user: String, password: String, onError: (Throwable) -&gt; CordaRPCOps = { logger.error("establishRpcConnection", it) throw it }): CordaRPCOps</ID>
    <ID>LongMethod:AbstractWrappedKeysTest.kt$AbstractWrappedKeysTest$@Test fun `node performs transactions using confidential identities with wrapped keys successfully`()</ID>
    <ID>LongMethod:AbstractZkLatch.kt$AbstractZkLatch$override fun stateChanged(client: CuratorFramework, newState: ConnectionState)</ID>
    <ID>LongMethod:ActionExecutorImpl.kt$ActionExecutorImpl$@Suspendable override fun executeAction(fiber: FlowFiber, action: Action)</ID>
    <ID>LongMethod:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$@Test fun `runs nodes with one configured to use additionalP2PAddresses`()</ID>
    <ID>LongMethod:AdvancedExceptionDialog.kt$//Attach a stacktrace for the exception that was used in the initialization of the dialog. fun AdvancedExceptionDialog.withStacktrace() : AdvancedExceptionDialog</ID>
    <ID>LongMethod:AffinityExecutorTests.kt$AffinityExecutorTests$@Test fun `pooled executor`()</ID>
    <ID>LongMethod:AffinityExecutorTests.kt$AffinityExecutorTests$@Test fun `single threaded affinity executor runs on correct thread`()</ID>
    <ID>LongMethod:AggregatedList.kt$AggregatedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out E&gt;)</ID>
    <ID>LongMethod:AggregatedList.kt$AggregatedList$private fun addItem(addedItem: E): Int?</ID>
    <ID>LongMethod:AggregatedList.kt$AggregatedList$private fun removeItem(removedItem: E): Pair&lt;Int, AggregationGroup&lt;E, A&gt;&gt;?</ID>
    <ID>LongMethod:AggregatedListTest.kt$AggregatedListTest$@Test fun removeWorks()</ID>
    <ID>LongMethod:Amount.kt$Amount.Companion$ @JvmStatic fun parseCurrency(input: String): Amount&lt;Currency&gt;</ID>
    <ID>LongMethod:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>LongMethod:AmountTests.kt$AmountTests$@Test fun `amount transfer aggregation`()</ID>
    <ID>LongMethod:AmountTests.kt$AmountTests$@Test fun `amount transfer apply`()</ID>
    <ID>LongMethod:AmountTests.kt$AmountTests$@Test fun `amount transfers equality`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$private fun set(key: K, value: V, logWarning: Boolean, store: (K, V) -&gt; V?): Boolean</ID>
    <ID>LongMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$fun alsoWrite(_value: T)</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$@Test fun `concurrent test purge between A and B`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$@Test fun `test no purge with only a single transaction`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$@Test fun `test purge mid-way in a single transaction`()</ID>
    <ID>LongMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$private fun doActivity()</ID>
    <ID>LongMethod:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$override fun runTool()</ID>
    <ID>LongMethod:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$private fun addClusterConnectorConfig(doc: Document)</ID>
    <ID>LongMethod:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$private fun addHAPolicyConfig(doc: Document)</ID>
    <ID>LongMethod:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$private fun generateBrokerXml()</ID>
    <ID>LongMethod:ArtemisConfigurationToolTest.kt$ArtemisConfigurationToolTest$@Test fun `test generate`()</ID>
    <ID>LongMethod:ArtemisConnectionTest.kt$ArtemisConnectionTest$@Test fun `Basic lifecycle test`()</ID>
    <ID>LongMethod:ArtemisMessagingClient.kt$ArtemisMessagingClient$override fun start(): Started</ID>
    <ID>LongMethod:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from // Artemis IO errors @Throws(IOException::class, AddressBindingException::class, KeyStoreException::class) private fun configureAndStartServer()</ID>
    <ID>LongMethod:ArtemisMessagingServer.kt$ArtemisMessagingServer$private fun createArtemisConfig()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$// Re-receive on different client from re-started sender @Test fun `re-send from different client and re-receive from different client is ignored`()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$// Redelivery from a sender who stops and restarts (some re-sends from the sender, with sender state reset with exception of recovered checkpoints) @Test fun `re-send from different client is ignored`()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$// Redelivery to a receiver who stops and restarts (some re-deliveries from Artemis, but with receiver state reset) @Test fun `re-receive from different client is ignored`()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$// Redelivery to a receiver who stops and restarts (some re-deliveries from Artemis, but with receiver state reset), but the original // messages were recorded as consumed out of order, and only the *second* message was acked. @Test fun `re-receive from different client is not ignored when acked out of order`()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$@Before fun setUp()</ID>
    <ID>LongMethod:ArtemisMessagingTest.kt$ArtemisMessagingTest$private fun createMessagingClient(server: NetworkHostAndPort = NetworkHostAndPort("localhost", serverPort), platformVersion: Int = 1): P2PMessagingClient</ID>
    <ID>LongMethod:ArtemisRpcTests.kt$ArtemisRpcTests$private fun testSslCommunication(nodeSSlconfig: MutualSslConfiguration, brokerSslOptions: BrokerRpcSslOptions?, useSslForBroker: Boolean, clientSslOptions: ClientRpcSslOptions?, address: NetworkHostAndPort = ports.nextHostAndPort(), adminAddress: NetworkHostAndPort = ports.nextHostAndPort(), baseDirectory: Path = tempFolder.root.toPath() )</ID>
    <ID>LongMethod:ArtemisUtils.kt$private fun createArtemisTextCertsLogin(artemisDir: Path, p2pPort: Int, p2pSslOptions: MutualSslConfiguration): ActiveMQServer</ID>
    <ID>LongMethod:AsyncLoadTestFlow.kt$AsyncLoadTestFlow$private fun runBatch(transactionCount: Int): Long</ID>
    <ID>LongMethod:AttachmentDemo.kt$@Suppress("DEPRECATION") // DOCSTART 1 fun recipient(rpc: CordaRPCOps, webPort: Int)</ID>
    <ID>LongMethod:AttachmentDemo.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:AttachmentDemoTest.kt$AttachmentDemoTest$// run with a 10,000,000 bytes in-memory zip file. In practice, a slightly bigger file will be used (~10,002,000 bytes). @Test fun `attachment demo using a 10MB zip file`()</ID>
    <ID>LongMethod:AttachmentDownloadServlet.kt$AttachmentDownloadServlet$@Throws(IOException::class) override fun doGet(req: HttpServletRequest, resp: HttpServletResponse)</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `calculateAllTrustInfo attachments signed by blacklisted keys output without trust root fields filled in`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `calculateAllTrustInfo only returns signed attachments or attachments manually installed on the node`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `calculateAllTrustInfo returns all attachment trust roots`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar not trusted if different key but same contract`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar not trusted if signed by a blacklisted key and not uploaded by trusted uploader`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar trusted if same key but different contract`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar trusted if signed by same key and has same contract as existing jar uploaded by a trusted uploader`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar trusted if the signing keys are a subset of an existing trusted jar's signers`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar trusted if the signing keys are a superset of an existing trusted jar's signers`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar trusted if the signing keys are an intersection of an existing trusted jar's signers`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `jar with inherited trust does not grant trust to other jars (no chain of trust)`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `neither jar trusted if same contract and signer but not uploaded by a trusted uploader`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `non-contract jar trusted if trusted jar with same key present`()</ID>
    <ID>LongMethod:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$@Test fun `non-contract jars not trusted if uploaded by non trusted uploaders`()</ID>
    <ID>LongMethod:AttachmentTrustTable.kt$AttachmentTrustTable$private fun createRows()</ID>
    <ID>LongMethod:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>LongMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>LongMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader.Companion$ private fun setOrDecorateURLStreamHandlerFactory()</ID>
    <ID>LongMethod:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$ fun &lt;T&gt; withAttachmentsClassloaderContext(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T): T</ID>
    <ID>LongMethod:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$@Test fun `Can serialize and deserialize with an attachment classloader`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading a trusted attachment that is signed by a blacklisted key`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed by a trusted uploader - intersection of keys match existing attachment`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Attachments with inherited trust do not grant trust to attachments being loaded (no chain of trust)`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if it is signed by a blacklisted key even if there is another attachment signed by the same keys that is trusted`()</ID>
    <ID>LongMethod:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if no other attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>LongMethod:AuthDBTests.kt$AuthDBTests$@Before override fun setUp()</ID>
    <ID>LongMethod:AzureBackend.kt$AzureBackend.Companion$fun fromContext(context: Context): AzureBackend</ID>
    <ID>LongMethod:AzureInstantiator.kt$AzureInstantiator$override fun instantiateContainer(imageId: String, portsToOpen: List&lt;Int&gt;, instanceName: String, env: Map&lt;String, String&gt;?): CompletableFuture&lt;Pair&lt;String, Map&lt;Int, Int&gt;&gt;&gt;</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Content signer works with X509Utilities`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate P-256 ECDSA key with hardware protection, sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate P-256 ECDSA key with software protection, sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate P-256K ECDSA key with hardware protection, sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate P-256K ECDSA key with software protection, sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate RSA key with hardware protection, sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate RSA key with software protection, sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate key with the default legal identity scheme, then sign and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate key with the default legal identity scheme, then sign using MD5withRSA and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate key with the default legal identity scheme, then sign using SHA512WITHECDSA (checking case) and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate key with the default legal identity scheme, then sign using SHA512withECDSA and verify data`()</ID>
    <ID>LongMethod:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate key with the default legal identity scheme, then sign using SHA512withRSA and verify data`()</ID>
    <ID>LongMethod:BCCryptoServiceTests.kt$BCCryptoServiceTests$private fun createKeystore(alias: String, keyPair: KeyPair) : CertificateStoreSupplier</ID>
    <ID>LongMethod:BCCryptoServiceTests.kt$BCCryptoServiceTests$private fun generateKeyAndSignForScheme(cryptoService: BCCryptoService, signatureScheme: SignatureScheme)</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$@Test fun `detect double spend`()</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$@Test fun `transactions can be re-notarised outside their time window`()</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$@Test fun `transactions outside their time window are rejected`()</ID>
    <ID>LongMethod:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$fun startBftClusterAndNode(clusterSize: Int, mockNet: InternalMockNetwork, exposeRaces: Boolean = false): Pair&lt;Party, TestStartedNode&gt;</ID>
    <ID>LongMethod:BFTSmart.kt$BFTSmart.Replica$protected fun commitInputStates( states: List&lt;StateRef&gt;, txId: SecureHash, callerName: CordaX500Name, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongMethod:BFTSmartNotaryService.kt$BFTSmartNotaryService$private fun createMap(): AppendOnlyPersistentMap&lt;StateRef, SecureHash, CommittedState, PersistentStateRef&gt;</ID>
    <ID>LongMethod:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$private fun verifyAndCommitTx(transaction: CoreTransaction, callerIdentity: Party, requestSignature: NotarisationRequestSignature): BFTSmart.ReplicaResponse</ID>
    <ID>LongMethod:BackChainResolutionSampler.kt$BackChainResolutionSampler$ fun determineStartNode(amount: Int, payFromNode: TransferNode, startUnitSize: Int) : TransferNode</ID>
    <ID>LongMethod:BackChainResolutionSampler.kt$BackChainResolutionSampler$override fun createFlowInvoke(rpcProxy: CordaRPCOps, testContext: JavaSamplerContext): BaseFlowSampler.FlowInvoke&lt;*&gt;</ID>
    <ID>LongMethod:BackChainResolutionSampler.kt$BackChainResolutionSampler$override fun setupTest(rpcProxy: CordaRPCOps, testContext: JavaSamplerContext)</ID>
    <ID>LongMethod:BackpressureHandlingTest.kt$BackpressureHandlingTest$@Test fun `health check flows can update their ETA and report on it`()</ID>
    <ID>LongMethod:BackpressureHandlingTest.kt$BackpressureHandlingTestRule$private fun startClusterAndNode(mockNet: InternalMockNetwork): Pair&lt;Party, TestStartedNode&gt;</ID>
    <ID>LongMethod:BankOfCordaWebApi.kt$BankOfCordaWebApi$ @POST @Path("issue-asset-request") @Consumes(MediaType.APPLICATION_JSON) fun issueAssetRequest(params: IssueRequestParams): Response</ID>
    <ID>LongMethod:Base58Test.kt$Base58Test$@Test fun testDecode()</ID>
    <ID>LongMethod:BaseFlowSampler.kt$BaseFlowSampler$override fun runTest(context: JavaSamplerContext): SampleResult</ID>
    <ID>LongMethod:BaseFlowSampler.kt$BaseFlowSampler$override fun setupTest(context: JavaSamplerContext)</ID>
    <ID>LongMethod:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit // signing to appropriately authorised contexts and initiating users. override fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature</ID>
    <ID>LongMethod:BlobInspector.kt$BlobInspector$fun run(out: PrintStream): Int</ID>
    <ID>LongMethod:BootstrapperView.kt$BootstrapperView$private fun processSelectedDirectory(dir: File)</ID>
    <ID>LongMethod:BridgeAMQPListenerServiceImpl.kt$BridgeAMQPListenerServiceImpl$override fun provisionKeysAndActivate(keyStore: CertificateStore, trustStore:CertificateStore, maxMessageSize: Int)</ID>
    <ID>LongMethod:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$private fun artemisReconnectionLoop()</ID>
    <ID>LongMethod:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$private fun startArtemisConnection()</ID>
    <ID>LongMethod:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$private fun stopArtemisConnection()</ID>
    <ID>LongMethod:BridgeConfigHelper.kt$BridgeConfigHelper$fun loadConfig(baseDirectory: Path, configFile: Path = baseDirectory / "firewall.conf"): FirewallConfiguration</ID>
    <ID>LongMethod:BridgeControlListener.kt$BridgeControlListener$fun start()</ID>
    <ID>LongMethod:BridgeControlListener.kt$BridgeControlListener$fun stop()</ID>
    <ID>LongMethod:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>LongMethod:BridgeControlListener.kt$BridgeControlListener$private fun registerBridgeDuplicateChecker(artemisSession: ClientSession)</ID>
    <ID>LongMethod:BridgeDriver.kt$fun DriverDSLImpl.startBridge(baseDir: Path, artemisPort: Int, advertisedP2PPort: Int, vararg nodeSSLKeystores: Path, configOverrides: Map&lt;String, Any&gt; = emptyMap(), floatPort: Int? = null, keyStorePassword: String = DEV_CA_KEY_STORE_PASS, truststorePassword: String = DEV_CA_TRUST_STORE_PASS): CordaFuture&lt;BridgeHandle&gt;</ID>
    <ID>LongMethod:BridgeDriver.kt$private fun DriverDSLImpl.startBridge(baseDirectory: Path, p2pPort: Int, brokerPort: Int, floatPort: Int, configOverrides: Map&lt;String, Any&gt;, artemisCertDir: Path, keystorePassword: String, truststorePassword: String): CordaFuture&lt;BridgeHandle&gt;</ID>
    <ID>LongMethod:BridgeDriver.kt$private fun DriverDSLImpl.startFloat(baseDirectory: Path, p2pPort: Int, brokerPort: Int, floatPort: Int, configOverrides: Map&lt;String, Any&gt;, artemisCertDir: Path, keystorePassword: String, truststorePassword: String): CordaFuture&lt;BridgeHandle&gt;</ID>
    <ID>LongMethod:BridgeDriver.kt$private fun DriverDSLImpl.startSingleProcessBridgeAndFloat(baseDirectory: Path, bridgePort: Int, brokerPort: Int, configOverrides: Map&lt;String, Any&gt;, artemisCertDir: Path? = null, keystorePassword: String, truststorePassword: String): CordaFuture&lt;BridgeHandle&gt;</ID>
    <ID>LongMethod:BridgeHSMTest.kt$BridgeHSMTest$@Test fun `Nodes behind all in one bridge can communicate with external node when using HSM`()</ID>
    <ID>LongMethod:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$@Test fun `Load bridge (bridge Inner) and float outer and stand them up`()</ID>
    <ID>LongMethod:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$private fun generateInternalCerts(bridgeConfig: FirewallConfiguration)</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Health check for inbound port in echo mode`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Load bridge (bridge Inner) and float outer and stand them up`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Load bridge and float outer with different passwords and stand them up`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Load simple all in one bridge and stand it up`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Run HA all in one mode`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Run HA float and bridge mode`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Run HA using Bully algorithm`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Test artemis failover logic with float`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test fun `Test artemis failover logic`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$@Test(timeout = 60000) fun `Test tunneling control message won't fail on small max message size`()</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$private fun createArtemis(): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$private fun createArtemis2(): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:BridgeIntegrationTest.kt$BridgeIntegrationTest$private fun createDummyPeerArtemis(): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:BridgeRestartTest.kt$BridgeRestartTest$@Test fun restartLongPingPongFlowRandomly()</ID>
    <ID>LongMethod:BridgeRestartTest.kt$BridgeRestartTest$@Test fun restartSeveralPingPongFlowsRandomly()</ID>
    <ID>LongMethod:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$override fun runTool()</ID>
    <ID>LongMethod:BridgeSmokeTest.kt$BridgeSmokeTest$private fun runBridge(configName: String, resourceSubDir: String = "")</ID>
    <ID>LongMethod:BridgeSmokeTest.kt$BridgeSmokeTest$private fun waitForBridge(process: Process)</ID>
    <ID>LongMethod:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$// The Main authentication logic, responsible for running all the configured checks for each user type // and return the actual User and principals private fun authenticateAndAuthorise(username: String, certificates: Array&lt;X509Certificate&gt;?, password: String): Pair&lt;String, List&lt;RolePrincipal&gt;&gt;</ID>
    <ID>LongMethod:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$override fun login(): Boolean</ID>
    <ID>LongMethod:BullyLeader.kt$BullyLeaderClient$override fun relinquishLeadership()</ID>
    <ID>LongMethod:BullyLeader.kt$BullyLeaderClient$private fun messageEvent(message: LeaderMessage)</ID>
    <ID>LongMethod:BullyLeader.kt$BullyLeaderClient$private fun timerEvent()</ID>
    <ID>LongMethod:BullyLeader.kt$BullyLeaderClient.ArtemisMessageSession.Companion$fun connectToArtemis(electionPath: String, locator: ServerLocator, factory: ClientSessionFactory, onMessage: (LeaderMessage) -&gt; Unit): ArtemisMessageSession</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Clients Randomly do Things`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Disconnect Tests`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Multi Leader Tests Different Priorities`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Multi Leader Tests`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Priority Leader Test`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Simple Leader Test Shutdown whilst leader`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Simple Leader Test`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$@Test fun `Simple Two Leader Test`()</ID>
    <ID>LongMethod:BullyLeaderTest.kt$BullyLeaderTest$private fun createConfig(port: Int, createCerts: Boolean = false): AbstractNodeConfiguration</ID>
    <ID>LongMethod:CaffeineStatsCounter.kt$private fun &lt;K, V, C : Cache&lt;K, V&gt;&gt; C.addExtraMetrics(registry: MetricRegistry, metricsPrefix: String): C</ID>
    <ID>LongMethod:Cap.kt$Cap$@Test fun `first fixing`()</ID>
    <ID>LongMethod:Cap.kt$Cap$@Test fun `second fixing`()</ID>
    <ID>LongMethod:Caplet.kt$Caplet$@Test fun fixing()</ID>
    <ID>LongMethod:Cash.kt$Cash$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:CashExitFlow.kt$CashExitFlow$ @Suspendable @Throws(CashException::class) override fun call(): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$@Suspendable override fun mainCall(maybeAnonymousRecipient: AbstractParty, recipientSession: FlowSession): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashIssueAndPaymentFlowTests.kt$CashIssueAndPaymentFlowTests$@Test fun `issue and pay some cash`()</ID>
    <ID>LongMethod:CashIssueAndPaymentNoSelectionFlowTests.kt$CashIssueAndPaymentNoSelectionTests$@Test fun `issue and pay some cash`()</ID>
    <ID>LongMethod:CashPaymentFlow.kt$AbstractCashPaymentFlow$@Suspendable override fun mainCall(maybeAnonymousRecipient: AbstractParty, recipientSession: FlowSession): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashPaymentFlow.kt$CashPaymentFlow$@Suspendable override fun call(): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashPaymentFlowTests.kt$CashPaymentFlowTests$@Test fun `pay some cash`()</ID>
    <ID>LongMethod:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$@Suspendable override fun mainCall(maybeAnonymousRecipient: AbstractParty, recipientSession: FlowSession): AbstractCashFlow.Result</ID>
    <ID>LongMethod:CashScenarioRunner.kt$CashScenarioRunner$override fun call(): Boolean</ID>
    <ID>LongMethod:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionOracleImpl.kt$CashSelectionOracleImpl$override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:CashSelectionTest.kt$CashSelectionTest$@Test fun `cash selection sees states added in the same transaction`()</ID>
    <ID>LongMethod:CashSelectionTest.kt$CashSelectionTest$@Test fun `don't return extra coins if the selected amount has been reached`()</ID>
    <ID>LongMethod:CashSelectionTest.kt$CashSelectionTest$@Test fun `select cash states issued by single transaction and give change`()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$// Double spend. @Test fun chainCashDoubleSpendFailsWith()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Before fun setUp()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun `extended issue examples`()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun exitLedger()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun generateSimpleSpendWithChange()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun generateSpendMixedDeposits()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun generateSpendTwiceWithinATransaction()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun multiIssuer()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun multiSpend()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun testMergeSplit()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun trivial()</ID>
    <ID>LongMethod:CashTests.kt$CashTests$@Test fun trivialMismatches()</ID>
    <ID>LongMethod:CashUtils.kt$CashUtils$ @JvmStatic @JvmOverloads @Throws(InsufficientBalanceException::class) @Suspendable fun generateSpend(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true): Pair&lt;TransactionBuilder, List&lt;PublicKey&gt;&gt;</ID>
    <ID>LongMethod:CertRoleTests.kt$CertRoleTests$@Test fun `check cert roles verify for various cert hierarchies`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when client's certificate is revoked and soft fail is disabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when client's certificate is revoked and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when servers's certificate is revoked and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection fails when servers's certificate is revoked`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection rejected when client certificate is revoked and external CRL source is used`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection succeeds when CRL cannot be obtained and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection succeeds when CRL retrieval is forbidden and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection works when client certificate is revoked and CRL check is OFF`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Revocation status check fails when the CRL distribution point is not set and soft fail is disabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Revocation status check succeds when the CRL distribution point is not set and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Simple AMPQ Client to Server connection works and soft fail is disabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `Simple AMPQ Client to Server connection works and soft fail is enabled`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `verify CRL algorithms`()</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private fun createClient(targetPort: Int, revocationConfig: RevocationConfig, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/$NODE_CRL", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/$EMPTY_CRL", maxMessageSize: Int = MAX_MESSAGE_SIZE): Pair&lt;AMQPClient, X509Certificate&gt;</ID>
    <ID>LongMethod:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private fun createServer(port: Int, name: CordaX500Name = ALICE_NAME, revocationConfig: RevocationConfig, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/$NODE_CRL", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/$EMPTY_CRL", maxMessageSize: Int = MAX_MESSAGE_SIZE): Pair&lt;AMQPServer, X509Certificate&gt;</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$@JvmStatic fun readExit(input: Input, clazz: Class&lt;*&gt;, value: Any?)</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>LongMethod:CheckpointAgent.kt$CheckpointHook$private fun prettyStatsTree(indent: Int, statsInfo: StatsInfo, identityInfo: IdentityInfo, builder: StringBuilder)</ID>
    <ID>LongMethod:CheckpointAgent.kt$fun readTree(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt; = IdentityHashMap()): Pair&lt;Int, IdentityInfo&gt;</ID>
    <ID>LongMethod:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$fun dump()</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$fun start(tokenizableServices: List&lt;Any&gt;)</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$private fun Checkpoint.toJson(id: UUID, now: Instant): CheckpointJson</ID>
    <ID>LongMethod:CheckpointDumper.kt$CheckpointDumper$private fun FlowIORequest&lt;*&gt;.toSuspendedOn(suspendedTimestamp: Instant, now: Instant): SuspendedOn</ID>
    <ID>LongMethod:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$ override fun build(schema: Schema): Class&lt;*&gt;</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$private fun ClassWriter.generateClassConstructor(schema: Schema)</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$private fun ClassWriter.generateStaticEnumConstructor(schema: Schema)</ID>
    <ID>LongMethod:ClassCarpenter.kt$ClassCarpenterImpl$private fun generateClass(classSchema: Schema): Class&lt;*&gt;</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun `generate multiple interfaces`()</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun `interface implementing interface`()</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun `string arrays`()</ID>
    <ID>LongMethod:ClassCarpenterTest.kt$ClassCarpenterTest$@Test fun prims()</ID>
    <ID>LongMethod:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$protected fun RemoteTypeInformation.rename(from: TypeIdentifier, to: TypeIdentifier): RemoteTypeInformation</ID>
    <ID>LongMethod:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$@Test fun `carpent some related classes`()</ID>
    <ID>LongMethod:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$@Test fun `complex ListenableFuture`()</ID>
    <ID>LongMethod:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$@Test fun `complex observables`()</ID>
    <ID>LongMethod:ClientRpcTutorial.kt$// START 6 fun generateTransactions(proxy: CordaRPCOps)</ID>
    <ID>LongMethod:ClientRpcTutorial.kt$@Suppress("DEPRECATION") fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:ClockUtilsTest.kt$ClockUtilsTest$@Test @Suspendable fun `test waiting for a deadline with multiple clock advance and incomplete Guava future on Fibers`()</ID>
    <ID>LongMethod:ClockUtilsTest.kt$ClockUtilsTest$@Test @Suspendable fun `test waiting for a deadline with multiple clock advance and incomplete JDK8 future on Fibers`()</ID>
    <ID>LongMethod:CollectSignaturesFlow.kt$CollectSignaturesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:CollectSignaturesFlow.kt$SignTransactionFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$@Test fun `successfully collects signatures when sessions are initiated with both AnonymousParty and WellKnownParty`()</ID>
    <ID>LongMethod:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllParamsAreOfTheSameType(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>LongMethod:CommandLineInterface.kt$CommandLineInterface$fun run(parsedArgs: CliParser)</ID>
    <ID>LongMethod:CommercialPaper.kt$CommercialPaper$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:CommercialPaperTests.kt$CommercialPaperTestsGeneric$@Test fun `trade lifecycle test`()</ID>
    <ID>LongMethod:CompatibilityTest.kt$CompatibilityTest$private fun assertSchemasMatch(original: Schema, reserialized: Schema)</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Command visibility tests`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `FilteredTransaction constructors and compatibility`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `FilteredTransaction signer manipulation tests`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Merkle root computations`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `WireTransaction constructors and compatibility`()</ID>
    <ID>LongMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `parameters hash visibility`()</ID>
    <ID>LongMethod:CompositeKeyTests.kt$CompositeKeyTests$@Test fun `Test save to keystore`()</ID>
    <ID>LongMethod:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key constraints`()</ID>
    <ID>LongMethod:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key validation with graph cycle detection`()</ID>
    <ID>LongMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we create a listener for a *nested* list. Note that 'indexMap' doesn't need to be adjusted on any // of these changes as the indices of nested lists don't change, just their contents. private fun createListener(wrapped: WrappedObservableList&lt;A&gt;): ListChangeListener&lt;A&gt;</ID>
    <ID>LongMethod:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>LongMethod:ConcatenatedListTest.kt$ConcatenatedListTest$@Test fun addWorks()</ID>
    <ID>LongMethod:ConcatenatedListTest.kt$ConcatenatedListTest$@Test fun permutationWorks()</ID>
    <ID>LongMethod:ConcatenatedListTest.kt$ConcatenatedListTest$@Test fun removeWorks()</ID>
    <ID>LongMethod:ConfigExporter.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:ConfigObfuscator.kt$ConfigObfuscator$ fun obfuscateConfiguration(config: String, hardwareAddress: ByteArray? = null, seed: ByteArray? = null, inputDelegate: ((String) -&gt; String)? = null): ObfuscationResult</ID>
    <ID>LongMethod:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$@Test fun `can decrypt field in config obfuscated with an input provider`()</ID>
    <ID>LongMethod:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$@Test fun `can decrypt field in config with overridden hardware address`()</ID>
    <ID>LongMethod:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$@Test fun `can decrypt multiple fields in config`()</ID>
    <ID>LongMethod:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$@Test fun `can decrypt single field in config`()</ID>
    <ID>LongMethod:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$@Test fun `can encrypt field in config with overridden hardware address`()</ID>
    <ID>LongMethod:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$@Test fun `can encrypt multiple fields in config`()</ID>
    <ID>LongMethod:ConfigTest.kt$ConfigTest$@Test fun `Check configs for docs`()</ID>
    <ID>LongMethod:ConfigTest.kt$ConfigTest$@Test fun `Load config withsocks support`()</ID>
    <ID>LongMethod:ConfigTest.kt$ConfigTest$@Test fun `passwords are hidden in logging`()</ID>
    <ID>LongMethod:ConfigUtilities.kt$// For Iterables figure out the type parameter and apply the same logic as above on the individual elements. private fun Iterable&lt;*&gt;.toConfigIterable(field: Field): Iterable&lt;Any?&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$// Problems: // - Forces you to have a primary constructor with all fields of name and type matching the configuration file structure. // - Encourages weak bean-like types. // - Cannot support a many-to-one relationship between configuration file structures and configuration domain type. This is essential for versioning of the configuration files. // - It's complicated and based on reflection, meaning problems with it are typically found at runtime. // - It doesn't support validation errors in a structured way. If something goes wrong, it throws exceptions, which doesn't support good usability practices like displaying all the errors at once. fun &lt;T : Any&gt; Config.parseAs(clazz: KClass&lt;T&gt;, onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle, nestedPath: String? = null, baseDirectory: Path? = null): T</ID>
    <ID>LongMethod:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: ManagedCryptoService? = null)</ID>
    <ID>LongMethod:ConfigUtilities.kt$@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN") // Reflect over the fields of the receiver and generate a value Map that can use to create Config object. private fun Any.toConfigMap(): Map&lt;String, Any&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$ConfigHelper$fun loadConfig(baseDirectory: Path, configFile: Path = baseDirectory / "node.conf", allowMissingConfig: Boolean = false, configOverrides: Config = ConfigFactory.empty()): Config</ID>
    <ID>LongMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType): Collection&lt;Any&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Collection&lt;Any&gt;</ID>
    <ID>LongMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType): Any?</ID>
    <ID>LongMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Any?</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$fun transportProcessInput(msg: ByteBuf)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$fun transportProcessOutput(ctx: ChannelHandlerContext)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$private fun getSender(target: String): Sender</ID>
    <ID>LongMethod:ConnectionStateMachine.kt$ConnectionStateMachine$private fun transmitMessages(sender: Sender)</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test @Ignore // TODO(mike): rework fun `Happy path for Hash to Signature Constraint migration`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Attachment canBeTransitionedFrom behaves as expected`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Fail early in the TransactionBuilder when attempting to change the hash of the HashConstraint on the spending transaction`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Input states contract version may be lower that current contract version`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `On contract annotated with NoConstraintPropagation there is no platform check for propagation, but the transaction builder can't use the AutomaticPlaceholderConstraint`()</ID>
    <ID>LongMethod:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Transaction validation fails, when constraints do not propagate correctly`()</ID>
    <ID>LongMethod:ContractDefinition.kt$ContractDefinition$/* @Test fun `builder problem - should not compile`() { val arr = arrange { actions { acmeCorp may { "execute" anytime { acmeCorp may { "problem" anytime { highStreetBank.gives(acmeCorp, 1.M, USD) } } } } } } assertTrue( arr is Actions ) if (arr is Actions) { assertEquals(1, arr.actions.size) } } */ @Test fun `builder problem - legal`()</ID>
    <ID>LongMethod:ContractJarTestUtils.kt$ContractJarTestUtils$fun signContractJar(jarURL: URL, copyFirst: Boolean, keyStoreDir: Path? = null, alias: String = "testAlias", pwd: String = "testPassword"): Pair&lt;Path, PublicKey&gt;</ID>
    <ID>LongMethod:ContractJarTestUtils.kt$ContractJarTestUtils$private fun createTestClass(workingDir: Path, className: String, packages: List&lt;String&gt;, versionSeed: Int = 0): Path</ID>
    <ID>LongMethod:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest$@Test fun `2 parties contract upgrade using RPC`()</ID>
    <ID>LongMethod:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$@Test fun `2 parties contract upgrade`()</ID>
    <ID>LongMethod:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$@Test fun `upgrade Cash to v2`()</ID>
    <ID>LongMethod:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun resolve(services: ServicesForResolution, sigs: List&lt;TransactionSignature&gt;): ContractUpgradeLedgerTransaction</ID>
    <ID>LongMethod:ContractUpgradeUtils.kt$ContractUpgradeUtils$fun &lt;OldState : ContractState, NewState : ContractState&gt; assembleUpgradeTx( stateAndRef: StateAndRef&lt;OldState&gt;, upgradedContractClass: Class&lt;out UpgradedContract&lt;OldState, NewState&gt;&gt;, privacySalt: PrivacySalt, services: ServicesForResolution ): ContractUpgradeWireTransaction</ID>
    <ID>LongMethod:CorDappInfoServlet.kt$CorDappInfoServlet$@Throws(IOException::class) override fun doGet(req: HttpServletRequest, resp: HttpServletResponse)</ID>
    <ID>LongMethod:CorDappSerializerTests.kt$CorDappSerializerTests$@Test fun testWithWhitelistAllowed()</ID>
    <ID>LongMethod:CordaCliWrapper.kt$fun CordaCliWrapper.start(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:CordaFlowToolWindow.kt$CordaFlowToolWindow.&lt;no name provided&gt;$override fun mouseClicked(e: MouseEvent?)</ID>
    <ID>LongMethod:CordaFutureImpl.kt$ fun &lt;V&gt; Collection&lt;CordaFuture&lt;out V&gt;&gt;.transpose(): CordaFuture&lt;List&lt;V&gt;&gt;</ID>
    <ID>LongMethod:CordaFutureImplTest.kt$CordaFutureTest$@Test fun `flatMap works`()</ID>
    <ID>LongMethod:CordaFutureImplTest.kt$CordaFutureTest$@Test fun `map works`()</ID>
    <ID>LongMethod:CordaMigration.kt$CordaMigration$private fun createDatabase(cacheFactory: MigrationNamedCacheFactory, identityService: PersistentIdentityService, schema: Set&lt;MappedSchema&gt;, databaseSchemaName: String?, transactionIsolationLevel: TransactionIsolationLevel): CordaPersistence</ID>
    <ID>LongMethod:CordaModule.kt$CordaModule$override fun setupModule(context: SetupContext)</ID>
    <ID>LongMethod:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>LongMethod:CordaRPCClient.kt$CordaRPCClientConfiguration$ @Suppress("DEPRECATION") @JvmOverloads fun copy( connectionMaxRetryInterval: Duration = this.connectionMaxRetryInterval, minimumServerProtocolVersion: Int = this.minimumServerProtocolVersion, trackRpcCallSites: Boolean = this.trackRpcCallSites, reapInterval: Duration = this.reapInterval, observationExecutorPoolSize: Int = this.observationExecutorPoolSize, cacheConcurrencyLevel: Int = this.cacheConcurrencyLevel, connectionRetryInterval: Duration = this.connectionRetryInterval, connectionRetryIntervalMultiplier: Double = this.connectionRetryIntervalMultiplier, maxReconnectAttempts: Int = this.maxReconnectAttempts, maxFileSize: Int = this.maxFileSize, deduplicationCacheExpiry: Duration = this.deduplicationCacheExpiry ): CordaRPCClientConfiguration</ID>
    <ID>LongMethod:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$@Test fun `a client can successfully unsubscribe a reconnecting observable`()</ID>
    <ID>LongMethod:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$@Test fun `rpc client calls and returned observables continue working when the server crashes and restarts`()</ID>
    <ID>LongMethod:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$@Test fun `rpc client calls and returned observables continue working when there is failover between servers`()</ID>
    <ID>LongMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `flow initiator via RPC`()</ID>
    <ID>LongMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `shutdown command stops the node`()</ID>
    <ID>LongMethod:CordaRPCOps.kt$ @Deprecated("For automated upgrades, consider using the `gracefulShutdown` command in an SSH session instead.") fun CordaRPCOps.pendingFlowsCount(): DataFeed&lt;Int, Pair&lt;Int, Int&gt;&gt;</ID>
    <ID>LongMethod:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun nodeDiagnosticInfo(): NodeDiagnosticInfo</ID>
    <ID>LongMethod:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun terminate(drainPendingFlows: Boolean)</ID>
    <ID>LongMethod:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$@Test fun `cash issue accepted`()</ID>
    <ID>LongMethod:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$@Test fun `issue and move`()</ID>
    <ID>LongMethod:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$override fun nodeDiagnosticInfo(): NodeDiagnosticInfo</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test @Ignore // TODO(mike): rework fun `issue cash and transfer using hash to signature constraints migration`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue and consume cash using hash constraints`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue and consume cash using signature constraints`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue cash using hash and signature constraints`()</ID>
    <ID>LongMethod:CordappConstraintsTests.kt$CordappConstraintsTests$@Test fun `issue cash using signature constraints`()</ID>
    <ID>LongMethod:CordappProviderImpl.kt$CordappProviderImpl$private fun loadContractsIntoAttachmentStore(): Map&lt;SecureHash, URL&gt;</ID>
    <ID>LongMethod:CordappSmokeTest.kt$CordappSmokeTest$@Test fun `FlowContent appName returns the filename of the CorDapp jar`()</ID>
    <ID>LongMethod:CordappSmokeTest.kt$CordappSmokeTest$private fun createNodeInfoWithSingleIdentity(name: CordaX500Name, nodeKeyPair: KeyPair, identityCertPublicKey: PublicKey): NodeInfo</ID>
    <ID>LongMethod:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$override fun runProgram(): Int</ID>
    <ID>LongMethod:CrlFetcher.kt$CrlFetcher$fun fetch(cert: X509Certificate): Set&lt;X509CRL&gt;</ID>
    <ID>LongMethod:CrlServer.kt$CrlServlet.Companion$fun Pair&lt;CertificateStoreSupplier, MutualSslConfiguration&gt;.recreateNodeCaAndTlsCertificates(nodeCaCrlDistPoint: String, tlsCrlDistPoint: String?, ROOT_CA: CertificateAndKeyPair, INTERMEDIATE_CA: CertificateAndKeyPair): X509Certificate</ID>
    <ID>LongMethod:CrlServer.kt$CrlServlet.Companion$fun createRevocationList(clrServer: CrlServer, signatureAlgorithm: String, caCertificate: X509Certificate, caPrivateKey: PrivateKey, endpoint: String, indirect: Boolean, serialNumbers: Set&lt;BigInteger&gt;): X509CRL</ID>
    <ID>LongMethod:CrlServer.kt$CrlServlet.Companion$fun replaceCrlDistPointCaCertificate(currentCaCert: X509Certificate, certType: CertificateType, issuerKeyPair: KeyPair, crlDistPoint: String?, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>LongMethod:CrossCashTest.kt$CrossCashState$override fun toString(): String</ID>
    <ID>LongMethod:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doSign(signatureScheme: SignatureScheme, privateKey: PrivateKey, clearData: ByteArray): ByteArray</ID>
    <ID>LongMethod:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$fun makeCryptoService( cryptoServiceName: SupportedCryptoServices, legalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier? = null, cryptoServiceConf: Path? = null, wrappingKeyStorePath: Path? = null ): CryptoService</ID>
    <ID>LongMethod:CryptoServiceSigningService.kt$CryptoServiceSigningService$private fun loop()</ID>
    <ID>LongMethod:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$ private fun testLifecycleWithLiveHSM(csName: SupportedCryptoServices, csConfigText: String)</ID>
    <ID>LongMethod:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$@Before fun setup()</ID>
    <ID>LongMethod:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$@Test fun testLifecycleWithBCCryptoService()</ID>
    <ID>LongMethod:CryptoServiceSpec.kt$CryptoServiceSpec$@Test fun `Content signer works with X509Utilities`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$// key generation test @Test fun `Generate key pairs`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA K1 keyPair from entropy`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA R1 keyPair from entropy`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256K1 deterministic key generation`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256R1 deterministic key generation`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256k1 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `ECDSA secp256r1 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `EDDSA ed25519 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `EdDSA ed25519 deterministic key generation`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `RSA full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CryptoUtilsTest.kt$CryptoUtilsTest$@Test fun `SPHINCS-256 full process keygen-sign-verify`()</ID>
    <ID>LongMethod:CustomCordapp.kt$CustomCordapp$@VisibleForTesting internal fun packageAsJar(file: Path)</ID>
    <ID>LongMethod:CustomCordapp.kt$CustomCordapp$private fun signJar(jarFile: Path)</ID>
    <ID>LongMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$ override fun register(customSerializer: CustomSerializer&lt;out Any&gt;)</ID>
    <ID>LongMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private fun doFindCustomSerializer(clazz: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>LongMethod:CustomVaultQuery.kt$CustomVaultQuery.Service$fun rebalanceCurrencyReserves(): List&lt;Amount&lt;Currency&gt;&gt;</ID>
    <ID>LongMethod:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$@Test fun `add checkpoint and then remove after 'restart'`()</ID>
    <ID>LongMethod:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$@Test fun `add two checkpoints then remove first one`()</ID>
    <ID>LongMethod:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$@Test fun `verify checkpoints compatible`()</ID>
    <ID>LongMethod:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$@Before fun setUp()</ID>
    <ID>LongMethod:DBTransactionStorage.kt$DBTransactionStorage$override fun &lt;T&gt; lockObjectsForWrite(ids: Collection&lt;SecureHash&gt;, dbTx: DatabaseTransaction, writePessimistically: Boolean, block: () -&gt; T): T</ID>
    <ID>LongMethod:DBTransactionStorage.kt$DBTransactionStorage$override fun addTransaction(transaction: SignedTransaction): Boolean</ID>
    <ID>LongMethod:DBTransactionStorage.kt$DBTransactionStorage.Companion$fun createTransactionsMap(cacheFactory: NamedCacheFactory) : AppendOnlyPersistentMapBase&lt;SecureHash, TxCacheValue, DBTransaction, String&gt;</ID>
    <ID>LongMethod:DataUploadServlet.kt$DataUploadServlet$@Throws(IOException::class) override fun doPost(req: HttpServletRequest, resp: HttpServletResponse)</ID>
    <ID>LongMethod:DbMapDeadlockTest.kt$DbMapDeadlockTest$fun recreateDeadlock(hikariProperties: Properties)</ID>
    <ID>LongMethod:DbScriptRunner.kt$ListPopulator$override fun populate(connection: Connection)</ID>
    <ID>LongMethod:DbTransactionsResolver.kt$DbTransactionsResolver$@Suspendable override fun downloadDependencies()</ID>
    <ID>LongMethod:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$fun customize(kryo: Kryo, publicKeySerializer: Serializer&lt;PublicKey&gt; = PublicKeySerializer): Kryo</ID>
    <ID>LongMethod:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$@Suppress("UNCHECKED_CAST") override fun read(kryo: Kryo, input: Input, type: Class&lt;ContractAttachment&gt;): ContractAttachment</ID>
    <ID>LongMethod:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$@Test fun `can establish TLS connection using remote signer`()</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$override fun transition(): TransitionResult</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.confirmMessageTransition(sessionState: SessionState, message: ConfirmSessionMessage)</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.endMessageTransition()</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.errorMessageTransition(sessionState: SessionState, payload: ErrorSessionMessage)</ID>
    <ID>LongMethod:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$private fun TransitionBuilder.rejectMessageTransition(sessionState: SessionState, payload: RejectSessionMessage)</ID>
    <ID>LongMethod:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>LongMethod:DeserializationInput.kt$DeserializationInput.Companion$@VisibleForTesting @Throws(AMQPNoTypeNotSerializableException::class) fun &lt;T&gt; withDataBytes( byteSequence: ByteSequence, encodingWhitelist: EncodingWhitelist, task: (ByteBuffer) -&gt; T ) : T</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryOfEnumsTest.kt$DeserializeNeedingCarpentryOfEnumsTest$@Test fun compositeIncludingEnums()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$@Test fun manyTypes()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun arrayOfTypes()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun listOfType()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun repeatedTypesAreRecognised()</ID>
    <ID>LongMethod:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$@Test fun verySimpleType()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$// See CORDA-2782 @Test @Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN") fun comparableNotWhitelistedOk()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$@Test fun arrayOfArrayOfIntArray()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$@Test fun testByteArray()</ID>
    <ID>LongMethod:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$@Test fun testCharArray()</ID>
    <ID>LongMethod:DirectBridgeSenderService.kt$DirectBridgeSenderService$override fun start()</ID>
    <ID>LongMethod:Disruption.kt$fun &lt;A&gt; Nodes.withDisruptions(disruptions: List&lt;DisruptionSpec&gt;, mainRandom: SplittableRandom, action: () -&gt; A): A</ID>
    <ID>LongMethod:DistributedServiceTests.kt$DistributedServiceTests$// TODO This should be in RaftNotaryServiceTests @Test fun `cluster survives if a notary is killed`()</ID>
    <ID>LongMethod:DistributedServiceTests.kt$DistributedServiceTests$private fun setup(compositeIdentity: Boolean = false, testBlock: () -&gt; Unit)</ID>
    <ID>LongMethod:DockerInstantiator.kt$DockerInstantiator$override fun instantiateContainer(imageId: String, portsToOpen: List&lt;Int&gt;, instanceName: String, env: Map&lt;String, String&gt;?): CompletableFuture&lt;Pair&lt;String, Map&lt;Int, Int&gt;&gt;&gt;</ID>
    <ID>LongMethod:Driver.kt$ fun &lt;A&gt; driver(defaultParameters: DriverParameters = DriverParameters(), dsl: DriverDSL.() -&gt; A): A</ID>
    <ID>LongMethod:Driver.kt$DriverParameters$fun copy( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters )</ID>
    <ID>LongMethod:Driver.kt$DriverParameters$fun copy( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, cordappsForAllNodes: Set&lt;TestCordapp&gt;? )</ID>
    <ID>LongMethod:Driver.kt$DriverParameters$fun copy( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, notaryCustomOverrides: Map&lt;String, Any?&gt;, inMemoryDB: Boolean, cordappsForAllNodes: Collection&lt;TestCordapp&gt;? )</ID>
    <ID>LongMethod:DriverDSL.kt$DriverDSL$ fun startNode( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride ): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$ fun &lt;DI : DriverDSL, D : InternalDriverDSL, A&gt; genericDriver( defaultParameters: DriverParameters = DriverParameters(), driverDslWrapper: (DriverDSLImpl) -&gt; D, coerce: (D) -&gt; DI, dsl: DI.() -&gt; A ): A</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$override fun start()</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun establishRpc(config: NodeConfig, processDeathFuture: CordaFuture&lt;out Process&gt;): CordaFuture&lt;CordaRPCOps&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNodeInternal(config: NodeConfig, webAddress: NetworkHostAndPort, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters, bytemanPort: Int? = null): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNodeRegistration( providedName: CordaX500Name, rootCert: X509Certificate, networkServicesConfig: NetworkServicesConfig, customOverrides: Map&lt;String, Any?&gt; = mapOf() ): CordaFuture&lt;NodeConfig&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNotaryIdentityGeneration(): CordaFuture&lt;List&lt;NotaryInfo&gt;&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startNotaryRegistration( spec: NotarySpec, rootCert: X509Certificate, compatibilityZone: CompatibilityZoneParams ): CordaFuture&lt;NotaryInfo&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startRaftNotaryCluster(spec: NotarySpec, localNetworkMap: LocalNetworkMap?): CordaFuture&lt;List&lt;NodeHandle&gt;&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl$private fun startRegisteredNode(name: CordaX500Name, localNetworkMap: LocalNetworkMap?, parameters: NodeParameters, p2pAddress: NetworkHostAndPort = portAllocation.nextHostAndPort(), bytemanPort: Int? = null): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl.Companion$private fun startInProcessNode( executorService: ScheduledExecutorService, config: NodeConfig ): CordaFuture&lt;Pair&lt;NodeWithInfo, Thread&gt;&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$DriverDSLImpl.Companion$private fun startOutOfProcessNode( config: NodeConfig, quasarJarPath: String, debugPort: Int?, bytemanJarPath: String?, bytemanPort: Int?, overriddenSystemProperties: Map&lt;String, String&gt;, maximumHeapSize: String, logLevelOverride: String?, vararg extraCmdLineFlag: String ): Process</ID>
    <ID>LongMethod:DriverDSLImpl.kt$NetworkVisibilityController.VisibilityHandle$fun listen(rpc: CordaRPCOps): CordaFuture&lt;Unit&gt;</ID>
    <ID>LongMethod:DriverDSLImpl.kt$fun &lt;A&gt; internalDriver( isDebug: Boolean = DriverParameters().isDebug, driverDirectory: Path = DriverParameters().driverDirectory, portAllocation: PortAllocation = DriverParameters().portAllocation, debugPortAllocation: PortAllocation = DriverParameters().debugPortAllocation, systemProperties: Map&lt;String, String&gt; = DriverParameters().systemProperties, useTestClock: Boolean = DriverParameters().useTestClock, startNodesInProcess: Boolean = DriverParameters().startNodesInProcess, extraCordappPackagesToScan: List&lt;String&gt; = @Suppress("DEPRECATION") DriverParameters().extraCordappPackagesToScan, waitForAllNodesToFinish: Boolean = DriverParameters().waitForAllNodesToFinish, notarySpecs: List&lt;NotarySpec&gt; = DriverParameters().notarySpecs, jmxPolicy: JmxPolicy = DriverParameters().jmxPolicy, networkParameters: NetworkParameters = DriverParameters().networkParameters, compatibilityZone: CompatibilityZoneParams? = null, notaryCustomOverrides: Map&lt;String, Any?&gt; = DriverParameters().notaryCustomOverrides, inMemoryDB: Boolean = DriverParameters().inMemoryDB, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, enableSNI: Boolean = DriverParameters().enableSNI, dsl: DriverDSLImpl.() -&gt; A ): A</ID>
    <ID>LongMethod:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$override fun runTest(context: JavaSamplerContext): SampleResult</ID>
    <ID>LongMethod:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$override fun setupTest(context: JavaSamplerContext)</ID>
    <ID>LongMethod:DummyFungibleContract.kt$DummyFungibleContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:DummyFungibleContract.kt$DummyFungibleContract.State$ override fun generateMappedObject(schema: MappedSchema): PersistentState</ID>
    <ID>LongMethod:DummyIssueAndMove.kt$DummyIssueAndMove$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:DummyLinearContract.kt$DummyLinearContract.State$override fun generateMappedObject(schema: MappedSchema): PersistentState</ID>
    <ID>LongMethod:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>LongMethod:EdDSATests.kt$EdDSATests$@Test fun `PureEdDSA Ed25519 test vectors`()</ID>
    <ID>LongMethod:EnterpriseCashSelectionSQLServerImpl.kt$EnterpriseCashSelectionSQLServerImpl$override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>LongMethod:EnterpriseNode.kt$EnterpriseNode.Startup$override fun drawBanner(versionInfo: VersionInfo)</ID>
    <ID>LongMethod:EnterpriseNode.kt$EnterpriseNode.Startup$private fun connectToRelay(config: RelayConfiguration, localBrokerPort: Int)</ID>
    <ID>LongMethod:EnterpriseNodeTest.kt$EnterpriseNodeTest$private fun createConfig(freshIdentitiesConfiguration: FreshIdentitiesConfiguration?): NodeConfigurationImpl</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun defaultAnnotationIsAddedToEnvelopeAndDeserialised()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun doubleRenameAnnotationIsAdded()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun multiEnums()</ID>
    <ID>LongMethod:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$@Test fun renameAnnotationIsAdded()</ID>
    <ID>LongMethod:EnumEvolveTests.kt$EnumEvolveTests$@Test fun deserializeWithRename()</ID>
    <ID>LongMethod:EnumEvolveTests.kt$EnumEvolveTests$@Test fun multiOperations()</ID>
    <ID>LongMethod:EnumTests.kt$EnumTests$@Test fun deserialiseSimpleTest()</ID>
    <ID>LongMethod:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>LongMethod:ErrorFlowTransition.kt$ErrorFlowTransition$// Buffer error messages in Initiating sessions, return the initialised ones. private fun bufferErrorMessagesInInitiatingSessions( sessions: Map&lt;SessionId, SessionState&gt;, errorMessages: List&lt;ErrorSessionMessage&gt; ): Pair&lt;List&lt;SessionState.Initiated&gt;, Map&lt;SessionId, SessionState&gt;&gt;</ID>
    <ID>LongMethod:ErrorFlowTransition.kt$ErrorFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>LongMethod:Eventually.kt$ inline fun &lt;R&gt; eventually( duration: Duration = Duration.ofSeconds(5), waitBetween: Duration = Duration.ofMillis(100), waitBefore: Duration = waitBetween, test: () -&gt; R): R</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun addMandatoryFieldWithAltReorderedConstructor()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun addMandatoryFieldWithAltReorderedConstructorAndRemoval()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun changeSubType()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun moreComplexNonNullWithReorder()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun multiVersion()</ID>
    <ID>LongMethod:EvolvabilityTests.kt$EvolvabilityTests$@Test fun multiVersionWithRemoval()</ID>
    <ID>LongMethod:Expect.kt$ fun &lt;S, E : Any&gt; S.genericExpectEvents( isStrict: Boolean = true, stream: S.((E) -&gt; Unit) -&gt; Unit, expectCompose: () -&gt; ExpectCompose&lt;E&gt; )</ID>
    <ID>LongMethod:Expect.kt$ExpectComposeState.Companion$fun &lt;E : Any&gt; fromExpectCompose(expectCompose: ExpectCompose&lt;E&gt;): ExpectComposeState&lt;E&gt;</ID>
    <ID>LongMethod:Explorer.kt$Explorer$@Throws(IOException::class) fun open(config: NodeConfigWrapper, onExit: (NodeConfigWrapper) -&gt; Unit)</ID>
    <ID>LongMethod:ExternalBrokerTests.kt$ExternalBrokertests$// TODO: un-ignore when node will be changed to no longer die on artemis connection loss @Ignore @Test fun `node terminates if connection to broker has been lost and cannot be re-established`()</ID>
    <ID>LongMethod:ExternalBrokerTests.kt$ExternalBrokertests$@Test @Ignore // TODO: Investigate why node will hang without the sleep after broker restart. fun `node can still send and recieve message after broker restart`()</ID>
    <ID>LongMethod:ExternalBrokerTests.kt$ExternalBrokertests$@Test fun `node startup sequence waits for broker to be available using default mode`()</ID>
    <ID>LongMethod:ExternalIdMappingTest.kt$ExternalIdMappingTest$@Test fun `Two states can be mapped to a single externalId`()</ID>
    <ID>LongMethod:ExternalIdMappingTest.kt$ExternalIdMappingTest$@Test fun `externalIds query criteria test`()</ID>
    <ID>LongMethod:ExternalMasterElectionService.kt$ExternalMasterElectionService$ private fun activate()</ID>
    <ID>LongMethod:ExternalSourceRevocationChecker.kt$ExternalSourceRevocationChecker$ @Throws(CertPathValidatorException::class) private fun checkApprovedCRLs(cert: X509Certificate, approvedCRLs: Set&lt;X509CRL&gt;)</ID>
    <ID>LongMethod:FXFwdTimeOption.kt$FXFwdTimeOption$@Test fun `maturity, bank exercise`()</ID>
    <ID>LongMethod:FXFwdTimeOption.kt$FXFwdTimeOption$@Test fun `maturity, corp exercise`()</ID>
    <ID>LongMethod:FetchDataFlow.kt$FetchDataFlow$@Suspendable @Throws(HashNotFound::class, MissingNetworkParameters::class) override fun call(): Result&lt;T&gt;</ID>
    <ID>LongMethod:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationChecker$fun start(checkpointSerializationContext: CheckpointSerializationContext)</ID>
    <ID>LongMethod:FiberMonitor.kt$FiberMonitor$private fun checkLeakedConnections(event: MonitorEvent)</ID>
    <ID>LongMethod:FiberMonitor.kt$MonitorEventCorrelator$fun merged(): Map&lt;Any, List&lt;FullMonitorEvent&gt;&gt;</ID>
    <ID>LongMethod:FilterServiceTest.kt$FilterServiceTest$@Test fun `Basic function tests`()</ID>
    <ID>LongMethod:FilterServiceTest.kt$FilterServiceTest$@Test fun `Rejection tests`()</ID>
    <ID>LongMethod:FinalityFlow.kt$FinalityFlow$@Suspendable @Throws(NotaryException::class) override fun call(): SignedTransaction</ID>
    <ID>LongMethod:FirewallInstance.kt$FirewallInstance$private fun createServices()</ID>
    <ID>LongMethod:FirewallStartup.kt$FirewallStartup$ override fun runProgram(): Int</ID>
    <ID>LongMethod:FirewallStartup.kt$FirewallStartup$private fun logStartupInfo(versionInfo: FirewallVersionInfo, conf: FirewallConfiguration)</ID>
    <ID>LongMethod:FlattenedList.kt$FlattenedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out ObservableValue&lt;out A&gt;&gt;)</ID>
    <ID>LongMethod:FlattenedListTest.kt$FlattenedListTest$@Test fun addWorks()</ID>
    <ID>LongMethod:FloatControlListenerService.kt$FloatControlListenerService$private fun forwardReceivedMessage(message: ReceivedMessage)</ID>
    <ID>LongMethod:FloatControlListenerService.kt$FloatControlListenerService$private fun onConnectToControl(connectionChange: ConnectionChange)</ID>
    <ID>LongMethod:FloatControlListenerService.kt$FloatControlListenerService$private fun onControlMessage(receivedMessage: ReceivedMessage)</ID>
    <ID>LongMethod:FloatControlListenerService.kt$FloatControlListenerService$private fun startControlListener()</ID>
    <ID>LongMethod:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$@Test fun `restart node with mismatch between suspended flow and installed CorDapps`()</ID>
    <ID>LongMethod:FlowCookbook.kt$InitiatorFlow$@Suppress("RemoveExplicitTypeArguments") @Suspendable override fun call()</ID>
    <ID>LongMethod:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$@Ignore("Some changes in startup order make this test's assumptions fail.") @Test fun `flow with send will resend on interrupted restart`()</ID>
    <ID>LongMethod:FlowFrameworkTests.kt$FlowFrameworkTests$@Test fun `FlowException thrown on other side`()</ID>
    <ID>LongMethod:FlowFrameworkTests.kt$FlowFrameworkTests$@Test fun `non-FlowException thrown on other side`()</ID>
    <ID>LongMethod:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$@Test fun `FlowException thrown and there is a 3rd unrelated party flow`()</ID>
    <ID>LongMethod:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$@Test fun `receiving from multiple parties`()</ID>
    <ID>LongMethod:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$@Test fun `sending to multiple parties`()</ID>
    <ID>LongMethod:FlowHospitalTest.kt$FlowHospitalTest$@Test fun `when double spend occurs, the flow is successfully deleted on the counterparty`()</ID>
    <ID>LongMethod:FlowManager.kt$NodeFlowManager$@Synchronized override fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiator: Class&lt;out FlowLogic&lt;*&gt;&gt;, responder: Class&lt;F&gt;)</ID>
    <ID>LongMethod:FlowMessaging.kt$FlowMessagingImpl$@Suspendable override fun sendSessionMessage(destination: Destination, message: SessionMessage, deduplicationId: SenderDeduplicationId)</ID>
    <ID>LongMethod:FlowRetryTest.kt$InitiatorFlow$@Suspendable override fun call(): Any</ID>
    <ID>LongMethod:FlowRunner.kt$FlowRunner$fun start()</ID>
    <ID>LongMethod:FlowRunner.kt$FlowRunner$fun stop(): Boolean</ID>
    <ID>LongMethod:FlowRunner.kt$FlowRunner$private fun run()</ID>
    <ID>LongMethod:FlowSnapshotTreeDataManager.kt$FlowSnapshotTreeDataManager$private fun buildChildrenModel( node: JsonNode?, parent: DefaultMutableTreeNode, label: String? = null)</ID>
    <ID>LongMethod:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$private fun extractStackSnapshotFromFiber(fiber: Fiber&lt;*&gt;, stackTrace: List&lt;StackTraceElement&gt;, flowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;): FlowStackSnapshot</ID>
    <ID>LongMethod:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$@Test fun `persistFlowStackSnapshot stack traces are aligned with stack objects`()</ID>
    <ID>LongMethod:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest$@Test fun `test executor`()</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$ @Suspendable private fun processEventsUntilFlowIsResumed(isDbTransactionOpenOnEntry: Boolean, isDbTransactionOpenOnExit: Boolean): Any?</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable override fun &lt;R : Any&gt; suspend(ioRequest: FlowIORequest&lt;R&gt;, maySkipCheckpoint: Boolean): R</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable override fun &lt;R&gt; subFlow(subFlow: FlowLogic&lt;R&gt;): R</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable override fun run()</ID>
    <ID>LongMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$private fun Throwable.fillInLocalStackTrace(): Throwable</ID>
    <ID>LongMethod:FlowTreeDataManager.kt$FlowTreeDataManager.DirObserver$private fun processEvent(event: WatchEvent&lt;*&gt;, key: WatchKey)</ID>
    <ID>LongMethod:FlowWatchPrintingSubscriber.kt$FlowWatchPrintingSubscriber$// TODO Add progress tracker? private fun createStateMachinesRow(smmUpdate: StateMachineUpdate)</ID>
    <ID>LongMethod:FlowWorker.kt$FlowWorker$fun start()</ID>
    <ID>LongMethod:FlowWorkerPartitioner.kt$FlowWorkerPartitioner$override fun initiateLatch(startedClient: CuratorFramework)</ID>
    <ID>LongMethod:FlowWorkerPartitioner.kt$FlowWorkerPartitioner$private fun watchFlowPartition(watchedClient: CuratorFramework)</ID>
    <ID>LongMethod:FlowWorkerRegister.kt$FlowWorkerRegister$ @Throws(Exception::class) override fun initiateLatch(startedClient: CuratorFramework)</ID>
    <ID>LongMethod:FlowWorkerRegister.kt$FlowWorkerRegister$private fun CuratorFramework.watchLeader()</ID>
    <ID>LongMethod:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$fun start()</ID>
    <ID>LongMethod:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$private fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlowInternal(smm: StateMachineManager, initiatedFlow: Class&lt;F&gt;, track: Boolean): Observable&lt;F&gt;</ID>
    <ID>LongMethod:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$private fun initialiseSerialization()</ID>
    <ID>LongMethod:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$@Test fun startStop()</ID>
    <ID>LongMethod:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$private fun setupFlowWorkerInfra(legalName: CordaX500Name): FlowWorkerInfra</ID>
    <ID>LongMethod:FlowWorkerTest.kt$FlowWorkerTest$@Test fun `cash issue`()</ID>
    <ID>LongMethod:FlowWorkerTest.kt$FlowWorkerTest$@Test fun `swap identities`()</ID>
    <ID>LongMethod:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$@Test fun `client with highest priority becomes leader`()</ID>
    <ID>LongMethod:FutureXCryptoService.kt$FutureXCryptoService$override fun sign(alias: String, data: ByteArray, signAlgorithm: String?): ByteArray</ID>
    <ID>LongMethod:FxLoad.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$@Suspendable override fun call(): SecureHash</ID>
    <ID>LongMethod:FxTransactionBuildTutorial.kt$ForeignExchangeRemoteFlow$@Suspendable override fun call()</ID>
    <ID>LongMethod:FxTransactionBuildTutorialTest.kt$FxTransactionBuildTutorialTest$@Test fun `Run ForeignExchangeFlow to completion`()</ID>
    <ID>LongMethod:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$private fun generateRpcSslCertificates(conf: NodeConfiguration)</ID>
    <ID>LongMethod:Generator.kt$Generator.Companion$ fun &lt;A&gt; frequency(generators: List&lt;Pair&lt;Double, Generator&lt;A&gt;&gt;&gt;): Generator&lt;A&gt;</ID>
    <ID>LongMethod:Generator.kt$Generator.Companion$fun &lt;A&gt; pickN(number: Int, list: List&lt;A&gt;)</ID>
    <ID>LongMethod:Generator.kt$Generator.Companion$fun &lt;A&gt; replicatePoisson(meanSize: Double, generator: Generator&lt;A&gt;, atLeastOne: Boolean = false)</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$// // If this doesn't blow up all is fine private fun fingerprintingDiffersStrip(state: Any)</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedGenericsReferencesByteArrayViaSerializedBytes()</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationInMultipleContextsDoesntColideGenericTypes()</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationOfGenerics()</ID>
    <ID>LongMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationWhereGenericDoesntImpactFingerprint()</ID>
    <ID>LongMethod:H2SecurityTests.kt$H2SecurityTests$@Test fun `malicious flow tries to enable remote code execution via h2 server`()</ID>
    <ID>LongMethod:HABrokerFailoverTest.kt$HABrokerFailoverTest$@Test fun `node can still send and recieve message after out-of-process broker restart`()</ID>
    <ID>LongMethod:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$@Throws(CertificateRequestException::class) override fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun restartLongPingPongFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun restartRecursiveFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun restartShortPingPongFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest$@Test fun softRestartLongPingPongFlowRandomly()</ID>
    <ID>LongMethod:HardRestartTest.kt$HardRestartTest.RecursiveA$@Suspendable override fun call(): String</ID>
    <ID>LongMethod:HibernateColumnConverterTests.kt$HibernateColumnConverterTests$// AbstractPartyToX500NameAsStringConverter could cause circular flush of Hibernate session because it is invoked during flush, and a // cache miss was doing a flush. This also checks that loading during flush does actually work. @Test fun `issue some cash on a notary that exists only in the database to check cache loading works in our identity column converters during flush of vault update`()</ID>
    <ID>LongMethod:HibernateConfiguration.kt$HibernateConfiguration$private fun makeSessionFactoryForSchemas(schemas: Set&lt;MappedSchema&gt;): SessionFactory</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `composite or query across VaultStates, VaultLinearStates and DummyLinearStates`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `query fungible states by owner party`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `query fungible states by participants`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `select by composite primary between VaultStates, VaultLinearStates and DummyLinearStates`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `three way join by composite primary between VaultStates, VaultLinearStates and DummyLinearStates`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `with sorting on attribute from common table`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$ @Test fun `with sorting on attribute from custom table`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$@Before fun setUp()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$@Test fun `calculate and order by cash balance for owner and currency`()</ID>
    <ID>LongMethod:HibernateConfigurationTest.kt$HibernateConfigurationTest$@Test fun `calculate cash balances`()</ID>
    <ID>LongMethod:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider$ fun createEntityManagerFactory(dataSource: DataSource, dataSourceProperties: Properties, databaseConfig: StandaloneJPANotaryDatabaseConfig, maxBatchSize: Int): EntityManagerFactory</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$private fun collectionComparisonToPredicate(column: Path&lt;out Any?&gt;, columnPredicate: CollectionExpression&lt;*&gt;): Predicate</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$override fun parseCriteria(criteria: AttachmentQueryCriteria.AttachmentsQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun &lt;L : StatePersistable&gt; parseCriteria(criteria: QueryCriteria.VaultCustomQueryCriteria&lt;L&gt;): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.FungibleAssetQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.LinearStateQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.VaultQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun &lt;O, R&gt; parseAggregateFunction(root: Root&lt;O&gt;, expression: CriteriaExpression.AggregateFunctionExpression&lt;O, R&gt;): Expression&lt;out Any?&gt;?</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun parse(sorting: Sort)</ID>
    <ID>LongMethod:Hooker.kt$Hooker$private fun instrumentBehaviour(method: CtBehavior, methodHooks: MethodHooks): List&lt;Method&gt;</ID>
    <ID>LongMethod:HospitalisingInterceptor.kt$HospitalisingInterceptor$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>LongMethod:HsmSimulator.kt$HsmSimulator$private fun pollAndWaitForHsmSimulator()</ID>
    <ID>LongMethod:HttpTests.kt$HttpTests$@Test fun `Simple AMPQ Client to Server`()</ID>
    <ID>LongMethod:HttpTests.kt$HttpTests$private fun createClient(): AMQPClient</ID>
    <ID>LongMethod:HttpTests.kt$HttpTests$private fun createServer(port: Int, name: CordaX500Name = ALICE_NAME): AMQPServer</ID>
    <ID>LongMethod:IRS.kt$IRS$@Test fun `first fixing`()</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap$ fun generateAgreement(floatingLeg: FloatingLeg, fixedLeg: FixedLeg, calculation: Calculation, common: Common, oracle: Party, notary: Party): TransactionBuilder</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap$private fun verifyFixCommand(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, command: CommandWithParties&lt;Commands.Refix&gt;)</ID>
    <ID>LongMethod:IRS.kt$InterestRateSwap.FloatingLeg$fun copy(floatingRatePayer: AbstractParty = this.floatingRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, rollConvention: DateRollConvention = this.rollConvention, fixingRollConvention: DateRollConvention = this.fixingRollConvention, resetDayInMonth: Int = this.resetDayInMonth, fixingPeriod: Int = this.fixingPeriodOffset, resetRule: PaymentRule = this.resetRule, fixingsPerPayment: Frequency = this.fixingsPerPayment, fixingCalendar: BusinessCalendar = this.fixingCalendar, index: String = this.index, indexSource: String = this.indexSource, indexTenor: Tenor = this.indexTenor )</ID>
    <ID>LongMethod:IRSDemoTest.kt$IRSDemoTest$@Test fun `runs IRS demo`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$ @Test fun generateIRSandFixSome()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$ fun trade(): LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$ fun tradegroups(): LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `ensure trade date and termination date checks are done pt1`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `ensure trade date and termination date checks are done pt2`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `expression calculation testing`()</ID>
    <ID>LongMethod:IRSTests.kt$IRSTests$@Test fun `various fixing tests`()</ID>
    <ID>LongMethod:IRSTests.kt$fun createDummyIRS(irsSelect: Int): InterestRateSwap.State</ID>
    <ID>LongMethod:IdenticonRenderer.kt$IdenticonRenderer$ private fun render(code: Int, patchSize: Double, backgroundColor: Color = Color.WHITE): Image</ID>
    <ID>LongMethod:IdenticonRenderer.kt$IdenticonRenderer$private fun drawPatch(g: GraphicsContext, x: Double, y: Double, patchIndex: Int, turn: Int, patchSize: Double, _invert: Boolean, color: PatchColor)</ID>
    <ID>LongMethod:IdentityServiceInternal.kt$IdentityServiceInternal$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false): PartyAndCertificate?</ID>
    <ID>LongMethod:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$@Test fun `it should be possible to migrate all existing identities to new hash function`()</ID>
    <ID>LongMethod:IdentitySyncFlow.kt$IdentitySyncFlow.Send$private fun extractOurConfidentialIdentities(): Map&lt;AbstractParty, PartyAndCertificate?&gt;</ID>
    <ID>LongMethod:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$@Test fun `don't offer other's identities confidential identities`()</ID>
    <ID>LongMethod:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$@Test fun `sync confidential identities`()</ID>
    <ID>LongMethod:InMemoryIdentityService.kt$InMemoryIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate): PartyAndCertificate?</ID>
    <ID>LongMethod:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with nested invalidate in the middle returns result of third loader`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `other thread get outside first transaction with invalidate in the middle returns result of other thread`()</ID>
    <ID>LongMethod:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `transaction started before invalidating thread commits does not cache until after the other thread commits`()</ID>
    <ID>LongMethod:Injectors.kt$fun startPublishingFixedRateInjector( metricRegistry: MetricRegistry, parallelism: Int, overallDuration: Duration, injectionRate: Rate, workBound: Int, queueSizeMetricName: String = "QueueSize", workDurationMetricName: String = "WorkDuration", work: () -&gt; CordaFuture&lt;*&gt; )</ID>
    <ID>LongMethod:Injectors.kt$fun startTightLoopInjector( parallelism: Int, numberOfInjections: Int, queueBound: Int, work: () -&gt; Unit )</ID>
    <ID>LongMethod:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$fun installShellExtensions(): Int</ID>
    <ID>LongMethod:InstrumentationTest.kt$InstrumentationTest$@Test fun testNodeRestart()</ID>
    <ID>LongMethod:InstrumentationTest.kt$InstrumentationTest$@Test fun testRulesInstall()</ID>
    <ID>LongMethod:InstrumentationTest.kt$InstrumentationTest$private fun setup(inMemoryDB: Boolean = true, testBlock: InternalDriverDSL.() -&gt; Unit)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$ @Throws(NoApplicableConstructor::class) fun &lt;T&gt; runFlowFromString(invoke: (Class&lt;out FlowLogic&lt;T&gt;&gt;, Array&lt;out Any?&gt;) -&gt; FlowProgressHandle&lt;T&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;, om: ObjectMapper): FlowProgressHandle&lt;T&gt;</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$// TODO Filtering on error/success when we will have some sort of flow auditing, for now it doesn't make much sense. @JvmStatic fun runStateMachinesView(out: RenderPrintWriter, rpcOps: CordaRPCOps): Any?</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun killFlowById(id: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: CordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$fun runLocalShell(onExit: () -&gt; Unit = {})</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$fun startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null, standalone: Boolean = false)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$private fun &lt;T&gt; getMatchingConstructorParamsAndTypes(parser: StringToMethodCallParser&lt;FlowLogic&lt;T&gt;&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;) : List&lt;Pair&lt;String, Type&gt;&gt;</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell$private fun _startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null)</ID>
    <ID>LongMethod:InteractiveShell.kt$InteractiveShell.ShellLifecycle$fun start(config: Properties, localUserName: String = "", localUserPassword: String = ""): Shell</ID>
    <ID>LongMethod:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$@Ignore @Test fun `ssh run flows via standalone shell over ssl to node`()</ID>
    <ID>LongMethod:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$@Ignore @Test fun `ssh runs flows via standalone shell`()</ID>
    <ID>LongMethod:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$@Test fun `dumpCheckpoints creates zip with json file for suspended flow`()</ID>
    <ID>LongMethod:InteractiveShellTest.kt$InteractiveShellTest$@Test fun niceTypeNamesInErrors()</ID>
    <ID>LongMethod:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$override fun createKeyStores()</ID>
    <ID>LongMethod:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$@Test fun `generate Artemis keystores correctly when using HSM`()</ID>
    <ID>LongMethod:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$@Test fun `generate Artemis keystores correctly`()</ID>
    <ID>LongMethod:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$@Test fun `generate tunnel keystores correctly when using HSM`()</ID>
    <ID>LongMethod:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$@Test fun `generate tunnel keystores correctly`()</ID>
    <ID>LongMethod:InternalMockNetwork.kt$InternalMockNetwork$private fun createNodeImpl(parameters: InternalMockNodeParameters, nodeFactory: (MockNodeArgs) -&gt; MockNode, start: Boolean): MockNode</ID>
    <ID>LongMethod:InternalMockNetwork.kt$private fun mockNodeConfiguration(certificatesDirectory: Path, wrappingKeyStorePath: Path): NodeConfiguration</ID>
    <ID>LongMethod:InternalMockNetworkTests.kt$InternalMockNetworkTests$ @Test fun `skip unhandled messages`()</ID>
    <ID>LongMethod:InternalTestUtils.kt$fun &lt;T&gt; DriverDSL.withDatabaseConnection(name: CordaX500Name, block: (Connection) -&gt; T): T</ID>
    <ID>LongMethod:InternalUtils.kt$// TODO: Add inline back when a new Kotlin version is released and check if the java.lang.VerifyError // returns in the IRSSimulationTest. If not, commit the inline back. @DeleteForDJVM fun &lt;T&gt; logElapsedTime(label: String, logger: Logger? = null, body: () -&gt; T): T</ID>
    <ID>LongMethod:Interpolators.kt$CubicSplineInterpolator$private fun computeSplineFunction(): SplineFunction</ID>
    <ID>LongMethod:IssueCash.kt$IssueCash$@JvmStatic fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:JPAUniquenessProvider.kt$JPAUniquenessProvider$ override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;UniquenessProvider.Result&gt;</ID>
    <ID>LongMethod:JPAUniquenessProvider.kt$JPAUniquenessProvider$private fun findAlreadyCommitted(session: Session, states: List&lt;StateRef&gt;, references: List&lt;StateRef&gt;): Map&lt;StateRef, StateConsumptionDetails&gt;</ID>
    <ID>LongMethod:JPAUniquenessProvider.kt$JPAUniquenessProvider$private fun processRequest(session: Session, request: CommitRequest, allConflicts: MutableMap&lt;StateRef, StateConsumptionDetails&gt;, toCommit: MutableList&lt;CommitRequest&gt;): UniquenessProvider.Result</ID>
    <ID>LongMethod:JPAUniquenessProvider.kt$JPAUniquenessProvider$private fun processRequests(requests: List&lt;CommitRequest&gt;)</ID>
    <ID>LongMethod:JacksonSupport.kt$JacksonSupport.X509CertificateSerializer$override fun serialize(value: X509Certificate, gen: JsonGenerator, serializers: SerializerProvider)</ID>
    <ID>LongMethod:JacksonSupportTest.kt$JacksonSupportTest$@Test fun TransactionSignature()</ID>
    <ID>LongMethod:JacksonSupportTest.kt$JacksonSupportTest$@Test fun `NodeInfo serialization`()</ID>
    <ID>LongMethod:JacksonSupportTest.kt$JacksonSupportTest$@Test fun `SignedTransaction (WireTransaction)`()</ID>
    <ID>LongMethod:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun RestrictedScanResult.toCordapp(url: RestrictedURL): CordappImpl</ID>
    <ID>LongMethod:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun loadCordapps(): List&lt;CordappImpl&gt;</ID>
    <ID>LongMethod:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseCordappInfo(manifest: Manifest?, defaultName: String): Cordapp.Info</ID>
    <ID>LongMethod:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.addManifest(fileName: String, vararg entries: Pair&lt;Attributes.Name, String&gt;)</ID>
    <ID>LongMethod:KMSUtils.kt$ fun freshCertificate(identityService: IdentityService, subjectPublicKey: PublicKey, issuer: PartyAndCertificate, issuerSigner: ContentSigner): PartyAndCertificate</ID>
    <ID>LongMethod:KeyStoreGenerator.kt$KeyStoreGenerator$fun writeKeyStore(output: OutputStream, alias: String, password: CharArray)</ID>
    <ID>LongMethod:KotlinIntegrationTestingTutorial.kt$KotlinIntegrationTestingTutorial$@Test fun `alice bob cash exchange example`()</ID>
    <ID>LongMethod:Kryo.kt$ImmutableClassSerializer$override fun read(kryo: Kryo, input: Input, type: Class&lt;T&gt;): T</ID>
    <ID>LongMethod:Kryo.kt$ImmutableClassSerializer$override fun write(kryo: Kryo, output: Output, obj: T)</ID>
    <ID>LongMethod:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$override fun &lt;T : Any&gt; deserialize(byteSequence: ByteSequence, clazz: Class&lt;T&gt;, context: CheckpointSerializationContext): T</ID>
    <ID>LongMethod:KryoStreamsTest.kt$KryoStreamsTest$@Test fun `ByteBufferOutputStream works`()</ID>
    <ID>LongMethod:KryoTests.kt$KryoTests$@Test fun rxSubscriptionsAreNotSerialized()</ID>
    <ID>LongMethod:LargeTransactionsTest.kt$LargeTransactionsTest$@Test fun checkCanSendLargeTransactions()</ID>
    <ID>LongMethod:Launcher.kt$DbManagementTool$fun runLegacyCommands(): Int</ID>
    <ID>LongMethod:Launcher.kt$Launcher.Companion$@JvmStatic fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:Launcher.kt$Launcher.Companion$internal fun prepareJMeterArguments(cmdLine: LauncherCommandLine): JMeterArgsPlus</ID>
    <ID>LongMethod:Launcher.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:LedgerDSLInterpreter.kt$Verifies$ fun failsWith(expectedMessage: String?): EnforceVerifyOrFail</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction$ private fun createLtxForVerification(): LedgerTransaction</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction$@Deprecated("LedgerTransactions should not be created directly, use WireTransaction.toLedgerTransaction instead.") fun copy(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = this.outputs, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt; = this.commands, attachments: List&lt;Attachment&gt; = this.attachments, id: SecureHash = this.id, notary: Party? = this.notary, timeWindow: TimeWindow? = this.timeWindow, privacySalt: PrivacySalt = this.privacySalt, networkParameters: NetworkParameters? = this.networkParameters ): LedgerTransaction</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction$@Deprecated("LedgerTransactions should not be created directly, use WireTransaction.toLedgerTransaction instead.") fun copy(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt ): LedgerTransaction</ID>
    <ID>LongMethod:LedgerTransaction.kt$LedgerTransaction.Companion$@CordaInternal internal fun create( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>LongMethod:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$// TODO perhaps these are too brittle because they test indices that are not stable. Use Expect dsl? @Test fun addWorks()</ID>
    <ID>LongMethod:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$@Test fun removeWorks()</ID>
    <ID>LongMethod:LegacyConfigurations.kt$Version3BridgeConfigurationImpl$override fun toConfig(): FirewallConfiguration</ID>
    <ID>LongMethod:LegacyConfigurations.kt$Version4FirewallConfiguration$override fun toConfig(): FirewallConfiguration</ID>
    <ID>LongMethod:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$@Suspendable override fun call(): Result</ID>
    <ID>LongMethod:LoadTest.kt$ fun runLoadTests(configuration: LoadTestConfiguration, tests: List&lt;Pair&lt;LoadTest&lt;*, *&gt;, LoadTest.RunParameters&gt;&gt;)</ID>
    <ID>LongMethod:LoadTest.kt$LoadTest$fun run(nodes: Nodes, parameters: RunParameters, random: SplittableRandom)</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private fun buildNonAtomic(rawType: Class&lt;*&gt;, type: Type, typeIdentifier: TypeIdentifier, typeParameterInformation: List&lt;LocalTypeInformation&gt;): LocalTypeInformation</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForClass(type: Class&lt;*&gt;, typeIdentifier: TypeIdentifier, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForParameterised( rawType: Class&lt;*&gt;, type: ParameterizedType, typeIdentifier: TypeIdentifier.Parameterised, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun makeConstructorPairedProperty(constructorIndex: Int, descriptor: PropertyDescriptor, constructorInformation: LocalConstructorInformation): LocalPropertyInformation?</ID>
    <ID>LongMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun missingMandatoryConstructorProperties( constructorInformation: LocalConstructorInformation, properties: Map&lt;PropertyName, LocalPropertyInformation&gt; ): List&lt;LocalConstructorParameterInformation&gt;</ID>
    <ID>LongMethod:LocalTypeModelTests.kt$LocalTypeModelTests$@Test fun `Primitives and collections`()</ID>
    <ID>LongMethod:LocalTypeModelTests.kt$LocalTypeModelTests$@Test fun `transitive types are non-composable creates non-composable type`()</ID>
    <ID>LongMethod:LogProcessor.kt$LogProcessor$private fun logStatement(line: String, tags: Map&lt;String, String&gt;, severity: String = "INFO")</ID>
    <ID>LongMethod:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$internal fun prepareStatsAndReset() : String</ID>
    <ID>LongMethod:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$@Test fun testActiveConnectionsTracking()</ID>
    <ID>LongMethod:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$@Test fun testStatsOutput()</ID>
    <ID>LongMethod:LoginView.kt$LoginView$tailrec fun login(): NodeMonitorModel?</ID>
    <ID>LongMethod:LoopbackBridgeManager.kt$LoopbackBridgeManager$override fun deployBridge(sourceX500Name: String, queueName: String, targets: List&lt;NetworkHostAndPort&gt;, legalNames: Set&lt;CordaX500Name&gt;)</ID>
    <ID>LongMethod:LoopbackBridgeTest.kt$LoopbackBridgeTest$// This test will hang if AMQP bridge is being use instead of Loopback bridge. @Test(timeout = 600000) fun `Nodes behind one bridge can communicate with each other using loopback bridge - with bridge started first`()</ID>
    <ID>LongMethod:LoopbackBridgeTest.kt$LoopbackBridgeTest$// This test will hang if AMQP bridge is being use instead of Loopback bridge. @Test(timeout = 600000) fun `Nodes behind one bridge can communicate with each other using loopback bridge - with bridge starts after nodes`()</ID>
    <ID>LongMethod:LoopbackBridgeTest.kt$LoopbackBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>LongMethod:LoopbackBridgeTest.kt$LoopbackBridgeTest$private fun createArtemis(sourceQueueName: String?): Triple&lt;ArtemisMessagingServer, ArtemisMessagingClient, BridgeManager&gt;</ID>
    <ID>LongMethod:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$@Test fun `login with invalid certificate chain`()</ID>
    <ID>LongMethod:MachineInformationCollector.kt$MachineInformationCollector$override fun collect(report: Report)</ID>
    <ID>LongMethod:Main.kt$BenchmarkTool$override fun run()</ID>
    <ID>LongMethod:Main.kt$Main$override fun start(stage: Stage)</ID>
    <ID>LongMethod:Main.kt$Node$fun avalancheLoop()</ID>
    <ID>LongMethod:Main.kt$fun connectAndAuthenticate(config: ToolConfig, block: (CryptoServerProvider) -&gt; Unit)</ID>
    <ID>LongMethod:Main.kt$fun generateSgxKey(config: ToolConfig)</ID>
    <ID>LongMethod:Main.kt$fun getMonitorable(proxy: CordaRPCOps, target: String?, notary: String?): Monitorable</ID>
    <ID>LongMethod:Main.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:Main.kt$fun sign(config: ToolConfig)</ID>
    <ID>LongMethod:Main.kt$private fun runLoadTest(loadTestConfiguration: LoadTestConfiguration)</ID>
    <ID>LongMethod:Main.kt$private fun runStabilityTest(loadTestConfiguration: LoadTestConfiguration)</ID>
    <ID>LongMethod:MainView.kt$MainView$fun initializeControls()</ID>
    <ID>LongMethod:MappedList.kt$MappedList$override fun sourceChanged(change: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>LongMethod:MatcherTests.kt$MatcherTests$@Test fun `nested items indent`()</ID>
    <ID>LongMethod:MaxTransactionSizeTests.kt$MaxTransactionSizeTests$@Test fun `check transaction will fail when exceed max transaction size limit`()</ID>
    <ID>LongMethod:MerkleTransaction.kt$FilteredTransaction.Companion$fun &lt;T : Any&gt; filter(t: T, componentGroupIndex: Int, internalIndex: Int)</ID>
    <ID>LongMethod:MessagingExecutor.kt$MessagingExecutor$fun cordaToArtemisMessage(message: Message, target: MessageRecipients? = null): ClientMessage?</ID>
    <ID>LongMethod:MessagingExecutor.kt$MessagingExecutor$fun start()</ID>
    <ID>LongMethod:MigrationExporter.kt$MigrationExporter$fun generateMigrationForCorDapp(mappedSchema: MappedSchema): Pair&lt;Class&lt;*&gt;, Path&gt;</ID>
    <ID>LongMethod:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$private fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>LongMethod:MockAttachmentStorage.kt$MockAttachmentStorage$private fun importAttachmentInternal(jar: InputStream, uploader: String, contractClassNames: List&lt;ContractClassName&gt;? = null, attachmentId: AttachmentId? = null, signers: List&lt;PublicKey&gt; = emptyList()): AttachmentId</ID>
    <ID>LongMethod:MockCordappProvider.kt$MockCordappProvider$fun addMockCordapp( contractClassName: ContractClassName, attachments: MockAttachmentStorage, contractHash: AttachmentId? = null, signers: List&lt;PublicKey&gt; = emptyList(), jarManifestAttributes: Map&lt;String,String&gt; = emptyMap() ): AttachmentId</ID>
    <ID>LongMethod:MockNodeMessagingService.kt$MockNodeMessagingService$ fun start(network: InMemoryMessagingNetwork, manuallyPumped: Boolean, id: Int, notaryService: PartyAndCertificate?)</ID>
    <ID>LongMethod:MockNodeMessagingService.kt$MockNodeMessagingService$ private fun getNextQueue(q: LinkedBlockingQueue&lt;InMemoryMessagingNetwork.MessageTransfer&gt;, block: Boolean): Pair&lt;InMemoryMessagingNetwork.MessageTransfer, List&lt;Handler&gt;&gt;?</ID>
    <ID>LongMethod:MockNodeMessagingService.kt$MockNodeMessagingService$private fun pumpReceiveInternal(block: Boolean): InMemoryMessagingNetwork.MessageTransfer?</ID>
    <ID>LongMethod:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndMockServices(cordappPackages: List&lt;String&gt;, identityService: IdentityService, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), vararg moreKeys: KeyPair): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>LongMethod:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndPersistentServices( cordappPackages: List&lt;String&gt;, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), moreKeys: Set&lt;KeyPair&gt;, moreIdentities: Set&lt;PartyAndCertificate&gt; ): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>LongMethod:ModeSelectingChannel.kt$ModeSelectingChannel$override fun decode(ctx: ChannelHandlerContext, inByteBuf: ByteBuf, out: MutableList&lt;Any&gt;?)</ID>
    <ID>LongMethod:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$@Test fun calculatedValues()</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$// The flow's event queue may be non-empty in case it shut down abruptly. We handle outstanding events here. private fun drainFlowEventQueue(flow: Flow)</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$override fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$override fun start(tokenizableServices: List&lt;Any&gt;)</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun &lt;A&gt; startFlowInternal( invocationContext: InvocationContext, flowLogic: FlowLogic&lt;A&gt;, flowStart: FlowStart, ourIdentity: Party, deduplicationHandler: DeduplicationHandler?, isStartIdempotent: Boolean ): CordaFuture&lt;FlowStateMachine&lt;A&gt;&gt;</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun addAndStartFlow(id: StateMachineRunId, flow: Flow)</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun createFlowFromCheckpoint( id: StateMachineRunId, serializedCheckpoint: SerializedBytes&lt;Checkpoint&gt;, isAnyCheckpointPersisted: Boolean, isStartIdempotent: Boolean, initialDeduplicationHandler: DeduplicationHandler? ): Flow?</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun onExistingSessionMessage(sessionMessage: ExistingSessionMessage, deduplicationHandler: DeduplicationHandler, sender: Party)</ID>
    <ID>LongMethod:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun onSessionInit(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent)</ID>
    <ID>LongMethod:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$@Test fun `detect double spend`()</ID>
    <ID>LongMethod:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$@Test fun `handles reference states`()</ID>
    <ID>LongMethod:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$@Test fun `handles transactions with only reference states`()</ID>
    <ID>LongMethod:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$@Test fun `should re-sign a transaction with an expired time-window without input states`()</ID>
    <ID>LongMethod:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$@Test fun `should re-sign a transaction with an expired time-window`()</ID>
    <ID>LongMethod:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests.RequestGenerationFlow$@Suspendable override fun call(): List&lt;Result&gt;</ID>
    <ID>LongMethod:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$ override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;Result&gt;</ID>
    <ID>LongMethod:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$ private fun &lt;T&gt; runWithRetry(operation: DBOperation&lt;T&gt;): T</ID>
    <ID>LongMethod:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$ private fun processBuffer(buffer: LinkedList&lt;CommitRequest&gt;)</ID>
    <ID>LongMethod:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$override fun execute(connection: Connection): Map&lt;UUID, Result&gt;</ID>
    <ID>LongMethod:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$private fun findAlreadyCommitted(connection: Connection, states: Set&lt;StateRef&gt;, references: Set&lt;StateRef&gt;): Map&lt;StateRef, StateConsumptionDetails&gt;</ID>
    <ID>LongMethod:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$private fun handleNoConflicts( request: CommitRequest, connection: Connection, toCommit: MutableList&lt;CommitRequest&gt;, allConflicts: MutableMap&lt;StateRef, StateConsumptionDetails&gt; ): Result</ID>
    <ID>LongMethod:MySQLUniquenessProviderTest.kt$MySQLUniquenessProviderTest$@Test fun `intra-batch conflict between reference state and input state is detected`()</ID>
    <ID>LongMethod:NetParams.kt$NetParamsSigner$override fun runProgram(): Int</ID>
    <ID>LongMethod:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$private fun buildContexts( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, serverCAScheme: SignatureScheme, serverTLSScheme: SignatureScheme, clientCAScheme: SignatureScheme, clientTLSScheme: SignatureScheme, cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES ): Pair&lt;SslContext, SslContext&gt;</ID>
    <ID>LongMethod:NettyTestClient.kt$NettyTestClient$private fun run()</ID>
    <ID>LongMethod:NettyTestServer.kt$NettyTestServer$fun run()</ID>
    <ID>LongMethod:Network.kt$Network$private fun NodeInfo.render(): MapViewComponents</ID>
    <ID>LongMethod:Network.kt$Network$private fun NodeInfo.renderButton(mapLabel: Label): Button</ID>
    <ID>LongMethod:Network.kt$Network$private fun fireBulletBetweenNodes(senderParty: Party, destParty: Party, startType: String, endType: String)</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun bootstrap( directory: Path, cordappJars: List&lt;Path&gt;, copyCordapps: CopyCordapps, fromCordform: Boolean, networkParametersOverrides: NetworkParametersOverrides = NetworkParametersOverrides() )</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun createNodeDirectoriesIfNeeded(directory: Path, fromCordform: Boolean): Boolean</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun installNetworkParameters( notaryInfos: List&lt;NotaryInfo&gt;, whitelist: Map&lt;String, List&lt;AttachmentId&gt;&gt;, existingNetParams: NetworkParameters?, nodeDirs: List&lt;Path&gt;, networkParametersOverrides: NetworkParametersOverrides ): NetworkParameters</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun loadNetworkParameters(nodeDirs: List&lt;Path&gt;): NetworkParameters?</ID>
    <ID>LongMethod:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$private fun generateNodeInfo(nodeDir: Path): Path</ID>
    <ID>LongMethod:NetworkBuilder.kt$NetworkBuilderImpl$override fun build(): CompletableFuture&lt;Pair&lt;List&lt;NodeInstance&gt;, Context&gt;&gt;</ID>
    <ID>LongMethod:NetworkMapHttpProxyTest.kt$AuthenticatedHttpProxy$private fun validateProxyAuth(clientRequest: HttpServletRequest?, proxyResponse: HttpServletResponse?): Boolean</ID>
    <ID>LongMethod:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$@POST @Path("publish") @Consumes(MediaType.APPLICATION_OCTET_STREAM) fun publishNodeInfo(input: InputStream): Response</ID>
    <ID>LongMethod:NetworkMapTest.kt$NetworkMapTest$@Test fun `parameters update test`()</ID>
    <ID>LongMethod:NetworkMapTest.kt$NetworkMapTest$@Test fun `test node heartbeat`()</ID>
    <ID>LongMethod:NetworkMapTest.kt$NetworkMapTest.Companion$@JvmStatic @Parameterized.Parameters(name = "{0}") fun runParams()</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun start(trustRoot: X509Certificate, currentParametersHash: SecureHash, ourNodeInfo: SignedNodeInfo, networkParameters: NetworkParameters, keyManagementService: KeyManagementService, networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings)</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun updateNetworkMapCache(): Duration</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$private fun handleUpdateNetworkParameters(networkMapClient: NetworkMapClient, update: ParametersUpdate)</ID>
    <ID>LongMethod:NetworkMapUpdater.kt$NetworkMapUpdater$private fun watchForNodeInfoFiles(): Subscription</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `auto acceptance checks are correct`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `emit new parameters update info on parameters update from network map`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `process add node updates from network map, with additional node infos from dir`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `process remove node updates from network map, with additional node infos from dir`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `remove node from filesystem deletes it from network map cache`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `remove node info file, but node in network map server`()</ID>
    <ID>LongMethod:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$private fun createMockNetworkMapCache(): NetworkMapCacheInternal</ID>
    <ID>LongMethod:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$override fun parseValid(configuration: Config, options: Configuration.Options): Validated&lt;PackageOwner, Configuration.Validation.Error&gt;</ID>
    <ID>LongMethod:NetworkParameters.kt$NetworkParameters$ fun copy(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations ): NetworkParameters</ID>
    <ID>LongMethod:NetworkParameters.kt$NetworkParameters$ fun copy(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations, eventHorizon: Duration = this.eventHorizon ): NetworkParameters</ID>
    <ID>LongMethod:NetworkParametersReader.kt$NetworkParametersReader$fun read(): NetworkParametersAndSigned</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$// This function is resolving and signing WireTransaction with special parameters. private fun TransactionBuilder.toSignedTransactionWithParameters(parameters: NetworkParameters?, services: ServiceHub): SignedTransaction</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$@Test fun `incorrect triangle of transactions`()</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$@Test fun `request parameters that are not in the storage`()</ID>
    <ID>LongMethod:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$@Test fun `transaction chain out of order parameters`()</ID>
    <ID>LongMethod:NetworkParametersTest.kt$NetworkParametersTest$@Test fun `package ownership checks are correct`()</ID>
    <ID>LongMethod:NetworkParametersTest.kt$NetworkParametersTest$@Test fun `that we can copy while preserving the event horizon`()</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ fun generateKeysAndRegister(tslPublicKey: PublicKey? = null)</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun submitOrResumeCertificateSigningRequest(publicKey: PublicKey, contentSigner: ContentSigner): String</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$fun generateNodeIdentity()</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private fun validateCertificates(registeringPublicKey: PublicKey, certificates: List&lt;X509Certificate&gt;)</ID>
    <ID>LongMethod:NetworkRegistrationHelper.kt$NodeRegistrationHelper$private fun createSSLKeystore(nodeCaPublicKey: PublicKey, tlsPublicKey: PublicKey?, nodeCaContentSigner: ContentSigner, nodeCaCertificateChain: List&lt;X509Certificate&gt;, tlsCertCrlIssuer: X500Name?)</ID>
    <ID>LongMethod:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$@Before fun init()</ID>
    <ID>LongMethod:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$@Test fun `successful registration`()</ID>
    <ID>LongMethod:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$private fun createRegistrationHelper(certRole: CertRole = CertRole.NODE_CA, dynamicResponse: (JcaPKCS10CertificationRequest) -&gt; List&lt;X509Certificate&gt;): NetworkRegistrationHelper</ID>
    <ID>LongMethod:NetworkStatusCollector.kt$NetworkStatusCollector$override fun collect(report: Report)</ID>
    <ID>LongMethod:NewTransaction.kt$NewTransaction$fun show(window: Window)</ID>
    <ID>LongMethod:NewTransaction.kt$NewTransaction$private fun newTransactionDialog(window: Window)</ID>
    <ID>LongMethod:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>LongMethod:Node.kt$Node$ private fun tryDetectIfNotPublicHost(host: String): String?</ID>
    <ID>LongMethod:Node.kt$Node$override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters)</ID>
    <ID>LongMethod:Node.kt$Node$private fun makeBridgeControlListener(serverAddress: NetworkHostAndPort, networkParameters: NetworkParameters) : BridgeControlListener?</ID>
    <ID>LongMethod:NodeAttachmentService.kt$NodeAttachmentService$// TODO: PLT-147: The attachment should be randomised to prevent brute force guessing and thus privacy leaks. private fun import(jar: InputStream, uploader: String?, filename: String?): AttachmentId</ID>
    <ID>LongMethod:NodeAttachmentService.kt$NodeAttachmentService$private fun createAttachmentFromDatabase(attachment: DBAttachment): Attachment</ID>
    <ID>LongMethod:NodeAttachmentService.kt$NodeAttachmentService$private fun getContractAttachmentVersions(contractClassName: String): NavigableMap&lt;Version, AttachmentIds&gt;</ID>
    <ID>LongMethod:NodeAttachmentService.kt$NodeAttachmentService.Companion$// Just iterate over the entries with verification enabled: should be good enough to catch mistakes. // Note that JarInputStream won't throw any kind of error at all if the file stream is in fact not // a ZIP! It'll just pretend it's an empty archive, which is kind of stupid but that's how it works. // So we have to check to ensure we found at least one item. // // For signed Jars add additional checks to close security holes left by the default jarSigner verifier: // - All entries listed in the Manifest are in the JAR file. // - No extra files in the JAR that were not listed in the Manifest. // Together with the check that all entries need to be signed by the same signers that is performed when the signers are read, // it should close any possibility of foul play. internal fun checkIsAValidJAR(stream: InputStream)</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `The strict JAR verification function fails signed JARs with removed or extra files that are valid according to the usual jarsigner`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing a single public key`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing multiple public keys`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `contract class, versioning and signing metadata can be used to search`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `corrupt entry throws exception`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `development mode - retrieve latest versions of signed contracts - multiple versions of same version id exist in store`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `getAllAttachmentsByCriteria returns all stored attachments when no filtering is applied`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `getAllAttachmentsByCriteria returns attachments filtered by criteria`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `missing is not cached`()</ID>
    <ID>LongMethod:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `sorting and compound conditions work`()</ID>
    <ID>LongMethod:NodeAttachmentTrustCalculator.kt$NodeAttachmentTrustCalculator$override fun calculateAllTrustInfo(): List&lt;AttachmentTrustInfo&gt;</ID>
    <ID>LongMethod:NodeBasedTest.kt$NodeBasedTest$@JvmOverloads fun initNode(legalName: CordaX500Name, platformVersion: Int = PLATFORM_VERSION, rpcUsers: List&lt;User&gt; = emptyList(), configOverrides: Map&lt;String, Any&gt; = emptyMap(), flowManager: FlowManager = NodeFlowManager(FlowOverrideConfig())): InProcessNode</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$@Test fun `reading node configuration allows systemProperties and custom`()</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$@Test fun `reading node configuration`()</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$@Test fun `reading webserver configuration`()</ID>
    <ID>LongMethod:NodeConfigTest.kt$NodeConfigTest$private fun createConfig( legalName: CordaX500Name = CordaX500Name(organisation = "Unknown", locality = "Nowhere", country = "GB"), p2pPort: Int = -1, rpcPort: Int = -1, rpcAdminPort: Int = -1, webPort: Int = -1, h2port: Int = -1, notary: NotaryService?, users: List&lt;User&gt; = listOf(user("guest")), issuableCurrencies: List&lt;String&gt; = emptyList() ): NodeConfig</ID>
    <ID>LongMethod:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$private fun testNodeConfiguration(): NodeConfigurationImpl</ID>
    <ID>LongMethod:NodeController.kt$NodeController$ fun validate(nodeData: NodeData): NodeConfigWrapper?</ID>
    <ID>LongMethod:NodeController.kt$NodeController$fun runCorda(pty: R3Pty, config: NodeConfigWrapper): Boolean</ID>
    <ID>LongMethod:NodeControllerTest.kt$NodeControllerTest$private fun createConfig( organisation: String = "Unknown", p2pPort: Int = 0, rpcPort: Int = 0, rpcAdminPort: Int = 0, webPort: Int = 0, h2port: Int = 0, notary: NotaryService? = null, users: List&lt;User&gt; = listOf(user("guest")) ): NodeConfigWrapper</ID>
    <ID>LongMethod:NodeCopier.kt$NodeCopier$fun copyBootstrapperFiles(nodeCacheDir: File)</ID>
    <ID>LongMethod:NodeCopier.kt$NodeCopier$internal fun mergeConfigs(configInCacheDir: File, rpcSettings: ConfigValue, sshSettings: ConfigValue, mergeMode: Mode = Mode.NODE)</ID>
    <ID>LongMethod:NodeInfo.kt$NodeInfoSigner$override fun runProgram(): Int</ID>
    <ID>LongMethod:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun atomicCopy(source: Path, destination: Path)</ID>
    <ID>LongMethod:NodeInfoWatcher.kt$NodeInfoWatcher$private fun pollDirectory(): List&lt;NodeInfoUpdate&gt;</ID>
    <ID>LongMethod:NodeJanitor.kt$NodeJanitor$ fun cleanUpProcessedMessages(database: CordaPersistence, clock: Clock, retainForDays: Int, retainPerSender: Int)</ID>
    <ID>LongMethod:NodeJanitor.kt$NodeJanitor$ private fun leaveOnlyLatestPerSender(session: Session, retainPerSender: Int): Int</ID>
    <ID>LongMethod:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$@Test fun `node should throw exception if cert path does not chain to the trust root`()</ID>
    <ID>LongMethod:NodeMonitorModel.kt$NodeMonitorModel$ fun register(nodeHostAndPort: NetworkHostAndPort, username: String, password: String)</ID>
    <ID>LongMethod:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>LongMethod:NodePerformanceTests.kt$NodePerformanceTests$@Test fun `empty flow per second`()</ID>
    <ID>LongMethod:NodePerformanceTests.kt$NodePerformanceTests$@Test fun `self pay rate without selection`()</ID>
    <ID>LongMethod:NodePerformanceTests.kt$NodePerformanceTests$@Test fun `self pay rate`()</ID>
    <ID>LongMethod:NodeProcess.kt$NodeProcess.Factory$private fun waitForNode(process: Process, config: NodeConfig, client: CordaRPCClient)</ID>
    <ID>LongMethod:NodeRPCTests.kt$NodeRPCTests$@Test fun `run nodeDiagnosticInfo`()</ID>
    <ID>LongMethod:NodeSchedulerService.kt$NodeSchedulerService$private fun getFlow(scheduledState: ScheduledStateRef): FlowLogic&lt;*&gt;?</ID>
    <ID>LongMethod:NodeSchedulerService.kt$NodeSchedulerService$private fun runLoopFunction()</ID>
    <ID>LongMethod:NodeSchedulerService.kt$NodeSchedulerService.Companion$ // We should try to make the Clock used in our code injectable (for tests etc) and to use the extension below // to wait in our code, rather than &lt;code&gt;Thread.sleep()&lt;/code&gt; or other time-based pauses. @Suspendable @VisibleForTesting // We specify full classpath on SettableFuture to differentiate it from the Quasar class of the same name fun awaitWithDeadline(clock: CordaClock, deadline: Instant, future: Future&lt;*&gt; = GuavaSettableFuture.create&lt;Any&gt;()): Boolean</ID>
    <ID>LongMethod:NodeSchedulerServiceTest.kt$NodeSchedulerPersistenceTest$@Ignore("Temporarily") @Test fun `test that if schedule is updated then the flow is invoked on the correct schedule`()</ID>
    <ID>LongMethod:NodeSchedulerServiceTest.kt$NodeSchedulerPersistenceTest$@Test fun `test that schedule is persisted`()</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$fun initialiseAndRun(cmdLineOptions: SharedNodeCmdLineOptions, afterNodeInitialisation: RunAfterNodeInitialisation, requireCertificates: Boolean = false): Int</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$fun isNodeRunningAt(baseDirectory: Path): Boolean</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$fun startNode(node: Node, startTime: Long)</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$open fun drawBanner(versionInfo: VersionInfo)</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$private fun lookupMachineNameAndMaybeWarn(): String</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartup$protected open fun logStartupInfo(versionInfo: VersionInfo, conf: NodeConfiguration)</ID>
    <ID>LongMethod:NodeStartup.kt$NodeStartupCli$override fun runProgram(): Int</ID>
    <ID>LongMethod:NodeStartup.kt$fun CliWrapperBase.initLogging(baseDirectory: Path): Boolean</ID>
    <ID>LongMethod:NodeStartupForWrappedKeysTest.kt$NodeStartupForWrappedKeysTest$@Test fun `when initial registration is done without secure confidential identities enabled, then subsequent startup with this enabled will fail`()</ID>
    <ID>LongMethod:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$@Test fun `persistent state survives node restart without reinitialising database schema`()</ID>
    <ID>LongMethod:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$@Test fun `persistent state survives node restart`()</ID>
    <ID>LongMethod:NodeTabView.kt$NodeTabView$private fun Pane.nearestCityField(): ComboBox&lt;WorldMapLocation&gt;</ID>
    <ID>LongMethod:NodeTabView.kt$NodeTabView$private fun launchNode(config: NodeConfigWrapper)</ID>
    <ID>LongMethod:NodeTerminalView.kt$NodeTerminalView$/* * We only want to run one web server for each node. * So disable the "launch" button when we have * launched the web server and only reenable it when * the web server has exited. */ private fun configureWebButton(config: NodeConfigWrapper)</ID>
    <ID>LongMethod:NodeTerminalView.kt$NodeTerminalView$@Suppress("DEPRECATION") private fun initialise(config: NodeConfigWrapper, ops: CordaRPCOps)</ID>
    <ID>LongMethod:NodeTerminalView.kt$NodeTerminalView$fun open(config: NodeConfigWrapper, onExit: (Int) -&gt; Unit)</ID>
    <ID>LongMethod:NodeTest.kt$NodeTest$@Test fun `Node can start with multiple keypairs for its identity`()</ID>
    <ID>LongMethod:NodeTest.kt$NodeTest$@Test fun `clear network map cache works`()</ID>
    <ID>LongMethod:NodeTest.kt$NodeTest$private fun createConfig(nodeName: CordaX500Name): NodeConfigurationImpl</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$ fun bootstrapContractStateTypes()</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$@Suspendable @Throws(StatesNotAvailableException::class) override fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending( lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt; ): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$@Throws(StatesNotAvailableException::class) override fun softLockReserve(lockId: UUID, stateRefs: NonEmptySet&lt;StateRef&gt;)</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$fun makeUpdate(tx: WireTransaction): Vault.Update&lt;ContractState&gt;?</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$fun resolveAndMakeUpdate(tx: CoreTransaction): Vault.Update&lt;ContractState&gt;?</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$override fun softLockRelease(lockId: UUID, stateRefs: NonEmptySet&lt;StateRef&gt;?)</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$private fun loadStatesWithVaultFilter(refs: Collection&lt;StateRef&gt;): Collection&lt;StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$private fun recordUpdate(update: Vault.Update&lt;ContractState&gt;, previouslySeen: Boolean): Vault.Update&lt;ContractState&gt;</ID>
    <ID>LongMethod:NodeVaultService.kt$NodeVaultService$private fun saveStates(session: Session, states: Map&lt;StateRef, StateAndRef&lt;ContractState&gt;&gt;, now: Instant, produced: Boolean)</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$// TODO: Unit test linear state relevancy checks @Test fun `correct updates are generated for general transactions`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test @Ignore fun `trackByCriteria filters updates and snapshots`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `attempt to lock states already soft locked by me`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `correct txs are marked as consumed`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `correct updates are generated when changing notaries`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `fungible state selection test`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `lock additional states to some already soft locked by me`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `soft locking attempt concurrent reserve`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `soft locking partial reserve states fails`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `states soft locking query granularity`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `states soft locking reserve and release`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun `unconsumedStatesForSpending from specific issuer party and refs`()</ID>
    <ID>LongMethod:NodeVaultServiceTest.kt$NodeVaultServiceTest$@Test fun addNoteToTransaction()</ID>
    <ID>LongMethod:NodeWebServer.kt$NodeWebServer$private fun buildServletContextHandler(localRpc: CordaRPCOps): ServletContextHandler</ID>
    <ID>LongMethod:NodeWebServer.kt$NodeWebServer$private fun initWebServer(localRpc: CordaRPCOps): Server</ID>
    <ID>LongMethod:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$override fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>LongMethod:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$@Test fun `should re-sign a transaction with an expired time-window`()</ID>
    <ID>LongMethod:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$@Test fun `should report conflict when inputs are reused across transactions`()</ID>
    <ID>LongMethod:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$@Test fun `should sign identical transaction multiple times (notarisation is idempotent)`()</ID>
    <ID>LongMethod:NotaryChangeTests.kt$NotaryChangeTests$@Test fun `should not break encumbrance links`()</ID>
    <ID>LongMethod:NotaryCopier.kt$NotaryCopier$private fun copyNotaryBootstrapperFiles(nodeCacheDir: File)</ID>
    <ID>LongMethod:NotaryRegistrationTool.kt$NotaryRegistrationTool$// Make sure the nodes don't have conflicting crypto service configurations private fun validateNodeHsmConfigs(configFiles: List&lt;Path&gt;)</ID>
    <ID>LongMethod:NotaryRegistrationTool.kt$NotaryRegistrationTool$override fun runProgram(): Int</ID>
    <ID>LongMethod:NotaryServiceFlow.kt$NotaryServiceFlow$@Suspendable override fun call(): Void?</ID>
    <ID>LongMethod:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can't perform a regular transaction on a de-listed notary`()</ID>
    <ID>LongMethod:NotaryWhitelistTests.kt$NotaryWhitelistTests$@Test fun `should reject transaction when a dependency does not contain notary in whitelist`()</ID>
    <ID>LongMethod:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$// obtains the data and calculates the grid of results private fun calculate(runner: CalculationRunner)</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// Create a fixed vs libor 3m swap private fun createStub3mFixedVsLibor3mSwap(): Trade</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// Create an overnight averaged vs libor 3m swap with spread private fun createOvernightAveragedWithSpreadVsLibor3mSwap(): Trade</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// create a libor 3m vs libor 6m basis swap with spread private fun createBasisLibor3mVsLibor6mWithSpreadSwap(): Trade</ID>
    <ID>LongMethod:OGSwapPricingExample.kt$SwapPricingExample$// obtains the data and calculates the grid of results private fun calculate(runner: CalculationRunner)</ID>
    <ID>LongMethod:OGTrade.kt$OGTrade$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>LongMethod:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$fun make(localTypeInformation: LocalTypeInformation.Composable, remoteTypeInformation: RemoteTypeInformation.Composable, constructor: LocalConstructorInformation, properties: Map&lt;String, LocalPropertyInformation&gt;, classLoader: ClassLoader, mustPreserveData: Boolean): EvolutionObjectSerializer</ID>
    <ID>LongMethod:ObjectSerializer.kt$ObjectSerializer.Companion$private fun makeForComposable(typeInformation: LocalTypeInformation.Composable, typeNotation: CompositeType, typeDescriptor: Symbol, factory: LocalSerializerFactory): ComposableObjectSerializer</ID>
    <ID>LongMethod:ObligationUtils.kt$ObligationUtils$ @JvmStatic fun &lt;P : Any&gt; generateSetLifecycle(tx: TransactionBuilder, statesAndRefs: List&lt;StateAndRef&lt;Obligation.State&lt;P&gt;&gt;&gt;, lifecycle: Obligation.Lifecycle, notary: Party)</ID>
    <ID>LongMethod:ObligationUtils.kt$ObligationUtils$ @JvmStatic fun &lt;P : Any&gt; generateSettle(tx: TransactionBuilder, statesAndRefs: Iterable&lt;StateAndRef&lt;Obligation.State&lt;P&gt;&gt;&gt;, assetStatesAndRefs: Iterable&lt;StateAndRef&lt;FungibleAsset&lt;P&gt;&gt;&gt;, moveCommand: MoveCommand, notary: Party)</ID>
    <ID>LongMethod:ObligationUtils.kt$ObligationUtils$@JvmStatic fun &lt;P : Any&gt; generatePaymentNetting(tx: TransactionBuilder, issued: Issued&lt;Obligation.Terms&lt;P&gt;&gt;, notary: Party, vararg inputs: StateAndRef&lt;Obligation.State&lt;P&gt;&gt;)</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit delays until transaction closed repeatable`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit delays until transaction closed`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit propagates error if transaction rolled back`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `bufferUntilDatabaseCommit swallows if transaction rolled back`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `check wrapping in db tx restarts if we pass through zero subscribers`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `combine tee and bufferUntilDatabaseCommit`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `new transaction open in observer when wrapped`()</ID>
    <ID>LongMethod:ObservablesTests.kt$ObservablesTests$@Test fun `tee correctly copies observations to multiple observers`()</ID>
    <ID>LongMethod:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T : Any&gt; generateSpend(tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;T&gt;&gt;, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData): Pair&lt;TransactionBuilder, List&lt;PublicKey&gt;&gt;</ID>
    <ID>LongMethod:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T: Any&gt; generateExit(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData): Set&lt;PublicKey&gt;</ID>
    <ID>LongMethod:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$@Test fun `flows draining mode suspends consumption of initial session messages`()</ID>
    <ID>LongMethod:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$ private fun isDuplicateWithPotentialOptimization(receivedSenderUUID: String, receivedSenderSeqNo: Long, msg: ReceivedMessage): Boolean</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun run()</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun start(myIdentity: PublicKey, serviceIdentity: PublicKey?, maxMessageSize: Int, advertisedAddress: NetworkHostAndPort = serverAddress, legalName: String)</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$ fun stop()</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$fun deliver(artemisMessage: ClientMessage)</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$private fun InnerState.registerBridgeControl(session: ClientSession, inboxes: List&lt;String&gt;)</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$private fun artemisToCordaMessage(message: ClientMessage): ReceivedMessage?</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingClient$private fun failoverCallback(event: FailoverEventType)</ID>
    <ID>LongMethod:P2PMessagingClient.kt$P2PMessagingConsumer$override fun start()</ID>
    <ID>LongMethod:ParametersUtilities.kt$@JvmOverloads fun testNetworkParameters( notaries: List&lt;NotaryInfo&gt; = emptyList(), minimumPlatformVersion: Int = 1, modifiedTime: Instant = Instant.now(), maxMessageSize: Int = 10485760, // TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer maxTransactionSize: Int = maxMessageSize * 50, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = emptyMap(), epoch: Int = 1, eventHorizon: Duration = 30.days, packageOwnership: Map&lt;String, PublicKey&gt; = emptyMap() ): NetworkParameters</ID>
    <ID>LongMethod:PartialMerkleTree.kt$PartialMerkleTree.Companion$ private fun buildPartialTree( root: MerkleTree, includeHashes: List&lt;SecureHash&gt;, usedHashes: MutableList&lt;SecureHash&gt; ): Pair&lt;Boolean, PartialTree&gt;</ID>
    <ID>LongMethod:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$@Before fun init()</ID>
    <ID>LongMethod:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$@Test fun `Find leaf index`()</ID>
    <ID>LongMethod:PartyAndCertificate.kt$PartyAndCertificate$ fun verify(trustAnchor: TrustAnchor): PKIXCertPathValidatorResult</ID>
    <ID>LongMethod:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$@Before fun setUp()</ID>
    <ID>LongMethod:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$private fun addNetworkParameters()</ID>
    <ID>LongMethod:PersistentIdentityService.kt$PersistentIdentityService$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate): PartyAndCertificate?</ID>
    <ID>LongMethod:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>LongMethod:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$override fun addNodes(nodes: List&lt;NodeInfo&gt;)</ID>
    <ID>LongMethod:PersistentScheduledFlowRepositoryTest.kt$PersistentScheduledFlowRepositoryTest$@Test fun `test that item is rescheduled`()</ID>
    <ID>LongMethod:PersistentStateServiceTests.kt$PersistentStateServiceTests$@Test fun `test child objects are persisted`()</ID>
    <ID>LongMethod:PluginRegistrationTest.kt$PluginRegistrationTest$@Test fun `test plugin registration` ()</ID>
    <ID>LongMethod:PortAllocationTest.kt$PortAllocationTest$@Test(timeout = 120_000) fun `should support multiprocess port allocation`()</ID>
    <ID>LongMethod:PortfolioApi.kt$PortfolioApi$ @GET @Path("{party}/portfolio/history/aggregated") @Produces(MediaType.APPLICATION_JSON) fun getPartyPortfolioHistoryAggregated(@PathParam("party") partyName: String): Response</ID>
    <ID>LongMethod:PortfolioApi.kt$PortfolioApi$ @GET @Path("{party}/trades") @Produces(MediaType.APPLICATION_JSON) fun getPartyTrades(@PathParam("party") partyName: String): Response</ID>
    <ID>LongMethod:PortfolioApiUtils.kt$PortfolioApiUtils$fun createTradeView(rpc: CordaRPCOps, state: IRSState): TradeView</ID>
    <ID>LongMethod:PortfolioApiUtils.kt$PortfolioApiUtils$fun createValuations(state: PortfolioState, portfolio: Portfolio): ValuationsView</ID>
    <ID>LongMethod:PortfolioSwap.kt$PortfolioSwap$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrint(arr: Arrangement)</ID>
    <ID>LongMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBigDecimal(per: Perceivable&lt;BigDecimal&gt;)</ID>
    <ID>LongMethod:PrettyPrint.kt$PrettyPrint$fun prettyPrintBoolean(per: Perceivable&lt;Boolean&gt;)</ID>
    <ID>LongMethod:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$@Synchronized private fun handleStateChange(newState: ConnectionState?)</ID>
    <ID>LongMethod:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$@Synchronized private fun setLeadership(newValue: Boolean)</ID>
    <ID>LongMethod:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$@Throws(Exception::class) private fun checkLeadership(children: List&lt;String&gt;)</ID>
    <ID>LongMethod:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$@Throws(Exception::class) private fun reset()</ID>
    <ID>LongMethod:PrioritizedLeaderLatchTest.kt$PrioritizedLeaderLatchTest$@Test fun `start stop`()</ID>
    <ID>LongMethod:ProcessUtilities.kt$ProcessUtilities$fun startJavaProcess( className: String, arguments: List&lt;String&gt;, classPath: List&lt;String&gt; = defaultClassPath, workingDirectory: Path? = null, jdwpPort: Int? = null, extraJvmArguments: List&lt;String&gt; = emptyList(), maximumHeapSize: String? = null ): Process</ID>
    <ID>LongMethod:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun openProfile(): List&lt;InstallConfig&gt;?</ID>
    <ID>LongMethod:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun saveProfile(): Boolean</ID>
    <ID>LongMethod:Program.kt$ConfigObfuscatorCli$override fun runProgram(): Int</ID>
    <ID>LongMethod:Program.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:Program.kt$private fun Array&lt;String&gt;.readNodeConfigPaths(): NodeConfigurationPaths?</ID>
    <ID>LongMethod:Program.kt$private fun findTimeWindow(logFiles: List&lt;Path&gt;): TimeWindow</ID>
    <ID>LongMethod:Program.kt$private fun getUsernameAndPassword(): Pair&lt;String, String&gt;?</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `steps tree index counts children steps`()</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `steps tree index counts two levels of children steps`()</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `structure changes are pushed down when progress trackers are added`()</ID>
    <ID>LongMethod:ProgressTrackerTest.kt$ProgressTrackerTest$@Test fun `structure changes are pushed down when progress trackers are removed`()</ID>
    <ID>LongMethod:PropertyDescriptor.kt$PropertyDescriptor$ fun validate()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Client Failover for multiple IP`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Message sent from AMQP to non-existent Artemis inbox is rejected and client disconnects`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `SNI AMQP client to SNI AMQP server`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Send a message from AMQP to Artemis inbox`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Send a message larger then maxMessageSize from AMQP to Artemis inbox`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Simple AMPQ Client to Server`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `Test AMQP Client with invalid root certificate`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$@Test fun `shared AMQPClient threadpool tests`()</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createAmqpConfigWithMultipleCerts(legalNames: List&lt;CordaX500Name&gt;, sourceLegalName: String? = null, maxMessageSize: Int = MAX_MESSAGE_SIZE, crlCheckSoftFail: Boolean = true, useOpenSsl: Boolean) :AMQPConfiguration</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createArtemisServerAndClient(maxMessageSize: Int = MAX_MESSAGE_SIZE): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createClient(maxMessageSize: Int = MAX_MESSAGE_SIZE, expectedRemoteLegalNames: Set&lt;CordaX500Name&gt; = setOf(ALICE_NAME, CHARLIE_NAME)): AMQPClient</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createServer(port: Int, name: CordaX500Name = ALICE_NAME, maxMessageSize: Int = MAX_MESSAGE_SIZE, crlCheckSoftFail: Boolean = true): AMQPServer</ID>
    <ID>LongMethod:ProtonWrapperTests.kt$ProtonWrapperTests$private fun createSharedThreadsClient(sharedEventGroup: EventLoopGroup, id: Int, maxMessageSize: Int = MAX_MESSAGE_SIZE): AMQPClient</ID>
    <ID>LongMethod:ProxyUtils.kt$ProxyUtils$fun fromConfig(proxyConfig: ProxyConfig): ProxySettings</ID>
    <ID>LongMethod:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ override operator fun get(key: PublicKey): KeyOwningIdentity?</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$ fun recordUsedInstrumentedCallStack()</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$PackageTree$ fun toGlobs(excludeTree: PackageTree): List&lt;Glob&gt;</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$override fun transform( loader: ClassLoader?, className: String, classBeingRedefined: Class&lt;*&gt;?, protectionDomain: ProtectionDomain?, classfileBuffer: ByteArray ): ByteArray</ID>
    <ID>LongMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$@JvmStatic fun premain(argumentsString: String?, instrumentation: Instrumentation)</ID>
    <ID>LongMethod:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun copy( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes ): FungibleAssetQueryCriteria</ID>
    <ID>LongMethod:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun copy( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null ): VaultQueryCriteria</ID>
    <ID>LongMethod:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun copy( status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, stateRefs: List&lt;StateRef&gt;? = this.stateRefs, notary: List&lt;AbstractParty&gt;? = this.notary, softLockingCondition: SoftLockingCondition? = this.softLockingCondition, timeCondition: TimeCondition? = this.timeCondition ): VaultQueryCriteria</ID>
    <ID>LongMethod:RPCApi.kt$RPCApi.ClientToServer.Companion$fun fromClientMessage(message: ClientMessage): ClientToServer</ID>
    <ID>LongMethod:RPCApi.kt$RPCApi.ServerToClient.Companion$fun fromClientMessage(context: SerializationContext, message: ClientMessage): ServerToClient</ID>
    <ID>LongMethod:RPCClient.kt$RPCClient$fun start( rpcOpsClass: Class&lt;I&gt;, username: String, password: String, externalTrace: Trace? = null, impersonatedActor: Actor? = null, targetLegalIdentity: CordaX500Name? = null ): RPCConnection&lt;I&gt;</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ fun start()</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun attemptReconnect()</ID>
    <ID>LongMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun cleanUpOnConnectionLoss()</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL$fun &lt;I : RPCOps&gt; startRpcServerWithBrokerRunning( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, brokerHandle: RpcBrokerHandle, queueDrainTimeout: Duration = 5.seconds ): RpcServerHandle&lt;I&gt;</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL$fun startRpcBroker( serverName: String = "driver-rpc-server-${random63BitValue()}", rpcUser: User = rpcTestUser, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE, customPort: NetworkHostAndPort? = null ): CordaFuture&lt;RpcBrokerHandle&gt;</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL$private fun startInVmRpcBroker( rpcUser: User = rpcTestUser, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE ): CordaFuture&lt;RpcBrokerHandle&gt;</ID>
    <ID>LongMethod:RPCDriver.kt$RPCDriverDSL.Companion$private fun ConfigurationImpl.configureCommonSettings(maxFileSize: Int, maxBufferedBytesPerClient: Long)</ID>
    <ID>LongMethod:RPCDriver.kt$RandomRpcUser.Companion$@JvmStatic fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:RPCDriver.kt$fun &lt;A&gt; rpcDriver( isDebug: Boolean = false, driverDirectory: Path = Paths.get("build") / "rpc-driver" / getTimestampAsDirectoryName(), portAllocation: PortAllocation = globalPortAllocation, debugPortAllocation: PortAllocation = globalDebugPortAllocation, systemProperties: Map&lt;String, String&gt; = emptyMap(), useTestClock: Boolean = false, startNodesInProcess: Boolean = false, waitForNodesToFinish: Boolean = false, extraCordappPackagesToScan: List&lt;String&gt; = emptyList(), notarySpecs: List&lt;NotarySpec&gt; = emptyList(), externalTrace: Trace? = null, @Suppress("DEPRECATION") jmxPolicy: JmxPolicy = JmxPolicy(), networkParameters: NetworkParameters = testNetworkParameters(), notaryCustomOverrides: Map&lt;String, Any?&gt; = emptyMap(), inMemoryDB: Boolean = true, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, enableSNI:Boolean = true, dsl: RPCDriverDSL.() -&gt; A ): A</ID>
    <ID>LongMethod:RPCPerformanceTests.kt$RPCPerformanceTests$ @Test fun `consumption rate`()</ID>
    <ID>LongMethod:RPCPerformanceTests.kt$RPCPerformanceTests$@Test fun `big messages`()</ID>
    <ID>LongMethod:RPCPerformanceTests.kt$RPCPerformanceTests$@Test fun `measure Megabytes per second for simple RPCs`()</ID>
    <ID>LongMethod:RPCPermissionsTests.kt$RPCPermissionsTests$@Test fun `joe user can call different methods matching to a wildcard`()</ID>
    <ID>LongMethod:RPCProxyWebService.kt$RPCProxyWebService$private fun &lt;T&gt; use(action: (CordaRPCOps) -&gt; T): Response</ID>
    <ID>LongMethod:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$// enable Flow Draining on Node B @Test fun startMultiACPartyCashFlows()</ID>
    <ID>LongMethod:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$@Test fun startMultiABCPartyCashFlows()</ID>
    <ID>LongMethod:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$@Test fun startMultiPartyCashFlows()</ID>
    <ID>LongMethod:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$@Test fun vaultQueryCash()</ID>
    <ID>LongMethod:RPCSecurityManagerImpl.kt$RPCPermissionResolver$override fun resolvePermission(representation: String): Permission</ID>
    <ID>LongMethod:RPCSecurityManagerImpl.kt$RPCSecurityManagerImpl.Companion$// Build internal Shiro securityManager instance private fun buildImpl(config: AuthServiceConfig, cacheFactory: NamedCacheFactory): DefaultSecurityManager</ID>
    <ID>LongMethod:RPCSecurityManagerTest.kt$RPCSecurityManagerTest$private fun checkUserActions(permissions: Set&lt;String&gt;, permitted: Set&lt;List&lt;String&gt;&gt;)</ID>
    <ID>LongMethod:RPCServer.kt$RPCServer$fun start(activeMqServerControl: ActiveMQServerControl)</ID>
    <ID>LongMethod:RPCServer.kt$RPCServer$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$ @Test fun `server cleans up queues after disconnected clients`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test @Ignore // TODO: This is ignored because Artemis slow consumers are broken. I'm not deleting it in case we can get the feature fixed. fun `slow consumers are kicked`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `3 server failover`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `client cleans up leaked observables`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `client reconnects to rebooted server`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `connection failover fails, rpc calls throw`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `deduplication in the client`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `deduplication in the server`()</ID>
    <ID>LongMethod:RPCStabilityTests.kt$RPCStabilityTests$@Test fun `observables error when connection breaks`()</ID>
    <ID>LongMethod:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$@Test fun `detect double spend`()</ID>
    <ID>LongMethod:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$ fun commitTransaction(raftCommit: Commit&lt;Commands.CommitTransaction&gt;): NotaryError?</ID>
    <ID>LongMethod:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$ override fun install(reader: SnapshotReader)</ID>
    <ID>LongMethod:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$ override fun snapshot(writer: SnapshotWriter)</ID>
    <ID>LongMethod:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$@Test fun `transactions can be re-notarised outside their time window`()</ID>
    <ID>LongMethod:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$private fun createReplica(myAddress: NetworkHostAndPort, clusterAddress: NetworkHostAndPort? = null): CompletableFuture&lt;Member&gt;</ID>
    <ID>LongMethod:RaftUniquenessProvider.kt$RaftUniquenessProvider$fun start()</ID>
    <ID>LongMethod:RaftUniquenessProvider.kt$RaftUniquenessProvider$override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;UniquenessProvider.Result&gt;</ID>
    <ID>LongMethod:RaftUniquenessProvider.kt$RaftUniquenessProvider.Companion$fun createMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;StateRef, Pair&lt;Long, SecureHash&gt;, CommittedState, String&gt;</ID>
    <ID>LongMethod:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$@Test fun `sent to flow hospital on error and retry on node restart`()</ID>
    <ID>LongMethod:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$@Suppress("KDocMissingDocumentation") @Suspendable @Throws(SignatureException::class, AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class) override fun call(): SignedTransaction</ID>
    <ID>LongMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;?): Any?</ID>
    <ID>LongMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$private tailrec fun establishConnectionWithRetry(retryInterval: Duration = 1.seconds, roundRobinIndex: Int = 0): CordaRPCConnection</ID>
    <ID>LongMethod:ReferenceInputStateTests.kt$ReferenceStateTests$@Test fun `Can't use old reference states`()</ID>
    <ID>LongMethod:ReferenceInputStateTests.kt$ReferenceStateTests$@Test fun `create a reference state then refer to it multiple times`()</ID>
    <ID>LongMethod:ReferenceInputStateTests.kt$ReferenceStateTests.ExampleContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$@Test fun `check old ref state is consumed when update used in tx with relevant states`()</ID>
    <ID>LongMethod:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$@Test fun `check ref state is persisted when used in tx with relevant states`()</ID>
    <ID>LongMethod:RegistrationTool.kt$RegistrationTool$// Make sure the nodes don't have conflicting crypto service configurations private fun validateNodeHsmConfigs(configFiles: List&lt;Path&gt;)</ID>
    <ID>LongMethod:RegistrationTool.kt$RegistrationTool$override fun runTool()</ID>
    <ID>LongMethod:RegistrationTool.kt$RegistrationTool$private fun makeBridgeCryptoService(bridgeConfig: Config, configDir: Path): CryptoService?</ID>
    <ID>LongMethod:RegistrationToolTest.kt$RegistrationToolTest$@Test fun `register multiple nodes with conflicting crypto services configurations`()</ID>
    <ID>LongMethod:RegistrationToolTest.kt$RegistrationToolTest$@Test fun `register nodes and bridge using HSM`()</ID>
    <ID>LongMethod:RegistrationToolTest.kt$RegistrationToolTest$@Test fun `register nodes and bridge without HSM`()</ID>
    <ID>LongMethod:RegistrationToolTest.kt$RegistrationToolTest$@Test fun `the tool can register multiple nodes at the same time`()</ID>
    <ID>LongMethod:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$private fun getUncached( remoteTypeInformation: RemoteTypeInformation, localTypeInformation: LocalTypeInformation ): AMQPSerializer&lt;Any&gt;</ID>
    <ID>LongMethod:ReplayedList.kt$ReplayedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>LongMethod:ReplayedListTest.kt$ReplayedListTest$@Test fun addWorks()</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// DOCSTART 2 private fun makeTransactions(signFirstTX: Boolean = true, withAttachment: SecureHash? = null): Pair&lt;SignedTransaction, SignedTransaction&gt;</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$@Test fun `triangle of transactions resolves fine`()</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private fun contractUpgradeChain(): SignedTransaction</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private fun makeLargeTransactionChain(chainLength: Int): SignedTransaction</ID>
    <ID>LongMethod:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private fun notaryChangeChain(): SignedTransaction</ID>
    <ID>LongMethod:RetryFlowMockTest.kt$RetryFlowMockTest$@Test fun `Restart does not set senderUUID`()</ID>
    <ID>LongMethod:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$@Test fun roundTripTest1()</ID>
    <ID>LongMethod:RoundTripTests.kt$RoundTripTests$@Test fun canSerializeClassesWithUntypedProperties()</ID>
    <ID>LongMethod:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer$ override fun readObject(obj: Any, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext ): Observable&lt;*&gt;</ID>
    <ID>LongMethod:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$@Test fun `FlowException is received by the RPC client`()</ID>
    <ID>LongMethod:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$fun startRpcFlowWorker(legalNames: Set&lt;CordaX500Name&gt;, rpcUsers: List&lt;net.corda.testing.node.User&gt;, numberOfFlowWorkers: Int = 1): CordaFuture&lt;RpcFlowWorkerHandle&gt;</ID>
    <ID>LongMethod:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$private fun generateNodeAndFlowConfigs(myLegalName: CordaX500Name, numberOfFlowWorkers: Int): Pair&lt;NodeConfiguration, List&lt;NodeConfiguration&gt;&gt;</ID>
    <ID>LongMethod:RpcReconnectTests.kt$RpcReconnectTests$ @Test fun `test that the RPC client is able to reconnect and proceed after node failure, restart, or connection reset`()</ID>
    <ID>LongMethod:RpcServerObservableSerializer.kt$RpcServerObservableSerializer$override fun writeDescribedObject( obj: Observable&lt;*&gt;, data: Data, type: Type, output: SerializationOutput, context: SerializationContext )</ID>
    <ID>LongMethod:RpcSslTest.kt$RpcSslTest$@Test fun `RPC client using ssl is able to run a command`()</ID>
    <ID>LongMethod:RpcSslTest.kt$RpcSslTest$@Test fun `RPC client using ssl will fail if connecting to a node that cannot present a matching certificate`()</ID>
    <ID>LongMethod:RpcSslTest.kt$RpcSslTest$@Test fun `The system RPC user can not connect to the rpc broker without the node's key`()</ID>
    <ID>LongMethod:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$@Test fun `cash pay`()</ID>
    <ID>LongMethod:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$fun start()</ID>
    <ID>LongMethod:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$private fun initialiseSerialization()</ID>
    <ID>LongMethod:RpcWorkerStartStopTest.kt$RpcWorkerStartStopTest$@Test fun startStop()</ID>
    <ID>LongMethod:RunOnceService.kt$RunOnceService$fun start()</ID>
    <ID>LongMethod:RunOnceService.kt$RunOnceService$private fun updateTimestamp(session: Session, mutualExclusion: MutualExclusion): Boolean</ID>
    <ID>LongMethod:RunOnceServiceTest.kt$RunOnceServiceTest$@Test fun `timer updates row`()</ID>
    <ID>LongMethod:SNIBridgeTest.kt$SNIBridgeTest$@Test fun `Nodes behind all in one bridge can communicate with external node`()</ID>
    <ID>LongMethod:SSHServerTest.kt$SSHServerTest$@Ignore @Test fun `ssh runs flows`()</ID>
    <ID>LongMethod:SSHServerTest.kt$SSHServerTest$@Test fun `ssh respects permissions`()</ID>
    <ID>LongMethod:SSLHelper.kt$LoggingTrustManagerWrapper$private fun certPathToString(certPath: Array&lt;out X509Certificate&gt;?): String</ID>
    <ID>LongMethod:SSLHelper.kt$internal fun createClientSslHelper(target: NetworkHostAndPort, expectedRemoteLegalNames: Set&lt;CordaX500Name&gt;, keyManagerFactory: KeyManagerFactory, trustManagerFactory: TrustManagerFactory): SslHandler</ID>
    <ID>LongMethod:SSLHelper.kt$internal fun initialiseTrustStoreAndEnableCrlChecking(trustStore: CertificateStore, revocationConfig: RevocationConfig): ManagerFactoryParameters</ID>
    <ID>LongMethod:Samplers.kt$LinearStateBatchNotariseSampler$// Each iteration of the test returns the next measurement from the large batch request. override fun runTest(context: JavaSamplerContext): SampleResult</ID>
    <ID>LongMethod:ScheduledCheckFlow.kt$ScheduledCheckFlow$@Suspendable override fun call()</ID>
    <ID>LongMethod:ScheduledCheckFlow.kt$ScheduledCheckFlow$@Suspendable private fun checkNotary( state: SchedulingContract.ScheduledCheckState, stateAndRef: StateAndRef&lt;SchedulingContract.ScheduledCheckState&gt;, lastSuccessTime: Instant, monitoringService: MonitoringService, prefix: String)</ID>
    <ID>LongMethod:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$@Test fun `test that when states are being spent at the same time that schedules trigger everything is processed`()</ID>
    <ID>LongMethod:ScheduledFlowTests.kt$ScheduledFlowTests$@Test fun `create and run scheduled flow then wait for result`()</ID>
    <ID>LongMethod:ScheduledFlowTests.kt$ScheduledFlowTests$@Test fun `run a whole batch of scheduled flows`()</ID>
    <ID>LongMethod:ScheduledFlowsDrainingModeTest.kt$ScheduledFlowsDrainingModeTest$@Test fun `flows draining mode ignores scheduled flows until unset`()</ID>
    <ID>LongMethod:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>LongMethod:SchemaMigration.kt$SchemaMigration$private fun doRunMigration( run: Boolean, outputWriter: Writer?, check: Boolean, existingCheckpoints: Boolean? = null, statusLogger: Logger? = null )</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_does_not_show_sensitive_values()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_list_does_not_show_sensitive_values()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun validation_with_nested_properties()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun validation_with_unknown_properties()</ID>
    <ID>LongMethod:SchemaTest.kt$SchemaTest$@Test fun validation_with_wrong_nested_properties()</ID>
    <ID>LongMethod:SendTransactionFlow.kt$DataVendingFlow$@Suspendable override fun call(): Void?</ID>
    <ID>LongMethod:SerializationOutput.kt$SerializationOutput$internal fun &lt;T : Any&gt; _serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `class constructor is invoked on deserialisation`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `test complex throwables serialize`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `test suppressed throwables serialize`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun `test transaction state`()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$@Test fun isPrimitive()</ID>
    <ID>LongMethod:SerializationOutputTests.kt$SerializationOutputTests$private inline fun &lt;reified T : Any&gt; serdes(obj: T, factory: SerializerFactory = defaultFactory(), freshDeserializationFactory: SerializerFactory = defaultFactory(), expectedEqual: Boolean = true, expectDeserializedEqual: Boolean = true): T</ID>
    <ID>LongMethod:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$@Suppress("UNCHECKED_CAST") @Test fun randomOrderSetter()</ID>
    <ID>LongMethod:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$@Test fun randomOrder()</ID>
    <ID>LongMethod:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$@JvmStatic @DeleteForDJVM fun build( whitelist: ClassWhitelist, carpenterClassLoader: ClassLoader, lenientCarpenterEnabled: Boolean = false, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false): SerializerFactory</ID>
    <ID>LongMethod:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$@JvmStatic @DeleteForDJVM fun build( whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false): SerializerFactory</ID>
    <ID>LongMethod:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$private fun makeFactory(whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry, allowEvolution: Boolean, overrideFingerPrinter: FingerPrinter?, onlyCustomSerializers: Boolean, mustPreserveDataWhenEvolving: Boolean): SerializerFactory</ID>
    <ID>LongMethod:ServerSNIMatcher.kt$ServerSNIMatcher$override fun matches(serverName: SNIServerName): Boolean</ID>
    <ID>LongMethod:ServiceHubConcurrentUsageTest.kt$ServiceHubConcurrentUsageTest$@Test fun `operations requiring a transaction work from another thread`()</ID>
    <ID>LongMethod:ServiceHubInternal.kt$ServiceHubInternal.Companion$fun recordTransactions(statesToRecord: StatesToRecord, txs: Collection&lt;SignedTransaction&gt;, validatedTransactions: WritableTransactionStorage, stateMachineRecordedTransactionMapping: StateMachineRecordedTransactionMappingStorage, vaultService: VaultServiceInternal, database: CordaPersistence)</ID>
    <ID>LongMethod:ServiceStateTest.kt$ServiceStateTest$@Test fun `Test basic domino behaviour of combiner`()</ID>
    <ID>LongMethod:ServiceStateTest.kt$ServiceStateTest$@Test fun `Test state helper`()</ID>
    <ID>LongMethod:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>LongMethod:SettingsModelTest.kt$SettingsModelTest$@Test fun `test save config and rollback`()</ID>
    <ID>LongMethod:SharedMemoryIncremental.kt$SharedMemoryIncremental$override fun nextPort(): Int</ID>
    <ID>LongMethod:ShutdownManager.kt$ShutdownManager$fun shutdown()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `HashConstraint cannot be migrated to SignatureConstraint if a HashConstraint is specified for one state and another uses an AutomaticPlaceholderConstraint`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `can evolve from lower contract class version to higher one`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `WhitelistConstraint cannot be migrated to SignatureConstraint if platform version is not 4 or greater`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint will only transition states that do not have a constraint specified`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint`()</ID>
    <ID>LongMethod:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `can evolve from lower contract class version to higher one`()</ID>
    <ID>LongMethod:SignatureConstraintVersioningTests.kt$ConsumeMessage$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$ fun upgradeCorDappBetweenTransactions( cordapp: CustomCordapp, newCordapp: CustomCordapp, whiteListedCordapps: Map&lt;ContractClassName, List&lt;CustomCordapp&gt;&gt;, systemProperties: Map&lt;String, String&gt;, startNodesInProcess: Boolean, minimumPlatformVersion: Int = 4, specifyExistingConstraint: Boolean = false, addAnotherAutomaticConstraintState: Boolean = false ): Pair&lt;CoreTransaction, CoreTransaction&gt;</ID>
    <ID>LongMethod:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$private fun DriverDSL.createConsumingTransaction( nodeName: CordaX500Name, cordapp: CustomCordapp, specifyExistingConstraint: Boolean, addAnotherAutomaticConstraintState: Boolean ): SignedTransaction</ID>
    <ID>LongMethod:SignedNodeInfo.kt$SignedNodeInfo$// TODO Add root cert param (or TrustAnchor) to make sure all the identities belong to the same root fun verified(): NodeInfo</ID>
    <ID>LongMethod:SignedNodeInfoTest.kt$SignedNodeInfoTest$private fun createNodeInfoWithSingleIdentity(name: CordaX500Name, nodeKeyPair: KeyPair, identityCertPublicKey: PublicKey): NodeInfo</ID>
    <ID>LongMethod:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>LongMethod:SimmFlow.kt$SimmFlow.Receiver$ @Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>LongMethod:SimmFlow.kt$SimmFlow.Requester$@Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>LongMethod:SimmValuationTest.kt$SimmValuationTest$@Test fun `runs SIMM valuation demo`()</ID>
    <ID>LongMethod:SimpleMessageFilterService.kt$SimpleMessageFilterService$override fun sendMessageToLocalBroker(inboundMessage: ReceivedMessage)</ID>
    <ID>LongMethod:SinglePartyNotaryService.kt$SinglePartyNotaryService$ @Suspendable open fun commitInputStates( inputs: List&lt;StateRef&gt;, txId: SecureHash, caller: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$// The flow's event queue may be non-empty in case it shut down abruptly. We handle outstanding events here. private fun drainFlowEventQueue(flow: Flow)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun start(tokenizableServices: List&lt;Any&gt;)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun &lt;A&gt; startFlowInternal( invocationContext: InvocationContext, flowLogic: FlowLogic&lt;A&gt;, flowStart: FlowStart, ourIdentity: Party, deduplicationHandler: DeduplicationHandler?, isStartIdempotent: Boolean ): CordaFuture&lt;FlowStateMachine&lt;A&gt;&gt;</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun addAndStartFlow(id: StateMachineRunId, flow: Flow)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun createFlowFromCheckpoint( id: StateMachineRunId, serializedCheckpoint: SerializedBytes&lt;Checkpoint&gt;, isAnyCheckpointPersisted: Boolean, isStartIdempotent: Boolean, initialDeduplicationHandler: DeduplicationHandler? ): Flow?</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun onExistingSessionMessage(sessionMessage: ExistingSessionMessage, deduplicationHandler: DeduplicationHandler, sender: Party)</ID>
    <ID>LongMethod:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun onSessionInit(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent)</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$@Test fun `Client Failover for multiple IP`()</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$@Test fun `Send a message from AMQP to Artemis inbox`()</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$@Test fun `Simple AMPQ Client to Server`()</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$@Test fun `shared AMQPClient threadpool tests`()</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$private fun createArtemisServerAndClient(): Pair&lt;ArtemisMessagingServer, ArtemisMessagingClient&gt;</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$private fun createClient(): AMQPClient</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$private fun createServer(port: Int, name: CordaX500Name = ALICE_NAME): AMQPServer</ID>
    <ID>LongMethod:SocksTests.kt$SocksTests$private fun createSharedThreadsClient(sharedEventGroup: EventLoopGroup, id: Int): AMQPClient</ID>
    <ID>LongMethod:Ssh.kt$Ssh.Companion$fun createSshTunnels(hosts: Array&lt;String&gt;, jmeterProperties: String, serverRmiMappings: Map&lt;String, Int&gt;, userName: String)</ID>
    <ID>LongMethod:StabilityTest.kt$StabilityTest$fun crossCashTest(replication: Int)</ID>
    <ID>LongMethod:StabilityTest.kt$StabilityTest$fun selfIssueTest(replication: Int)</ID>
    <ID>LongMethod:StaffedFlowHospital.kt$StaffedFlowHospital$ fun flowErrored(flowFiber: FlowFiber, currentState: StateMachineState, errors: List&lt;Throwable&gt;)</ID>
    <ID>LongMethod:StaffedFlowHospital.kt$StaffedFlowHospital$ fun sessionInitErrored(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent, error: Throwable)</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$ override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;UniquenessProvider.Result&gt;</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$ private fun withRetry(block: () -&gt; Unit, transaction: EntityTransaction)</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$private fun processRequest(request: CommitRequest, allConflicts: MutableMap&lt;StateRef, StateConsumptionDetails&gt;, toCommit: MutableList&lt;CommitRequest&gt;, entityManager: EntityManager): UniquenessProvider.Result</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$private fun processRequests(buffer: LinkedList&lt;CommitRequest&gt;)</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$@Before fun before()</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$@Test fun `detect double spend`()</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$@Test fun `transactions can be re-notarised outside their time window`()</ID>
    <ID>LongMethod:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$@Test fun `transactions outside their time window are rejected`()</ID>
    <ID>LongMethod:StandaloneShell.kt$StandaloneShell$override fun runProgram(): Int</ID>
    <ID>LongMethod:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun args_to_config()</ID>
    <ID>LongMethod:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_override_config_from_file()</ID>
    <ID>LongMethod:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_to_config_from_file()</ID>
    <ID>LongMethod:StartLocalPerfCorDapp.kt$StartLocalPerfCorDapp.Companion$@JvmStatic fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendInitialSessionMessagesIfNeeded(sourceSessions: Set&lt;SessionId&gt;)</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendToSessionsTransition(sourceSessionIdToMessage: Map&lt;SessionId, SerializedBytes&lt;Any&gt;&gt;)</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun collectEndedEmptySessionErrors(sessionIds: Collection&lt;SessionId&gt;, checkpoint: Checkpoint): List&lt;Throwable&gt;</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun collectRelevantErrorsToThrow(flowIORequest: FlowIORequest&lt;*&gt;, checkpoint: Checkpoint): List&lt;Throwable&gt;</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun pollSessionMessages(sessions: SessionMap, sessionIds: Set&lt;SessionId&gt;): PollResult?</ID>
    <ID>LongMethod:StartedFlowTransition.kt$StartedFlowTransition$private fun sendAndReceiveTransition(flowIORequest: FlowIORequest.SendAndReceive): TransitionResult</ID>
    <ID>LongMethod:StateMachineState.kt$Checkpoint.Companion$fun create( invocationContext: InvocationContext, flowStart: FlowStart, flowLogicClass: Class&lt;FlowLogic&lt;*&gt;&gt;, frozenFlowLogic: SerializedBytes&lt;FlowLogic&lt;*&gt;&gt;, ourIdentity: Party, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean ): Try&lt;Checkpoint&gt;</ID>
    <ID>LongMethod:StateMachineViewer.kt$StateMachineViewer$fun makeColumns(table: TableView&lt;StateMachineData&gt;, tableItems: ObservableList&lt;StateMachineData&gt;, withResult: Boolean = true)</ID>
    <ID>LongMethod:StateMachineViewer.kt$StateMachineViewer$private fun &lt;T&gt; makeResultVBox(vbox: VBox, result: T)</ID>
    <ID>LongMethod:StateMachineViewer.kt$StateMachineViewer$private fun makePeerGrid(gridPane: GridPane, initiator: FlowInitiator.Peer)</ID>
    <ID>LongMethod:StateMachineViewer.kt$StateMachineViewer$private fun makeScheduledGrid(gridPane: GridPane, initiator: FlowInitiator.Scheduled)</ID>
    <ID>LongMethod:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:StatusTransitionsTest.kt$StatusTransitionsTest$@Test fun `basic correct cases`()</ID>
    <ID>LongMethod:StatusTransitionsTest.kt$StatusTransitionsTest$@Test fun `role change signer correct`()</ID>
    <ID>LongMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>LongMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parseArguments(methodNameHint: String, parameters: List&lt;Pair&lt;String, Type&gt;&gt;, args: String): Array&lt;Any?&gt;</ID>
    <ID>LongMethod:StructuresTests.kt$AttachmentTest$@Test fun `openAsJAR does not leak file handle if attachment has corrupted manifest`()</ID>
    <ID>LongMethod:SwapDataView.kt$fun SwapData.toView(viewingParty: Party, portfolio: Portfolio? = null, presentValue: MultiCurrencyAmount? = null, IM: InitialMarginTriple? = null): SwapDataView</ID>
    <ID>LongMethod:SwapExample.kt$SwapExample$fun main(@Suppress("UNUSED_PARAMETER") args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:SwapExample.kt$SwapExample$fun testingEqualitymain(@Suppress("UNUSED_PARAMETER") args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Suspendable override fun call(): LinkedHashMap&lt;Party, AnonymousParty&gt;</ID>
    <ID>LongMethod:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests$@Test fun `issue key`()</ID>
    <ID>LongMethod:SystematicTerminationTest.kt$SystematicTerminationTest$@Test fun testNodeRestart()</ID>
    <ID>LongMethod:TLSAuthenticationTests.kt$TLSAuthenticationTests$private fun buildTLSFactories( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, client1CAScheme: SignatureScheme, client1TLSScheme: SignatureScheme, client2CAScheme: SignatureScheme, client2TLSScheme: SignatureScheme ): Pair&lt;SSLServerSocketFactory, SSLSocketFactory&gt;</ID>
    <ID>LongMethod:TLSAuthenticationTests.kt$TLSAuthenticationTests$private fun buildTLSSockets( serverSocketFactory: SSLServerSocketFactory, clientSocketFactory: SSLSocketFactory, serverPort: Int = 0, // Use 0 to get first free socket. clientPort: Int = 0, // Use 0 to get first free socket. cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES ): Pair&lt;SSLServerSocket, SSLSocket&gt;</ID>
    <ID>LongMethod:TLSAuthenticationTests.kt$TLSAuthenticationTests$private fun testConnect(serverSocket: ServerSocket, clientSocket: SSLSocket, expectedCipherSuite: String)</ID>
    <ID>LongMethod:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$@Test fun testGetTargets()</ID>
    <ID>LongMethod:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$@Test fun testStopCheckScheduleFlow()</ID>
    <ID>LongMethod:TestCommandLine.kt$TestCommandLine$@Test fun checkWeGetJmeterArgs()</ID>
    <ID>LongMethod:TestCommsFlow.kt$TestCommsFlowInitiator$@Suspendable override fun call(): List&lt;String&gt;</ID>
    <ID>LongMethod:TestConfig.kt$TestConfig$@Test fun testLoadFile()</ID>
    <ID>LongMethod:TestDSL.kt$TestLedgerDSLInterpreter$override fun verifies(): EnforceVerifyOrFail</ID>
    <ID>LongMethod:TestDSL.kt$TestLedgerDSLInterpreter$private fun &lt;R&gt; recordTransactionWithTransactionMap( transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TestTransactionDSLInterpreter.() -&gt; R, transactionMap: HashMap&lt;SecureHash, WireTransactionWithLocation&gt; = HashMap(), /** If set to true, will add dummy components to [transactionBuilder] to make it valid. */ fillTransaction: Boolean ): WireTransaction</ID>
    <ID>LongMethod:TestKeyManagerFactoryWrapper.kt$TestKeyManagerFactoryWrapper$@Test fun testWrapping()</ID>
    <ID>LongMethod:TestKeyManagerFactoryWrapper.kt$TestKeyManagerFactoryWrapper$@Test fun testWrappingSeparately()</ID>
    <ID>LongMethod:TestLauncherHelpers.kt$TestLauncherHelpers$@Test fun testCommandLineMungingGradleTestExceptions()</ID>
    <ID>LongMethod:TestLauncherHelpers.kt$TestLauncherHelpers$@Test fun testJMeterArgPreparationServerCustomProperties()</ID>
    <ID>LongMethod:TestNettyTestInfra.kt$TestNettyTestInfra$@Test fun testFailureHandling()</ID>
    <ID>LongMethod:TestNettyTestInfra.kt$TestNettyTestInfra$@Test fun testPingPong()</ID>
    <ID>LongMethod:TestNotaryFlow.kt$TestNotaryFlow$@Suspendable override fun call(): String</ID>
    <ID>LongMethod:TestNotaryTypes.kt$TestNotaryTypes$@Test fun testRaftNotary()</ID>
    <ID>LongMethod:TestNotaryTypes.kt$TestNotaryTypes$@Test fun testSimpleNotary()</ID>
    <ID>LongMethod:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$@Test fun checkFailingNotary()</ID>
    <ID>LongMethod:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$@Test fun checkHangingNotary()</ID>
    <ID>LongMethod:TestTrustManagerFactoryWrapper.kt$TestTrustManagerFactoryWrapper$@Test fun testWrapping()</ID>
    <ID>LongMethod:Tests.kt$private fun findTimeWindow(logFiles: List&lt;Path&gt;): TimeWindow</ID>
    <ID>LongMethod:ThrowableSerializer.kt$ThrowableSerializer$override fun fromProxy(proxy: ThrowableProxy): Throwable</ID>
    <ID>LongMethod:TimedFlowTests.kt$TimedFlowTestRule$private fun startClusterAndNode(mockNet: InternalMockNetwork): Triple&lt;Party, TestStartedNode, TestStartedNode&gt;</ID>
    <ID>LongMethod:TimedFlowTests.kt$TimedFlowTests$@Test fun `timed flow can update its ETA`()</ID>
    <ID>LongMethod:TimedFlowTests.kt$TimedFlowTests$@Test fun `timed flow cannot update its ETA to less than default`()</ID>
    <ID>LongMethod:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>LongMethod:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>LongMethod:ToggleFieldTest.kt$ToggleFieldTest$ @Test fun `leaked thread propagates holder to non-global thread, with warning`()</ID>
    <ID>LongMethod:ToggleFieldTest.kt$ToggleFieldTest$@Test fun `inherited values are poisoned on clear`()</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun enterSubFlowTransition(event: Event.EnterSubFlow): TransitionResult</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun flowFinishTransition(event: Event.FlowFinish): TransitionResult</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun leaveSubFlowTransition(): TransitionResult</ID>
    <ID>LongMethod:TopLevelTransition.kt$TopLevelTransition$private fun suspendTransition(event: Event.Suspend): TransitionResult</ID>
    <ID>LongMethod:TrackedConsoleTask.kt$TrackedConsoleTask$private fun startWithRichTerminal()</ID>
    <ID>LongMethod:TrackedConsoleTask.kt$TrackedConsoleTask$private fun startWithoutRichTerminal()</ID>
    <ID>LongMethod:TraderDemo.kt$TraderDemo$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:TraderDemoClientApi.kt$TraderDemoClientApi$fun runIssuer(amount: Amount&lt;Currency&gt;, buyerName: CordaX500Name, sellerName: CordaX500Name)</ID>
    <ID>LongMethod:TraderDemoTest.kt$TraderDemoTest$@Test fun `Test restart node during flow works properly`()</ID>
    <ID>LongMethod:TraderDemoTest.kt$TraderDemoTest$@Test fun `runs trader demo`()</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun resolveStatePointers(transactionState: TransactionState&lt;*&gt;)</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun selectAttachmentConstraint( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, attachmentToUse: ContractAttachment, services: ServicesForResolution): AttachmentConstraint</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$ private fun selectContractAttachmentsAndOutputStateConstraints( services: ServicesForResolution, @Suppress("UNUSED_PARAMETER") serializationContext: SerializationContext? ): Pair&lt;Collection&lt;SecureHash&gt;, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt;</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$@CordaInternal internal fun toWireTransactionWithContext(services: ServicesForResolution, serializationContext: SerializationContext? = null): WireTransaction</ID>
    <ID>LongMethod:TransactionBuilder.kt$TransactionBuilder$private fun addMissingAttachment(missingClass: String, services: ServicesForResolution, originalException: Throwable): Boolean</ID>
    <ID>LongMethod:TransactionBuilderTest.kt$TransactionBuilderTest$@Before fun setup()</ID>
    <ID>LongMethod:TransactionBuilderTest.kt$TransactionBuilderTest$@Test fun `automatic signature constraint`()</ID>
    <ID>LongMethod:TransactionDataModel.kt$PartiallyResolvedTransaction.Companion$fun fromSignedTransaction( transaction: SignedTransaction, inputTransactions: Map&lt;StateRef, SignedTransaction?&gt; ): PartiallyResolvedTransaction</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `correct encumbrance state must be provided`()</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `encumbered states cannot be assigned to different notaries`()</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `non bi-directional encumbrance will fail`()</ID>
    <ID>LongMethod:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$@Test fun `states must be bi-directionally encumbered`()</ID>
    <ID>LongMethod:TransactionGenerator.kt$TransactionGenerator$fun writeFailure(output: OutputStream)</ID>
    <ID>LongMethod:TransactionGenerator.kt$TransactionGenerator$fun writeSuccess(output: OutputStream)</ID>
    <ID>LongMethod:TransactionOrderingTests.kt$TransactionOrderingTests$@Test fun `Out of order transactions are recorded in vault correctly`()</ID>
    <ID>LongMethod:TransactionSignatureTest.kt$TransactionSignatureTest$@Test fun `Verify multi-tx signature`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `general transactions cannot change notary`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `signed transaction missing signatures - CompositeKey`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `signed transaction missing signatures`()</ID>
    <ID>LongMethod:TransactionTests.kt$TransactionTests$@Test fun `transactions with no inputs can have any notary`()</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun createComponentGroups(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?): List&lt;ComponentGroup&gt;</ID>
    <ID>LongMethod:TransactionUtils.kt$ fun deserialiseCommands( componentGroups: List&lt;ComponentGroup&gt;, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, @Suppress("UNUSED_PARAMETER") context: SerializationContext = factory.defaultContext ): List&lt;Command&lt;*&gt;&gt;</ID>
    <ID>LongMethod:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>LongMethod:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyContracts()</ID>
    <ID>LongMethod:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>LongMethod:TransactionViewer.kt$TransactionViewer.ContractStatesView$private fun getCell(contractState: StateAndRef&lt;ContractState&gt;): Node</ID>
    <ID>LongMethod:TransformsSchema.kt$TransformsSchema$@Suppress("NAME_SHADOWING") override fun toString(): String</ID>
    <ID>LongMethod:TransformsSchema.kt$TransformsSchema.Companion$ override fun newInstance(described: Any?): TransformsSchema</ID>
    <ID>LongMethod:TransitionDiagnosticRecord.kt$TransitionDiagnosticRecord$override fun toString(): String</ID>
    <ID>LongMethod:TransitionExecutorImpl.kt$TransitionExecutorImpl$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>LongMethod:TunnelControlTest.kt$TunnelControlTest$@Test fun `Basic tunnel life cycle test`()</ID>
    <ID>LongMethod:TunnelControlTest.kt$TunnelControlTest$@Test fun `Inbound message test`()</ID>
    <ID>LongMethod:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$override fun start()</ID>
    <ID>LongMethod:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private fun closeAMQPClient()</ID>
    <ID>LongMethod:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private fun onConnectToControl(connectionChange: ConnectionChange)</ID>
    <ID>LongMethod:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private fun processCrlTopic(receivedMessage: ReceivedMessage)</ID>
    <ID>LongMethod:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private fun processDataTopic(receivedMessage: ReceivedMessage)</ID>
    <ID>LongMethod:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private fun processSigningTopic(receivedMessage: ReceivedMessage)</ID>
    <ID>LongMethod:TutorialContract.kt$CommercialPaper$// DOCSTART 3 override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:TutorialTestDSL.kt$TutorialTestDSL$// DOCSTART 10 @Test fun `chain commercial tweak`()</ID>
    <ID>LongMethod:TutorialTestDSL.kt$TutorialTestDSL$// DOCSTART 8 @Test fun `chain commercial paper`()</ID>
    <ID>LongMethod:TutorialTestDSL.kt$TutorialTestDSL$// DOCSTART 9 @Test fun `chain commercial paper double spend`()</ID>
    <ID>LongMethod:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$@Suspendable override fun call(): SignedTransaction</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Ignore @Test fun `check dependencies of sale asset are resolved`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Ignore @Test fun `track works`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `check dependencies of sale asset are resolved`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `shutdown and restore`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `track works`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test fun `trade cash for commercial paper`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$@Test(expected = InsufficientBalanceException::class) fun `trade cash for commercial paper fails using soft locking`()</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.fillUpForBuyer( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party): Pair&lt;Vault&lt;ContractState&gt;, List&lt;WireTransaction&gt;&gt;</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.fillUpForBuyerAndInsertFakeTransactions( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode ): Triple&lt;Vault&lt;ContractState&gt;, List&lt;WireTransaction&gt;, Map&lt;SecureHash,SignedTransaction&gt;&gt;</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.fillUpForSeller( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, attachmentID: SecureHash?, notary: Party): Pair&lt;Vault&lt;ContractState&gt;, List&lt;WireTransaction&gt;&gt;</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;.runWithError( bobError: Boolean, aliceError: Boolean, expectedMessageSubstring: String )</ID>
    <ID>LongMethod:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private fun insertFakeTransactions( wtxToSign: List&lt;WireTransaction&gt;, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode): Map&lt;SecureHash, SignedTransaction&gt;</ID>
    <ID>LongMethod:TypeLoader.kt$ClassCarpentingTypeLoader$override fun load( remoteTypeInformation: Collection&lt;RemoteTypeInformation&gt;, context: SerializationContext ): Map&lt;TypeIdentifier, Type&gt;</ID>
    <ID>LongMethod:TypeModellingFingerPrinter.kt$FingerPrintingState$// For a type we haven't seen before, determine the correct path depending on the type of type it is. private fun fingerprintNewType(type: LocalTypeInformation)</ID>
    <ID>LongMethod:TypeParameterUtils.kt$ private fun inferTypeVariables(actualClass: Class&lt;*&gt;, declaredClass: Class&lt;*&gt;, declaredType: ParameterizedType): Type?</ID>
    <ID>LongMethod:UniversalContract.kt$UniversalContract$fun evalBigDecimal(tx: LedgerTransaction, expr: Perceivable&lt;BigDecimal&gt;): BigDecimal</ID>
    <ID>LongMethod:UniversalContract.kt$UniversalContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$@Test fun `should take fast path for known unspent states`()</ID>
    <ID>LongMethod:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$@Test fun `should work with reference states`()</ID>
    <ID>LongMethod:UnstartedFlowTransition.kt$UnstartedFlowTransition$// Initialise initiated session, store initial payload, send confirmation back. private fun TransitionBuilder.initialiseInitiatedSession(flowStart: FlowStart.Initiated)</ID>
    <ID>LongMethod:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>LongMethod:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>LongMethod:Utils.kt$fun testConfig( port: Int, host: String = "127.0.0.1", connectionTimeout: Int = 30000, timeout: Int = 60000, keepSessionAlive: Boolean = false, keyGroup: String = "TEST.CORDACONNECT.ROOT", keySpecifier: Int = 1, username: String = "INTEGRATION_TEST", password: String = "INTEGRATION_TEST"): UtimacoCryptoService.UtimacoConfig</ID>
    <ID>LongMethod:UtimacoCryptoService.kt$UtimacoCryptoService$override fun sign(alias: String, data: ByteArray, signAlgorithm: String?): ByteArray</ID>
    <ID>LongMethod:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$override fun parseValid(configuration: Config, options: Configuration.Options): Valid&lt;NodeConfiguration&gt;</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should re-sign a transaction with an expired time-window`()</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should reject transaction without network parameters`()</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should report conflict when inputs are reused across transactions`()</ID>
    <ID>LongMethod:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$@Test fun `should sign identical transaction multiple times (notarisation is idempotent)`()</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$ fun fillWithSomeTestCash(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT): Vault&lt;Cash.State&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$@JvmOverloads fun fillWithSomeTestDeals(dealIds: List&lt;String&gt;, issuerServices: ServiceHub = services, participants: List&lt;AbstractParty&gt; = emptyList(), includeMe: Boolean = true): Vault&lt;DealState&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$@JvmOverloads fun fillWithSomeTestLinearAndDealStates(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now()): Vault&lt;LinearState&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller$@JvmOverloads fun fillWithSomeTestLinearStates(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), uniqueIdentifier: UniqueIdentifier? = null, linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now(), constraint: AttachmentConstraint = AutomaticPlaceholderConstraint, includeMe: Boolean = true): Vault&lt;LinearState&gt;</ID>
    <ID>LongMethod:VaultFiller.kt$VaultFiller.Companion$fun calculateRandomlySizedAmounts(howMuch: Amount&lt;Currency&gt;, min: Int, max: Int, rng: Random): LongArray</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$ @Test fun trackCashStates_unconsumed()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun `track by of contract state interface returns updates of all states`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun `track by of super class only returns updates of sub classes of tracked type`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun `track by only returns updates of tracked type`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_all()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_consumed()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackDealStates()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTests$@Test fun trackLinearStates()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$ // specifying Query on Commercial Paper contract state attributes @Test fun `custom query using JPA - commercial paper schema V1 single attribute`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$// specifying Query on Commercial Paper contract state attributes @Test fun `custom query using JPA - commercial paper schema V1 - multiple attributes`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$// specifying Query on Linear state attributes @Test fun `unconsumed linear heads for linearId between two timestamps for a given external id`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$// test paging with aggregate function and group by clause @Test fun `test paging with aggregate function and group by clause`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions count by contract type and state status`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions sum by issuer and currency and sort by aggregate sum`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions with single group clause`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `aggregate functions without group clause`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `composite query for fungible and linear states for multiple participants`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `composite query for fungible and linear states`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query by contract states constraint type and data`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query by contract states constraint type`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query with sort criteria works even when multiple pages have the same value for the sort criteria field`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `query with sort criteria works with pagination`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `state relevancy queries`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed cash states sorted by state ref txnId and index`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed cash states sorted by state ref`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed fungible assets for selected issuer parties`()</ID>
    <ID>LongMethod:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `unconsumed states with soft locking`()</ID>
    <ID>LongMethod:VaultRestartTest.kt$VaultRestartTest$@Test fun `restart and query vault after adding some cash states`()</ID>
    <ID>LongMethod:VaultStateMigration.kt$VaultStateMigration$override fun execute(database: Database?)</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$// Used to generate a persistent database for further testing. @Test @Ignore fun `Create persistent DB`()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$@Before fun setUp()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$@Test fun `Check state fields are correct`()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$@Test fun `State with non-owning key for our name marked as relevant`()</ID>
    <ID>LongMethod:VaultStateMigrationTest.kt$VaultStateMigrationTest$private fun addNetworkParameters()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `consuming multiple contract state types`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `issue and attempt double spend`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `issue and spend total correctly and irrelevant ignored`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `sequencing LinearStates works`()</ID>
    <ID>LongMethod:VaultWithCashTest.kt$VaultWithCashTest$@Test fun `spending cash in vault of mixed state types works`()</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateBFTSmartNotary(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateCore(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateJPANotary(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateMySQLNotary(versionInfo: VersionInfo): CordappImpl?</ID>
    <ID>LongMethod:VirtualCordapps.kt$VirtualCordapp$ fun generateRaftNotary(versionInfo: VersionInfo): CordappImpl</ID>
    <ID>LongMethod:WebServer.kt$WebServer$@Throws(IOException::class) fun open(config: NodeConfigWrapper): CordaFuture&lt;URI&gt;</ID>
    <ID>LongMethod:WebServer.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongMethod:WhitelistGenerator.kt$fun generateWhitelist(networkParameters: NetworkParameters?, excludeContracts: List&lt;ContractClassName&gt;, cordappJars: List&lt;ContractsJar&gt;, includeContracts: List&lt;ContractClassName&gt;, optionalCordappJars: List&lt;ContractsJar&gt;): Map&lt;ContractClassName, List&lt;AttachmentId&gt;&gt;</ID>
    <ID>LongMethod:WireTransaction.kt$WireTransaction$@DeleteForDJVM override fun toString(): String</ID>
    <ID>LongMethod:WireTransaction.kt$WireTransaction$private fun toLedgerTransactionInternal( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>LongMethod:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>LongMethod:WithReferencedStatesFlow.kt$WithReferencedStatesFlow$@Suspendable override fun call(): T</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorial.kt$RecordCompletionFlow$@Suspendable override fun call()</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow$@Suspendable override fun call(): StateAndRef&lt;TradeApprovalContract.State&gt;</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$ override fun verify(tx: LedgerTransaction)</ID>
    <ID>LongMethod:WorkflowTransactionBuildTutorialTest.kt$WorkflowTransactionBuildTutorialTest$@Test fun `Run workflow to completion`()</ID>
    <ID>LongMethod:X509NameConstraintsTest.kt$X509NameConstraintsTest$@Test fun `illegal common name`()</ID>
    <ID>LongMethod:X509NameConstraintsTest.kt$X509NameConstraintsTest$@Test fun `x500 name with correct cn and extra attribute`()</ID>
    <ID>LongMethod:X509NameConstraintsTest.kt$X509NameConstraintsTest$private fun makeKeyStores(subjectName: X500Name, nameConstraints: NameConstraints): Pair&lt;X509KeyStore, X509KeyStore&gt;</ID>
    <ID>LongMethod:X509Utilities.kt$X509Utilities$ @JvmStatic fun createCertificate(certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>LongMethod:X509Utilities.kt$X509Utilities$ fun createCertificate(certificateType: CertificateType, issuer: X500Principal, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>LongMethod:X509Utilities.kt$X509Utilities$ fun createPartialCertificate(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509v3CertificateBuilder</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$@Test fun `create server cert and use in OpenSSL channel`()</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$@Test fun `create server cert and use in SSL socket`()</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$@Test fun `create server certificate in keystore for SSL`()</ID>
    <ID>LongMethod:X509UtilitiesTest.kt$X509UtilitiesTest$private fun createValidServerCertIncludeCRL(signatureSchemeRoot: SignatureScheme, signatureSchemeChild: SignatureScheme)</ID>
    <ID>LongMethod:ZeroCouponBond.kt$ZeroCouponBond$@Test fun move()</ID>
    <ID>LongMethod:ZkClientTest.kt$ZkClientTests$@Test fun `client with highest priority becomes leader`()</ID>
    <ID>LongMethod:ZkClientTest.kt$ZkClientTests$@Test fun `client with mid-level priority joins and becomes leader after current leader relinquishes`()</ID>
    <ID>LongMethod:ZkClientTest.kt$ZkClientTests$@Test fun `clients randomly do things`()</ID>
    <ID>LongMethod:ZkClientTest.kt$ZkClientTests$@Test fun `clients with higher priority join and take leadership`()</ID>
    <ID>LongMethod:ZkClientTest.kt$ZkClientTests$@Test fun `leader relinquishes, next highest priority takes over`()</ID>
    <ID>LongMethod:ZkClientTest.kt$ZkClientTests$@Test fun `single client relinquishes leadership`()</ID>
    <ID>LongMethod:main.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>LongParameterList:AMQPSerializer.kt$AMQPSerializer$(obj: Any, data: Data, type: Type, output: SerializationOutput, context: SerializationContext, debugIndent: Int = 0)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet())</ID>
    <ID>LongParameterList:AbstractNode.kt$(databaseConfig: DatabaseConfig, wellKnownPartyFromX500Name: (CordaX500Name) -&gt; Party?, wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?, schemaService: SchemaService, cacheFactory: NamedCacheFactory, customClassLoader: ClassLoader?)</ID>
    <ID>LongParameterList:AbstractNode.kt$(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>LongParameterList:ArtemisMessagingServer.kt$ArtemisMessagingServer$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean)</ID>
    <ID>LongParameterList:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, sslOptions: BrokerRpcSslOptions, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean)</ID>
    <ID>LongParameterList:ArtemisRpcTests.kt$ArtemisRpcTests$(nodeSSlconfig: MutualSslConfiguration, brokerSslOptions: BrokerRpcSslOptions?, useSslForBroker: Boolean, clientSslOptions: ClientRpcSslOptions?, address: NetworkHostAndPort = ports.nextHostAndPort(), adminAddress: NetworkHostAndPort = ports.nextHostAndPort(), baseDirectory: Path = tempFolder.root.toPath() )</ID>
    <ID>LongParameterList:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$(hostAndPort: NetworkHostAndPort, keyStore: FileBasedCertificateStoreSupplier?, trustStore: FileBasedCertificateStoreSupplier?, enableSSL: Boolean = true, useOpenSsl: Boolean = false, keyStoreProvider: String? = null)</ID>
    <ID>LongParameterList:ArtemisUtils.kt$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T)</ID>
    <ID>LongParameterList:BFTSmart.kt$BFTSmart.Replica$( states: List&lt;StateRef&gt;, txId: SecureHash, callerName: CordaX500Name, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:BridgeDriver.kt$(baseDir: Path, artemisPort: Int, advertisedP2PPort: Int, vararg nodeSSLKeystores: Path, configOverrides: Map&lt;String, Any&gt; = emptyMap(), floatPort: Int? = null, keyStorePassword: String = DEV_CA_KEY_STORE_PASS, truststorePassword: String = DEV_CA_TRUST_STORE_PASS)</ID>
    <ID>LongParameterList:BridgeDriver.kt$(baseDirectory: Path, bridgePort: Int, brokerPort: Int, configOverrides: Map&lt;String, Any&gt;, artemisCertDir: Path? = null, keystorePassword: String, truststorePassword: String)</ID>
    <ID>LongParameterList:BridgeDriver.kt$(baseDirectory: Path, p2pPort: Int, brokerPort: Int, configOverrides: Map&lt;String, Any&gt;, artemisCertDir: Path?, floatPort: Int? = null, keystorePassword: String = DEV_CA_KEY_STORE_PASS, truststorePassword: String = DEV_CA_TRUST_STORE_PASS)</ID>
    <ID>LongParameterList:BridgeDriver.kt$(baseDirectory: Path, p2pPort: Int, brokerPort: Int, floatPort: Int, configOverrides: Map&lt;String, Any&gt;, artemisCertDir: Path, keystorePassword: String, truststorePassword: String)</ID>
    <ID>LongParameterList:Cash.kt$Cash$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:Cash.kt$Cash.Companion$(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, ourIdentity: PartyAndCertificate, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet())</ID>
    <ID>LongParameterList:CashTests.kt$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub = this, outputNotary: Party, ref: OpaqueBytes = OpaqueBytes(ByteArray(1, { 1 })), ownedBy: AbstractParty? = null, issuedBy: PartyAndReference = DUMMY_CASH_ISSUER)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, ourIdentity: PartyAndCertificate, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(port: Int, name: CordaX500Name = ALICE_NAME, crlCheckSoftFail: Boolean, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/$NODE_CRL", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/$EMPTY_CRL", maxMessageSize: Int = MAX_MESSAGE_SIZE)</ID>
    <ID>LongParameterList:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(port: Int, name: CordaX500Name = ALICE_NAME, revocationConfig: RevocationConfig, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/$NODE_CRL", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/$EMPTY_CRL", maxMessageSize: Int = MAX_MESSAGE_SIZE)</ID>
    <ID>LongParameterList:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$(baseDirectory: Path, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD)</ID>
    <ID>LongParameterList:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$(certificatesDirectory: Path, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD, trustStoreKeyPassword: String = TrustStore.DEFAULT_KEY_PASSWORD, @Suppress("UNUSED_PARAMETER") useOpenSsl: Boolean = false)</ID>
    <ID>LongParameterList:ContractAttachment.kt$ContractAttachment.Companion$(attachment: Attachment, contract: ContractClassName, additionalContracts: Set&lt;ContractClassName&gt; = emptySet(), uploader: String? = null, signerKeys: List&lt;PublicKey&gt; = emptyList(), version: Int = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(expiry: String, notional: BigDecimal, strike: BigDecimal, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(expiry: String, notional: Long, strike: Double, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(partyA: Party, amountA: BigDecimal, currencyA: Currency, partyB: Party, amountB: BigDecimal, currencyB: Currency)</ID>
    <ID>LongParameterList:ContractJarTestUtils.kt$ContractJarTestUtils$(workingDir: Path, contractNames: List&lt;String&gt;, signed: Boolean = false, version: Int = 1, generateManifest: Boolean = true, jarFileName : String? = null)</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, notary: Party = this.notary, legacyContractAttachment: Attachment = this.legacyContractAttachment, upgradedContractClassName: ContractClassName = this.upgradedContract::class.java.name, upgradedContractAttachment: Attachment = this.upgradedContractAttachment, id: SecureHash = this.id, privacySalt: PrivacySalt = this.privacySalt, sigs: List&lt;TransactionSignature&gt; = this.sigs, networkParameters: NetworkParameters = this.networkParameters )</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters, upgradedContract: UpgradedContract&lt;ContractState, *&gt; )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClient$(username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, targetLegalIdentity: CordaX500Name?, gracefulReconnect: Boolean = false)</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClientConfiguration$( connectionMaxRetryInterval: Duration = this.connectionMaxRetryInterval, minimumServerProtocolVersion: Int = this.minimumServerProtocolVersion, trackRpcCallSites: Boolean = this.trackRpcCallSites, reapInterval: Duration = this.reapInterval, observationExecutorPoolSize: Int = this.observationExecutorPoolSize, cacheConcurrencyLevel: Int = this.cacheConcurrencyLevel, connectionRetryInterval: Duration = this.connectionRetryInterval, connectionRetryIntervalMultiplier: Double = this.connectionRetryIntervalMultiplier, maxReconnectAttempts: Int = this.maxReconnectAttempts, maxFileSize: Int = this.maxFileSize, deduplicationCacheExpiry: Duration = this.deduplicationCacheExpiry )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:CrlServer.kt$CrlServlet.Companion$(clrServer: CrlServer, signatureAlgorithm: String, caCertificate: X509Certificate, caPrivateKey: PrivateKey, endpoint: String, indirect: Boolean, serialNumbers: Set&lt;BigInteger&gt;)</ID>
    <ID>LongParameterList:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$( cryptoServiceName: SupportedCryptoServices, legalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier? = null, cryptoServiceConf: Path? = null, timeout: Duration? = null, wrappingKeyStorePath: Path? = null )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, cordappsForAllNodes: Set&lt;TestCordapp&gt;? )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, notaryCustomOverrides: Map&lt;String, Any?&gt;, inMemoryDB: Boolean, cordappsForAllNodes: Collection&lt;TestCordapp&gt;? )</ID>
    <ID>LongParameterList:DriverDSL.kt$DriverDSL$( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize )</ID>
    <ID>LongParameterList:DriverDSL.kt$DriverDSL$( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride )</ID>
    <ID>LongParameterList:DriverDSLImpl.kt$( isDebug: Boolean = DriverParameters().isDebug, driverDirectory: Path = DriverParameters().driverDirectory, portAllocation: PortAllocation = DriverParameters().portAllocation, debugPortAllocation: PortAllocation = DriverParameters().debugPortAllocation, systemProperties: Map&lt;String, String&gt; = DriverParameters().systemProperties, useTestClock: Boolean = DriverParameters().useTestClock, startNodesInProcess: Boolean = DriverParameters().startNodesInProcess, extraCordappPackagesToScan: List&lt;String&gt; = @Suppress("DEPRECATION") DriverParameters().extraCordappPackagesToScan, waitForAllNodesToFinish: Boolean = DriverParameters().waitForAllNodesToFinish, notarySpecs: List&lt;NotarySpec&gt; = DriverParameters().notarySpecs, jmxPolicy: JmxPolicy = DriverParameters().jmxPolicy, networkParameters: NetworkParameters = DriverParameters().networkParameters, compatibilityZone: CompatibilityZoneParams? = null, notaryCustomOverrides: Map&lt;String, Any?&gt; = DriverParameters().notaryCustomOverrides, inMemoryDB: Boolean = DriverParameters().inMemoryDB, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, enableSNI: Boolean = DriverParameters().enableSNI, dsl: DriverDSLImpl.() -&gt; A )</ID>
    <ID>LongParameterList:DriverDSLImpl.kt$DriverDSLImpl.Companion$( config: NodeConfig, quasarJarPath: String, debugPort: Int?, bytemanJarPath: String?, bytemanPort: Int?, overriddenSystemProperties: Map&lt;String, String&gt;, maximumHeapSize: String, logLevelOverride: String?, vararg extraCmdLineFlag: String )</ID>
    <ID>LongParameterList:DummyFungibleContract.kt$DummyFungibleContract$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$(config: NodeConfiguration, myInfo: NodeInfo, signedNetworkParameters: NetworkParametersAndSigned, ourKeyPair: KeyPair, trustRoot: X509Certificate, nodeCa: X509Certificate)</ID>
    <ID>LongParameterList:FlowWorkerTest.kt$FlowWorkerTest$(config: NodeConfiguration, myInfo: NodeInfo, signedNetworkParameters: NetworkParametersAndSigned, ourKeyPair: KeyPair, trustRoot: X509Certificate, nodeCa: X509Certificate)</ID>
    <ID>LongParameterList:IRS.kt$FloatingRatePaymentEvent$(date: LocalDate = this.date, accrualStartDate: LocalDate = this.accrualStartDate, accrualEndDate: LocalDate = this.accrualEndDate, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, fixingDate: LocalDate = this.fixingDate, notional: Amount&lt;Currency&gt; = this.notional, rate: Rate = this.rate)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap$(floatingLeg: FloatingLeg, fixedLeg: FixedLeg, calculation: Calculation, common: Common, oracle: Party, notary: Party)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap.FixedLeg$(fixedRatePayer: AbstractParty = this.fixedRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, fixedRate: FixedRate = this.fixedRate)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap.FloatingLeg$(floatingRatePayer: AbstractParty = this.floatingRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, rollConvention: DateRollConvention = this.rollConvention, fixingRollConvention: DateRollConvention = this.fixingRollConvention, resetDayInMonth: Int = this.resetDayInMonth, fixingPeriod: Int = this.fixingPeriodOffset, resetRule: PaymentRule = this.resetRule, fixingsPerPayment: Frequency = this.fixingsPerPayment, fixingCalendar: BusinessCalendar = this.fixingCalendar, index: String = this.index, indexSource: String = this.indexSource, indexTenor: Tenor = this.indexTenor )</ID>
    <ID>LongParameterList:IdenticonRenderer.kt$IdenticonRenderer$(g: GraphicsContext, x: Double, y: Double, patchIndex: Int, turn: Int, patchSize: Double, _invert: Boolean, color: PatchColor)</ID>
    <ID>LongParameterList:Injectors.kt$( metricRegistry: MetricRegistry, parallelism: Int, overallDuration: Duration, injectionRate: Rate, workBound: Int, queueSizeMetricName: String = "QueueSize", workDurationMetricName: String = "WorkDuration", work: () -&gt; CordaFuture&lt;*&gt; )</ID>
    <ID>LongParameterList:InteractiveShell.kt$InteractiveShell$(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongParameterList:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$(commonName: String, keystorePath: Path, trustStorePath: Path, storePassword: String, entryPassword: String, trustStorePassword: String)</ID>
    <ID>LongParameterList:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$(cryptoServiceName: String?, cryptoServiceConfigPath: Path?, keystorePath: Path, storePassword: String, entryPassword: String, x500Name: CordaX500Name)</ID>
    <ID>LongParameterList:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$(serviceName: String, root: CertificateAndKeyPair, keystorePath: Path, storePassword: String, entryPassword: String, alias: String)</ID>
    <ID>LongParameterList:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$(serviceName: String, root: CertificateAndKeyPair, keystorePath: Path, storePassword: String, entryPassword: String, alias: String, cryptoService: CryptoService)</ID>
    <ID>LongParameterList:InternalTestUtils.kt$(hikariProperties: Properties, databaseConfig: DatabaseConfig, wellKnownPartyFromX500Name: (CordaX500Name) -&gt; Party?, wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?, schemaService: SchemaService = NodeSchemaService(), cacheFactory: NamedCacheFactory = TestingNamedCacheFactory(), ourName: CordaX500Name = TestIdentity(ALICE_NAME, 70).name)</ID>
    <ID>LongParameterList:InternalTestUtils.kt$(inputs: List&lt;StateRef&gt;, attachments: List&lt;SecureHash&gt;, outputs: List&lt;TransactionState&lt;*&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt = PrivacySalt())</ID>
    <ID>LongParameterList:JarSignatureTestUtils.kt$JarSignatureTestUtils$(alias: String = "Test", storePassword: String = "secret!", name: String = CODE_SIGNER.toString(), keyalg: String = "RSA", keyPassword: String = storePassword, storeName: String = "_teststore")</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = this.outputs, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt; = this.commands, attachments: List&lt;Attachment&gt; = this.attachments, id: SecureHash = this.id, notary: Party? = this.notary, timeWindow: TimeWindow? = this.timeWindow, privacySalt: PrivacySalt = this.privacySalt, networkParameters: NetworkParameters? = this.networkParameters )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt )</ID>
    <ID>LongParameterList:LedgerTransaction.kt$LedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>LongParameterList:MockServices.kt$MockServices.Companion$( cordappLoader: CordappLoader, identityService: IdentityService, networkParameters: NetworkParameters, initialIdentity: TestIdentity, moreKeys: Set&lt;KeyPair&gt;, keyManagementService: KeyManagementService, schemaService: SchemaService, persistence: CordaPersistence )</ID>
    <ID>LongParameterList:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$( flowLogic: FlowLogic&lt;A&gt;, initiatingMessageDeduplicationHandler: DeduplicationHandler, peerSession: FlowSessionImpl, initiatedSessionId: SessionId, initiatingMessage: InitialSessionMessage, senderCoreFlowVersion: Int?, initiatedFlowInfo: FlowInfo )</ID>
    <ID>LongParameterList:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$( invocationContext: InvocationContext, flowLogic: FlowLogic&lt;A&gt;, flowStart: FlowStart, ourIdentity: Party, deduplicationHandler: DeduplicationHandler?, isStartIdempotent: Boolean )</ID>
    <ID>LongParameterList:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, serverCAScheme: SignatureScheme, serverTLSScheme: SignatureScheme, clientCAScheme: SignatureScheme, clientTLSScheme: SignatureScheme, cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES )</ID>
    <ID>LongParameterList:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$(copyCordapps: CopyCordapps = CopyCordapps.FirstRunOnly, packageOwnership: Map&lt;String, PublicKey&gt;? = emptyMap(), minimumPlatformVerison: Int? = PLATFORM_VERSION, maxMessageSize: Int? = DEFAULT_MAX_MESSAGE_SIZE, maxTransactionSize: Int? = DEFAULT_MAX_TRANSACTION_SIZE, eventHorizon: Duration? = 30.days)</ID>
    <ID>LongParameterList:NetworkMapUpdater.kt$NetworkMapUpdater$(trustRoot: X509Certificate, currentParametersHash: SecureHash, ourNodeInfo: SignedNodeInfo, networkParameters: NetworkParameters, keyManagementService: KeyManagementService, networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings)</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations )</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations, eventHorizon: Duration = this.eventHorizon )</ID>
    <ID>LongParameterList:NodeConfigTest.kt$NodeConfigTest$( legalName: CordaX500Name = CordaX500Name(organisation = "Unknown", locality = "Nowhere", country = "GB"), p2pPort: Int = -1, rpcPort: Int = -1, rpcAdminPort: Int = -1, webPort: Int = -1, h2port: Int = -1, notary: NotaryService?, users: List&lt;User&gt; = listOf(user("guest")), issuableCurrencies: List&lt;String&gt; = emptyList() )</ID>
    <ID>LongParameterList:NodeControllerTest.kt$NodeControllerTest$( organisation: String = "Unknown", p2pPort: Int = 0, rpcPort: Int = 0, rpcAdminPort: Int = 0, webPort: Int = 0, h2port: Int = 0, notary: NotaryService? = null, users: List&lt;User&gt; = listOf(user("guest")) )</ID>
    <ID>LongParameterList:NodeParameters.kt$NodeParameters$( providedName: CordaX500Name?, rpcUsers: List&lt;User&gt;, verifierType: VerifierType, customOverrides: Map&lt;String, Any?&gt;, startInSameProcess: Boolean?, maximumHeapSize: String )</ID>
    <ID>LongParameterList:NodeParameters.kt$NodeParameters$( providedName: CordaX500Name?, rpcUsers: List&lt;User&gt;, verifierType: VerifierType, customOverrides: Map&lt;String, Any?&gt;, startInSameProcess: Boolean?, maximumHeapSize: String, additionalCordapps: Collection&lt;TestCordapp&gt; = emptySet(), flowOverrides: Map&lt;out Class&lt;out FlowLogic&lt;*&gt;&gt;, Class&lt;out FlowLogic&lt;*&gt;&gt;&gt; )</ID>
    <ID>LongParameterList:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction.Companion$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, newNotary: Party, id: SecureHash, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters)</ID>
    <ID>LongParameterList:ObjectSerializer.kt$ComposableObjectWriter$( obj: Any, data: Data, @Suppress("UNUSED_PARAMETER") type: Type, output: SerializationOutput, context: SerializationContext, debugIndent: Int )</ID>
    <ID>LongParameterList:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$(localTypeInformation: LocalTypeInformation.Composable, remoteTypeInformation: RemoteTypeInformation.Composable, constructor: LocalConstructorInformation, properties: Map&lt;String, LocalPropertyInformation&gt;, classLoader: ClassLoader, mustPreserveData: Boolean)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, acceptableContract: SecureHash, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, dueBefore: Instant, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, issuanceDef: Obligation.Terms&lt;P&gt;, pennies: Long, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amount: Amount&lt;T&gt;, to: AbstractParty, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;T&gt;&gt;, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:ParametersUtilities.kt$( notaries: List&lt;NotaryInfo&gt; = emptyList(), minimumPlatformVersion: Int = 1, modifiedTime: Instant = Instant.now(), maxMessageSize: Int = 10485760, // TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer maxTransactionSize: Int = maxMessageSize * 50, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = emptyMap(), epoch: Int = 1, eventHorizon: Duration = 30.days, packageOwnership: Map&lt;String, PublicKey&gt; = emptyMap() )</ID>
    <ID>LongParameterList:PhysicalLocationStructures.kt$WorldCoordinate$(screenWidth: Double, screenHeight: Double, topLatitude: Double, bottomLatitude: Double, leftLongitude: Double, rightLongitude: Double)</ID>
    <ID>LongParameterList:ProcessUtilities.kt$ProcessUtilities$( arguments: List&lt;String&gt;, classPath: List&lt;String&gt; = defaultClassPath, workingDirectory: Path? = null, jdwpPort: Int? = null, extraJvmArguments: List&lt;String&gt; = emptyList(), maximumHeapSize: String? = null )</ID>
    <ID>LongParameterList:ProcessUtilities.kt$ProcessUtilities$( className: String, arguments: List&lt;String&gt;, classPath: List&lt;String&gt; = defaultClassPath, workingDirectory: Path? = null, jdwpPort: Int? = null, extraJvmArguments: List&lt;String&gt; = emptyList(), maximumHeapSize: String? = null )</ID>
    <ID>LongParameterList:Program.kt$(opt: String, longOpt: String, description: String, hasArg: Boolean = true, isRequired: Boolean = false, type: Class&lt;*&gt; = String::class.java)</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, stateRefs: List&lt;StateRef&gt;? = this.stateRefs, notary: List&lt;AbstractParty&gt;? = this.notary, softLockingCondition: SoftLockingCondition? = this.softLockingCondition, timeCondition: TimeCondition? = this.timeCondition )</ID>
    <ID>LongParameterList:RPCClient.kt$RPCClient$( rpcOpsClass: Class&lt;I&gt;, username: String, password: String, externalTrace: Trace? = null, impersonatedActor: Actor? = null, targetLegalIdentity: CordaX500Name? = null )</ID>
    <ID>LongParameterList:RPCDriver.kt$( isDebug: Boolean = false, driverDirectory: Path = Paths.get("build") / "rpc-driver" / getTimestampAsDirectoryName(), portAllocation: PortAllocation = globalPortAllocation, debugPortAllocation: PortAllocation = globalDebugPortAllocation, systemProperties: Map&lt;String, String&gt; = emptyMap(), useTestClock: Boolean = false, startNodesInProcess: Boolean = false, waitForNodesToFinish: Boolean = false, extraCordappPackagesToScan: List&lt;String&gt; = emptyList(), notarySpecs: List&lt;NotarySpec&gt; = emptyList(), externalTrace: Trace? = null, @Suppress("DEPRECATION") jmxPolicy: JmxPolicy = JmxPolicy(), networkParameters: NetworkParameters = testNetworkParameters(), notaryCustomOverrides: Map&lt;String, Any?&gt; = emptyMap(), inMemoryDB: Boolean = true, cordappsForAllNodes: Collection&lt;TestCordappInternal&gt;? = null, enableSNI:Boolean = true, dsl: RPCDriverDSL.() -&gt; A )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, brokerHandle: RpcBrokerHandle, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( serverName: String = "driver-rpc-server-${random63BitValue()}", rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 5L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, customPort: NetworkHostAndPort? = null, ops: I )</ID>
    <ID>LongParameterList:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$(config: NodeConfiguration, myInfo: NodeInfo, ourKeyPair: KeyPair, trustRoot: X509Certificate, nodeCa: X509Certificate, signedNetworkParameters: NetworkParametersReader.NetworkParametersAndSigned)</ID>
    <ID>LongParameterList:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$(config: NodeConfiguration, myInfo: NodeInfo, signedNetworkParameters: NetworkParametersReader.NetworkParametersAndSigned, ourKeyPair: KeyPair, trustRoot: X509Certificate, nodeCa: X509Certificate)</ID>
    <ID>LongParameterList:RpcHelper.kt$( @Suppress("UNUSED_PARAMETER") crossinline flowConstructor: (A, B, C) -&gt; R, arg0: A, arg1: B, arg2: C, retryInterval: Duration = 5.seconds, giveUpInterval: Duration = 5.minutes )</ID>
    <ID>LongParameterList:RpcHelper.kt$( @Suppress("UNUSED_PARAMETER") crossinline flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, retryInterval: Duration = 5.seconds, giveUpInterval: Duration = 5.minutes )</ID>
    <ID>LongParameterList:RpcWorker.kt$Main$(config: NodeConfiguration, myInfo: NodeInfo, signedNetworkParameters: NetworkParametersReader.NetworkParametersAndSigned, ourKeyPair: KeyPair, trustRoot: X509Certificate, nodeCa: X509Certificate, serverControl: ActiveMQServerControl)</ID>
    <ID>LongParameterList:SerializationEnvironment.kt$SerializationEnvironment.Companion$( serializationFactory: SerializationFactory, p2pContext: SerializationContext, rpcServerContext: SerializationContext? = null, rpcClientContext: SerializationContext? = null, storageContext: SerializationContext? = null, checkpointContext: CheckpointSerializationContext? = null, checkpointSerializer: CheckpointSerializer? = null )</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$( whitelist: ClassWhitelist, carpenterClassLoader: ClassLoader, lenientCarpenterEnabled: Boolean = false, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false)</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$( whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false)</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$(whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry, allowEvolution: Boolean, overrideFingerPrinter: FingerPrinter?, onlyCustomSerializers: Boolean, mustPreserveDataWhenEvolving: Boolean)</ID>
    <ID>LongParameterList:ServiceHubInternal.kt$ServiceHubInternal.Companion$(statesToRecord: StatesToRecord, txs: Collection&lt;SignedTransaction&gt;, validatedTransactions: WritableTransactionStorage, stateMachineRecordedTransactionMapping: StateMachineRecordedTransactionMappingStorage, vaultService: VaultServiceInternal, database: CordaPersistence)</ID>
    <ID>LongParameterList:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$( cordapp: CustomCordapp, newCordapp: CustomCordapp, whiteListedCordapps: Map&lt;ContractClassName, List&lt;CustomCordapp&gt;&gt;, systemProperties: Map&lt;String, String&gt;, startNodesInProcess: Boolean, minimumPlatformVersion: Int = 4, specifyExistingConstraint: Boolean = false, addAnotherAutomaticConstraintState: Boolean = false )</ID>
    <ID>LongParameterList:SinglePartyNotaryService.kt$SinglePartyNotaryService$( inputs: List&lt;StateRef&gt;, txId: SecureHash, caller: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongParameterList:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$( flowLogic: FlowLogic&lt;A&gt;, initiatingMessageDeduplicationHandler: DeduplicationHandler, peerSession: FlowSessionImpl, initiatedSessionId: SessionId, initiatingMessage: InitialSessionMessage, senderCoreFlowVersion: Int?, initiatedFlowInfo: FlowInfo )</ID>
    <ID>LongParameterList:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$( invocationContext: InvocationContext, flowLogic: FlowLogic&lt;A&gt;, flowStart: FlowStart, ourIdentity: Party, deduplicationHandler: DeduplicationHandler?, isStartIdempotent: Boolean )</ID>
    <ID>LongParameterList:StateMachineState.kt$Checkpoint.Companion$( invocationContext: InvocationContext, flowStart: FlowStart, flowLogicClass: Class&lt;FlowLogic&lt;*&gt;&gt;, frozenFlowLogic: SerializedBytes&lt;FlowLogic&lt;*&gt;&gt;, ourIdentity: Party, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean )</ID>
    <ID>LongParameterList:TLSAuthenticationTests.kt$TLSAuthenticationTests$( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, client1CAScheme: SignatureScheme, client1TLSScheme: SignatureScheme, client2CAScheme: SignatureScheme, client2TLSScheme: SignatureScheme )</ID>
    <ID>LongParameterList:TLSAuthenticationTests.kt$TLSAuthenticationTests$( serverSocketFactory: SSLServerSocketFactory, clientSocketFactory: SSLSocketFactory, serverPort: Int = 0, // Use 0 to get first free socket. clientPort: Int = 0, // Use 0 to get first free socket. cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES )</ID>
    <ID>LongParameterList:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$(contractClassName: ContractClassName, label: String?, notary: Party, encumbrance: Int?, attachmentConstraint: AttachmentConstraint, contractState: ContractState)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?)</ID>
    <ID>LongParameterList:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, attachmentID: SecureHash?, notary: Party)</ID>
    <ID>LongParameterList:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode )</ID>
    <ID>LongParameterList:UniquenessProvider.kt$UniquenessProvider$( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow? = null, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:Utils.kt$( port: Int, host: String = "127.0.0.1", connectionTimeout: Int = 30000, timeout: Int = 60000, keepSessionAlive: Boolean = false, keyGroup: String = "TEST.CORDACONNECT.ROOT", keySpecifier: Int = 1, username: String = "INTEGRATION_TEST", password: String = "INTEGRATION_TEST")</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT)</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, thisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT)</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now())</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), uniqueIdentifier: UniqueIdentifier? = null, linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now(), constraint: AttachmentConstraint = AutomaticPlaceholderConstraint, includeMe: Boolean = true)</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime )</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime, relevancyStatus: Vault.RelevancyStatus? )</ID>
    <ID>LongParameterList:WireTransaction.kt$WireTransaction.Companion$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, issuerSigner: ContentSigner, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:internalAccessTestHelpers.kt$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>MagicNumber:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$90</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$10</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$100</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$1000</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$10000</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$1024</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$20000</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$3</ID>
    <ID>MagicNumber:AMQPBridgeTest.kt$AMQPBridgeTest$40000</ID>
    <ID>MagicNumber:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$128</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.CHOICE$7</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.COMPOSITE_TYPE$5</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.FIELD$4</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.OBJECT_DESCRIPTOR$3</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.REFERENCED_OBJECT$8</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.RESTRICTED_TYPE$6</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.TRANSFORM_ELEMENT$10</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.TRANSFORM_ELEMENT_KEY$11</ID>
    <ID>MagicNumber:AMQPDescriptorRegistry.kt$AMQPDescriptorRegistry.TRANSFORM_SCHEMA$9</ID>
    <ID>MagicNumber:AMQPFirewallSerializationScheme.kt$AMQPFirewallSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPListenerTest.kt$AMQPListenerTest$10005</ID>
    <ID>MagicNumber:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$3</ID>
    <ID>MagicNumber:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$4</ID>
    <ID>MagicNumber:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$5</ID>
    <ID>MagicNumber:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$6</ID>
    <ID>MagicNumber:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPServer.kt$AMQPServer$100</ID>
    <ID>MagicNumber:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$33</ID>
    <ID>MagicNumber:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$3</ID>
    <ID>MagicNumber:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$4</ID>
    <ID>MagicNumber:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$5</ID>
    <ID>MagicNumber:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$6</ID>
    <ID>MagicNumber:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$2048</ID>
    <ID>MagicNumber:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$512</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$3</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$4</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$5</ID>
    <ID>MagicNumber:AbstractNode.kt$AbstractNode$1000</ID>
    <ID>MagicNumber:AbstractNode.kt$AbstractNode$50</ID>
    <ID>MagicNumber:AbstractNode.kt$AbstractNode$512</ID>
    <ID>MagicNumber:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$1000</ID>
    <ID>MagicNumber:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$12</ID>
    <ID>MagicNumber:AbstractNodeTests.kt$AbstractNodeTests$100</ID>
    <ID>MagicNumber:AbstractNodeTests.kt$AbstractNodeTests$4</ID>
    <ID>MagicNumber:AbstractNodeTests.kt$AbstractNodeTests$5</ID>
    <ID>MagicNumber:AbstractRPCTest.kt$AbstractRPCTest$5</ID>
    <ID>MagicNumber:AbstractScenarioRunner.kt$AbstractScenarioRunner$10</ID>
    <ID>MagicNumber:AbstractScenarioRunner.kt$AbstractScenarioRunner.Companion$5</ID>
    <ID>MagicNumber:AbstractWrappedKeysTest.kt$AbstractWrappedKeysTest$10</ID>
    <ID>MagicNumber:AbstractWrappedKeysTest.kt$AbstractWrappedKeysTest$1000</ID>
    <ID>MagicNumber:AbstractWrappedKeysTest.kt$AbstractWrappedKeysTest$12</ID>
    <ID>MagicNumber:AccessOrderLinkedHashMap.kt$AccessOrderLinkedHashMap$0.75f</ID>
    <ID>MagicNumber:AccessOrderLinkedHashMap.kt$AccessOrderLinkedHashMap$16</ID>
    <ID>MagicNumber:Adapter.kt$Adapter$10</ID>
    <ID>MagicNumber:Adapter.kt$Adapter$2004</ID>
    <ID>MagicNumber:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$1234</ID>
    <ID>MagicNumber:AffinityExecutorTests.kt$AffinityExecutorTests$3</ID>
    <ID>MagicNumber:AggregatedListTest.kt$AggregatedListTest$3</ID>
    <ID>MagicNumber:AggregatedListTest.kt$AggregatedListTest$4</ID>
    <ID>MagicNumber:AggregatedListTest.kt$AggregatedListTest$6</ID>
    <ID>MagicNumber:AggregatedListTest.kt$AggregatedListTest$8</ID>
    <ID>MagicNumber:AggregatedListTest.kt$AggregatedListTest$9</ID>
    <ID>MagicNumber:AllExceptionMapper.kt$AllExceptionMapper$500</ID>
    <ID>MagicNumber:Amount.kt$AmountTransfer$31</ID>
    <ID>MagicNumber:AmountTest.kt$AmountTest$100</ID>
    <ID>MagicNumber:AmountTest.kt$AmountTest$123456</ID>
    <ID>MagicNumber:AmountTest.kt$AmountTest$200</ID>
    <ID>MagicNumber:AmountTest.kt$AmountTest$250</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$10</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$100</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$1000</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$11</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$123</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$1234L</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$256</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$3</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$4</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$5</ID>
    <ID>MagicNumber:AmountTests.kt$AmountTests$6</ID>
    <ID>MagicNumber:AppendOnlyPersistentMapNonConcurrentTest.kt$AppendOnlyPersistentMapNonConcurrentTest$3</ID>
    <ID>MagicNumber:ArraySerializer.kt$ArraySerializer$4</ID>
    <ID>MagicNumber:ArtemisConnectionTest.kt$ArtemisConnectionTest$11005</ID>
    <ID>MagicNumber:ArtemisConnectionTest.kt$ArtemisConnectionTest$20000</ID>
    <ID>MagicNumber:ArtemisConnectionTest.kt$ArtemisConnectionTest$40000</ID>
    <ID>MagicNumber:ArtemisMessagingClient.kt$ArtemisMessagingClient$30000</ID>
    <ID>MagicNumber:ArtemisMessagingClient.kt$ArtemisMessagingClient$60000</ID>
    <ID>MagicNumber:ArtemisMessagingServer.kt$ArtemisMessagingServer$10L</ID>
    <ID>MagicNumber:ArtemisMessagingServer.kt$ArtemisMessagingServer$2000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$10</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$100_000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$200</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$20000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$3</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$40000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$5</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$50_000</ID>
    <ID>MagicNumber:ArtemisMessagingTest.kt$ArtemisMessagingTest$60000L</ID>
    <ID>MagicNumber:ArtemisRpcTests.kt$ArtemisRpcTests$10000</ID>
    <ID>MagicNumber:ArtemisRpcTests.kt$ArtemisRpcTests$60000L</ID>
    <ID>MagicNumber:ArtemisRpcTests.kt$ArtemisRpcTests.TestRpcOpsImpl$1000</ID>
    <ID>MagicNumber:ArtemisUtils.kt$2000</ID>
    <ID>MagicNumber:AssociatedListTest.kt$AssociatedListTest$12</ID>
    <ID>MagicNumber:AssociatedListTest.kt$AssociatedListTest$3</ID>
    <ID>MagicNumber:AssociatedListTest.kt$AssociatedListTest$4</ID>
    <ID>MagicNumber:AssociatedListTest.kt$AssociatedListTest$5</ID>
    <ID>MagicNumber:AsyncLoadTestFlow.kt$AsyncLoadTestFlow$10</ID>
    <ID>MagicNumber:AsyncLoadTestFlow.kt$AsyncLoadTestFlow$32</ID>
    <ID>MagicNumber:AsyncLoadTestFlow.kt$AsyncLoadTestFlow$4.0</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10006</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10009</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10010</ID>
    <ID>MagicNumber:AttachmentDemoTest.kt$AttachmentDemoTest$10_000_000</ID>
    <ID>MagicNumber:AttachmentLoadingTests.kt$AttachmentLoadingTests$1234</ID>
    <ID>MagicNumber:AttachmentTrustTable.kt$AttachmentTrustTable$3</ID>
    <ID>MagicNumber:AttachmentUploaderJob.kt$AttachmentUploaderJob$401</ID>
    <ID>MagicNumber:AttachmentsClassLoader.kt$AttachmentsClassLoader$4</ID>
    <ID>MagicNumber:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$20</ID>
    <ID>MagicNumber:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$3</ID>
    <ID>MagicNumber:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$42</ID>
    <ID>MagicNumber:AuthDBTests.kt$AuthDBTests$1500</ID>
    <ID>MagicNumber:AuthDBTests.kt$AuthDBTests$50</ID>
    <ID>MagicNumber:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService$32</ID>
    <ID>MagicNumber:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$0x30</ID>
    <ID>MagicNumber:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$4</ID>
    <ID>MagicNumber:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$128</ID>
    <ID>MagicNumber:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$3650</ID>
    <ID>MagicNumber:AzureSmbVolume.kt$AzureSmbVolume$5000</ID>
    <ID>MagicNumber:BCCryptoServiceTests.kt$BCCryptoServiceTests$365</ID>
    <ID>MagicNumber:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$10</ID>
    <ID>MagicNumber:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$3</ID>
    <ID>MagicNumber:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$30</ID>
    <ID>MagicNumber:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$10</ID>
    <ID>MagicNumber:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$11000</ID>
    <ID>MagicNumber:BFTSmart.kt$BFTSmart.Client$100</ID>
    <ID>MagicNumber:BFTSmart.kt$BFTSmart.Replica.&lt;no name provided&gt;$20000</ID>
    <ID>MagicNumber:BFTSmartConfigInternal.kt$3</ID>
    <ID>MagicNumber:BFTSmartConfigInternal.kt$BFTSmartConfigInternal$200</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$10</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$11000</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$11001</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$11002</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$20</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$3</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$4</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$6</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$7</ID>
    <ID>MagicNumber:BFTSmartConfigTests.kt$BFTSmartConfigTests$9</ID>
    <ID>MagicNumber:BackChainResolutionSampler.kt$BackChainResolutionSampler$16</ID>
    <ID>MagicNumber:BackChainResolutionSampler.kt$BackchainOpCode.FINAL_PAYMENT$0x03</ID>
    <ID>MagicNumber:BackpressureHandlingTest.kt$BackpressureHandlingTest$10</ID>
    <ID>MagicNumber:BackpressureHandlingTest.kt$BackpressureHandlingTest$20</ID>
    <ID>MagicNumber:BackpressureHandlingTest.kt$BackpressureHandlingTest$5</ID>
    <ID>MagicNumber:BackpressureHandlingTest.kt$BackpressureHandlingTest$7</ID>
    <ID>MagicNumber:BackpressureHandlingTest.kt$BackpressureHandlingTestRule$3</ID>
    <ID>MagicNumber:Base58Test.kt$Base58Test$3471844090L</ID>
    <ID>MagicNumber:Base58Test.kt$Base58Test$4</ID>
    <ID>MagicNumber:Base58Test.kt$Base58Test$7</ID>
    <ID>MagicNumber:BlobWriter.kt$3</ID>
    <ID>MagicNumber:BlobWriter.kt$4</ID>
    <ID>MagicNumber:BlobWriter.kt$5</ID>
    <ID>MagicNumber:BlobWriter.kt$6</ID>
    <ID>MagicNumber:BootstrapperView.kt$BootstrapperView$4</ID>
    <ID>MagicNumber:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$30000</ID>
    <ID>MagicNumber:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$60000</ID>
    <ID>MagicNumber:BridgeHSMTest.kt$BridgeHSMTest$5</ID>
    <ID>MagicNumber:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$10005</ID>
    <ID>MagicNumber:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$11005</ID>
    <ID>MagicNumber:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$20000</ID>
    <ID>MagicNumber:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$40000</ID>
    <ID>MagicNumber:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$7890</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$10</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$100</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$10005</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$1000L</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$11005</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$11105</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$12005</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$20</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$20000</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$3</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$32</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$40000</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$5</ID>
    <ID>MagicNumber:BridgeIntegrationTest.kt$BridgeIntegrationTest$7890</ID>
    <ID>MagicNumber:BridgeRestartTest.kt$BridgeRestartTest$10</ID>
    <ID>MagicNumber:BridgeRestartTest.kt$BridgeRestartTest$100</ID>
    <ID>MagicNumber:BridgeRestartTest.kt$BridgeRestartTest$5000</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$10005</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$11005</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$11105</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$20000</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$40000</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$5</ID>
    <ID>MagicNumber:BridgeSmokeTest.kt$BridgeSmokeTest$60</ID>
    <ID>MagicNumber:BridgeToolTest.kt$BridgeToolTest$4</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$10</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$100</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$10000L</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$100L</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$11005</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$20</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$20000</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$2000L</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$30</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$40000</ID>
    <ID>MagicNumber:BullyLeaderTest.kt$BullyLeaderTest$9</ID>
    <ID>MagicNumber:ByteArrays.kt$10</ID>
    <ID>MagicNumber:ByteArrays.kt$16</ID>
    <ID>MagicNumber:ByteArrays.kt$4</ID>
    <ID>MagicNumber:ByteArrays.kt$ByteSequence$31</ID>
    <ID>MagicNumber:ByteArraysTest.kt$ByteArraysTest$3</ID>
    <ID>MagicNumber:ByteArraysTest.kt$ByteArraysTest$4</ID>
    <ID>MagicNumber:ByteArraysTest.kt$ByteArraysTest$5</ID>
    <ID>MagicNumber:ByteArraysTest.kt$ByteArraysTest$6</ID>
    <ID>MagicNumber:ByteArraysTest.kt$ByteArraysTest$9</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$1024</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$256</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$64</ID>
    <ID>MagicNumber:CacheTracingTest.kt$CacheTracingTest$10</ID>
    <ID>MagicNumber:CacheTracingTest.kt$CacheTracingTest$3L</ID>
    <ID>MagicNumber:CacheTracingTest.kt$CacheTracingTest$4L</ID>
    <ID>MagicNumber:CacheTracingTest.kt$CacheTracingTest$5L</ID>
    <ID>MagicNumber:CacheTracingTest.kt$CacheTracingTest$8</ID>
    <ID>MagicNumber:CaffeineStatsCounter.kt$&lt;no name provided&gt;$100L</ID>
    <ID>MagicNumber:Cap.kt$20</ID>
    <ID>MagicNumber:Cap.kt$Cap$0.5</ID>
    <ID>MagicNumber:Cap.kt$Cap$1.5</ID>
    <ID>MagicNumber:Cap.kt$Cap$2016</ID>
    <ID>MagicNumber:Cap.kt$Cap$250</ID>
    <ID>MagicNumber:Cap.kt$Cap$50</ID>
    <ID>MagicNumber:Cap.kt$Cap$9</ID>
    <ID>MagicNumber:Cap.kt$Cap.&lt;no name provided&gt;$150</ID>
    <ID>MagicNumber:Caplet.kt$Caplet$0.5</ID>
    <ID>MagicNumber:Caplet.kt$Caplet$1.5</ID>
    <ID>MagicNumber:Caplet.kt$Caplet$2016</ID>
    <ID>MagicNumber:Caplet.kt$Caplet$250</ID>
    <ID>MagicNumber:Caplet.kt$Caplet$50</ID>
    <ID>MagicNumber:Caplet.kt$Caplet$9</ID>
    <ID>MagicNumber:Cash.kt$10</ID>
    <ID>MagicNumber:CashExitFlowTests.kt$CashExitFlowTests$2000</ID>
    <ID>MagicNumber:CashExitFlowTests.kt$CashExitFlowTests$500</ID>
    <ID>MagicNumber:CashIssueAndPaymentFlowTests.kt$CashIssueAndPaymentFlowTests$500</ID>
    <ID>MagicNumber:CashIssueAndPaymentNoSelectionFlowTests.kt$CashIssueAndPaymentNoSelectionTests$500</ID>
    <ID>MagicNumber:CashIssueFlowTests.kt$CashIssueFlowTests$500</ID>
    <ID>MagicNumber:CashPaymentFlowTests.kt$CashPaymentFlowTests$1500</ID>
    <ID>MagicNumber:CashPaymentFlowTests.kt$CashPaymentFlowTests$2000</ID>
    <ID>MagicNumber:CashPaymentFlowTests.kt$CashPaymentFlowTests$4000</ID>
    <ID>MagicNumber:CashPaymentFlowTests.kt$CashPaymentFlowTests$500</ID>
    <ID>MagicNumber:CashScenarioRunner.kt$CashScenarioRunner$100L</ID>
    <ID>MagicNumber:CashScenarioRunner.kt$CashScenarioRunner$10L</ID>
    <ID>MagicNumber:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$100</ID>
    <ID>MagicNumber:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$1000</ID>
    <ID>MagicNumber:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$3</ID>
    <ID>MagicNumber:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$999</ID>
    <ID>MagicNumber:CashSelectionH2Test.kt$CashSelectionH2Test$100</ID>
    <ID>MagicNumber:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$3</ID>
    <ID>MagicNumber:CashSelectionTest.kt$CashSelectionTest$1000</ID>
    <ID>MagicNumber:CashSelectionTest.kt$CashSelectionTest$3</ID>
    <ID>MagicNumber:CashSelectionTest.kt$CashSelectionTest$3.01</ID>
    <ID>MagicNumber:CashSelectionTest.kt$CashSelectionTest$300</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$10</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$100</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$1000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$10000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$1150</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$12</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$150</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$200</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$2000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$3</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$30</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$32</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$320</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$34</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$4</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$400</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$4000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$5</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$50</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$500</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$5000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$580</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$6</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$6000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$658</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$7</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$7000</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$8</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$80</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$800</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$81</ID>
    <ID>MagicNumber:CashTests.kt$CashTests$90</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer$5.0</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.CashWidget$10.0</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.CashWidget$300</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.StateRowGraphic$16</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.StateRowGraphic$30.0</ID>
    <ID>MagicNumber:CheatingSecurityProvider.kt$CheatingSecurityProvider$1.8</ID>
    <ID>MagicNumber:CheckTestFlows.kt$CheckAllTheTestFlows$5</ID>
    <ID>MagicNumber:CityDatabaseTest.kt$CityDatabaseTest$0.12</ID>
    <ID>MagicNumber:CityDatabaseTest.kt$CityDatabaseTest$51.5</ID>
    <ID>MagicNumber:ClassCarpenter.kt$ClassCarpenterImpl$3</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$0xDEAD</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$1.23</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$10</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$127</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$16</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$3</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$32</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$4</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$4.56F</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$42</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$5</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$6</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$7</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$8</ID>
    <ID>MagicNumber:ClassCarpenterTest.kt$ClassCarpenterTest$99</ID>
    <ID>MagicNumber:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$42</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$3</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$4</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$5</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests.TestOps$2000</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests.TestOpsImpl$1000</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests.TestOpsImpl$3</ID>
    <ID>MagicNumber:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests.TestOpsImpl$4</ID>
    <ID>MagicNumber:ClientRpcExample.kt$ClientRpcExample$3</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$0.7</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$0.8</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$1000</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$10000</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$2000</ID>
    <ID>MagicNumber:ClockUtilsTest.kt$ClockUtilsTest$10</ID>
    <ID>MagicNumber:ClockUtilsTest.kt$ClockUtilsTest$6</ID>
    <ID>MagicNumber:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$3</ID>
    <ID>MagicNumber:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$10</ID>
    <ID>MagicNumber:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$30</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$10</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$1000</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$1200</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$123</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$700</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$8</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$CommercialPaperTestsGeneric$900</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$KotlinCommercialPaperLegacyTest$1000</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$KotlinCommercialPaperLegacyTest$123</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$KotlinCommercialPaperLegacyTest$7</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$KotlinCommercialPaperTest$1000</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$KotlinCommercialPaperTest$123</ID>
    <ID>MagicNumber:CommercialPaperTests.kt$KotlinCommercialPaperTest$7</ID>
    <ID>MagicNumber:CompatibleTransactionTests.kt$CompatibleTransactionTests$100</ID>
    <ID>MagicNumber:CompatibleTransactionTests.kt$CompatibleTransactionTests$101</ID>
    <ID>MagicNumber:CompatibleTransactionTests.kt$CompatibleTransactionTests$3</ID>
    <ID>MagicNumber:CompatibleTransactionTests.kt$CompatibleTransactionTests$4</ID>
    <ID>MagicNumber:CompatibleTransactionTests.kt$CompatibleTransactionTests$6</ID>
    <ID>MagicNumber:CompatibleTransactionTests.kt$CompatibleTransactionTests$8</ID>
    <ID>MagicNumber:CompositeKey.kt$CompositeKey$31</ID>
    <ID>MagicNumber:CompositeKeyTests.kt$CompositeKeyTests$13</ID>
    <ID>MagicNumber:CompositeKeyTests.kt$CompositeKeyTests$14</ID>
    <ID>MagicNumber:CompositeKeyTests.kt$CompositeKeyTests$27</ID>
    <ID>MagicNumber:CompositeKeyTests.kt$CompositeKeyTests$3</ID>
    <ID>MagicNumber:CompositeKeyTests.kt$CompositeKeyTests$5</ID>
    <ID>MagicNumber:CompositeMemberCompositeSchemaToClassCarpenterTests.kt$CompositeMembers$10</ID>
    <ID>MagicNumber:CompositeMemberCompositeSchemaToClassCarpenterTests.kt$CompositeMembers$20</ID>
    <ID>MagicNumber:CompositeSignature.kt$CompositeSignature$1024</ID>
    <ID>MagicNumber:ConcatenatedListTest.kt$ConcatenatedListTest$3</ID>
    <ID>MagicNumber:ConcatenatedListTest.kt$ConcatenatedListTest$4</ID>
    <ID>MagicNumber:ConcatenatedListTest.kt$ConcatenatedListTest$5</ID>
    <ID>MagicNumber:ConcatenatedListTest.kt$ConcatenatedListTest$6</ID>
    <ID>MagicNumber:ConcatenatedListTest.kt$ConcatenatedListTest$7</ID>
    <ID>MagicNumber:ConcurrencyUtilsTest.kt$ConcurrencyUtilsTest$100</ID>
    <ID>MagicNumber:ConfigExporter.kt$3</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator$0xff</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator$16</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator.CipherText$16</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator.CipherText$8</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator.CipherText.Companion$128</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator.CipherText.Companion$16</ID>
    <ID>MagicNumber:ConfigObfuscator.kt$ConfigObfuscator.CipherText.Companion$8</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$10</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$20</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$3</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$30</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$4</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$40</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$5</ID>
    <ID>MagicNumber:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$6</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$1.2</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$100</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$123</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$2223</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$2225</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$3</ID>
    <ID>MagicNumber:ConfigParsingTest.kt$ConfigParsingTest$3.4</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$10005</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$11005</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$12005</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$12345</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$30000L</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$34</ID>
    <ID>MagicNumber:ConfigTest.kt$ConfigTest$60</ID>
    <ID>MagicNumber:ConnectionManager.kt$ConnectionManager$22</ID>
    <ID>MagicNumber:ConnectionStateMachine.kt$ConnectionStateMachine$1500</ID>
    <ID>MagicNumber:ConnectionStateMachine.kt$ConnectionStateMachine$4</ID>
    <ID>MagicNumber:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$1000</ID>
    <ID>MagicNumber:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$2000</ID>
    <ID>MagicNumber:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$4</ID>
    <ID>MagicNumber:ContractAttachmentSerializerTest.kt$ContractAttachmentSerializerTest$1024</ID>
    <ID>MagicNumber:ContractDefinition.kt$ContractDefinition$1070</ID>
    <ID>MagicNumber:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$1000</ID>
    <ID>MagicNumber:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$1000000</ID>
    <ID>MagicNumber:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2$1000</ID>
    <ID>MagicNumber:CorDappSerializerTests.kt$CorDappSerializerTests$100</ID>
    <ID>MagicNumber:CorDappSerializerTests.kt$CorDappSerializerTests$100L</ID>
    <ID>MagicNumber:CorDappSerializerTests.kt$CorDappSerializerTests$3</ID>
    <ID>MagicNumber:CordaFlowToolWindow.kt$CordaFlowToolWindow$0.05</ID>
    <ID>MagicNumber:CordaFlowToolWindow.kt$CordaFlowToolWindow$0.5</ID>
    <ID>MagicNumber:CordaFlowToolWindow.kt$CordaFlowToolWindow$3</ID>
    <ID>MagicNumber:CordaFutureImplTest.kt$CordaFutureTest$100</ID>
    <ID>MagicNumber:CordaFutureImplTest.kt$CordaFutureTest$200</ID>
    <ID>MagicNumber:CordaFutureImplTest.kt$TransposeTest$100</ID>
    <ID>MagicNumber:CordaFutureImplTest.kt$TransposeTest$3</ID>
    <ID>MagicNumber:CordaModuleWizardStep.kt$CordaModuleWizardPanel$11</ID>
    <ID>MagicNumber:CordaModuleWizardStep.kt$CordaModuleWizardPanel$12</ID>
    <ID>MagicNumber:CordaModuleWizardStep.kt$CordaModuleWizardPanel$4</ID>
    <ID>MagicNumber:CordaModuleWizardStep.kt$CordaModuleWizardPanel$5</ID>
    <ID>MagicNumber:CordaPersistence.kt$DatabaseConfig.Defaults$100L</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClient$128</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$3</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$31</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$5</ID>
    <ID>MagicNumber:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$10</ID>
    <ID>MagicNumber:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$4</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$10</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$100</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$1000</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$120</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$123</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$20</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest$2000</ID>
    <ID>MagicNumber:CordaRPCClientTest.kt$CordaRPCClientTest.StandaloneCashRpcClient$10000</ID>
    <ID>MagicNumber:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$10</ID>
    <ID>MagicNumber:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$100</ID>
    <ID>MagicNumber:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$1000L</ID>
    <ID>MagicNumber:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$5</ID>
    <ID>MagicNumber:CordaSecurityProvider.kt$CordaSecurityProvider$0.1</ID>
    <ID>MagicNumber:CordaServiceTest.kt$CordaServiceTest.DummyServiceFlow$100</ID>
    <ID>MagicNumber:CordappConstraintsTests.kt$CordappConstraintsTests$1000</ID>
    <ID>MagicNumber:CordappConstraintsTests.kt$CordappConstraintsTests$500</ID>
    <ID>MagicNumber:CordappResolverTest.kt$CordappResolverTest$222</ID>
    <ID>MagicNumber:CordappResolverTest.kt$CordappResolverTest$555</ID>
    <ID>MagicNumber:CordappSmokeTest.kt$CordappSmokeTest$1234</ID>
    <ID>MagicNumber:CrlFetcher.kt$CrlFetcher.Companion$1000</ID>
    <ID>MagicNumber:CrlFetcher.kt$CrlFetcher.Companion$60</ID>
    <ID>MagicNumber:CrlServer.kt$CrlServlet.Companion$10</ID>
    <ID>MagicNumber:CrlServer.kt$CrlServlet.Companion$3</ID>
    <ID>MagicNumber:CrlServer.kt$CrlServlet.Companion$5</ID>
    <ID>MagicNumber:CrossCashTest.kt$1000</ID>
    <ID>MagicNumber:CrossCashTest.kt$10000</ID>
    <ID>MagicNumber:CrossCashTest.kt$3000</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$2048</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$256</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3072</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$4</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$5</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$6</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$8</ID>
    <ID>MagicNumber:CryptoServiceSigningService.kt$CryptoServiceSigningService$1000L</ID>
    <ID>MagicNumber:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$1000</ID>
    <ID>MagicNumber:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$10000</ID>
    <ID>MagicNumber:CryptoServiceSpec.kt$CryptoServiceSpec$3650</ID>
    <ID>MagicNumber:CryptoUtils.kt$8</ID>
    <ID>MagicNumber:CryptoUtilsTest.kt$CryptoUtilsTest$1000000</ID>
    <ID>MagicNumber:CryptoUtilsTest.kt$CryptoUtilsTest$256</ID>
    <ID>MagicNumber:CryptoUtilsTest.kt$CryptoUtilsTest$258</ID>
    <ID>MagicNumber:CryptoUtilsTest.kt$CryptoUtilsTest$259</ID>
    <ID>MagicNumber:CryptoUtilsTest.kt$CryptoUtilsTest$514</ID>
    <ID>MagicNumber:CurrenciesTests.kt$CurrenciesTests$1000L</ID>
    <ID>MagicNumber:CurrenciesTests.kt$CurrenciesTests$1200L</ID>
    <ID>MagicNumber:CurrenciesTests.kt$CurrenciesTests$1234L</ID>
    <ID>MagicNumber:CurrenciesTests.kt$CurrenciesTests$1500000000L</ID>
    <ID>MagicNumber:CurrenciesTests.kt$CurrenciesTests$500000L</ID>
    <ID>MagicNumber:CurrenciesTests.kt$CurrenciesTests$5000L</ID>
    <ID>MagicNumber:CustomVaultQueryTest.kt$CustomVaultQueryTest$1000</ID>
    <ID>MagicNumber:CustomVaultQueryTest.kt$CustomVaultQueryTest$500</ID>
    <ID>MagicNumber:CustomVaultQueryTest.kt$CustomVaultQueryTest$800</ID>
    <ID>MagicNumber:CustomVaultQueryTest.kt$CustomVaultQueryTest$900</ID>
    <ID>MagicNumber:DBTransactionStorageTests.kt$DBTransactionStorageTests$1024</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$10</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$30.0</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$350</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$CockroachDBDataSourceFactory$26257</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$CockroachDBDataSourceFactory$8080</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$CockroachDBJpaContainer$200</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$CockroachDBJpaContainer$26257</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$CockroachDBJpaContainer$8080</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$MySQLDataSourceFactory$3306</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$MySQLDataSourceFactory$33060</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$OracleDataSourceFactory$1521</ID>
    <ID>MagicNumber:DatabaseTestContainers.kt$OracleJpaContainer$1521</ID>
    <ID>MagicNumber:DbMapDeadlockTest.kt$DbMapDeadlockTest$10</ID>
    <ID>MagicNumber:DbMapDeadlockTest.kt$DbMapDeadlockTest$100</ID>
    <ID>MagicNumber:DbMapDeadlockTest.kt$DbMapDeadlockTest$2000</ID>
    <ID>MagicNumber:DbMapDeadlockTest.kt$DbMapDeadlockTest$70</ID>
    <ID>MagicNumber:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$32</ID>
    <ID>MagicNumber:DelegatedKeystoreProvider.kt$DelegatedKeystoreProvider$0.1</ID>
    <ID>MagicNumber:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$10</ID>
    <ID>MagicNumber:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$1000</ID>
    <ID>MagicNumber:DelegatedSignatureProvider.kt$DelegatedSignatureProvider$0.1</ID>
    <ID>MagicNumber:DeserializeAndReturnEnvelopeTests.kt$DeserializeAndReturnEnvelopeTests$10</ID>
    <ID>MagicNumber:DeserializeAndReturnEnvelopeTests.kt$DeserializeAndReturnEnvelopeTests$123</ID>
    <ID>MagicNumber:DeserializeAndReturnEnvelopeTests.kt$DeserializeAndReturnEnvelopeTests$30.0F</ID>
    <ID>MagicNumber:DeserializeMapTests.kt$DeserializeMapTests$3</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$0b0101</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$0b1010</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$10.0</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$10.0F</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$100</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$20.0</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$20.0F</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$200</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$3</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest$4</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$10</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$12</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$20</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$3</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$4</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$5</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$6</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$7</ID>
    <ID>MagicNumber:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$8</ID>
    <ID>MagicNumber:DeserializeQueryableStateTest.kt$TestState$432</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$0b0101</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$0b1000</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$0b1100</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$0b1110</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$0b1111</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$10</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$10.0</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$100.023232F</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$100.2</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$10F</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$1455.2</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$1455.433400F</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$2147483650</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$2147483800</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$3</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$4</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$5</ID>
    <ID>MagicNumber:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$6</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$10</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$100</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$20</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$3</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$30</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$5</ID>
    <ID>MagicNumber:DistributedServiceTests.kt$DistributedServiceTests$50</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$1000</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$5</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$60</ID>
    <ID>MagicNumber:DriverTests.kt$DriverTests$200</ID>
    <ID>MagicNumber:DriverTests.kt$DriverTests$3</ID>
    <ID>MagicNumber:DummyIssueAndMove.kt$DummyIssueAndMove$1000</ID>
    <ID>MagicNumber:DurationHelper.kt$1000000</ID>
    <ID>MagicNumber:DurationHelper.kt$24L</ID>
    <ID>MagicNumber:DurationHelper.kt$3</ID>
    <ID>MagicNumber:DurationHelper.kt$60L</ID>
    <ID>MagicNumber:EfficiencyKnownUnspentCachingDriver.kt$EfficiencyKnownUnspentCachingDriver$100_000</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F193</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F385</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F469</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4B0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4BB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4CE</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4DA</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4F0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F51C</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F537</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F60E</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F634</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F6AB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x200D</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2620</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x26A0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2705</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x27A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2B05</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0xFE0F</ID>
    <ID>MagicNumber:EncodingUtilsTest.kt$EncodingUtilsTest$7</ID>
    <ID>MagicNumber:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$10</ID>
    <ID>MagicNumber:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$7</ID>
    <ID>MagicNumber:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$8</ID>
    <ID>MagicNumber:EnterpriseNode.kt$EnterpriseNode.Startup$7</ID>
    <ID>MagicNumber:EnterpriseNode.kt$EnterpriseNode.Startup$93</ID>
    <ID>MagicNumber:EnterpriseNodeTest.kt$EnterpriseNodeTest$12345</ID>
    <ID>MagicNumber:EnterpriseNodeTest.kt$EnterpriseNodeTest$456</ID>
    <ID>MagicNumber:EnumClassTests.kt$EnumClassTests$3</ID>
    <ID>MagicNumber:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$3</ID>
    <ID>MagicNumber:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$6</ID>
    <ID>MagicNumber:EnumTests.kt$EnumTests$8</ID>
    <ID>MagicNumber:EnumTests.kt$EnumTests.BrasWithInit.PUSHUP$100</ID>
    <ID>MagicNumber:EnumTests.kt$EnumTests.BrasWithInit.PUSHUP$200</ID>
    <ID>MagicNumber:EnumTests.kt$EnumTests.BrasWithInit.UNDERWIRE$3</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.2</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.3</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.7</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.8</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$0.1</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$0.9</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$10000</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$1000000</ID>
    <ID>MagicNumber:Eventually.kt$100</ID>
    <ID>MagicNumber:Eventually.kt$5</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$10</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$100</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$1000</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$20</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$200</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$3</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$30</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$300</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$4</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$400</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$5</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$500</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests$600</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests.C$3</ID>
    <ID>MagicNumber:EvolvabilityTests.kt$EvolvabilityTests.C$4</ID>
    <ID>MagicNumber:Examples.kt$Examples$1.2</ID>
    <ID>MagicNumber:Examples.kt$Examples$1.3</ID>
    <ID>MagicNumber:Examples.kt$Examples$1070</ID>
    <ID>MagicNumber:ExceptionsErrorCodeFunctions.kt$3</ID>
    <ID>MagicNumber:ExceptionsErrorCodeFunctions.kt$36</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.01</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.18</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.31</ID>
    <ID>MagicNumber:ExchangeRateModelTest.kt$ExchangeRateModelTest$10</ID>
    <ID>MagicNumber:ExchangeRateModelTest.kt$ExchangeRateModelTest$100</ID>
    <ID>MagicNumber:ExchangeRateModelTest.kt$ExchangeRateModelTest$101</ID>
    <ID>MagicNumber:ExchangeRateModelTest.kt$ExchangeRateModelTest$1297</ID>
    <ID>MagicNumber:ExchangeRateModelTest.kt$ExchangeRateModelTest.Companion$0.01</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$100</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$10000</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$20000</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$40000</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$5</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$8500</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$9000</ID>
    <ID>MagicNumber:ExternalBrokerTests.kt$ExternalBrokertests$9500</ID>
    <ID>MagicNumber:ExternalIdMappingTest.kt$ExternalIdMappingTest$1337L</ID>
    <ID>MagicNumber:FXFwdTimeOption.kt$FXFwdTimeOption$1070</ID>
    <ID>MagicNumber:FXSwap.kt$FXSwap$1070</ID>
    <ID>MagicNumber:FXSwap.kt$FXSwap$900</ID>
    <ID>MagicNumber:FastThreadLocalTest.kt$FastThreadLocalTest$100</ID>
    <ID>MagicNumber:FastThreadLocalTest.kt$FastThreadLocalTest$3</ID>
    <ID>MagicNumber:FiberMonitor.kt$FiberMonitor$100</ID>
    <ID>MagicNumber:FiberMonitor.kt$FiberMonitor$1000</ID>
    <ID>MagicNumber:FinalityFlowTests.kt$FinalityFlowTests$1000</ID>
    <ID>MagicNumber:FinalityHandlerTest.kt$FinalityHandlerTest$1000</ID>
    <ID>MagicNumber:FirewallStartup.kt$FirewallStartup$10</ID>
    <ID>MagicNumber:FirewallStartup.kt$FirewallStartup$100.0</ID>
    <ID>MagicNumber:FirewallStartup.kt$FirewallStartup$1000</ID>
    <ID>MagicNumber:FixingFlow.kt$FixingFlow.Fixer.&lt;no name provided&gt;$30</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$12</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$123</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$1234</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$3</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$34</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$4</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$4321</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$5</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$56</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$6</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$78</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$8765</ID>
    <ID>MagicNumber:FlattenedListTest.kt$FlattenedListTest$910</ID>
    <ID>MagicNumber:FloatControlListenerService.kt$FloatControlListenerService$0xAA</ID>
    <ID>MagicNumber:FloatControlListenerService.kt$FloatControlListenerService$0xAA55</ID>
    <ID>MagicNumber:FlowAsyncOperationTests.kt$FlowAsyncOperationTests$10</ID>
    <ID>MagicNumber:FlowAsyncOperationTests.kt$FlowAsyncOperationTests$100</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$30</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$45</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$777</ID>
    <ID>MagicNumber:FlowCookbook.kt$ResponderFlow$99</ID>
    <ID>MagicNumber:FlowCookbook.kt$ResponderFlow.&lt;no name provided&gt;$777</ID>
    <ID>MagicNumber:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$4</ID>
    <ID>MagicNumber:FlowFrameworkTests.kt$FlowFrameworkTests$10L</ID>
    <ID>MagicNumber:FlowFrameworkTests.kt$FlowFrameworkTests$11L</ID>
    <ID>MagicNumber:FlowFrameworkTests.kt$FlowFrameworkTests$20L</ID>
    <ID>MagicNumber:FlowFrameworkTests.kt$FlowFrameworkTests$21L</ID>
    <ID>MagicNumber:FlowFrameworkTests.kt$FlowFrameworkTests$3</ID>
    <ID>MagicNumber:FlowFrameworkTests.kt$FlowFrameworkTests$4</ID>
    <ID>MagicNumber:FlowHospitalTest.kt$FlowHospitalTest$2_000</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic$300</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic.Companion$5</ID>
    <ID>MagicNumber:FlowLogicRefFactoryImplTest.kt$FlowLogicRefFactoryImplTest$3</ID>
    <ID>MagicNumber:FlowMonitor.kt$FlowMonitor$1000</ID>
    <ID>MagicNumber:FlowRetryTest.kt$FlowRetryTest$10</ID>
    <ID>MagicNumber:FlowRetryTest.kt$FlowRetryTest$3</ID>
    <ID>MagicNumber:FlowRetryTest.kt$InitiatorFlow$2000</ID>
    <ID>MagicNumber:FlowRunner.kt$FlowRunner$1000L</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$14</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$16</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$64</ID>
    <ID>MagicNumber:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$5</ID>
    <ID>MagicNumber:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest$1000</ID>
    <ID>MagicNumber:FlowVersioningTest.kt$FlowVersioningTest$3</ID>
    <ID>MagicNumber:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$4</ID>
    <ID>MagicNumber:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$50</ID>
    <ID>MagicNumber:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$10</ID>
    <ID>MagicNumber:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$1111</ID>
    <ID>MagicNumber:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$3</ID>
    <ID>MagicNumber:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$5</ID>
    <ID>MagicNumber:FlowWorkerTest.kt$FlowWorkerTest$10</ID>
    <ID>MagicNumber:FlowWorkerTest.kt$FlowWorkerTest$1111</ID>
    <ID>MagicNumber:FlowWorkerTest.kt$FlowWorkerTest$1112</ID>
    <ID>MagicNumber:FlowWorkerTest.kt$FlowWorkerTest$3</ID>
    <ID>MagicNumber:FlowWorkerTest.kt$FlowWorkerTest$5</ID>
    <ID>MagicNumber:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$1000</ID>
    <ID>MagicNumber:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$3</ID>
    <ID>MagicNumber:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$59980</ID>
    <ID>MagicNumber:FoundNode.kt$FoundNode$31</ID>
    <ID>MagicNumber:FxLoad.kt$1000</ID>
    <ID>MagicNumber:FxLoad.kt$10000</ID>
    <ID>MagicNumber:FxLoad.kt$1024</ID>
    <ID>MagicNumber:FxLoad.kt$160</ID>
    <ID>MagicNumber:FxLoad.kt$8</ID>
    <ID>MagicNumber:FxTransactionBuildTutorialTest.kt$FxTransactionBuildTutorialTest$100</ID>
    <ID>MagicNumber:FxTransactionBuildTutorialTest.kt$FxTransactionBuildTutorialTest$1000</ID>
    <ID>MagicNumber:FxTransactionBuildTutorialTest.kt$FxTransactionBuildTutorialTest$200</ID>
    <ID>MagicNumber:Generator.kt$Generator.Companion$16</ID>
    <ID>MagicNumber:Generator.kt$Generator.Companion$17</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$10</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$100</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$100L</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$1020304</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$121</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$20.0</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$3.0</ID>
    <ID>MagicNumber:GenericsTests.kt$GenericsTests$5060708</ID>
    <ID>MagicNumber:GuiUtilities.kt$1000</ID>
    <ID>MagicNumber:GuiUtilities.kt$1000.0</ID>
    <ID>MagicNumber:GuiUtilitiesKtTest.kt$GuiUtilitiesKtTest$100</ID>
    <ID>MagicNumber:GuiUtilitiesKtTest.kt$GuiUtilitiesKtTest$1000000000</ID>
    <ID>MagicNumber:GuiUtilitiesKtTest.kt$GuiUtilitiesKtTest$1000000000000000</ID>
    <ID>MagicNumber:GuiUtilitiesKtTest.kt$GuiUtilitiesKtTest$10500</ID>
    <ID>MagicNumber:GuiUtilitiesKtTest.kt$GuiUtilitiesKtTest$1500000000000</ID>
    <ID>MagicNumber:GuiUtilitiesKtTest.kt$GuiUtilitiesKtTest$5000000</ID>
    <ID>MagicNumber:HABrokerFailoverTest.kt$HABrokerFailoverTest$1000</ID>
    <ID>MagicNumber:HABrokerFailoverTest.kt$HABrokerFailoverTest$10000</ID>
    <ID>MagicNumber:HABrokerFailoverTest.kt$HABrokerFailoverTest$20000</ID>
    <ID>MagicNumber:HABrokerFailoverTest.kt$HABrokerFailoverTest$40000</ID>
    <ID>MagicNumber:HABrokerFailoverTest.kt$HABrokerFailoverTest$50</ID>
    <ID>MagicNumber:HABrokerFailoverTest.kt$HABrokerFailoverTest$95000</ID>
    <ID>MagicNumber:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$10</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$10</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$100</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$1000</ID>
    <ID>MagicNumber:HardRestartTest.kt$HardRestartTest$8</ID>
    <ID>MagicNumber:HashLookupCommandTest.kt$HashLookupCommandTest$2224</ID>
    <ID>MagicNumber:HashLookupCommandTest.kt$HashLookupCommandTest$5000</ID>
    <ID>MagicNumber:HibernateColumnConverterTests.kt$HibernateColumnConverterTests$1337L</ID>
    <ID>MagicNumber:HibernateColumnConverterTests.kt$HibernateColumnConverterTests$500</ID>
    <ID>MagicNumber:HibernateConfiguration.kt$HibernateConfiguration$40</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$10</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$100</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$1000</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$10000L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$12</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$123L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$15</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$200</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$20000L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$25</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$250</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$3</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$300</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$30000L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$4</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$400</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$40000L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$5</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$50</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$500</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$6</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$75000L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$7500L</ID>
    <ID>MagicNumber:HibernateConfigurationTest.kt$HibernateConfigurationTest$8</ID>
    <ID>MagicNumber:HttpUtils.kt$HttpUtils$5</ID>
    <ID>MagicNumber:HttpUtils.kt$HttpUtils$90</ID>
    <ID>MagicNumber:IOUFlowResponder.kt$IOUFlowResponder.&lt;no name provided&gt;$100</ID>
    <ID>MagicNumber:IRS.kt$FloatingRatePaymentEvent$31</ID>
    <ID>MagicNumber:IRS.kt$IRS$0.5</ID>
    <ID>MagicNumber:IRS.kt$IRS$1.5</ID>
    <ID>MagicNumber:IRS.kt$IRS$2016</ID>
    <ID>MagicNumber:IRS.kt$IRS$250</ID>
    <ID>MagicNumber:IRS.kt$IRS$50</ID>
    <ID>MagicNumber:IRS.kt$IRS$9</ID>
    <ID>MagicNumber:IRS.kt$InterestRateSwap.CommonLeg$31</ID>
    <ID>MagicNumber:IRS.kt$InterestRateSwap.FixedLeg$31</ID>
    <ID>MagicNumber:IRS.kt$InterestRateSwap.FloatingLeg$31</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$31</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$360.0</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$4</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$8</ID>
    <ID>MagicNumber:IRSDemo.kt$10004</ID>
    <ID>MagicNumber:IRSDemo.kt$10007</ID>
    <ID>MagicNumber:IRSDemo.kt$10010</ID>
    <ID>MagicNumber:IRSDemoDockerTest.kt$IRSDemoDockerTest$120</ID>
    <ID>MagicNumber:IRSDemoDockerTest.kt$IRSDemoDockerTest$8080</ID>
    <ID>MagicNumber:IRSDemoTest.kt$IRSDemoTest$180</ID>
    <ID>MagicNumber:IRSDemoTest.kt$IRSDemoTest$6</ID>
    <ID>MagicNumber:IRSTests.kt$10</ID>
    <ID>MagicNumber:IRSTests.kt$100</ID>
    <ID>MagicNumber:IRSTests.kt$10000</ID>
    <ID>MagicNumber:IRSTests.kt$15900000</ID>
    <ID>MagicNumber:IRSTests.kt$20</ID>
    <ID>MagicNumber:IRSTests.kt$2015</ID>
    <ID>MagicNumber:IRSTests.kt$2016</ID>
    <ID>MagicNumber:IRSTests.kt$2025</ID>
    <ID>MagicNumber:IRSTests.kt$2026</ID>
    <ID>MagicNumber:IRSTests.kt$250000</ID>
    <ID>MagicNumber:IRSTests.kt$25000000</ID>
    <ID>MagicNumber:IRSTests.kt$3</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$100</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$12</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$15</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$2015</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$2016</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$3</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$30</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$5</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$6</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$8</ID>
    <ID>MagicNumber:IRSTests.kt$IRSTests$9</ID>
    <ID>MagicNumber:IRSUtils.kt$PercentageRatioUnit$100</ID>
    <ID>MagicNumber:Id.kt$Id$31</ID>
    <ID>MagicNumber:IdempotentFlowTests.kt$IdempotentFlowTests$3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$16</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$90.0</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$0x3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$10</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$11</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$12</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$13</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$14</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$15</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$16</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$18</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$20</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$21</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$22</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$24</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$256</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$27</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$32.0f</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$4</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$6</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$7</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$8</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$90</ID>
    <ID>MagicNumber:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$1000</ID>
    <ID>MagicNumber:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$3</ID>
    <ID>MagicNumber:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$4</ID>
    <ID>MagicNumber:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$5</ID>
    <ID>MagicNumber:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$6</ID>
    <ID>MagicNumber:InheritanceSchemaToClassCarpenterTests.kt$InheritanceSchemaToClassCarpenterTests$20</ID>
    <ID>MagicNumber:InheritanceSchemaToClassCarpenterTests.kt$InheritanceSchemaToClassCarpenterTests$23</ID>
    <ID>MagicNumber:InheritanceSchemaToClassCarpenterTests.kt$InheritanceSchemaToClassCarpenterTests$42</ID>
    <ID>MagicNumber:InputStreamSerializer.kt$InputStreamSerializer$4096</ID>
    <ID>MagicNumber:InstrumentationTest.kt$InstrumentationTest$10</ID>
    <ID>MagicNumber:InstrumentationTest.kt$InstrumentationTest$100</ID>
    <ID>MagicNumber:InstrumentationTest.kt$InstrumentationTest$11</ID>
    <ID>MagicNumber:InstrumentationTest.kt$InstrumentationTest$5</ID>
    <ID>MagicNumber:InstrumentationTest.kt$InstrumentationTest$500</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$2223</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$2224</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$4</ID>
    <ID>MagicNumber:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$5000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$20000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$3</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$40000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$5</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork$30000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork$50</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork.MockNode$1000</ID>
    <ID>MagicNumber:InternalMockNetworkTests.kt$InternalMockNetworkTests$3</ID>
    <ID>MagicNumber:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$30000</ID>
    <ID>MagicNumber:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$60000</ID>
    <ID>MagicNumber:InternalTestUtils.kt$40</ID>
    <ID>MagicNumber:InternalTestUtils.kt$500</ID>
    <ID>MagicNumber:InternalTestUtils.kt$70</ID>
    <ID>MagicNumber:InternalUtils.kt$30</ID>
    <ID>MagicNumber:InternalUtils.kt$InputStreamAndHash.Companion$1024</ID>
    <ID>MagicNumber:InternalUtilsTest.kt$InternalUtilsTest$0xFF</ID>
    <ID>MagicNumber:InternalUtilsTest.kt$InternalUtilsTest$100</ID>
    <ID>MagicNumber:InternalUtilsTest.kt$InternalUtilsTest$3</ID>
    <ID>MagicNumber:InternalUtilsTest.kt$InternalUtilsTest$4</ID>
    <ID>MagicNumber:InternalUtilsTest.kt$InternalUtilsTest$5</ID>
    <ID>MagicNumber:InternalUtilsTest.kt$InternalUtilsTest$9</ID>
    <ID>MagicNumber:Interpolators.kt$CubicSplineInterpolator$3</ID>
    <ID>MagicNumber:Interpolators.kt$CubicSplineInterpolator$3.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$0.01</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$1.5</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$10.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$10.91</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$11.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$11.5</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$2.5</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$2.8</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$3.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$3.28</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$3.3</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$3.7</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$4.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$4.03</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$4.3</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$4.37</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$4.7</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$5.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$6.0</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$6.7</ID>
    <ID>MagicNumber:InterpolatorsTest.kt$InterpolatorsTest$9.46</ID>
    <ID>MagicNumber:IrsDemoWebApplication.kt$IrsDemoWebApplication$100</ID>
    <ID>MagicNumber:IrsDemoWebApplication.kt$IrsDemoWebApplication$1000</ID>
    <ID>MagicNumber:JPAUniquenessProvider.kt$JPAUniquenessProvider$100</ID>
    <ID>MagicNumber:JPAUniquenessProvider.kt$JPAUniquenessProvider$16</ID>
    <ID>MagicNumber:JPAUniquenessProviderTests.kt$JPAUniquenessProviderTests$32</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$1234</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$128</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$2500000000</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$2_500_000_000</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$3</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$4</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$4434</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$5</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$54321</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$6</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$7</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$8</ID>
    <ID>MagicNumber:JacksonSupportTest.kt$JacksonSupportTest$9090</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$CordappLoaderTemplate$36</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$CordappLoaderTemplate$64</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$JarScanningCordappLoader$1000</ID>
    <ID>MagicNumber:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$3</ID>
    <ID>MagicNumber:JarSignatureCollector.kt$JarSignatureCollector$1024</ID>
    <ID>MagicNumber:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$5</ID>
    <ID>MagicNumber:JarSignatureTestUtils.kt$JarSignatureTestUtils$14</ID>
    <ID>MagicNumber:KMSUtils.kt$3650</ID>
    <ID>MagicNumber:KotlinIntegrationTestingTutorial.kt$KotlinIntegrationTestingTutorial$1000</ID>
    <ID>MagicNumber:Kryo.kt$InputStreamSerializer$4096</ID>
    <ID>MagicNumber:KryoStreams.kt$1024</ID>
    <ID>MagicNumber:KryoStreams.kt$64</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$10</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$100</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$101</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$11</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$12345</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$3</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$5</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest$9</ID>
    <ID>MagicNumber:KryoStreamsTest.kt$KryoStreamsTest.NegInputStream$0xff</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$.03</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$.5</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$0.12345</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$0x01234567</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$0x76543210</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$10</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$11</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$1111</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$12</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$123</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$12344</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$12345</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$13</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$14</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$15</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$16</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$17</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$18</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$19</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$20</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$20000</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$20222</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$21</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$22</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$23</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$24</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$25</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$26</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$27</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$28</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$29</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$3</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$30</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$31</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$32</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$4</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$5</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$6</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$7</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$8</ID>
    <ID>MagicNumber:KryoTests.kt$KryoTests$9</ID>
    <ID>MagicNumber:LargeTransactionsTest.kt$LargeTransactionsTest$14</ID>
    <ID>MagicNumber:LargeTransactionsTest.kt$LargeTransactionsTest$16</ID>
    <ID>MagicNumber:LargeTransactionsTest.kt$LargeTransactionsTest$3</ID>
    <ID>MagicNumber:LazyMappedListTest.kt$LazyMappedListTest$10</ID>
    <ID>MagicNumber:LazyMappedListTest.kt$LazyMappedListTest$16</ID>
    <ID>MagicNumber:LazyMappedListTest.kt$LazyMappedListTest$3</ID>
    <ID>MagicNumber:LazyMappedListTest.kt$LazyMappedListTest$5</ID>
    <ID>MagicNumber:LazyMappedListTest.kt$LazyMappedListTest$9</ID>
    <ID>MagicNumber:LazyMappedListTest.kt$LazyMappedListTest$999</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$10</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$3</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$4</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$5</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$6</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$7</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$8</ID>
    <ID>MagicNumber:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$9</ID>
    <ID>MagicNumber:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$12</ID>
    <ID>MagicNumber:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$213</ID>
    <ID>MagicNumber:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$3</ID>
    <ID>MagicNumber:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$34</ID>
    <ID>MagicNumber:LeftOuterJoinedMapTest.kt$LeftOuterJoinedMapTest$91</ID>
    <ID>MagicNumber:LegacyConfigurations.kt$Version3BridgeConfigurationImpl$60</ID>
    <ID>MagicNumber:LegacyConfigurations.kt$Version4FirewallConfiguration$60</ID>
    <ID>MagicNumber:LegalNameValidatorTest.kt$LegalNameValidatorTest$255</ID>
    <ID>MagicNumber:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$0.05</ID>
    <ID>MagicNumber:LinearStateScenarioRunner.kt$LinearStateScenarioRunner$1000.0</ID>
    <ID>MagicNumber:ListsSerializationTest.kt$0x80</ID>
    <ID>MagicNumber:Literal.kt$1000</ID>
    <ID>MagicNumber:Literal.kt$1000000</ID>
    <ID>MagicNumber:LoadGenerator.kt$LoadGeneratorServer$10000</ID>
    <ID>MagicNumber:LocalSerializationRule.kt$LocalSerializationRule$128</ID>
    <ID>MagicNumber:LogTracer.kt$LogTracer$200</ID>
    <ID>MagicNumber:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$100</ID>
    <ID>MagicNumber:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$1024</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$10</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$10001</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$20</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$3</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$4</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$40</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$5</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$50L</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$7</ID>
    <ID>MagicNumber:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$9000</ID>
    <ID>MagicNumber:LoopbackBridgeTest.kt$LoopbackBridgeTest$1000</ID>
    <ID>MagicNumber:LoopbackBridgeTest.kt$LoopbackBridgeTest$20000</ID>
    <ID>MagicNumber:LoopbackBridgeTest.kt$LoopbackBridgeTest$3</ID>
    <ID>MagicNumber:LoopbackBridgeTest.kt$LoopbackBridgeTest$40000</ID>
    <ID>MagicNumber:LoopbackBridgeTest.kt$LoopbackBridgeTest$5</ID>
    <ID>MagicNumber:Main.kt$0x03</ID>
    <ID>MagicNumber:Main.kt$100</ID>
    <ID>MagicNumber:Main.kt$1000</ID>
    <ID>MagicNumber:Main.kt$10000L</ID>
    <ID>MagicNumber:Main.kt$1000L</ID>
    <ID>MagicNumber:Main.kt$10010</ID>
    <ID>MagicNumber:Main.kt$10014</ID>
    <ID>MagicNumber:Main.kt$10018</ID>
    <ID>MagicNumber:Main.kt$20000L</ID>
    <ID>MagicNumber:Main.kt$2000L</ID>
    <ID>MagicNumber:Main.kt$3072</ID>
    <ID>MagicNumber:Main.kt$4000L</ID>
    <ID>MagicNumber:Main.kt$5000L</ID>
    <ID>MagicNumber:Main.kt$500L</ID>
    <ID>MagicNumber:Main.kt$BenchmarkTool$10</ID>
    <ID>MagicNumber:Main.kt$BenchmarkTool$100</ID>
    <ID>MagicNumber:Main.kt$Main$600.0</ID>
    <ID>MagicNumber:Main.kt$Main$800.0</ID>
    <ID>MagicNumber:Main.kt$Node$10</ID>
    <ID>MagicNumber:Main.kt$Node$3</ID>
    <ID>MagicNumber:Main.kt$Transaction$5</ID>
    <ID>MagicNumber:MainView.kt$MainView$10.0</ID>
    <ID>MagicNumber:MainView.kt$MainView$12.0</ID>
    <ID>MagicNumber:MainView.kt$MainView$150</ID>
    <ID>MagicNumber:MainView.kt$MainView$30</ID>
    <ID>MagicNumber:MainView.kt$MainView$5.0</ID>
    <ID>MagicNumber:ManagedCryptoServiceTest.kt$ManagedCryptoServiceTest$500</ID>
    <ID>MagicNumber:MappedListTest.kt$MappedListTest$3</ID>
    <ID>MagicNumber:MappedListTest.kt$MappedListTest$5</ID>
    <ID>MagicNumber:MappedListTest.kt$MappedListTest$7</ID>
    <ID>MagicNumber:MapsSerializationTest.kt$MapsSerializationTest$10.0</ID>
    <ID>MagicNumber:MaxTransactionSizeTests.kt$MaxTransactionSizeTests$1024</ID>
    <ID>MagicNumber:MaxTransactionSizeTests.kt$MaxTransactionSizeTests$3</ID>
    <ID>MagicNumber:Measure.kt$3</ID>
    <ID>MagicNumber:MemUtils.kt$1024</ID>
    <ID>MagicNumber:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor$4</ID>
    <ID>MagicNumber:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.CONTINUOUS_RETRY$3</ID>
    <ID>MagicNumber:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.CONTINUOUS_RETRY$5</ID>
    <ID>MagicNumber:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.DEFAULT$3</ID>
    <ID>MagicNumber:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.DEFAULT$5</ID>
    <ID>MagicNumber:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.FAIL_FAST$3</ID>
    <ID>MagicNumber:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.FAIL_FAST$5</ID>
    <ID>MagicNumber:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$1024L</ID>
    <ID>MagicNumber:MockContractAttachment.kt$113</ID>
    <ID>MagicNumber:MockContractAttachment.kt$15</ID>
    <ID>MagicNumber:MockContractAttachment.kt$2</ID>
    <ID>MagicNumber:MockContractAttachment.kt$20</ID>
    <ID>MagicNumber:MockContractAttachment.kt$24</ID>
    <ID>MagicNumber:MockContractAttachment.kt$3</ID>
    <ID>MagicNumber:MockContractAttachment.kt$4</ID>
    <ID>MagicNumber:MockContractAttachment.kt$47</ID>
    <ID>MagicNumber:MockContractAttachment.kt$5</ID>
    <ID>MagicNumber:MockContractAttachment.kt$52</ID>
    <ID>MagicNumber:MockContractAttachment.kt$54</ID>
    <ID>MagicNumber:MockContractAttachment.kt$55</ID>
    <ID>MagicNumber:MockContractAttachment.kt$6</ID>
    <ID>MagicNumber:MockContractAttachment.kt$66</ID>
    <ID>MagicNumber:MockContractAttachment.kt$67</ID>
    <ID>MagicNumber:MockContractAttachment.kt$7</ID>
    <ID>MagicNumber:MockContractAttachment.kt$73</ID>
    <ID>MagicNumber:MockContractAttachment.kt$75</ID>
    <ID>MagicNumber:MockContractAttachment.kt$78</ID>
    <ID>MagicNumber:MockContractAttachment.kt$79</ID>
    <ID>MagicNumber:MockContractAttachment.kt$8</ID>
    <ID>MagicNumber:MockContractAttachment.kt$80</ID>
    <ID>MagicNumber:MockContractAttachment.kt$97</ID>
    <ID>MagicNumber:MockNetworkParametersService.kt$MockNetworkParametersStorage$20</ID>
    <ID>MagicNumber:MockServices.kt$MockServices$10000</ID>
    <ID>MagicNumber:MockServices.kt$MockServices.Companion.&lt;no name provided&gt;$512</ID>
    <ID>MagicNumber:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$23</ID>
    <ID>MagicNumber:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$4</ID>
    <ID>MagicNumber:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$42</ID>
    <ID>MagicNumber:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$42L</ID>
    <ID>MagicNumber:MultiMemberCompositeSchemaToClassCarpenterTests.kt$MultiMemberCompositeSchemaToClassCarpenterTests$5</ID>
    <ID>MagicNumber:MultiThreadedStateMachineExecutor.kt$MultiThreadedStateMachineExecutor$4</ID>
    <ID>MagicNumber:MySQLNotaryConfig.kt$MySQLNotaryConfig.Defaults$1.5</ID>
    <ID>MagicNumber:MySQLNotaryConfig.kt$MySQLNotaryConfig.Defaults$100_000</ID>
    <ID>MagicNumber:MySQLNotaryConfig.kt$MySQLNotaryConfig.Defaults$10_000</ID>
    <ID>MagicNumber:MySQLNotaryConfig.kt$MySQLNotaryConfig.Defaults$200</ID>
    <ID>MagicNumber:MySQLNotaryConfig.kt$MySQLNotaryConfig.Defaults$500</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$10</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$100</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$30</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$3600</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$5</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$50</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$60L</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests.RequestGenerationFlow$10</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests.RequestGenerationFlow$32</ID>
    <ID>MagicNumber:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests.RequestGenerationFlow$4.0</ID>
    <ID>MagicNumber:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$100</ID>
    <ID>MagicNumber:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$3</ID>
    <ID>MagicNumber:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.LogRequests$3</ID>
    <ID>MagicNumber:MySQLUniquenessProviderTest.kt$MySQLUniquenessProviderTest$32</ID>
    <ID>MagicNumber:NettyTestClient.kt$NettyTestClient$5</ID>
    <ID>MagicNumber:NettyTestHandler.kt$NettyTestHandler$5</ID>
    <ID>MagicNumber:NettyTestServer.kt$NettyTestServer$100</ID>
    <ID>MagicNumber:NettyTestServer.kt$NettyTestServer$5</ID>
    <ID>MagicNumber:Network.kt$Network$0.8</ID>
    <ID>MagicNumber:Network.kt$Network$1.2</ID>
    <ID>MagicNumber:Network.kt$Network$10</ID>
    <ID>MagicNumber:Network.kt$Network$10.0</ID>
    <ID>MagicNumber:Network.kt$Network$15.0</ID>
    <ID>MagicNumber:Network.kt$Network$180.0</ID>
    <ID>MagicNumber:Network.kt$Network$2.5</ID>
    <ID>MagicNumber:Network.kt$Network$2000.0</ID>
    <ID>MagicNumber:Network.kt$Network$3.0</ID>
    <ID>MagicNumber:Network.kt$Network$300.0</ID>
    <ID>MagicNumber:Network.kt$Network$4</ID>
    <ID>MagicNumber:Network.kt$Network$5.0</ID>
    <ID>MagicNumber:Network.kt$Network$500.0</ID>
    <ID>MagicNumber:Network.kt$Network$6.0</ID>
    <ID>MagicNumber:Network.kt$Network$85.0511</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper$3</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper$30</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$3</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$40</ID>
    <ID>MagicNumber:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$5</ID>
    <ID>MagicNumber:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$7</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$10000</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$20000</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$30</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$7</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$70</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$80</ID>
    <ID>MagicNumber:NetworkBootstrapperTest.kt$NetworkBootstrapperTest.Companion$128</ID>
    <ID>MagicNumber:NetworkHostAndPort.kt$NetworkHostAndPort$0xffff</ID>
    <ID>MagicNumber:NetworkHostAndPortTest.kt$NetworkHostAndPortTest$1234</ID>
    <ID>MagicNumber:NetworkHostAndPortTest.kt$NetworkHostAndPortTest$65535</ID>
    <ID>MagicNumber:NetworkHostAndPortTest.kt$NetworkHostAndPortTest$65536</ID>
    <ID>MagicNumber:NetworkMap.kt$NetworkMap$10</ID>
    <ID>MagicNumber:NetworkMapCacheTest.kt$NetworkMapCacheTest$24012017L</ID>
    <ID>MagicNumber:NetworkMapClientTest.kt$NetworkMapClientTest$100000</ID>
    <ID>MagicNumber:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$100000</ID>
    <ID>MagicNumber:NetworkMapServer.kt$NetworkMapServer$500</ID>
    <ID>MagicNumber:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$100000</ID>
    <ID>MagicNumber:NetworkMapTest.kt$NetworkMapTest$2000</ID>
    <ID>MagicNumber:NetworkMapTest.kt$NetworkMapTest$5</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$24</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$4</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$50</ID>
    <ID>MagicNumber:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$10</ID>
    <ID>MagicNumber:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$1000</ID>
    <ID>MagicNumber:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$4</ID>
    <ID>MagicNumber:NetworkParametersReaderTest.kt$NetworkParametersReaderTest$100000</ID>
    <ID>MagicNumber:NetworkParametersTest.kt$NetworkParametersTest$100</ID>
    <ID>MagicNumber:NetworkParametersTest.kt$NetworkParametersTest$2000</ID>
    <ID>MagicNumber:NetworkParametersTest.kt$NetworkParametersTest$2001</ID>
    <ID>MagicNumber:NetworkParametersTest.kt$NetworkParametersTest$500</ID>
    <ID>MagicNumber:NetworkProxyTests.kt$NetworkProxyTests$1234</ID>
    <ID>MagicNumber:NetworkProxyTests.kt$NetworkProxyTests$5678</ID>
    <ID>MagicNumber:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$10</ID>
    <ID>MagicNumber:NetworkRegistrationHelper.kt$NodeRegistrationHelper$10</ID>
    <ID>MagicNumber:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$4</ID>
    <ID>MagicNumber:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$5</ID>
    <ID>MagicNumber:NetworkStatusCollector.kt$NetworkStatusCollector$5</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$10.0</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$16</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$20.0</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$40.0</ID>
    <ID>MagicNumber:Node.kt$Node$1000L</ID>
    <ID>MagicNumber:Node.kt$Node$128</ID>
    <ID>MagicNumber:Node.kt$Node$256</ID>
    <ID>MagicNumber:Node.kt$Node$4</ID>
    <ID>MagicNumber:Node.kt$Node$60000L</ID>
    <ID>MagicNumber:Node.kt$Node.Companion$171</ID>
    <ID>MagicNumber:Node.kt$Node.Companion$40</ID>
    <ID>MagicNumber:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$10</ID>
    <ID>MagicNumber:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$3</ID>
    <ID>MagicNumber:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$4</ID>
    <ID>MagicNumber:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$6</ID>
    <ID>MagicNumber:NodeCmdLineOptions.kt$NodeCmdLineOptions$2222</ID>
    <ID>MagicNumber:NodeConfigTest.kt$NodeConfigTest$10001</ID>
    <ID>MagicNumber:NodeConfigTest.kt$NodeConfigTest$20001</ID>
    <ID>MagicNumber:NodeConfigTest.kt$NodeConfigTest$40002</ID>
    <ID>MagicNumber:NodeConfiguration.kt$1024L</ID>
    <ID>MagicNumber:NodeConfiguration.kt$GraphiteOptions.Defaults$60</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration$5</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration.Companion$20</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration.Companion$300</ID>
    <ID>MagicNumber:NodeConfiguration.kt$RelayConfiguration.Defaults$22</ID>
    <ID>MagicNumber:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$5</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$1234</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$20000</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$3</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$4</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$40000</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$5</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$6</ID>
    <ID>MagicNumber:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$8080</ID>
    <ID>MagicNumber:NodeControllerTest.kt$NodeControllerTest$1234</ID>
    <ID>MagicNumber:NodeControllerTest.kt$NodeControllerTest$2356</ID>
    <ID>MagicNumber:NodeControllerTest.kt$NodeControllerTest$3478</ID>
    <ID>MagicNumber:NodeControllerTest.kt$NodeControllerTest$7777</ID>
    <ID>MagicNumber:NodeInfo.kt$NodeInfoSigner$4</ID>
    <ID>MagicNumber:NodeInfoTests.kt$NodeInfoTests$10000</ID>
    <ID>MagicNumber:NodeInfoWatcher.kt$NodeInfoWatcher$5</ID>
    <ID>MagicNumber:NodeInfoWatcherTest.kt$NodeInfoWatcherTest$5</ID>
    <ID>MagicNumber:NodeInterestRatesTest.kt$NodeInterestRatesTest$0.0000001</ID>
    <ID>MagicNumber:NodeInterestRatesTest.kt$NodeInterestRatesTest$0.7316228</ID>
    <ID>MagicNumber:NodeInterestRatesTest.kt$NodeInterestRatesTest$1000</ID>
    <ID>MagicNumber:NodeNamedCache.kt$DefaultNamedCacheFactory$1024L</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$0.000001</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$0.001</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$10000</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$2000L</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$300L</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$5</ID>
    <ID>MagicNumber:NodePerformanceTests.kt$NodePerformanceTests$50L</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess$60</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess.Factory$120</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess.Factory$5</ID>
    <ID>MagicNumber:NodeRPC.kt$NodeRPC$5</ID>
    <ID>MagicNumber:NodeRestartTests.kt$NodeRestartTests$123</ID>
    <ID>MagicNumber:NodeRestartTests.kt$NodeRestartTests.Responder$123</ID>
    <ID>MagicNumber:NodeSchedulerService.kt$NodeSchedulerService$60</ID>
    <ID>MagicNumber:NodeSchedulerServiceTest.kt$NodeSchedulerPersistenceTest$5</ID>
    <ID>MagicNumber:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTest$5</ID>
    <ID>MagicNumber:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTestBase$5</ID>
    <ID>MagicNumber:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTestBase$5000</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$10</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$100.0</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$1000</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$20</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$7</ID>
    <ID>MagicNumber:NodeStartupPerformanceTests.kt$NodeStartupPerformanceTests$10</ID>
    <ID>MagicNumber:NodeStartupPerformanceTests.kt$NodeStartupPerformanceTests$1_000_000.0</ID>
    <ID>MagicNumber:NodeTabView.kt$NodeTabView$24.0</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$160</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$2.5</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$80</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView.TerminalSettingsProvider$50</ID>
    <ID>MagicNumber:NodeTest.kt$NodeTest$10</ID>
    <ID>MagicNumber:NodeTest.kt$NodeTest$202</ID>
    <ID>MagicNumber:NodeTest.kt$NodeTest$456</ID>
    <ID>MagicNumber:NodeTest.kt$NodeTest$789</ID>
    <ID>MagicNumber:NodeUnloadHandlerTests.kt$NodeUnloadHandlerTests$30</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$10</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$100</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$1000</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$100L</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$110</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$20</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$200</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$3</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$30</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$32</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$4</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$5</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$6</ID>
    <ID>MagicNumber:NodeVaultServiceTest.kt$NodeVaultServiceTest$7</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$100</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$32768</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$40</ID>
    <ID>MagicNumber:NonEmptySetTest.kt$NonEmptySetTest.General$17</ID>
    <ID>MagicNumber:NonEmptySetTest.kt$NonEmptySetTest.General$22</ID>
    <ID>MagicNumber:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$4</ID>
    <ID>MagicNumber:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$30</ID>
    <ID>MagicNumber:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$3600</ID>
    <ID>MagicNumber:Notarise.kt$10</ID>
    <ID>MagicNumber:Notarise.kt$10003</ID>
    <ID>MagicNumber:NotaryChangeTests.kt$30</ID>
    <ID>MagicNumber:NotaryFunctionalSamplers.kt$NotariseDoubleSpendSampler$2_000_000</ID>
    <ID>MagicNumber:NotaryFunctionalSamplers.kt$NotariseDuplicateTransactionSampler$2_000_000</ID>
    <ID>MagicNumber:NotaryServiceTests.kt$NotaryServiceTests$13</ID>
    <ID>MagicNumber:NotaryWhitelistTests.kt$NotaryWhitelistTests$30</ID>
    <ID>MagicNumber:NotaryWhitelistTests.kt$NotaryWhitelistTests$4</ID>
    <ID>MagicNumber:NullKeys.kt$NullKeys$32</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$0.015</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$100000000.0</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$12</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2014</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2015</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2021</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$21</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$7</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$9</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.001</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.00123</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.0025</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.0091</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.01</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.015</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.03</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$100000000.0</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$12</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$17</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2013</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2014</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2016</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2020</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2021</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2024</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$22</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$24</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$27</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$3</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$4</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$5</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$6</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$61600000.0</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$7</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$8</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$9</ID>
    <ID>MagicNumber:OGUtils.kt$0.001</ID>
    <ID>MagicNumber:ObjectDiffer.kt$ObjectDiffer$3</ID>
    <ID>MagicNumber:ObjectDiffer.kt$ObjectDiffer$4</ID>
    <ID>MagicNumber:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$3</ID>
    <ID>MagicNumber:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$4</ID>
    <ID>MagicNumber:OptInLogCollector.kt$OptInLogCollector$24</ID>
    <ID>MagicNumber:OptInLogCollector.kt$OptInLogCollector$3</ID>
    <ID>MagicNumber:OptInLogCollector.kt$OptInLogCollector$60</ID>
    <ID>MagicNumber:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$1000</ID>
    <ID>MagicNumber:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$20</ID>
    <ID>MagicNumber:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$70</ID>
    <ID>MagicNumber:OracleUtils.kt$11</ID>
    <ID>MagicNumber:OracleUtils.kt$24</ID>
    <ID>MagicNumber:OracleUtils.kt$45</ID>
    <ID>MagicNumber:OrdinalIO.kt$OrdinalBits$128</ID>
    <ID>MagicNumber:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$10</ID>
    <ID>MagicNumber:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$5</ID>
    <ID>MagicNumber:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest$10</ID>
    <ID>MagicNumber:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest$100</ID>
    <ID>MagicNumber:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest$50</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingClient$30000</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingClient$60000</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingConsumer$10</ID>
    <ID>MagicNumber:P2PMessagingTest.kt$P2PMessagingTest$10</ID>
    <ID>MagicNumber:P2PMessagingTest.kt$P2PMessagingTest$3</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$0.02</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$0.8</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$10</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$20</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$23L</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$5</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$50</ID>
    <ID>MagicNumber:ParametersUtilities.kt$30</ID>
    <ID>MagicNumber:ParametersUtilities.kt$50</ID>
    <ID>MagicNumber:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$1000</ID>
    <ID>MagicNumber:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$19</ID>
    <ID>MagicNumber:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$3</ID>
    <ID>MagicNumber:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$4</ID>
    <ID>MagicNumber:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$5</ID>
    <ID>MagicNumber:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$900</ID>
    <ID>MagicNumber:PartyAndCertificateTest.kt$PartyAndCertificateTest$83</ID>
    <ID>MagicNumber:PartyTest.kt$PartyTest$20170207L</ID>
    <ID>MagicNumber:PartyTest.kt$PartyTest$7201702L</ID>
    <ID>MagicNumber:Password.kt$Password$5</ID>
    <ID>MagicNumber:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$1000</ID>
    <ID>MagicNumber:PersistentScheduledFlowRepositoryTest.kt$PersistentScheduledFlowRepositoryTest$5</ID>
    <ID>MagicNumber:PersistentTypes.kt$MappedSchema$31</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$180</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$180.0</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$360.0</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$4</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$90</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$10</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$1000</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$50_000</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$512</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$60_000</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$8</ID>
    <ID>MagicNumber:PortAllocationTest.kt$PortAllocationTest$8_000</ID>
    <ID>MagicNumber:PortfolioApi.kt$PortfolioApi$2016</ID>
    <ID>MagicNumber:PortfolioApi.kt$PortfolioApi$6</ID>
    <ID>MagicNumber:PrioritizedLeaderLatchTest.kt$PrioritizedLeaderLatchTest$100</ID>
    <ID>MagicNumber:PrivacySaltTest.kt$PrivacySaltTest$0x14</ID>
    <ID>MagicNumber:PrivacySaltTest.kt$PrivacySaltTest$0x7f</ID>
    <ID>MagicNumber:PrivacySaltTest.kt$PrivacySaltTest$32</ID>
    <ID>MagicNumber:PrivatePropertyTests.kt$PrivatePropertyTests$1010101</ID>
    <ID>MagicNumber:PrivatePropertyTests.kt$PrivatePropertyTests$33</ID>
    <ID>MagicNumber:PrivatePropertyTests.kt$PrivatePropertyTests$44</ID>
    <ID>MagicNumber:ProcessUtilitiesTests.kt$ProcessUtilitiesTests$20</ID>
    <ID>MagicNumber:ProfileController.kt$ProfileController$3</ID>
    <ID>MagicNumber:Program.kt$1000</ID>
    <ID>MagicNumber:Program.kt$1024</ID>
    <ID>MagicNumber:Program.kt$2000</ID>
    <ID>MagicNumber:Program.kt$5</ID>
    <ID>MagicNumber:Program.kt$8</ID>
    <ID>MagicNumber:Program.kt$ConfigObfuscatorCli$0xFF</ID>
    <ID>MagicNumber:Program.kt$ConfigObfuscatorCli$16</ID>
    <ID>MagicNumber:ProgressTracker.kt$ProgressTracker.Step$31</ID>
    <ID>MagicNumber:ProgressTrackerTest.kt$ProgressTrackerTest$10</ID>
    <ID>MagicNumber:ProgressTrackerTest.kt$ProgressTrackerTest$3</ID>
    <ID>MagicNumber:ProgressTrackerTest.kt$ProgressTrackerTest$4</ID>
    <ID>MagicNumber:ProgressTrackerTest.kt$ProgressTrackerTest$5</ID>
    <ID>MagicNumber:ProgressTrackerTest.kt$ProgressTrackerTest$6</ID>
    <ID>MagicNumber:ProgressTrackerTest.kt$ProgressTrackerTest$7</ID>
    <ID>MagicNumber:PropertyTest.kt$PropertyTest$23L</ID>
    <ID>MagicNumber:PropertyTest.kt$PropertyTest$3L</ID>
    <ID>MagicNumber:PropertyValidationTest.kt$PropertyValidationTest$1.2</ID>
    <ID>MagicNumber:PropertyValidationTest.kt$PropertyValidationTest$3</ID>
    <ID>MagicNumber:PropertyValidationTest.kt$PropertyValidationTest$3L</ID>
    <ID>MagicNumber:PropertyValidationTest.kt$PropertyValidationTest$8080</ID>
    <ID>MagicNumber:ProtonWrapperTests.kt$ProtonWrapperTests$1000</ID>
    <ID>MagicNumber:ProtonWrapperTests.kt$ProtonWrapperTests$100_000</ID>
    <ID>MagicNumber:ProtonWrapperTests.kt$ProtonWrapperTests$20000</ID>
    <ID>MagicNumber:ProtonWrapperTests.kt$ProtonWrapperTests$40000</ID>
    <ID>MagicNumber:PublicKeyToOwningIdentityCacheImplTest.kt$PublicKeyToOwningIdentityCacheImplTest$20</ID>
    <ID>MagicNumber:PublicKeyToOwningIdentityCacheImplTest.kt$PublicKeyToOwningIdentityCacheImplTest$5</ID>
    <ID>MagicNumber:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$20</ID>
    <ID>MagicNumber:R3Pty.kt$R3Pty$30</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$30000</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$60000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$1000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$16384</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$31</ID>
    <ID>MagicNumber:RPCConcurrencyTests.kt$RPCConcurrencyTests$10</ID>
    <ID>MagicNumber:RPCConcurrencyTests.kt$RPCConcurrencyTests$100</ID>
    <ID>MagicNumber:RPCConcurrencyTests.kt$RPCConcurrencyTests$3</ID>
    <ID>MagicNumber:RPCConcurrencyTests.kt$RPCConcurrencyTests$6</ID>
    <ID>MagicNumber:RPCConcurrencyTests.kt$RPCConcurrencyTests.TestOpsImpl$1000</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$10L</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$5</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$5L</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL.Companion$10</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$100</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$3</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$4</ID>
    <ID>MagicNumber:RPCFailureTests.kt$RPCFailureTests.OpsImpl$1000</ID>
    <ID>MagicNumber:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests$10</ID>
    <ID>MagicNumber:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests$3</ID>
    <ID>MagicNumber:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests$4</ID>
    <ID>MagicNumber:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests.TestOpsImpl$1000</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$100</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$1000</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$1000.0</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$10000</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$1000000.0</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$1024</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$1024.0</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$1024L</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$10_000_000</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$20000L</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$4</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$4096</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$5</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests$512</ID>
    <ID>MagicNumber:RPCPerformanceTests.kt$RPCPerformanceTests.TestOpsImpl$1000</ID>
    <ID>MagicNumber:RPCPermissionsTests.kt$RPCPermissionsTests.TestOpsImpl$1000</ID>
    <ID>MagicNumber:RPCProxyServer.kt$13000</ID>
    <ID>MagicNumber:RPCProxyServerTest.kt$RPCProxyServerTest$12000</ID>
    <ID>MagicNumber:RPCProxyServerTest.kt$RPCProxyServerTest$13000</ID>
    <ID>MagicNumber:RPCProxyWebService.kt$RPCProxyWebService$10</ID>
    <ID>MagicNumber:RPCProxyWebService.kt$RPCProxyWebService$1000</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$100</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$1000</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$125</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$13002</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$13007</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$13012</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$250</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$4</ID>
    <ID>MagicNumber:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$500</ID>
    <ID>MagicNumber:RPCServer.kt$RPCServer$5</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$10</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$100</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$1000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$1024</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$1234</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$12345</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$200</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$250</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$4</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$5</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$500</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$5000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$54321</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests$9999</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests.&lt;no name provided&gt;$1000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests.DummyOps$1000</ID>
    <ID>MagicNumber:RPCStabilityTests.kt$RPCStabilityTests.SlowConsumerRPCOpsImpl$1000</ID>
    <ID>MagicNumber:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$30</ID>
    <ID>MagicNumber:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$1024</ID>
    <ID>MagicNumber:RandomFailingProxy.kt$RandomFailingProxy$2000</ID>
    <ID>MagicNumber:RandomFailingProxy.kt$RandomFailingProxy$700</ID>
    <ID>MagicNumber:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$10.0</ID>
    <ID>MagicNumber:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$5.0</ID>
    <ID>MagicNumber:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$6.0</ID>
    <ID>MagicNumber:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$100</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$4</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$1000</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$10</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$9</ID>
    <ID>MagicNumber:ReferenceInputStateTests.kt$ReferenceStateTests$1000</ID>
    <ID>MagicNumber:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$3</ID>
    <ID>MagicNumber:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$4</ID>
    <ID>MagicNumber:RegistrationServer.kt$RegistrationServer$10</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$12</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$1234</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$3</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$34</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$4</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$4321</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$5</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$56</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$6</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$78</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$8765</ID>
    <ID>MagicNumber:ReplayedListTest.kt$ReplayedListTest$910</ID>
    <ID>MagicNumber:ResolveStatePointersTest.kt$ResolveStatePointersTest$20</ID>
    <ID>MagicNumber:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$4</ID>
    <ID>MagicNumber:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$2500</ID>
    <ID>MagicNumber:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$4</ID>
    <ID>MagicNumber:RetryFlowMockTest.kt$RetryFlowMockTest$100</ID>
    <ID>MagicNumber:RetryFlowMockTest.kt$RetryFlowMockTest$10000</ID>
    <ID>MagicNumber:RetryFlowMockTest.kt$RetryFlowMockTest$30</ID>
    <ID>MagicNumber:RetryFlowMockTest.kt$RetryFlowMockTest$5</ID>
    <ID>MagicNumber:RigorousMockTest.kt$RigorousMockTest$4</ID>
    <ID>MagicNumber:RigorousMockTest.kt$RigorousMockTest$5</ID>
    <ID>MagicNumber:RigorousMockTest.kt$RigorousMockTest$6</ID>
    <ID>MagicNumber:RigorousMockTest.kt$RigorousMockTest$7</ID>
    <ID>MagicNumber:RollOutTests.kt$RollOutTests$10</ID>
    <ID>MagicNumber:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$100</ID>
    <ID>MagicNumber:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$128</ID>
    <ID>MagicNumber:RoundTripTests.kt$RoundTripTests$4</ID>
    <ID>MagicNumber:RoundTripTests.kt$RoundTripTests$83</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$2000</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$5L</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$8</ID>
    <ID>MagicNumber:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$123L</ID>
    <ID>MagicNumber:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$120</ID>
    <ID>MagicNumber:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$3</ID>
    <ID>MagicNumber:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$5</ID>
    <ID>MagicNumber:RpcHelper.kt$5</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$10</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$100</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$1000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$10000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$12000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$2000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$250</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$3</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$4</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$4000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$5</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$50</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$5000</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$6</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$7</ID>
    <ID>MagicNumber:RpcReconnectTests.kt$RpcReconnectTests$8000</ID>
    <ID>MagicNumber:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$100</ID>
    <ID>MagicNumber:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$11</ID>
    <ID>MagicNumber:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$3</ID>
    <ID>MagicNumber:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$6</ID>
    <ID>MagicNumber:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$8</ID>
    <ID>MagicNumber:RpcWorkerPaidTest.kt$RpcWorkerPaidTest$10</ID>
    <ID>MagicNumber:RpcWorkerPaidTest.kt$RpcWorkerPaidTest$10000</ID>
    <ID>MagicNumber:RpcWorkerPaidTest.kt$RpcWorkerPaidTest$8</ID>
    <ID>MagicNumber:RpcWorkerStartStopTest.kt$RpcWorkerStartStopTest$10</ID>
    <ID>MagicNumber:RpcWorkerTest.kt$RpcWorkerTest$10</ID>
    <ID>MagicNumber:RunOnceServiceTest.kt$RunOnceServiceTest$20000000000000000</ID>
    <ID>MagicNumber:RunOnceServiceTest.kt$RunOnceServiceTest$3</ID>
    <ID>MagicNumber:SNIBridgeTest.kt$SNIBridgeTest$5</ID>
    <ID>MagicNumber:SSHDConfiguration.kt$SSHDConfiguration$0xffff</ID>
    <ID>MagicNumber:SSHServerTest.kt$SSHServerTest$2222</ID>
    <ID>MagicNumber:SSHServerTest.kt$SSHServerTest$5000</ID>
    <ID>MagicNumber:SSLHelper.kt$32</ID>
    <ID>MagicNumber:SSLHelperTest.kt$SSLHelperTest$1234</ID>
    <ID>MagicNumber:SSLHelperTest.kt$SSLHelperTest$32</ID>
    <ID>MagicNumber:Samplers.kt$CashIssueAndPaySampler$2_000_000</ID>
    <ID>MagicNumber:Samplers.kt$CashIssueSampler$1_100_000_000_000</ID>
    <ID>MagicNumber:Samplers.kt$CashPaySampler$1_000_000_000</ID>
    <ID>MagicNumber:Samplers.kt$TxResolutionSampler$1000</ID>
    <ID>MagicNumber:Samplers.kt$TxResolutionSampler$1_000_000_000</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$10</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$100</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$20</ID>
    <ID>MagicNumber:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$23</ID>
    <ID>MagicNumber:ScheduledFlowTests.kt$ScheduledFlowTests$99</ID>
    <ID>MagicNumber:ScheduledFlowsDrainingModeTest.kt$ScheduledFlowsDrainingModeTest$5</ID>
    <ID>MagicNumber:Schema.kt$CompositeType.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$CompositeType.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$Descriptor$0xffff</ID>
    <ID>MagicNumber:Schema.kt$Descriptor$32</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$5</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$6</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$5</ID>
    <ID>MagicNumber:SchemaMigrationTest.kt$SchemaMigrationTest$70</ID>
    <ID>MagicNumber:SchemaTest.kt$SchemaTest$17.3</ID>
    <ID>MagicNumber:SchemaTest.kt$SchemaTest$3L</ID>
    <ID>MagicNumber:SchemaTest.kt$SchemaTest$44444</ID>
    <ID>MagicNumber:SearchField.kt$SearchField$10</ID>
    <ID>MagicNumber:SearchField.kt$SearchField$5.0</ID>
    <ID>MagicNumber:SecureArtemisConfiguration.kt$SecureArtemisConfiguration$128</ID>
    <ID>MagicNumber:SecureArtemisConfiguration.kt$SecureArtemisConfiguration$16</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.Companion$32</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.SHA256$32</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x03</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x1e</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x32</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x3a</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x3c</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x42</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x47</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x56</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x63</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x64</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x7d</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0x7f</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$0xFF</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$32</ID>
    <ID>MagicNumber:SecureHashTest.kt$SecureHashTest$8</ID>
    <ID>MagicNumber:SecureRandomTest.kt$SecureRandomTest$10</ID>
    <ID>MagicNumber:SecureRandomTest.kt$SecureRandomTest$100</ID>
    <ID>MagicNumber:SecureRandomTest.kt$SecureRandomTest$1000</ID>
    <ID>MagicNumber:SelfIssueTest.kt$1000</ID>
    <ID>MagicNumber:SerDeserCarpentryTest.kt$SerDeserCarpentryTest$123</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$.03</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$.5</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$0x03</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$10</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$10.0</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$10.0F</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$100</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$1000000L</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$1018</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$12</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$123</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$12345</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$16</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$20000</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$20059</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$3</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$32</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$4</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$456</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$5</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$97</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$98</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests$99</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests.C$4</ID>
    <ID>MagicNumber:SerializationOutputTests.kt$SerializationOutputTests.C.D$4</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$100</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$200</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$3</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$300</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$4</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$400</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$5</ID>
    <ID>MagicNumber:SerializationPropertyOrdering.kt$SerializationPropertyOrdering$500</ID>
    <ID>MagicNumber:SerializationTokenTest.kt$SerializationTokenTest.LargeTokenizable$1024</ID>
    <ID>MagicNumber:ServiceHubConcurrentUsageTest.kt$ServiceHubConcurrentUsageTest.TestFlow$10</ID>
    <ID>MagicNumber:SharedMemoryIncremental.kt$SharedMemoryIncremental$16</ID>
    <ID>MagicNumber:ShutdownManager.kt$ShutdownManager$5</ID>
    <ID>MagicNumber:ShutdownManager.kt$ShutdownManager$60</ID>
    <ID>MagicNumber:SignedNodeInfoTest.kt$SignedNodeInfoTest$1234</ID>
    <ID>MagicNumber:SimmFlow.kt$100</ID>
    <ID>MagicNumber:SimmFlow.kt$1e-9</ID>
    <ID>MagicNumber:SimmValuationTest.kt$SimmValuationTest$0.1</ID>
    <ID>MagicNumber:SimmValuationTest.kt$SimmValuationTest$1000</ID>
    <ID>MagicNumber:SocksTests.kt$SocksTests$20000</ID>
    <ID>MagicNumber:SocksTests.kt$SocksTests$40000</ID>
    <ID>MagicNumber:SpecificationTest.kt$SpecificationTest$10L</ID>
    <ID>MagicNumber:SpecificationTest.kt$SpecificationTest$8080</ID>
    <ID>MagicNumber:SpecificationTest.kt$SpecificationTest$8081</ID>
    <ID>MagicNumber:SpringDriver.kt$SpringBootDriverDSL$10</ID>
    <ID>MagicNumber:SpringDriver.kt$SpringBootDriverDSL$30</ID>
    <ID>MagicNumber:SpringDriver.kt$SpringBootDriverDSL$5</ID>
    <ID>MagicNumber:Ssh.kt$Ssh.Companion$22</ID>
    <ID>MagicNumber:StabilityTest.kt$StabilityTest$100000</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital$1.5</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital$10</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital.DuplicateInsertSpecialist$3</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$10</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$100</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$127</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$3</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$429</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$513</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$629</ID>
    <ID>MagicNumber:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$83</ID>
    <ID>MagicNumber:StandaloneJPANotaryConfig.kt$StandaloneJPANotaryConfig.Defaults$1.5</ID>
    <ID>MagicNumber:StandaloneJPANotaryConfig.kt$StandaloneJPANotaryConfig.Defaults$10</ID>
    <ID>MagicNumber:StandaloneJPANotaryConfig.kt$StandaloneJPANotaryConfig.Defaults$100_000</ID>
    <ID>MagicNumber:StandaloneJPANotaryConfig.kt$StandaloneJPANotaryConfig.Defaults$10_000</ID>
    <ID>MagicNumber:StandaloneJPANotaryConfig.kt$StandaloneJPANotaryConfig.Defaults$200</ID>
    <ID>MagicNumber:StandaloneJPANotaryConfig.kt$StandaloneJPANotaryConfig.Defaults$500</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$100</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$16</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider.Companion$16</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider.Companion$64</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider.Companion$65</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$10</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$30</ID>
    <ID>MagicNumber:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$60L</ID>
    <ID>MagicNumber:StandaloneShell.kt$StandaloneShell$7</ID>
    <ID>MagicNumber:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$1234</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$100.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$15.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$150.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$200.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$26.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$30</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer$30.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer.StateMachineWidget$10.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer.StateMachineWidget$30.0</ID>
    <ID>MagicNumber:StateMachineViewer.kt$StateMachineViewer.StateMachineWidget$5.0</ID>
    <ID>MagicNumber:StatePointerSearchTests.kt$StatePointerSearchTests$100L</ID>
    <ID>MagicNumber:StateRevisionFlow.kt$StateRevisionFlow.Requester$30</ID>
    <ID>MagicNumber:StreamTests.kt$StreamTests$2116</ID>
    <ID>MagicNumber:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$101</ID>
    <ID>MagicNumber:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$12</ID>
    <ID>MagicNumber:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$3</ID>
    <ID>MagicNumber:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$3L</ID>
    <ID>MagicNumber:Structures.kt$PrivacySalt$32</ID>
    <ID>MagicNumber:StructuresTests.kt$AttachmentTest$512</ID>
    <ID>MagicNumber:StructuresTests.kt$AttachmentTest.&lt;no name provided&gt;$512</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$0.013</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$0.015</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$100</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$100000000.0</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$1e-9</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$200000000.0</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$2016</ID>
    <ID>MagicNumber:SwapExample.kt$SwapExample$6</ID>
    <ID>MagicNumber:Swaption.kt$Swaption$0.5</ID>
    <ID>MagicNumber:Swaption.kt$Swaption$2016</ID>
    <ID>MagicNumber:Swaption.kt$Swaption$50</ID>
    <ID>MagicNumber:Swaption.kt$Swaption$9</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest$100</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest$4</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest$5</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest$6</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest$7</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$3</ID>
    <ID>MagicNumber:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$4</ID>
    <ID>MagicNumber:TLSAuthenticationTests.kt$TLSAuthenticationTests$1000</ID>
    <ID>MagicNumber:TLSAuthenticationTests.kt$TLSAuthenticationTests$30</ID>
    <ID>MagicNumber:TagExtractor.kt$TagExtractor$4</ID>
    <ID>MagicNumber:TagExtractor.kt$TagExtractor$5</ID>
    <ID>MagicNumber:TargetVersionDependentRules.kt$StateContractValidationEnforcementRule$4</ID>
    <ID>MagicNumber:TendermintAdapter.kt$TendermintStateMachine$8</ID>
    <ID>MagicNumber:TendermintClient.kt$TendermintClient$100</ID>
    <ID>MagicNumber:TendermintClient.kt$TendermintClient$1000L</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$10</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$1000</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$12345</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$12346</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$12347</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$12348</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$3</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$4</ID>
    <ID>MagicNumber:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$5</ID>
    <ID>MagicNumber:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$12</ID>
    <ID>MagicNumber:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$3</ID>
    <ID>MagicNumber:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$70</ID>
    <ID>MagicNumber:TestConfig.kt$TestConfig$100</ID>
    <ID>MagicNumber:TestConfig.kt$TestConfig$120</ID>
    <ID>MagicNumber:TestConfig.kt$TestConfig$12345</ID>
    <ID>MagicNumber:TestConfig.kt$TestConfig$300</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$10</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$1051</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$12</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$22</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$25</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$41</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$485</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$5</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$54</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$723743</ID>
    <ID>MagicNumber:TestHelpers.kt$TestHelpers$83</ID>
    <ID>MagicNumber:TestIdentityTests.kt$TestIdentityTests$123</ID>
    <ID>MagicNumber:TestLauncherHelpers.kt$TestLauncherHelpers$10101</ID>
    <ID>MagicNumber:TestLauncherHelpers.kt$TestLauncherHelpers$21011</ID>
    <ID>MagicNumber:TestLauncherHelpers.kt$TestLauncherHelpers$5150</ID>
    <ID>MagicNumber:TestNettyTestInfra.kt$TestNettyTestInfra$56234</ID>
    <ID>MagicNumber:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$1234</ID>
    <ID>MagicNumber:TestNotaryTypes.kt$TestNotaryTypes$100</ID>
    <ID>MagicNumber:TestNotaryTypes.kt$TestNotaryTypes$3</ID>
    <ID>MagicNumber:TestNotaryTypes.kt$TestNotaryTypes$4</ID>
    <ID>MagicNumber:TestNotaryTypes.kt$TestNotaryTypes$5</ID>
    <ID>MagicNumber:TestNotaryTypes.kt$TestNotaryTypes$7</ID>
    <ID>MagicNumber:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$4</ID>
    <ID>MagicNumber:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$5</ID>
    <ID>MagicNumber:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$6</ID>
    <ID>MagicNumber:TestUtils.kt$10000</ID>
    <ID>MagicNumber:TestUtils.kt$30000</ID>
    <ID>MagicNumber:Tests.kt$TestSource$2000</ID>
    <ID>MagicNumber:Tests.kt$TestSource$5</ID>
    <ID>MagicNumber:TimeWindowTest.kt$TimeWindowTest$10</ID>
    <ID>MagicNumber:TimeWindowTest.kt$TimeWindowTest$12</ID>
    <ID>MagicNumber:TimeWindowTest.kt$TimeWindowTest$15</ID>
    <ID>MagicNumber:TimeWindowTest.kt$TimeWindowTest$30</ID>
    <ID>MagicNumber:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests$3</ID>
    <ID>MagicNumber:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests$5</ID>
    <ID>MagicNumber:TimedFlowTests.kt$TimedFlowTestRule$10</ID>
    <ID>MagicNumber:TimedFlowTests.kt$TimedFlowTestRule$3</ID>
    <ID>MagicNumber:TimedFlowTests.kt$TimedFlowTests$10</ID>
    <ID>MagicNumber:TimedFlowTests.kt$TimedFlowTests$3</ID>
    <ID>MagicNumber:TimedFlowTests.kt$TimedFlowTests$30</ID>
    <ID>MagicNumber:Timestamp.kt$Timestamp$1000</ID>
    <ID>MagicNumber:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$10</ID>
    <ID>MagicNumber:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$1000</ID>
    <ID>MagicNumber:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$10</ID>
    <ID>MagicNumber:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$1000</ID>
    <ID>MagicNumber:TracingCacheWrapper.kt$CacheTracing.TraceCollector$10</ID>
    <ID>MagicNumber:TracingCacheWrapper.kt$CacheTracing.TraceCollector$100</ID>
    <ID>MagicNumber:TrackedCollector.kt$TrackedCollector$1500</ID>
    <ID>MagicNumber:TrackedCollector.kt$TrackedCollector$500</ID>
    <ID>MagicNumber:TrackedConsoleTask.kt$TrackedConsoleTask$150</ID>
    <ID>MagicNumber:TrackedConsoleTask.kt$TrackedConsoleTask$3</ID>
    <ID>MagicNumber:TraderDemo.kt$TraderDemo$1_000_000_000_000</ID>
    <ID>MagicNumber:TraderDemo.kt$TraderDemo$1_100_000_000_000</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$10</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$1000.0</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$3</ID>
    <ID>MagicNumber:TraderDemoTest.kt$TraderDemoTest$100</ID>
    <ID>MagicNumber:TraderDemoTest.kt$TraderDemoTest$5</ID>
    <ID>MagicNumber:TraderDemoTest.kt$TraderDemoTest$95</ID>
    <ID>MagicNumber:TransactionBuilder.kt$TransactionBuilder$4</ID>
    <ID>MagicNumber:TransactionDSLInterpreter.kt$TransactionDSL$30</ID>
    <ID>MagicNumber:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$3</ID>
    <ID>MagicNumber:TransactionGenerator.kt$TransactionGenerator$10</ID>
    <ID>MagicNumber:TransactionGenerator.kt$TransactionGenerator$1000</ID>
    <ID>MagicNumber:TransactionGenerator.kt$TransactionGenerator$20</ID>
    <ID>MagicNumber:TransactionGenerator.kt$TransactionGenerator$2000</ID>
    <ID>MagicNumber:TransactionGenerator.kt$TransactionGenerator$3000</ID>
    <ID>MagicNumber:TransactionOrderingTests.kt$TransactionOrderingTests$3</ID>
    <ID>MagicNumber:TransactionSerializationTests.kt$TransactionSerializationTests$100</ID>
    <ID>MagicNumber:TransactionSerializationTests.kt$TransactionSerializationTests$30</ID>
    <ID>MagicNumber:TransactionSerializationTests.kt$TransactionSerializationTests$400</ID>
    <ID>MagicNumber:TransactionSerializationTests.kt$TransactionSerializationTests$5</ID>
    <ID>MagicNumber:TransactionSerializationTests.kt$TransactionSerializationTests$600</ID>
    <ID>MagicNumber:TransactionSignature.kt$TransactionSignature$31</ID>
    <ID>MagicNumber:TransactionSignatureTest.kt$TransactionSignatureTest$1234567890L</ID>
    <ID>MagicNumber:TransactionSignatureTest.kt$TransactionSignatureTest$3</ID>
    <ID>MagicNumber:TransactionSignatureTest.kt$TransactionSignatureTest$4</ID>
    <ID>MagicNumber:TransactionTests.kt$TransactionTests.&lt;no name provided&gt;$1234</ID>
    <ID>MagicNumber:TransactionUtils.kt$4</ID>
    <ID>MagicNumber:TransactionVerificationExceptionSerialisationTests.kt$TransactionVerificationExceptionSerialisationTests$12</ID>
    <ID>MagicNumber:TransactionVerificationExceptionSerialisationTests.kt$TransactionVerificationExceptionSerialisationTests$20</ID>
    <ID>MagicNumber:TransactionVerificationExceptionSerialisationTests.kt$TransactionVerificationExceptionSerialisationTests$40</ID>
    <ID>MagicNumber:TransactionVerifierServiceInternal.kt$Verifier$4</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$15.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$20.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$200.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$26.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$400.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$10.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$16</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$30.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$5.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.TransactionWidget$30.0</ID>
    <ID>MagicNumber:TransformsSchema.kt$EnumDefaultSchemaTransform$17</ID>
    <ID>MagicNumber:TransformsSchema.kt$RenameSchemaTransform$11</ID>
    <ID>MagicNumber:TransformsSchema.kt$UnknownTestTransform.Companion$3</ID>
    <ID>MagicNumber:TunnelControlMessages.kt$CrlResponse$10</ID>
    <ID>MagicNumber:TunnelControlTest.kt$TunnelControlTest$0x11</ID>
    <ID>MagicNumber:TunnelControlTest.kt$TunnelControlTest$0x22</ID>
    <ID>MagicNumber:TunnelControlTest.kt$TunnelControlTest$12005</ID>
    <ID>MagicNumber:TunnelControlTest.kt$TunnelControlTest$12345</ID>
    <ID>MagicNumber:TunnelControlTest.kt$TunnelControlTest$6789</ID>
    <ID>MagicNumber:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService$100</ID>
    <ID>MagicNumber:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService$60</ID>
    <ID>MagicNumber:TutorialFlowAsyncOperationTest.kt$TutorialFlowAsyncOperationTest$3</ID>
    <ID>MagicNumber:TutorialTestDSL.kt$TutorialTestDSL$1000</ID>
    <ID>MagicNumber:TutorialTestDSL.kt$TutorialTestDSL$123</ID>
    <ID>MagicNumber:TutorialTestDSL.kt$TutorialTestDSL$7</ID>
    <ID>MagicNumber:TutorialTestDSL.kt$TutorialTestDSL$900</ID>
    <ID>MagicNumber:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$60</ID>
    <ID>MagicNumber:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$30</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$10</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$1000</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$1200</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$2000</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$3</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$300</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$7</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$700</ID>
    <ID>MagicNumber:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$800</ID>
    <ID>MagicNumber:TypesafeCordappConfigTests.kt$TypesafeCordappConfigTests$1.01</ID>
    <ID>MagicNumber:UniquenessProviderTests.kt$RaftUniquenessProviderFactory$10987</ID>
    <ID>MagicNumber:UniquenessProviderTests.kt$UniquenessProviderTests$30</ID>
    <ID>MagicNumber:UniquenessProviderTests.kt$UniquenessProviderTests$32</ID>
    <ID>MagicNumber:UniquenessProviderTests.kt$UniquenessProviderTests$90</ID>
    <ID>MagicNumber:UniversalContract.kt$UniversalContract$100.0</ID>
    <ID>MagicNumber:UnspentStatesCache.kt$UnspentStatesCache$100_000</ID>
    <ID>MagicNumber:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$32</ID>
    <ID>MagicNumber:Util.kt$24</ID>
    <ID>MagicNumber:Util.kt$60</ID>
    <ID>MagicNumber:UtilsTest.kt$UtilsTest$12.0</ID>
    <ID>MagicNumber:UtilsTest.kt$UtilsTest$17</ID>
    <ID>MagicNumber:UtilsTest.kt$UtilsTest$2.0</ID>
    <ID>MagicNumber:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest$257</ID>
    <ID>MagicNumber:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$30</ID>
    <ID>MagicNumber:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$3600</ID>
    <ID>MagicNumber:VaultFiller.kt$VaultFiller$3</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestRule$10</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestRule$20</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestRule$21</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestRule$70</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestRule$80</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestRule$90</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTests$10</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTests$100</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTests$20</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTests$3</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTests$5</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTests$99</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$100</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$1000</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10000</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10000.0</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$100000</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$1000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10274L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10343L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$10L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$11</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$110000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$11298L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$12</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$13</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$14</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$15</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$150000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$1500L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$15L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$16</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$17</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$20</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$200</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$20000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$201</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$20100L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$25</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$2500L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$3</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$30</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$300</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$30000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$3L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$4</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$400</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$40000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$402</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$4L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$5</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$50</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$500</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$5000</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$50000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$5000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$500L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$59</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$5L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$6</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$600</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$60000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$7</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$70000L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$75</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$8</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$8702L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$9</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$9351L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$9481L</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$95</ID>
    <ID>MagicNumber:VaultQueryTests.kt$VaultQueryTestsBase$9L</ID>
    <ID>MagicNumber:VaultRestartTest.kt$VaultRestartTest$500</ID>
    <ID>MagicNumber:VaultStateMigration.kt$VaultStateIterator$1000</ID>
    <ID>MagicNumber:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$10</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$10</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$100</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$1000</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$1010</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$11</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$12</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$20</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$3</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$300L</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$5</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$500L</ID>
    <ID>MagicNumber:VaultStateMigrationTest.kt$VaultStateMigrationTest$6</ID>
    <ID>MagicNumber:VaultUpdateTests.kt$VaultUpdateTests$3</ID>
    <ID>MagicNumber:VaultUpdateTests.kt$VaultUpdateTests$4</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$10</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$100</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$20</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$3</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$30.45</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$34.70</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$34.85</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$40</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$6</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$60</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$7</ID>
    <ID>MagicNumber:VaultWithCashTest.kt$VaultWithCashTest$80</ID>
    <ID>MagicNumber:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$8080</ID>
    <ID>MagicNumber:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$8081</ID>
    <ID>MagicNumber:WebServer.kt$10</ID>
    <ID>MagicNumber:WebServer.kt$100.0</ID>
    <ID>MagicNumber:WebServer.kt$WebServer$500</ID>
    <ID>MagicNumber:WireTransaction.kt$WireTransaction$4</ID>
    <ID>MagicNumber:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow$60</ID>
    <ID>MagicNumber:WorkflowTransactionBuildTutorial.kt$SubmitTradeApprovalFlow$60</ID>
    <ID>MagicNumber:X509EdDSAEngineTest.kt$X509EdDSAEngineTest.Companion$8</ID>
    <ID>MagicNumber:X509Utilities.kt$X509Utilities$3650</ID>
    <ID>MagicNumber:X509UtilitiesTest.kt$X509UtilitiesTest$10</ID>
    <ID>MagicNumber:X509UtilitiesTest.kt$X509UtilitiesTest$1000</ID>
    <ID>MagicNumber:X509UtilitiesTest.kt$X509UtilitiesTest$5</ID>
    <ID>MagicNumber:ZeroCouponBond.kt$ZeroCouponBond$100</ID>
    <ID>MagicNumber:ZeroCouponBond.kt$ZeroCouponBond$80</ID>
    <ID>MagicNumber:ZeroFilterTest.kt$ZeroFilterTest$26</ID>
    <ID>MagicNumber:ZeroFilterTest.kt$ZeroFilterTest$5</ID>
    <ID>MagicNumber:ZeroFilterTest.kt$ZeroFilterTest$6</ID>
    <ID>MagicNumber:ZkClientTest.kt$ZkClientTests$100</ID>
    <ID>MagicNumber:ZkClientTest.kt$ZkClientTests$1000</ID>
    <ID>MagicNumber:ZkClientTest.kt$ZkClientTests$2000</ID>
    <ID>MagicNumber:ZkClientTest.kt$ZkClientTests$4</ID>
    <ID>MagicNumber:ZkClientTest.kt$ZkClientTests$50</ID>
    <ID>MagicNumber:ZkClientTest.kt$ZkClientTests$60L</ID>
    <ID>MagicNumber:errorAndTerminate.kt$10</ID>
    <ID>MatchingDeclarationName:AMQPSerializerFactories.kt$net.corda.serialization.internal.amqp.AMQPSerializerFactories.kt</ID>
    <ID>MatchingDeclarationName:AMQPTestSerialiationScheme.kt$net.corda.node.internal.serialization.testutils.AMQPTestSerialiationScheme.kt</ID>
    <ID>MatchingDeclarationName:ArtemisUtils.kt$net.corda.nodeapi.internal.ArtemisUtils.kt</ID>
    <ID>MatchingDeclarationName:AttachmentDemo.kt$net.corda.attachmentdemo.AttachmentDemo.kt</ID>
    <ID>MatchingDeclarationName:AzureRegistryLocator.kt$net.corda.networkbuilder.containers.push.azure.AzureRegistryLocator.kt</ID>
    <ID>MatchingDeclarationName:BridgeDriver.kt$net.corda.bridge.BridgeDriver.kt</ID>
    <ID>MatchingDeclarationName:BullyLeader.kt$net.corda.nodeapi.internal.bully.BullyLeader.kt</ID>
    <ID>MatchingDeclarationName:CashIssueAndPaymentNoSelectionFlowTests.kt$com.r3.corda.enterprise.perftestcordapp.flows.CashIssueAndPaymentNoSelectionFlowTests.kt</ID>
    <ID>MatchingDeclarationName:CheckTestFlows.kt$com.r3.corda.enterprise.perftestcordapp.flows.CheckTestFlows.kt</ID>
    <ID>MatchingDeclarationName:CheckpointSerializationScheme.kt$net.corda.serialization.internal.CheckpointSerializationScheme.kt</ID>
    <ID>MatchingDeclarationName:CheckpointSerializationTestHelpers.kt$net.corda.testing.core.internal.CheckpointSerializationTestHelpers.kt</ID>
    <ID>MatchingDeclarationName:ClassCarpenterTestUtils.kt$net.corda.serialization.internal.carpenter.ClassCarpenterTestUtils.kt</ID>
    <ID>MatchingDeclarationName:ConfigException.kt$net.corda.core.cordapp.ConfigException.kt</ID>
    <ID>MatchingDeclarationName:ConfigUtilities.kt$net.corda.node.services.config.ConfigUtilities.kt</ID>
    <ID>MatchingDeclarationName:ContractsDSL.kt$net.corda.core.contracts.ContractsDSL.kt</ID>
    <ID>MatchingDeclarationName:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>MatchingDeclarationName:CryptoUtils.kt$net.corda.core.crypto.CryptoUtils.kt</ID>
    <ID>MatchingDeclarationName:CurrencyParameterSensitivitySerialiser.kt$net.corda.vega.plugin.customserializers.CurrencyParameterSensitivitySerialiser.kt</ID>
    <ID>MatchingDeclarationName:EnterpriseFlowLogicRefFactory.kt$net.corda.node.services.statemachine.EnterpriseFlowLogicRefFactory.kt</ID>
    <ID>MatchingDeclarationName:ExternalBrokerTests.kt$net.corda.node.ExternalBrokerTests.kt</ID>
    <ID>MatchingDeclarationName:FinanceWorkflowsUtils.kt$net.corda.finance.workflows.utils.FinanceWorkflowsUtils.kt</ID>
    <ID>MatchingDeclarationName:FlowHook.kt$net.corda.flowhook.FlowHook.kt</ID>
    <ID>MatchingDeclarationName:FlowStackSnapshot.kt$net.corda.testing.internal.FlowStackSnapshot.kt</ID>
    <ID>MatchingDeclarationName:IRSDemo.kt$net.corda.irs.web.demo.IRSDemo.kt</ID>
    <ID>MatchingDeclarationName:InterestSwapRestAPI.kt$net.corda.irs.web.api.InterestSwapRestAPI.kt</ID>
    <ID>MatchingDeclarationName:InternalAccessTestHelpers.kt$net.corda.serialization.internal.InternalAccessTestHelpers.kt</ID>
    <ID>MatchingDeclarationName:InternalTestUtils.kt$net.corda.testing.node.internal.InternalTestUtils.kt</ID>
    <ID>MatchingDeclarationName:IrsDemoClientApi.kt$net.corda.irs.web.demo.IrsDemoClientApi.kt</ID>
    <ID>MatchingDeclarationName:KeyStoreConfigHelpers.kt$net.corda.nodeapi.internal.KeyStoreConfigHelpers.kt</ID>
    <ID>MatchingDeclarationName:Main.kt$com.r3.ha.notaryregistration.Main.kt</ID>
    <ID>MatchingDeclarationName:Main.kt$net.corda.bootstrapper.Main.kt</ID>
    <ID>MatchingDeclarationName:Main.kt$net.corda.notaryhealthcheck.client.Main.kt</ID>
    <ID>MatchingDeclarationName:Main.kt$net.corda.tools.benchmark.Main.kt</ID>
    <ID>MatchingDeclarationName:Measure.kt$net.corda.client.rpc.Measure.kt</ID>
    <ID>MatchingDeclarationName:MockNetworkParametersService.kt$net.corda.testing.node.internal.MockNetworkParametersService.kt</ID>
    <ID>MatchingDeclarationName:NamedCache.kt$net.corda.core.internal.NamedCache.kt</ID>
    <ID>MatchingDeclarationName:NetParams.kt$net.corda.netparams.NetParams.kt</ID>
    <ID>MatchingDeclarationName:NetworkParametersServiceInternal.kt$net.corda.core.internal.NetworkParametersServiceInternal.kt</ID>
    <ID>MatchingDeclarationName:NetworkProxy.kt$net.corda.node.utilities.NetworkProxy.kt</ID>
    <ID>MatchingDeclarationName:OGSwapPricingCcpExample.kt$net.corda.vega.analytics.example.OGSwapPricingCcpExample.kt</ID>
    <ID>MatchingDeclarationName:OGSwapPricingExample.kt$net.corda.vega.analytics.example.OGSwapPricingExample.kt</ID>
    <ID>MatchingDeclarationName:PlatformSecureRandom.kt$net.corda.core.crypto.internal.PlatformSecureRandom.kt</ID>
    <ID>MatchingDeclarationName:Program.kt$net.corda.configobfuscator.Program.kt</ID>
    <ID>MatchingDeclarationName:Query.kt$net.corda.webserver.api.Query.kt</ID>
    <ID>MatchingDeclarationName:ReceiveAllFlowTests.kt$net.corda.coretests.flows.ReceiveAllFlowTests.kt</ID>
    <ID>MatchingDeclarationName:ReferenceInputStateTests.kt$net.corda.coretests.transactions.ReferenceInputStateTests.kt</ID>
    <ID>MatchingDeclarationName:RigorousMock.kt$net.corda.testing.internal.RigorousMock.kt</ID>
    <ID>MatchingDeclarationName:RpcServerCordaFutureSerialiser.kt$net.corda.node.serialization.amqp.RpcServerCordaFutureSerialiser.kt</ID>
    <ID>MatchingDeclarationName:SSLHelper.kt$net.corda.nodeapi.internal.protonwrapper.netty.SSLHelper.kt</ID>
    <ID>MatchingDeclarationName:SampleData.kt$net.corda.deterministic.verifier.SampleData.kt</ID>
    <ID>MatchingDeclarationName:SerializationHelper.kt$net.corda.networkbuilder.serialization.SerializationHelper.kt</ID>
    <ID>MatchingDeclarationName:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>MatchingDeclarationName:Specification.kt$net.corda.common.configuration.parsing.internal.Specification.kt</ID>
    <ID>MatchingDeclarationName:SpringDriver.kt$net.corda.test.spring.SpringDriver.kt</ID>
    <ID>MatchingDeclarationName:SupportedTransforms.kt$net.corda.serialization.internal.amqp.SupportedTransforms.kt</ID>
    <ID>MatchingDeclarationName:TargetVersionDependentRules.kt$net.corda.core.internal.rules.TargetVersionDependentRules.kt</ID>
    <ID>MatchingDeclarationName:TestConstants.kt$net.corda.testing.core.TestConstants.kt</ID>
    <ID>MatchingDeclarationName:TestUtils.kt$net.corda.testing.core.TestUtils.kt</ID>
    <ID>MatchingDeclarationName:Tests.kt$com.r3.corda.tracelog.Tests.kt</ID>
    <ID>MatchingDeclarationName:TracingCacheWrapper.kt$net.corda.core.internal.profiling.TracingCacheWrapper.kt</ID>
    <ID>MatchingDeclarationName:TransactionTypes.kt$net.corda.explorer.model.TransactionTypes.kt</ID>
    <ID>MatchingDeclarationName:TutorialFlowStateMachines.kt$net.corda.docs.kotlin.tutorial.flowstatemachines.TutorialFlowStateMachines.kt</ID>
    <ID>MatchingDeclarationName:Utils.kt$io.cryptoblk.core.Utils.kt</ID>
    <ID>MatchingDeclarationName:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>MatchingDeclarationName:VirtualCordapps.kt$net.corda.node.internal.cordapp.VirtualCordapps.kt</ID>
    <ID>MatchingDeclarationName:ZkClientTest.kt$net.corda.nodeapi.internal.zookeeper.ZkClientTest.kt</ID>
    <ID>MatchingDeclarationName:main.kt$net.corda.tools.testing.pinger.main.kt</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager : BridgeManager</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$// queueNamesToBridgesMap returns a mutable list, .toList converts it to a immutable list so it won't be changed by the [destroyBridge] method. val bridges = queueNamesToBridgesMap[queueName]?.toList() destroyBridge(queueName, bridges?.flatMap { it.targets } ?: emptyList()) bridges?.map { it.sourceX500Name to BridgeEntry(it.queueName, it.targets, it.legalNames.toList(), serviceAddress = false) }?.toMap() ?: emptyMap()</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$AMQPBridge</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$it.sourceX500Name to BridgeEntry(it.queueName, it.targets, it.legalNames.toList(), serviceAddress = false)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$override</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$private val amqpConfig: AMQPConfiguration = AMQPConfigurationImpl(keyStore, trustStore, proxyConfig, maxMessageSize, revocationConfig,useOpenSSL, enableSNI, trace = trace, _sslHandshakeTimeout = sslHandshakeTimeout)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$val newAMQPConfig = with(amqpConfig) { AMQPConfigurationImpl(keyStore, trustStore, proxyConfig, maxMessageSize, revocationConfig, useOpenSsl, enableSNI, sourceX500Name, trace, sslHandshakeTimeout) }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$val newBridge = AMQPBridge(sourceX500Name, queueName, targets, legalNames, newAMQPConfig, sharedEventLoopGroup!!, artemis!!, bridgeMetricsService)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$ArtemisState</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$logDebugWithMDC { "Bridged Send to ${legalNames.first()} uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}" }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$logInfoWithMDC("Artemis session restart failed. Aborting by restarting AMQP connection.")</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$logInfoWithMDC("Rollback rejected message uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}")</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$session.createConsumer(queueName, "hyphenated_props:sender-subject-name = '${amqpConfig.sourceX500Name}'")</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$val msg = "Message exceeds maxMessageSize network parameter, maxMessageSize: [${amqpConfig.maxMessageSize}], message size: [${artemisMessage.bodySize}], " + "dropping message, uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}"</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$val session = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge${ // Now, bounce the AMQP connection to restart the sequence of establishing the connectivity back from the beginning. withMDC { log.warn("Create artemis session error. Restarting AMQP connection", ex) } stopAndStartOutbound() }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge${ // Session timed out stopping. The request/responses can be out of sequence on the session now, so abandon it. session = null // The consumer is also dead now too as attached to the dead session. consumer = null return false }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge${ logInfoWithMDC("Creating session and consumer.") val sessionFactory = startedArtemis.sessionFactory val session = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) this.session = session // Several producers (in the case of shared bridge) can put messages in the same outbound p2p queue. The consumers are created using the source x500 name as a filter val consumer = if (amqpConfig.enableSNI) { session.createConsumer(queueName, "hyphenated_props:sender-subject-name = '${amqpConfig.sourceX500Name}'") } else { session.createConsumer(queueName) } this.consumer = consumer consumer.setMessageHandler(this@AMQPBridge::clientArtemisMessageHandler) return session }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge${ logInfoWithMDC("Stopping AMQP bridge") artemis(ArtemisState.STOPPING) { logInfoWithMDC("Stopping Artemis because stopping AMQP bridge") closeConsumer() consumer = null stopSession() session = null ArtemisState.STOPPED } bridgeMetricsService?.bridgeDisconnected(targets, legalNames) connectedSubscription?.unsubscribe() connectedSubscription = null // Do this last because we already scheduled the Artemis stop, so it's okay to unsubscribe onConnected first. amqpClient.stop() }</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.RemoteInboxAddress.Companion.translateLocalQueueToInboxAddress</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$artemisRecClient.started!!.session.createQueue(SimpleString(queueName), RoutingType.ANYCAST, SimpleString(queueName), true)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000))).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$enableSNI</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$private</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, artemisAddress, MAX_MESSAGE_SIZE, confirmationWindowSize = artemisConfig.enterpriseConfiguration.tuning.p2pConfirmationWindowSize)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, targetAdress, MAX_MESSAGE_SIZE, confirmationWindowSize = 10 * 1024)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val artemisServer = ArtemisMessagingServer(artemisConfig, NetworkHostAndPort("0.0.0.0", targetAdress.port), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val artemisServer = ArtemisMessagingServer(artemisConfig, artemisAddress.copy(host = "0.0.0.0"), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$val p2pSslConfiguration = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, useOpenSsl = useOpenSsl)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest${ // Note that the opposite of this test (that a connection is established if strict checking is disabled) is carried out by the // ack/nack test above. "Strict CRL checking" means that soft fail mode is disabled. val sourceQueueName = "internal.peers." + BOB.publicKey.toStringShort() val (artemisServer, artemisClient, bridge) = createArtemis(sourceQueueName, crlCheckSoftFail = false) createAMQPServer().use { val connectedFuture = it.onConnection.toFuture() it.start() val connectedResult = connectedFuture.get() assertEquals(false, connectedResult.connected) } bridge.stop() artemisClient.stop() artemisServer.stop() }</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest${ val numMessages = 10000 // Create local queue val sourceQueueName = "internal.peers." + BOB.publicKey.toStringShort() val (artemisServer, artemisClient, bridgeManager) = createArtemis(sourceQueueName) val artemis = artemisClient.started!! val queueName = ArtemisMessagingComponent.RemoteInboxAddress(BOB.publicKey).queueName val (artemisRecServer, artemisRecClient) = createArtemisReceiver(amqpAddress, "artemisBridge") //artemisBridgeClient.started!!.session.createQueue(SimpleString(queueName), RoutingType.ANYCAST, SimpleString(queueName), true) var numReceived = 0 artemisRecClient.started!!.session.createQueue(SimpleString(queueName), RoutingType.ANYCAST, SimpleString(queueName), true) val artemisConsumer = artemisRecClient.started!!.session.createConsumer(queueName) val rubbishPayload = ByteArray(10 * 1024) var timeNanosCreateMessage = 0L var timeNanosSendMessage = 0L var timeMillisRead = 0L val recThread = thread { val current = artemisConsumer.receive() val messageId = current.getIntProperty(P2PMessagingHeaders.senderUUID) assertEquals(numReceived, messageId) ++numReceived current.acknowledge() timeMillisRead = measureTimeMillis { while (numReceived &lt; numMessages) { val currentMsg = artemisConsumer.receive() val loopMessageId = currentMsg.getIntProperty(P2PMessagingHeaders.senderUUID) assertEquals(numReceived, loopMessageId) ++numReceived currentMsg.acknowledge() } } } val simpleSourceQueueName = SimpleString(sourceQueueName) val totalTimeMillis = measureTimeMillis { repeat(numMessages) { i -&gt; var artemisMessage: ClientMessage? = null timeNanosCreateMessage += measureNanoTime { artemisMessage = artemis.session.createMessage(true).apply { putIntProperty(P2PMessagingHeaders.senderUUID, i) writeBodyBufferBytes(rubbishPayload) // Use the magic deduplication property built into Artemis as our message identity too putStringProperty(HDR_DUPLICATE_DETECTION_ID, SimpleString(UUID.randomUUID().toString())) } } timeNanosSendMessage += measureNanoTime { artemis.producer.send(simpleSourceQueueName, artemisMessage, {}) } } artemisClient.started!!.session.commit() recThread.join(1.hours.toMillis()) } println("Creating $numMessages messages took ${timeNanosCreateMessage / (1000 * 1000)} milliseconds") println("Sending $numMessages messages took ${timeNanosSendMessage / (1000 * 1000)} milliseconds") println("Receiving $numMessages messages took $timeMillisRead milliseconds") println("Total took $totalTimeMillis milliseconds") assertEquals(numMessages, numReceived) bridgeManager.stop() artemisClient.stop() artemisServer.stop() artemisRecClient.stop() artemisRecServer.stop() }</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$"Message for incorrect legal identity ${msg.destinationLegalName} expected ${remoteCert!!.subjectX500Principal}"</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$cause is SSLException &amp;&amp; (cause.message?.contains("close_notify") == true) -&gt; logWarnWithMDC("Received close_notify during handshake")</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$eventProcessor = EventProcessor(ch, serverMode, localCert!!.subjectX500Principal.toString(), remoteCert!!.subjectX500Principal.toString(), userName, password)</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$logInfoWithMDC("Handshake completed with subject: $remoteX500Name, requested server name: ${sslHandler.getRequestedServerName()}.")</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$private fun logErrorWithMDC(msg: String, ex: Throwable? = null)</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$require</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$suppressClose = true</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler${ // The SniCompletionEvent is fired up before context is switched (after SslHandshakeCompletionEvent) // so we save the requested server name now to be able log it once the handshake is completed successfully // Note: this event is only triggered when using OpenSSL. requestedServerName = evt.hostname() logInfoWithMDC("SNI completion success.") }</ID>
    <ID>MaxLineLength:AMQPClient.kt$AMQPClient.ClientChannelInitializer$createClientOpenSslHandler(target, parent.allowedRemoteLegalNames, wrappedKeyManagerFactory, trustManagerFactory, ch.alloc())</ID>
    <ID>MaxLineLength:AMQPClient.kt$AMQPClient.ClientChannelInitializer$createClientSslHelper(target, parent.allowedRemoteLegalNames, wrappedKeyManagerFactory, trustManagerFactory)</ID>
    <ID>MaxLineLength:AMQPClient.kt$AMQPClient.ClientChannelInitializer$log.error("Blocking future connection attempts to $target due to bad certificate on endpoint")</ID>
    <ID>MaxLineLength:AMQPClient.kt$ProxyConfig$data</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*,*&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$@Suppress("UNUSED") constructor() : this(emptySet(), emptySet(), AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, serializerFactoriesForContexts)</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$return SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader, context.lenientCarpenterEnabled).apply { register(RpcClientObservableDeSerializer) register(RpcClientCordaFutureSerializer(this)) register(RxNotificationSerializer(this)) }</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$ fun initialiseSerialization(classLoader: ClassLoader? = null, customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt; = emptySet(), serializationWhitelists: Set&lt;SerializationWhitelist&gt; = emptySet(), serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$fun createSerializationEnv(classLoader: ClassLoader? = null, customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt; = emptySet(), serializationWhitelists: Set&lt;SerializationWhitelist&gt; = emptySet(), serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised()): SerializationEnvironment</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$nodeSerializationEnv = createSerializationEnv(classLoader, customSerializers, serializationWhitelists, serializerFactoriesForContexts)</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$p2pContext = if (classLoader != null) AMQP_P2P_CONTEXT.withClassLoader(classLoader) else AMQP_P2P_CONTEXT</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$registerScheme(AMQPClientSerializationScheme(customSerializers, serializationWhitelists, serializerFactoriesForContexts))</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * An optional Health Check Phrase which if passed through the channel will cause AMQP Server to echo it back instead of doing normal pipeline processing */ val healthCheckPhrase: String? get() = null</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * An optional set of IPv4/IPv6 remote address strings which will be compared to the remote address of inbound connections and these will only log at TRACE level */ @JvmDefault val silencedIPs: Set&lt;String&gt; get() = emptySet()</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * Enables full debug tracing of all netty and AMQP level packets. This logs aat very high volume and is only for developers. */ @JvmDefault val trace: Boolean get() = false</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$/** * The maximum allowed size for packets, which will be dropped ahead of send. In future may also be enforced on receive, * but currently that is deferred to Artemis and the bridge code. */ val maxMessageSize: Int</ID>
    <ID>MaxLineLength:AMQPConfiguration.kt$AMQPConfiguration$get() = DEFAULT_SSL_HANDSHAKE_TIMEOUT_MILLIS // Aligned with sun.security.provider.certpath.URICertStore.DEFAULT_CRL_CONNECT_TIMEOUT</ID>
    <ID>MaxLineLength:AMQPFirewallSerializationScheme.kt$AMQPFirewallSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:AMQPFirewallSerializationScheme.kt$AMQPFirewallSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap { 128 })</ID>
    <ID>MaxLineLength:AMQPFirewallSerializationScheme.kt$AMQPFirewallSerializationScheme$override fun canDeserializeVersion(magic: CordaSerializationMagic, target: SerializationContext.UseCase)</ID>
    <ID>MaxLineLength:AMQPListenerTest.kt$AMQPListenerTest$amqpListenerService.provisionKeysAndActivate(bridgeConfig.publicSSLConfiguration.keyStore.get(), bridgeConfig.publicSSLConfiguration.trustStore.get(), maxMessageSize)</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel$cache.getOrPut(typeDescriptor) { interpretationState.run { typeNotation.name.typeIdentifier.interpretIdentifier() } }</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel$throw NotSerializableException("Cannot resolve cyclic reference to ${typeInformation.typeIdentifier}")</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$ fun TypeIdentifier.interpretIdentifier(): RemoteTypeInformation</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$ private fun TypeIdentifier.interpretNoNotation(): RemoteTypeInformation</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$ private fun TypeNotation.interpretNotation(identifier: TypeIdentifier): RemoteTypeInformation</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$private</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$return if (isInterface) RemoteTypeInformation.AnInterface(typeDescriptor, identifier, properties, interfaces, typeParameters) else RemoteTypeInformation.Composable(typeDescriptor, identifier, properties, interfaces, typeParameters)</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModel.kt$AMQPRemoteTypeModel.InterpretationState$val constants = choices.asSequence().mapIndexed { index, choice -&gt; choice.name to index }.toMap(LinkedHashMap())</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests$C&lt;V&gt; : Superclass</ID>
    <ID>MaxLineLength:AMQPRemoteTypeModelTests.kt$AMQPRemoteTypeModelTests.Superclass$open</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$@DeleteForDJVM constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$private</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$val key = SerializationFactoryCacheKey(context.whitelist, context.deserializationClassLoader, context.preventDataLoss, context.customSerializers)</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme${ // This is a hack introduced in version 3 to fix a spring boot issue - CORDA-1747. // It breaks the shell because it overwrites the CordappClassloader with the system classloader that doesn't know about any CorDapps. // In case a spring boot serialization issue with generics is found, a better solution needs to be found to address it. // var contextToUse = context // if (context.useCase == SerializationContext.UseCase.RPCClient) { // contextToUse = context.withClassLoader(getContextClassLoader()) // } val serializerFactory = getSerializerFactory(context) return DeserializationInput(serializerFactory).deserialize(byteSequence, clazz, context) }</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme${ with(factory) { register(publicKeySerializer) register(net.corda.serialization.internal.amqp.custom.PrivateKeySerializer) register(net.corda.serialization.internal.amqp.custom.ThrowableSerializer(this)) register(net.corda.serialization.internal.amqp.custom.BigDecimalSerializer) register(net.corda.serialization.internal.amqp.custom.BigIntegerSerializer) register(net.corda.serialization.internal.amqp.custom.CurrencySerializer) register(net.corda.serialization.internal.amqp.custom.OpaqueBytesSubSequenceSerializer(this)) register(net.corda.serialization.internal.amqp.custom.InstantSerializer(this)) register(net.corda.serialization.internal.amqp.custom.DurationSerializer(this)) register(net.corda.serialization.internal.amqp.custom.LocalDateSerializer(this)) register(net.corda.serialization.internal.amqp.custom.LocalDateTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.LocalTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ZonedDateTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ZoneIdSerializer(this)) register(net.corda.serialization.internal.amqp.custom.OffsetTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.OffsetDateTimeSerializer(this)) register(net.corda.serialization.internal.amqp.custom.OptionalSerializer(this)) register(net.corda.serialization.internal.amqp.custom.YearSerializer(this)) register(net.corda.serialization.internal.amqp.custom.YearMonthSerializer(this)) register(net.corda.serialization.internal.amqp.custom.MonthDaySerializer(this)) register(net.corda.serialization.internal.amqp.custom.PeriodSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ClassSerializer(this)) register(net.corda.serialization.internal.amqp.custom.X509CertificateSerializer) register(net.corda.serialization.internal.amqp.custom.X509CRLSerializer) register(net.corda.serialization.internal.amqp.custom.CertPathSerializer(this)) register(net.corda.serialization.internal.amqp.custom.StringBufferSerializer) register(net.corda.serialization.internal.amqp.custom.InputStreamSerializer) register(net.corda.serialization.internal.amqp.custom.BitSetSerializer(this)) register(net.corda.serialization.internal.amqp.custom.EnumSetSerializer(this)) register(net.corda.serialization.internal.amqp.custom.ContractAttachmentSerializer(this)) registerNonDeterministicSerializers(factory) } // This step is registering custom serializers, which have been added after node initialisation (i.e. via attachments during transaction verification). // Note: the order between the registration of customSerializers and cordappCustomSerializers must be preserved as-is. The reason is the following: // Currently, the serialization infrastructure does not support multiple versions of a class (the first one that is registered dominates). // As a result, when inside a context with attachments class loader, we prioritize serializers loaded on-demand from attachments to serializers that had been // loaded during node initialisation, by scanning the cordapps folder. context.customSerializers.forEach { customSerializer -&gt; factory.registerExternal(CorDappCustomSerializer(customSerializer, factory)) } cordappCustomSerializers.forEach { customSerializer -&gt; factory.registerExternal(CorDappCustomSerializer(customSerializer, factory)) } context.properties[ContextPropertyKeys.SERIALIZERS]?.apply { uncheckedCast&lt;Any, List&lt;CustomSerializer&lt;out Any&gt;&gt;&gt;(this).forEach { factory.register(it) } } }</ID>
    <ID>MaxLineLength:AMQPSerializer.kt$AMQPSerializer$ fun readObject(obj: Any, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext): T</ID>
    <ID>MaxLineLength:AMQPSerializer.kt$AMQPSerializer$ fun writeClassInfo(output: SerializationOutput)</ID>
    <ID>MaxLineLength:AMQPSerializer.kt$AMQPSerializer$/** * Textual unique representation of the JVM type this represents. Will be encoded into the AMQP stream and * will appear in the schema. * * This should be unique enough that we can use one global cache of [AMQPSerializer]s and use this as the look up key. */ val typeDescriptor: Symbol</ID>
    <ID>MaxLineLength:AMQPSerializerFactories.kt$ fun createClassCarpenter(context: SerializationContext): ClassCarpenter</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer$val channelFuture = server.bind(hostName, port).sync() // block/throw here as better to know we failed to claim port than carry on</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer.ServerChannelInitializer$amqpConfiguration.healthCheckPhrase?.let { pipeline.addLast(ModeSelectingChannel.NAME, ModeSelectingChannel(it)) }</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer.ServerChannelInitializer$private</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor() : this(emptySet(), emptySet(), AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised() )</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, serializerFactoriesForContexts)</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$return SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader, context.lenientCarpenterEnabled).apply { register(RpcServerObservableSerializer()) register(RpcServerCordaFutureSerializer(this)) register(RxNotificationSerializer(this)) }</ID>
    <ID>MaxLineLength:AMQPSigningService.kt$AMQPSigningService$RequestResponseServiceHelper(amqpControl, floatClientName, sourceLink, sourceLegalName, auditService, log, stateHelper, FloatControlTopics.FLOAT_SIGNING_TOPIC, SigningResponse::class, responseTimeOut)</ID>
    <ID>MaxLineLength:AMQPSigningService.kt$AMQPSigningService$private</ID>
    <ID>MaxLineLength:AMQPTestUtils.kt$val dir = ProjectStructure.projectRootDir / "serialization" / "src" / "test" / "resources" / javaClass.packageName.replace('.', separatorChar)</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$else -&gt; throw IllegalTypeNameParserStateException("Type name '$typeString' contains illegal character '$c'")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$throw IllegalTypeNameParserStateException("Nested depth of type parameters exceeds maximum of $MAX_TYPE_PARAM_DEPTH")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingArray$data</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingParameterList$data</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingRawType$data</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$assertParsesCompatibly&lt;WithParameters&lt;IntArray, WithParameter&lt;Array&lt;WithParameters&lt;Array&lt;Array&lt;Date&gt;&gt;, UUID&gt;&gt;&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$verify(" java.util.Map &lt; java.util.Map&lt; java.lang.String, java.lang.Integer &gt;, java.util.Map &lt; java.lang.Long , java.lang.String &gt; &gt;")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$verify("java.util.List&lt;net.corda.core.contracts.Command&lt;net.corda.core.contracts.Command&lt;net.corda.core.contracts.CommandData&gt;&gt;&gt;")</ID>
    <ID>MaxLineLength:AMQPTypeIdentifiers.kt$AMQPTypeIdentifiers$is TypeIdentifier.Parameterised</ID>
    <ID>MaxLineLength:AMQPTypeIdentifiers.kt$AMQPTypeIdentifiers$private val primitiveByteArrayType = TypeIdentifier.ArrayOf(TypeIdentifier.forClass(Byte::class.javaPrimitiveType!!))</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Create a new tree of steps that also holds a reference to the parent of each step. This is required to uniquely identify each step // (assuming that each step label is unique at a given level). private fun transformTree(inputTree: List&lt;InputTreeStep&gt;): List&lt;ProgressStep&gt;</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$ansi.a("${IntStream.range(indent, indent).mapToObj { "\t" }.toList().joinToString(separator = "") { s -&gt; s }} $errorIcon ${error.message}")</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$updatesSubscription</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer$val newTree = transformTree(it.first.map { elem -&gt; InputTreeStep(elem.first, elem.second) }) // Process indices first, as if the tree has changed the associated index with this update is for the old tree. Note // that the one case where this isn't true is the very first update, but in this case the index should be 0 (as this // update is for the initial state). The remapping on a new tree assumes the step at index 0 is always at least current, // so this case is handled there. treeIndex = it.second treeIndexProcessed.add(it.second) if (newTree != tree) { remapIndices(newTree) tree = newTree } draw(true)</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // By combining the two observables, a race condition where both emit items at roughly the same time is avoided. This could // result in steps being incorrectly marked as skipped. Instead, whenever either observable emits an item, a pair of the // last index and last tree is returned, which ensures that updates to either are processed in series. updatesSubscription = combineLatest(treeUpdates, indexUpdates) { tree, index -&gt; Pair(tree, index) }.subscribe( { val newTree = transformTree(it.first.map { elem -&gt; InputTreeStep(elem.first, elem.second) }) // Process indices first, as if the tree has changed the associated index with this update is for the old tree. Note // that the one case where this isn't true is the very first update, but in this case the index should be 0 (as this // update is for the initial state). The remapping on a new tree assumes the step at index 0 is always at least current, // so this case is handled there. treeIndex = it.second treeIndexProcessed.add(it.second) if (newTree != tree) { remapIndices(newTree) tree = newTree } draw(true) }, { done(it) }, { done(null) } ) }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // If some steps were removed from the progress tracker, we don't want to leave junk hanging around below. val linesToClear = prevLinesDrawn - newLinesDrawn repeat(linesToClear) { ansi.eraseLine() ansi.newline() } ansi.cursorUp(linesToClear) }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // If there is nothing on the stack at any point, it implies that this step is at the top level and has no parent. null }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$ANSIProgressRenderer${ // The top of the stack is at the same or lower level than the current step. Remove items from the top until the topmost // item is at a higher level - this is the parent step. repeat(levelDifference + 1) { stack.pop() } }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer : ANSIProgressRenderer</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$appenderRefs.forEach { config.addAppender(manager.configuration.appenders[it.ref], it.level, it.filter) }</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$loggerFor&lt;StdoutANSIProgressRenderer&gt;().warn("Cannot find console appender - progress tracking may not work as expected")</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$val consoleAppender = manager.configuration.appenders.values.filterIsInstance&lt;ConsoleAppender&gt;().singleOrNull { it.name == "Console-Selector" }</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 2, listOf(stepSuccess(STEP_1_LABEL), stepSkipped(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 3, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 4, listOf(stepActive(STEP_1_LABEL), stepNotRun(STEP_4_LABEL), stepNotRun(STEP_5_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 5, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_3_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 6, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_3_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL), stepNotRun(STEP_4_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_2_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_4_LABEL), Pair(0, STEP_5_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_2_LABEL), Pair(1, STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_2_LABEL), Pair(1, STEP_3_LABEL), Pair(2, STEP_4_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$flowProgressHandle = FlowProgressHandleImpl(StateMachineRunId.createRandom(), openFuture&lt;String&gt;(), Observable.empty(), stepsTreeIndexFeed, stepsTreeFeed)</ID>
    <ID>MaxLineLength:APIServer.kt$APIServer</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$ByteSequence.of(byteArrayOf('c'.toByte(), 'o'.toByte(), 'r'.toByte(), 'd'.toByte(), 'a'.toByte(), 0.toByte(), 0.toByte(), 1.toByte()))</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val backingMap = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;({ maxFactories }).toSynchronised()</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val deserialized = serialized.deserialize(context = context, serializationFactory = serializationEnvironment.serializationFactory)</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val factory = SerializerFactoryBuilder.build(TESTING_CONTEXT.whitelist, TESTING_CONTEXT.deserializationClassLoader)</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val scheme = object : AbstractAMQPSerializationScheme(emptySet(), emptySet(), backingMap, createSerializerFactoryFactory()) { override fun rpcClientSerializerFactory(context: SerializationContext): SerializerFactory { return factory } override fun rpcServerSerializerFactory(context: SerializationContext): SerializerFactory { return factory } override fun canDeserializeVersion(magic: CordaSerializationMagic, target: SerializationContext.UseCase): Boolean { return true } }</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$// We whitelist sources of transaction JARs for now as a temporary state until the DJVM and other security sandboxes // have been integrated, at which point we'll be able to run untrusted code downloaded over the network and this mechanism // can be removed. Because we ARE downloading attachments over the P2P network in anticipation of this upgrade, we // track the source of each attachment in our store. TestDSL is used by LedgerDSLInterpreter when custom attachments // are added in unit test code. val TRUSTED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, TESTDSL_UPLOADER)</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$AbstractAttachment.Companion$ @DeleteForDJVM fun SerializeAsTokenContext.attachmentDataLoader(id: SecureHash): () -&gt; ByteArray</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$AbstractCashFlow$@Suspendable protected</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$CashException : FlowException</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ @Suspendable fun unconsumedCashStatesForSpending(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet()): List&lt;StateAndRef&lt;Cash.State&gt;&gt;</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ abstract fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ protected abstract fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection for $amount retrieved ${stateAndRefs.count()} states totalling $totalPennies pennies: $stateAndRefs")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection requested $amount but retrieved $totalPennies pennies with state refs: ${stateAndRefs.map { it.ref }}")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$onlyFromIssuerParties: Set&lt;AbstractParty&gt;</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$private</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$val durationMillis = (minOf(retrySleep.shl(retryCount), retryCap / 2) * (1.0 + Math.random())).toInt()</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion$"\nPlease specify an implementation in META-INF/services/${AbstractCashSelection::class.qualifiedName}."</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion$val cashSelectionAlgos = ServiceLoader.load(AbstractCashSelection::class.java, this::class.java.classLoader).toList()</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion${ instance.set(cashSelectionAlgo) cashSelectionAlgo }</ID>
    <ID>MaxLineLength:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashFlow$ @Suspendable abstract protected fun mainCall(maybeAnonymousRecipient: AbstractParty, recipientSession: FlowSession): Result</ID>
    <ID>MaxLineLength:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashFlow$ abstract protected fun makeAnonymousFlow(): AbstractConfidentialAwareCashFlow&lt;T&gt;</ID>
    <ID>MaxLineLength:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashFlow$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashFlow&lt;T&gt; : AbstractCashFlow</ID>
    <ID>MaxLineLength:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashResponderFlow$abstract</ID>
    <ID>MaxLineLength:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashResponderFlow&lt;T&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$ private fun defaultRetainForDays(eventHorizon: Duration): Int</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$" for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key"</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"match what's in the key store: $subject. You might need to adjust the configuration of `notary.serviceLegalName`."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"or if you don't have one yet, fill out the config file and run corda.jar initial-registration. "</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$( CertificateType.LEGAL_IDENTITY, nodeCaCert.subjectX500Principal, nodeCaCert.publicKey, cryptoService.getSigner(X509Utilities.CORDA_CLIENT_CA), nodeCaCert.subjectX500Principal, legalIdentityPublicKey, // TODO this might be smaller than DEFAULT_VALIDITY_WINDOW, shall we strictly apply DEFAULT_VALIDITY_WINDOW? X509Utilities.getCertificateValidityWindow( DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, nodeCaCert) )</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$(configuration.enterpriseConfiguration.tuning.p2pConfirmationWindowSize / 512) + 1</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$/** * Should be [rx.schedulers.Schedulers.io] for production, * or [rx.internal.schedulers.CachedThreadScheduler] (with shutdown registered with [runOnStop]) for shared-JVM testing. */ protected abstract val rxIoScheduler: Scheduler</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// Ideally we should be disabling the FinalityHandler if it's not needed, to prevent any party from submitting transactions to us without // us checking. Previously this was gated on app target version and if there were no apps with target version &lt;= 3 then the handler would // be disabled. However this prevents seemless rolling-upgrades and so it was removed until a better solution comes along. private fun installFinalityHandler()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// TODO Cancelling parameters updates - if we do that, how we ensure that no one uses cancelled parameters in the transactions? val networkMapUpdater = NetworkMapUpdater( networkMapCache, NodeInfoWatcher( configuration.baseDirectory, @Suppress("LeakingThis") rxIoScheduler, Duration.ofMillis(configuration.additionalNodeInfoPollingFrequencyMsec) ), networkMapClient, configuration.baseDirectory, configuration.extraNetworkMapKeys, networkParametersStorage ).closeOnStop()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$AllCertificateStores</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$CheckpointVerifier.verifyCheckpointsCompatible(checkpointStorage, cordappProvider.cordapps, versionInfo.platformVersion, services, tokenizableServices)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$ServiceInstantiationException : CordaException</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$cordapp.initiatedFlows.groupBy { it.requireAnnotation&lt;InitiatedBy&gt;().value.java }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$database.startHikariPool(props, configuration.database, schemaService.schemaOptions.keys, metricRegistry, this.cordappLoader, configuration.baseDirectory, configuration.myLegalName)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(ContractUpgradeFlow.Initiate::class, NotaryChangeHandler::class, ::ContractUpgradeHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(NotaryChangeFlow::class, NotaryChangeHandler::class, ::NotaryChangeHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(SwapIdentitiesFlow::class, SwapIdentitiesHandler::class, ::SwapIdentitiesHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$if (!cryptoService.containsKey(legalIdentityPrivateKeyAlias) &amp;&amp; !signingCertificateStore.contains(legalIdentityPrivateKeyAlias)) { // Directly use the X500 name to public key map, as the identity service requires the node identity to start correctly. database.transaction { val x500Map = PersistentIdentityService.createX500ToKeyMap(cacheFactory) require(configuration.myLegalName !in x500Map) { // There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues." } } log.info("$legalIdentityPrivateKeyAlias not found in key store, generating fresh key!") createAndStoreLegalIdentity(legalIdentityPrivateKeyAlias) signingCertificateStore = configuration.signingCertificateStore.get() // We need to resync after [createAndStoreLegalIdentity]. } else { checkAliasMismatch(legalIdentityPrivateKeyAlias, signingCertificateStore) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.error("Corda service ${it.name} failed to instantiate. Reason was: ${e.cause?.rootMessage}", e.cause)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.info("Private key '$alias' stored in the configured crypto service (${cryptoServiceType.userFriendlyName}). Certificate-chain stored in node's file-based keystore.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.info("Will sleep for $mutualExclusionConfiguration.waitInterval seconds till lease expires then shutting down this process.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.warn("Found more than one node registration with our legal name, this is only expected if our keypair has been regenerated")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.warn("The format of the autogenerated dev. mode certificate this system uses has been deprecated. Please contact support@r3.com for information on how to upgrade.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$networkParametersStorage.setCurrentParameters(signedNetParams, trustRoot) identityService.loadIdentities(nodeInfo.legalIdentitiesAndCerts) attachments.start() cordappProvider.start() nodeProperties.start() // Place the long term identity key in the KMS. Eventually, this is likely going to be separated again because // the KMS is meant for derived temporary keys used in transactions, and we're not supposed to sign things with // the identity key. But the infrastructure to make that easy isn't here yet. keyManagementService.start(keyPairs) val notaryService = maybeStartNotaryService(myNotaryIdentity) installCordaServices() contractUpgradeService.start() vaultService.start() ScheduledActivityObserver.install(vaultService, schedulerService, flowLogicRefFactory) val frozenTokenizableServices = tokenizableServices!! tokenizableServices = null verifyCheckpointsCompatible(frozenTokenizableServices) checkpointDumper.start(frozenTokenizableServices) smm.start(frozenTokenizableServices) // Shut down the SMM so no Fibers are scheduled. runOnStop += { smm.stop(acceptableLiveFiberCountOnStop()) } (smm as? StateMachineManagerInternal)?.let { val flowMonitor = FlowMonitor({ smm.snapshot().filter { flow -&gt; flow !in smm.flowHospital }.toSet() }, configuration.flowMonitorPeriodMillis, configuration.flowMonitorSuspensionLoggingThresholdMillis) runOnStop += flowMonitor::stop flowMonitor.start() } schedulerService.start() createStartedNode(nodeInfo, rpcOps, notaryService).also { _started = it }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$parseSecureHashConfiguration(configuration.blacklistedAttachmentSigningKeys) { "Error while adding signing key $it to blacklistedAttachmentSigningKeys" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$parseSecureHashConfiguration(configuration.cordappSignerKeyFingerprintBlacklist) { "Error while adding key fingerprint $it to blacklistedAttachmentSigningKeys" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$private</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$protected open</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$protected open fun generateKeyPair(alias: String)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$protected val cacheFactory = cacheFactoryPrototype.bindWithConfig(configuration).bindWithMetrics(metricRegistry).tokenize()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$signingCertificateStore = configuration.signingCertificateStore.get()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw ConfigurationException("The name '$legalName' for $NODE_IDENTITY_ALIAS_PREFIX doesn't match what's in the key store: $subject")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw ConfigurationException("The name of the notary service '$serviceLegalName' for $DISTRIBUTED_NOTARY_ALIAS_PREFIX doesn't " + "match what's in the key store: $subject. You might need to adjust the configuration of `notary.serviceLegalName`.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw IllegalArgumentException("At least one of the keystores or truststore passwords does not match configuration.")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw IllegalStateException("CryptoService and signingCertificateStore are not aligned, the entry for key-alias: $alias is only found in $keyExistsIn")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw IllegalStateException("The cryptoservice configured for $description (${configuration.cryptoServiceName}) is unavailable", e)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val (netParams, signedNetParams) = NetworkParametersReader(trustRoot, networkMapClient, configuration.baseDirectory).read()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val blacklisted = isCRLDistributionPointBlacklisted(configuration.signingCertificateStore.get().query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) })</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val certificates = if (cryptoService.containsKey(compositeKeyAlias) &amp;&amp; signingCertificateStore.contains(compositeKeyAlias)) { val certificate = signingCertificateStore[compositeKeyAlias] // We have to create the certificate chain for the composite key manually, this is because we don't have a keystore // provider that understand compositeKey-privateKey combo. The cert chain is created using the composite key certificate + // the tail of the private key certificates, as they are both signed by the same certificate chain. listOf(certificate) + privateKeyAliasCertChain.drop(1) } else { checkAliasMismatch(compositeKeyAlias, signingCertificateStore) // If [compositeKeyAlias] does not exist, we assume the notary is CFT, and each cluster member shares the same notary key pair. privateKeyAliasCertChain }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val certificates: List&lt;X509Certificate&gt; = signingCertificateStore.query { getCertificateChain(legalIdentityPrivateKeyAlias) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val checkpointDumper = CheckpointDumper(checkpointStorage, database, services, services.configuration.baseDirectory)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val cordappProvider = CordappProviderImpl(cordappLoader, CordappConfigFileProvider(configuration.cordappDirectories), attachments).tokenize()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val extendedServiceConstructor = serviceClass.getDeclaredConstructor(AppServiceHub::class.java).apply { isAccessible = true }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val keyExistsIn: String = if (cryptoService.containsKey(alias)) "CryptoService" else "signingCertificateStore"</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val servicesForResolution = ServicesForResolutionImpl(identityService, attachments, cordappProvider, networkParametersStorage, transactionStorage).also { attachments.servicesForResolution = it }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ // Directly use the X500 name to public key map, as the identity service requires the node identity to start correctly. database.transaction { val x500Map = PersistentIdentityService.createX500ToKeyMap(cacheFactory) require(configuration.myLegalName !in x500Map) { // There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues." } } log.info("$legalIdentityPrivateKeyAlias not found in key store, generating fresh key!") createAndStoreLegalIdentity(legalIdentityPrivateKeyAlias) signingCertificateStore = configuration.signingCertificateStore.get() // We need to resync after [createAndStoreLegalIdentity]. }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ // Step 1. Check trustStore, sslKeyStore and identitiesKeyStore exist. sslKeystore should exist only when using embedded Artemis and bridge. val certStores = try { requireNotNull(getCertificateStores()) { "One or more keyStores (identity or TLS) or trustStore not found. " + "Please either copy your existing keys and certificates from another node, " + "or if you don't have one yet, fill out the config file and run corda.jar initial-registration. " + "Read more at: https://docs.corda.net/permissioning.html" } } catch (e: KeyStoreException) { throw IllegalArgumentException("At least one of the keystores or truststore passwords does not match configuration.") } // Step 2. Check that trustStore contains the correct key-alias entry. require(CORDA_ROOT_CA in certStores.trustStore) { "Alias for trustRoot key not found. Please ensure you have an updated trustStore file." } // Step 3. Check that TLS keyStore contains the correct key-alias entry. Not necessary when using an external messaging server. certStores.sslKeyStore?.let { require(CORDA_CLIENT_TLS in certStores.sslKeyStore) { "Alias for TLS key not found. Please ensure you have an updated TLS keyStore file." } } // Step 4. Check that identity keyStores contain the correct key-alias entry for Node CA. require(CORDA_CLIENT_CA in certStores.identitiesKeyStore) { "Alias for Node CA key not found. Please ensure you have an updated identity keyStore file." } // Step 5. Check all cert paths chain to the trusted root. val trustRoot = certStores.trustStore[CORDA_ROOT_CA] certStores.sslKeyStore?.let { val sslCertChainRoot = certStores.sslKeyStore.query { getCertificateChain(CORDA_CLIENT_TLS) }.last() require(sslCertChainRoot == trustRoot) { "TLS certificate must chain to the trusted root." } } val nodeCaCertChainRoot = certStores.identitiesKeyStore.query { getCertificateChain(CORDA_CLIENT_CA) }.last() require(nodeCaCertChainRoot == trustRoot) { "Client CA certificate must chain to the trusted root." } if (configuration.devMode) { val blacklisted = isCRLDistributionPointBlacklisted(configuration.signingCertificateStore.get().query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }) if (blacklisted) { log.warn("The format of the autogenerated dev. mode certificate this system uses has been deprecated. Please contact support@r3.com for information on how to upgrade.") } } return trustRoot }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ // The following will throw IOException if key file not found or KeyStoreException if keystore password is incorrect. configuration.p2pSslOptions.keyStore.get() }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ // When using external Artemis and bridge, the node's TLS keystore should not be used by the node for any purpose. null }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ checkAliasMismatch(compositeKeyAlias, signingCertificateStore) // If [compositeKeyAlias] does not exist, we assume the notary is CFT, and each cluster member shares the same notary key pair. privateKeyAliasCertChain }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ log.debug { val driverClasses = DriverManager.getDrivers().asSequence().map { it.javaClass.name } "Available JDBC drivers: $driverClasses" } val props = configuration.dataSourceProperties if (props.isEmpty) throw DatabaseConfigurationException("There must be a database configured.") //Enterprise differs to Open Source as it doesn't distinguish internal schemas and Cordapp's schemas as all tables are created by Liquibase database.startHikariPool(props, configuration.database, schemaService.schemaOptions.keys, metricRegistry, this.cordappLoader, configuration.baseDirectory, configuration.myLegalName) // Now log the vendor string as this will also cause a connection to be tested eagerly. logVendorString(database, log) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ val certificate = signingCertificateStore[compositeKeyAlias] // We have to create the certificate chain for the composite key manually, this is because we don't have a keystore // provider that understand compositeKey-privateKey combo. The cert chain is created using the composite key certificate + // the tail of the private key certificates, as they are both signed by the same certificate chain. listOf(certificate) + privateKeyAliasCertChain.drop(1) }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode${ val loadedServices = cordappLoader.cordapps.flatMap { it.services } // This sets the Cordapp classloader on the contextClassLoader of the current thread, prior to initializing services // Needed because of bug CORDA-2653 - some Corda services can utilise third-party libraries that require access to // the Thread context class loader val oldContextClassLoader: ClassLoader? = Thread.currentThread().contextClassLoader try { Thread.currentThread().contextClassLoader = cordappLoader.appClassLoader loadedServices.forEach { try { installCordaService(it) } catch (e: NoSuchMethodException) { log.error("${it.name}, as a Corda service, must have a constructor with a single parameter of type " + ServiceHub::class.java.name) } catch (e: ServiceInstantiationException) { if (e.cause != null) { log.error("Corda service ${it.name} failed to instantiate. Reason was: ${e.cause?.rootMessage}", e.cause) } else { log.error("Corda service ${it.name} failed to instantiate", e) } } catch (e: Exception) { log.error("Unable to install Corda service ${it.name}", e) } } } finally { Thread.currentThread().contextClassLoader = oldContextClassLoader } }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.AppServiceHubImpl$private</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.AppServiceHubImpl$require(logicType.isAnnotationPresent(StartableByService::class.java)) { "${logicType.name} was not designed for starting by a CordaService" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$inner</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$override val attachmentTrustCalculator: AttachmentTrustCalculator get() = this@AbstractNode.attachmentTrustCalculator</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$override val networkParametersService: NetworkParametersStorage get() = this@AbstractNode.networkParametersStorage</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.ServiceHubInternalImpl$override val transactionVerifierService: TransactionVerifierService get() = this@AbstractNode.transactionVerifierService</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:AbstractNode.kt$FlowStarterImpl : FlowStarter</ID>
    <ID>MaxLineLength:AbstractNode.kt$ex is HikariPool.PoolInitializationException -&gt; throw CouldNotCreateDataSourceException("Could not connect to the database. Please check your JDBC connection URL, or the connectivity to the database.", ex)</ID>
    <ID>MaxLineLength:AbstractNode.kt$ex.cause is ClassNotFoundException -&gt; throw CouldNotCreateDataSourceException("Could not find the database driver class. Please add it to the 'drivers' folder. See: https://docs.corda.net/corda-configuration-file.html")</ID>
    <ID>MaxLineLength:AbstractNode.kt$fun CordaPersistence.startHikariPool(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>MaxLineLength:AbstractNode.kt$org.hibernate.type.descriptor.java.JavaTypeDescriptorRegistry.INSTANCE.addDescriptor(AbstractPartyDescriptor(wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous))</ID>
    <ID>MaxLineLength:AbstractNode.kt$return ClientRpcSslOptions(trustStorePath = nodeRpcOptions.sslConfig!!.keyStorePath, trustStorePassword = nodeRpcOptions.sslConfig!!.keyStorePassword)</ID>
    <ID>MaxLineLength:AbstractNode.kt$return CordaPersistence(databaseConfig, schemaService.schemaOptions.keys, cacheFactory, attributeConverters, customClassLoader)</ID>
    <ID>MaxLineLength:AbstractNode.kt$schemaMigration.nodeStartup(dataSource.connection.use { DBCheckpointStorage().getCheckpointCount(it) != 0L }, isH2Database(jdbcUrl))</ID>
    <ID>MaxLineLength:AbstractNode.kt$val attributeConverters = listOf(PublicKeyToTextConverter(), AbstractPartyToX500NameAsStringConverter(wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous))</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$ internal fun ensurePrivateKeyIsNotInKeyStoreFile(alias: String, nodeKeyStore: Path, keyStorePassword: String = DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$assertThat(result.stx.sigs.map { it.by.encoded!! }.filter { it.contentEquals(alicePubKey!!.encoded) }).hasSize(1)</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$assertThat(result.stx.sigs.single { it.by.encoded!!.contentEquals(alicePubKey!!.encoded) }.isValid(result.stx.id))</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$ensurePrivateKeyIsNotInKeyStoreFile("${X509Utilities.NODE_IDENTITY_ALIAS_PREFIX}-private-key", alice.baseDirectory / "certificates" / "nodekeystore.jks")</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$ensurePrivateKeyIsNotInKeyStoreFile(X509Utilities.CORDA_CLIENT_CA, alice.baseDirectory / "certificates" / "nodekeystore.jks")</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$AbstractNodeRegistrationTest$notaryCustomOverrides = mapOf("devMode" to false, "cordappSignerKeyFingerprintBlacklist" to listOf&lt;String&gt;())</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$assertEquals(privateKey.declaredField&lt;AlgorithmId&gt;("algid").value, aliasPrivateKey.declaredField&lt;AlgorithmId&gt;("algid").value)</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$assertTrue(privateKey.declaredField&lt;ByteArray&gt;("encodedKey").value.contentEquals(aliasPrivateKey.declaredField&lt;ByteArray&gt;("encodedKey").value))</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$assertTrue(privateKey.declaredField&lt;ByteArray&gt;("key").value.contentEquals(aliasPrivateKey.declaredField&lt;ByteArray&gt;("key").value))</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt$internal</ID>
    <ID>MaxLineLength:AbstractNodeRegistrationTest.kt${ val keyStore = KeyStore.getInstance(KEYSTORE_TYPE) keyStore.load(nodeKeyStore.inputStream(), keyStorePassword.toCharArray()) // The private key from the file. val privateKey = keyStore.getKey(alias, keyStorePassword.toCharArray()) // a new private key that should be identical. val aliasPrivateKey = PKCS8Key.parseKey(DerValue(AliasPrivateKey(alias).encoded)) assertTrue(aliasPrivateKey.encoded.contentEquals(privateKey.encoded)) // comparing the output of getEncoded() is not sufficient, because it is not necessarily a simple getter. Therefore we access the // actual fields that contain relevant data and make sure they are identical. assertTrue(privateKey.declaredField&lt;ByteArray&gt;("encodedKey").value.contentEquals(aliasPrivateKey.declaredField&lt;ByteArray&gt;("encodedKey").value)) assertTrue(privateKey.declaredField&lt;ByteArray&gt;("key").value.contentEquals(aliasPrivateKey.declaredField&lt;ByteArray&gt;("key").value)) assertEquals(privateKey.declaredField&lt;AlgorithmId&gt;("algid").value, aliasPrivateKey.declaredField&lt;AlgorithmId&gt;("algid").value) // Demonstrate that signing is not possible val ecSignature = Signature.getInstance("SHA256withECDSA") assertFailsWith&lt;InvalidKeyException&gt; { ecSignature.initSign(privateKey as PrivateKey) } // We don't really know what type of key it is at this point val rsaSignature = Signature.getInstance("SHA256withRSA") assertFailsWith&lt;InvalidKeyException&gt; { rsaSignature.initSign(privateKey as PrivateKey) } }</ID>
    <ID>MaxLineLength:AbstractNodeTests.kt$AbstractNodeTests$return "jdbc:h2:file:$baseDir/persistence;DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=10000;WRITE_DELAY=100;AUTO_SERVER_PORT=0"</ID>
    <ID>MaxLineLength:AbstractNodeTests.kt$AbstractNodeTests${ // Note this test also covers a transaction that CordaPersistence does while it's instantiating: val database = configureDatabase(hikariProperties(freshURL()), DatabaseConfig(), { null }, { null }) val log = mock&lt;Logger&gt;() // Don't care what happens here. // Actually 10 is enough to reproduce old code hang, as pool size is 10 and we leaked 9 connections and 1 is in flight: repeat(100) { logVendorString(database, log) } }</ID>
    <ID>MaxLineLength:AbstractParty.kt$AbstractParty$ override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:AbstractPartyDescriptor.kt$AbstractPartyDescriptor$private val wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?</ID>
    <ID>MaxLineLength:AbstractPartyToX500NameAsStringConverter.kt$AbstractPartyToX500NameAsStringConverter$private val wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?</ID>
    <ID>MaxLineLength:AbstractRPCTest.kt$AbstractRPCTest$startInVmRpcServer(ops = ops, rpcUser = rpcUser, configuration = serverConfiguration, queueDrainTimeout = queueDrainTimeout)</ID>
    <ID>MaxLineLength:AbstractRPCTest.kt$AbstractRPCTest$startRpcClient&lt;I&gt;(broker.hostAndPort!!, rpcUser.username, rpcUser.password, clientConfiguration)</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Acceptor&lt;in T&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Instigator&lt;out S : ContractState, out T : ContractState, out M&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Proposal&lt;out M&gt;</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$ @Throws(StateReplacementException::class) protected abstract fun verifyProposal(stx: SignedTransaction, proposal: Proposal&lt;T&gt;)</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$override val progressTracker: ProgressTracker = Acceptor.tracker()</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$require(myKey in requiredKeys) { "Party is not a participant for any of the input states of transaction ${stx.id}" }</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$@Suspendable private</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$return excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, originalState.state.data.participants)).map { initiateFlow(it.key) to it.value }</ID>
    <ID>MaxLineLength:AbstractWrappedKeysTest.kt$AbstractWrappedKeysTest$notaryCustomOverrides = mapOf("devMode" to false, "cordappSignerKeyFingerprintBlacklist" to listOf&lt;String&gt;())</ID>
    <ID>MaxLineLength:Action.kt$Action$RetryFlowFromSafePoint : Action</ID>
    <ID>MaxLineLength:Action.kt$Action$ScheduleFlowTimeout : Action</ID>
    <ID>MaxLineLength:Action.kt$Action.PersistCheckpoint$data</ID>
    <ID>MaxLineLength:Action.kt$FlowRemovalReason${ data class OrderlyFinish(val flowReturnValue: Any?) : FlowRemovalReason() data class ErrorFinish(val flowErrors: List&lt;FlowError&gt;) : FlowRemovalReason() object SoftShutdown : FlowRemovalReason() { override fun toString() = "SoftShutdown" } // TODO Should we remove errored flows? How will the flow hospital work? Perhaps keep them in memory for a while, flush // them after a timeout, reload them on flow hospital request. In any case if we ever want to remove them // (e.g. temporarily) then add a case for that here. }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$detailedLogger.trace { "Flow(action=propagate_error;flowId=$currentFlowId,exception=${exception?.message})" }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$detailedLogger.trace { "Flow(action=retry_safe_point;flowId=$currentFlowId;flow=${action.currentState.flowLogic};subFlows=[${checkpoint.subFlowStack.joinToString { it.flowClass.simpleName }}];state=${checkpoint.flowState::class.simpleName};error=${checkpoint.errorState::class.simpleName};suspends=${checkpoint.numberOfSuspends})" }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$detailedLogger.trace { "Session(action=send_existing_message;flowId=$currentFlowId;message=${action.message::class.simpleName};id=${action.deduplicationId.deduplicationId.toString};recipient=${action.peerParty})" }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$detailedLogger.trace { "Session(action=send_initial_message;flowId=$currentFlowId;initiatorFlow=${action.initialise.initiatorFlowClassName};id=${action.deduplicationId.deduplicationId.toString};appName=${action.initialise.appName};flowVersion=${action.initialise.flowVersion};recipient=${action.destination})" }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$flowMessaging.sendSessionMessage(sessionState.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, action.senderUUID))</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$private val checkpointBandwidth = metrics.register("Flows.CheckpointVolumeBytesPerSecondCurrent", LatchedGauge(checkpointSizesThisSecond))</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$private val checkpointBandwidthHist = metrics.register("Flows.CheckpointVolumeBytesPerSecondHist", Histogram(SlidingTimeWindowArrayReservoir(1, TimeUnit.DAYS)))</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$driver</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$haConfig["additionalP2PAddresses"] = ConfigValueFactory.fromIterable(listOf(altAddress))</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$startNode(providedName = DUMMY_BANK_A_NAME, rpcUsers = listOf(testUser), customOverrides = haConfig)</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$startNode(providedName = DUMMY_BANK_B_NAME, rpcUsers = listOf(testUser), customOverrides = mapOf("p2pAddress" to portAllocation.nextHostAndPort().toString()))</ID>
    <ID>MaxLineLength:AdditionalNodeInfoCollector.kt$AdditionalNodeInfoCollector : TrackedCollector</ID>
    <ID>MaxLineLength:Address.kt$Address.Companion$return Validated.invalid(sequenceOf("Value format is \"&lt;host(String)&gt;:&lt;port:(Int)&gt;\"").map(mapError).toSet())</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `rpc address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `rpc admin address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertBindExceptionForOverrides { address -&gt; mapOf("h2Settings" to mapOf("address" to address.toString()), "dataSourceProperties.dataSource.password" to "password") }</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertThat(exception.addresses).contains(address).withFailMessage("Expected addresses to contain $address but was ${exception.addresses}.")</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertThatThrownBy { startNode(customOverrides = overrides(address)).getOrThrow() }</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assumeTrue(!IntegrationTest.isRemoteDatabaseMode())</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$driver</ID>
    <ID>MaxLineLength:AffinityExecutor.kt$AffinityExecutor$ fun executeASAP(runnable: () -&gt; Unit)</ID>
    <ID>MaxLineLength:AggregatedList.kt$AggregatedList&lt;A, E : Any, K : Any&gt; : TransformationList</ID>
    <ID>MaxLineLength:AliasPrivateKeyTest.kt$AliasPrivateKeyTest$signingCertStore.query { setPrivateKey(alias, aliasPrivateKey, listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), "entrypassword") }</ID>
    <ID>MaxLineLength:AliasPrivateKeyTest.kt$AliasPrivateKeyTest$val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "keystorepass").get(createNew = true)</ID>
    <ID>MaxLineLength:AliasPrivateKeyTest.kt$AliasPrivateKeyTest${ val alias = "01234567890" val aliasPrivateKey = AliasPrivateKey(alias) val certificatesDirectory = tempFolder.root.toPath() val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "keystorepass").get(createNew = true) signingCertStore.query { setPrivateKey(alias, aliasPrivateKey, listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), "entrypassword") } // We can retrieve the certificate. assertTrue { signingCertStore.contains(alias) } // We can retrieve the certificate. assertEquals(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT, signingCertStore[alias]) // Although we can store an AliasPrivateKey, we cannot retrieve it. But, it's fine as we use certStore for storing/handling certs only. assertEquals(aliasPrivateKey, signingCertStore.query { getPrivateKey(alias, "entrypassword") }) }</ID>
    <ID>MaxLineLength:AliasProvidingKeyMangerWrapper.kt$AliasProvidingExtendedKeyMangerWrapper : X509ExtendedKeyManagerX509KeyManagerAliasProvidingKeyMangerWrapper</ID>
    <ID>MaxLineLength:AliasProvidingKeyMangerWrapper.kt$AliasProvidingExtendedKeyMangerWrapper$override</ID>
    <ID>MaxLineLength:AliasProvidingKeyMangerWrapper.kt$AliasProvidingKeyMangerWrapperImpl : AliasProvidingKeyMangerWrapperX509KeyManager</ID>
    <ID>MaxLineLength:AliasProvidingKeyMangerWrapper.kt$AliasProvidingKeyMangerWrapperImpl$override</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted : ClassWhitelist</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted$ override fun hasListed(type: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted$throw IllegalStateException("The $matchType $aMatch of ${type.name} is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted${ // TODO: blacklistedClasses += type.name // add it, so checking is faster next time we encounter this class. val matchType = if (Class.forName(aMatch).isInterface) "superinterface" else "superclass" throw IllegalStateException("The $matchType $aMatch of ${type.name} is blacklisted, so it cannot be used in serialization.") }</ID>
    <ID>MaxLineLength:Amount.kt$Amount$Companion</ID>
    <ID>MaxLineLength:Amount.kt$Amount$operator</ID>
    <ID>MaxLineLength:Amount.kt$Amount$require(other.displayTokenSize == displayTokenSize) { "Token size mismatch: ${other.displayTokenSize} vs $displayTokenSize" }</ID>
    <ID>MaxLineLength:Amount.kt$Amount${ // Amount represents a static balance of physical assets as managed by the distributed ledger and is not allowed // to become negative a rule further maintained by the Contract verify method. // N.B. If concepts such as an account overdraft are required this should be modelled separately via Obligations, // or similar second order smart contract concepts. require(quantity &gt;= 0) { "Negative amounts are not allowed: $quantity" } }</ID>
    <ID>MaxLineLength:Amount.kt$Amount.Companion$ @JvmStatic @JvmOverloads fun &lt;T : Any&gt; fromDecimal(displayQuantity: BigDecimal, token: T, rounding: RoundingMode = RoundingMode.FLOOR): Amount&lt;T&gt;</ID>
    <ID>MaxLineLength:Amount.kt$Amount.Companion$ @JvmStatic fun &lt;T : Any&gt; Iterable&lt;Amount&lt;T&gt;&gt;.sumOrZero(token: T)</ID>
    <ID>MaxLineLength:Amount.kt$Amount&lt;T : Any&gt; : Comparable</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$ @Suppress("UNUSED") fun novate(centralParty: P): List&lt;AmountTransfer&lt;T, P&gt;&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$destination: P = this.destination</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$remaining = SourceAndAmount(payer, balance.amount.copy(quantity = Math.subtractExact(balance.amount.quantity, residual)), newRef)</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$result = 31 * result + (source.hashCode() xor destination.hashCode())</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer.Companion$ @JvmStatic @JvmOverloads fun &lt;T : Any, P : Any&gt; fromDecimal(displayQuantityDelta: BigDecimal, token: T, source: P, destination: P, rounding: RoundingMode = RoundingMode.DOWN): AmountTransfer&lt;T, P&gt;</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer.Companion$destination: P</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer&lt;T : Any, P : Any&gt;</ID>
    <ID>MaxLineLength:Amount.kt$TokenizableAssetInfo$/** The nominal display unit size of a single token, potentially with trailing decimal display places if the scale parameter is non-zero. */ val displayTokenSize: BigDecimal</ID>
    <ID>MaxLineLength:AmountTest.kt$AmountTest$assertThat(yamlMapper.valueToTree&lt;TextNode&gt;(Amount.parseCurrency("$250000"))).isEqualTo(TextNode("250000.00 USD"))</ID>
    <ID>MaxLineLength:AmountTest.kt$AmountTest$assertThat(yamlMapper.valueToTree&lt;TextNode&gt;(Amount.parseCurrency("25000000"))).isEqualTo(TextNode("25000000.00 GBP"))</ID>
    <ID>MaxLineLength:AmountTests.kt$AmountTests$val collector = Collectors.toMap&lt;SourceAndAmount&lt;Currency, String&gt;, Pair&lt;String, Currency&gt;, BigDecimal&gt;({ Pair(it.source, it.amount.token) }, { it.amount.toDecimal() }, { x, y -&gt; x + y })</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$AnalyticsEngine$ratesProvider: ImmutableRatesProvider</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$ override fun calculateSensitivitiesBatch(trades: List&lt;ResolvedSwapTrade&gt;, pricer: DiscountingSwapProductPricer, ratesProvider: ImmutableRatesProvider): Map&lt;ResolvedSwapTrade, CurrencyAmount&gt;</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$override</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$portfolioMargin: InitialMarginTriple</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$ratesProvider: ImmutableRatesProvider</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$val calculatorTotal = RwamBimmNotProductClassesCalculator(fxRateProvider, Currency.EUR, IsdaConfiguration.INSTANCE)</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$val t = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, it.value.currencyParameterSensitivities, it.value.multiCurrencyAmount)</ID>
    <ID>MaxLineLength:AnonymousParty.kt$AnonymousParty : DestinationAbstractParty</ID>
    <ID>MaxLineLength:AnotherDummyContract.kt$AnotherDummyContract$return TransactionBuilder(notary).withItems(StateAndContract(state, ANOTHER_DUMMY_PROGRAM_ID), Command(Commands.Create(), owner.party.owningKey))</ID>
    <ID>MaxLineLength:AppServiceHub.kt$AppServiceHub : ServiceHub</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ fun addOrUpdate(key: K, value: V, updateFn: (K, V) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ fun addWithDuplicatesAllowed(key: K, value: V, logWarning: Boolean = true): Boolean</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ operator fun set(key: K, value: V)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$log.warn("Double insert in ${this.javaClass.name} for entity class $persistentEntityClass key $key, not inserting the second time")</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$oldValueInCache</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // IMPORTANT: The flush is needed because detach() makes the queue of unflushed entries invalid w.r.t. Hibernate internal state if the found entity is unflushed. // We want the detach() so that we rely on our cache memory management and don't retain strong references in the Hibernate session. session.flush() }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // If someone is writing (but not us) // For those not writing, they need to re-load the value from the database (which their database transaction MIGHT see). // For those writing, they need to re-load the value from the database (which their database transaction CAN see). Transactional.InFlight(this, key, { loadValue(key) }, { loadValue(key)!! }) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // If we found a value already in the database, and we were not already writing, then it's already committed but got evicted. Transactional.Committed(oldValue) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // Some database transactions, including us, writing, with readers seeing whatever is in the database and writers seeing the (in memory) value. Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // Someone else is writing, so store away! val retainedValueFromDB = store(key, value) wasWritten = (retainedValueFromDB == null) // If the store function claims the value is new in the DB, then either the value is brand new or updated. In this case, // update the old value in the cache with the new value. Otherwise, leave it as it was before. if (wasWritten) { oldValueInCache.apply { alsoWrite(value) } } else { oldValueInCache } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ val retainedValueFromDB = store(key, value) wasWritten = (retainedValueFromDB == null) // If the value has been updated, then isUnique will be true. In this case, the Committed value needs to be replaced // with InFlight to indicate that this transaction has changed the value associated with this key. Note that this allows // for cases where the value passed to set differs from that in the cache, but an update function has decided that this // differing value should not be written to the database. if (wasWritten) { Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) } } else { oldValueInCache } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional$InFlight&lt;K, T&gt; : Transactional</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$// The value from the perspective of the eviction algorithm of the cache. i.e. we want to reveal memory footprint to it etc. override val peekableValue: T? get() = if (writerValueLoader.get() != _writerValueLoader) writerValueLoader.get()() else if (readerValueLoader.get() != _readerValueLoader) readerValueLoader.get()() else null</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$get() = if (isPresentAsWriter) loadAsWriter() else if (isPresentAsReader) loadAsReader()!! else throw NoSuchElementException("Not present")</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$get() = if (writerValueLoader.get() != _writerValueLoader) writerValueLoader.get()() else if (readerValueLoader.get() != _readerValueLoader) readerValueLoader.get()() else null</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$private val _writerValueLoader: () -&gt; T = { throw IllegalAccessException("No value loader provided") }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight${ // Make the lazy loader the writers see actually just return the value that has been set. writerValueLoader.set { _value } // We make all these vals so that the lambdas do not need a reference to this, and so the onCommit only has a weak ref to the value. // We want this so that the cache could evict the value (due to memory constraints etc) without the onCommit callback // retaining what could be a large memory footprint object. val tx = contextTransaction val strongKey = key val strongMap = map if (map.addPendingKey(key, tx)) { // If the transaction commits, update cache to make globally visible if we're first for this key, // and then stop saying the transaction is writing the key. tx.onCommit { strongMap.cache.asMap().computeIfPresent(strongKey) { _, transactional: Transactional&lt;T&gt; -&gt; if (transactional is Transactional.InFlight&lt;*, T&gt;) { transactional.committed.set(true) val value = transactional.peekableValue if (value != null) { Transactional.Committed(value) } else { transactional } } else { transactional } } strongMap.removePendingKey(strongKey, tx) } // If the transaction rolls back, stop saying this transaction is writing the key. tx.onRollback { strongMap.removePendingKey(strongKey, tx) } } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.Unknown$val readValue = _valueLoader() // We re-write the value into the cache so that any weigher can re-assess the weight based on the loaded value. map.cache.asMap().compute(key) { _, oldValue -&gt; if (oldValue === this@Unknown) { if (readValue == null) Missing() else Committed(readValue) } else oldValue } readValue</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapNonConcurrentTest.kt$AppendOnlyPersistentMapNonConcurrentTest$NodeSchemaService(setOf(MappedSchema(AppendOnlyPersistentMapTest::class.java, 1, listOf(AppendOnlyPersistentMapNonConcurrentTest.PersistentMapEntry::class.java))))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$NodeSchemaService(setOf(MappedSchema(AppendOnlyPersistentMapTest::class.java, 1, listOf(PersistentMapEntry::class.java))))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.SuccessButErrorOnCommit))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit), Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest${ // Writes intentionally do not check the database first, so purging between read and write changes behaviour // Also, a purge after write causes the subsequent read to flush to the database, causing the read to generate a constraint violation when single threaded (in same database transaction). val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit), Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)) scenario = remapped[scenario] ?: scenario prepopulateIfRequired() val map = createMap() val a = TestThread("A", map, true).apply { phase1.countDown() phase3.countDown() } val b = TestThread("B", map, true).apply { phase1.countDown() phase3.countDown() } try { database.transaction { a.run() map.invalidate() b.run() } } catch (t: PersistenceException) { // This only helps if thrown on commit, otherwise other latches not counted down. assertEquals(t.message, Outcome.SuccessButErrorOnCommit, a.outcome) } a.await(a::phase4) b.await(b::phase4) assertTrue(map.pendingKeysIsEmpty()) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(false, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.Read, Outcome.Success, Outcome.Fail, Outcome.Success)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(false, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.WriteDuplicateAllowed, Outcome.Success, Outcome.SuccessButErrorOnCommit, Outcome.Fail)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(true, ReadOrWrite.Write, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(true, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.WriteDuplicateAllowed, Outcome.Fail, Outcome.Fail)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$inner</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$val outcome = if (name == "A") scenario.aExpected else if (singleThreaded) scenario.bExpectedIfSingleThreaded else scenario.bExpected</ID>
    <ID>MaxLineLength:Arrangement.kt$And : Arrangement</ID>
    <ID>MaxLineLength:Arrangement.kt$Obligation$data</ID>
    <ID>MaxLineLength:Arrangement.kt$RollOut$data</ID>
    <ID>MaxLineLength:ArraySerializer.kt$PrimBooleanArraySerializer : PrimArraySerializer</ID>
    <ID>MaxLineLength:ArtemisBroker.kt$fun java.io.IOException.isBindingError()</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool : HAToolBase</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--acceptor-address"], converter = [NetworkHostAndPortConverter::class], description = ["The broker instance acceptor network address for incoming connections."], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--cluster-password"], description = ["Artemis cluster password."], defaultValue = DEFAULT_CLUSTER_PASSWORD)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--cluster-user"], description = ["The username of the Artemis cluster."], defaultValue = "corda-cluster-user")</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--connectors"], converter = [NetworkHostAndPortConverter::class], split = ",", description = ["A list of network hosts and ports separated by commas representing the artemis connectors used for the Artemis HA cluster. The first entry in the list will be used by the instance configured by this tool."])</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--keystore"], converter = [URIValueValidator::class], description = ["The SSL keystore path."], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--keystore-password"], converter = [URIValueValidator::class], description = ["The SSL keystore password."], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--path"], description = ["The path where the generated configuration files will be installed."], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--truststore"], converter = [URIValueValidator::class], description = ["The SSL truststore path."], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--truststore-password"], converter = [URIValueValidator::class], description = ["The SSL truststore password."], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$@Option(names = ["--user"], converter = [CordaX500NameConverter::class], description = ["The X500 name of connecting users (clients). Example value: \"CN=artemis, O=Corda, L=London, C=GB\""], required = true)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$it.textContent = String.format(ACCEPTOR_STRING, acceptorHostAndPort, keyStore, keyStorePass, trustStore, trustStorePass)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$javaClass.classLoader.getResourceAsStream("login.config").copyTo(workingDir / "login.config", StandardCopyOption.REPLACE_EXISTING)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$printWarning("Using default cluster password, please consider changing the password in broker.xml or provide a password using --cluster-password.")</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$require(dist != null) { printError("Attempting to create a new Artemis instance. Distribution path missing.") }</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$require(dist!!.isDirectory() &amp;&amp; (dist!!/"bin"/"artemis").exists()) { "Invalid artemis distribution directory path $dist, please extract the content prior running the utility if the distribution is in a compressed file." }</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$textContent = String.format(CONNECTOR_STRING, address, keyStore, keyStorePass, trustStore, trustStorePass)</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool$val args = "create corda_p2p_broker --allow-anonymous --user $ARTEMIS_DEFAULT_USER --password $ARTEMIS_DEFAULT_USER_PASS -- $workingDir"</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool${ // If the file already exists, read the journal-buffer-timeout and configure the same in the newly generated broker.xml val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file) val elements = doc.getElementsByTagName("journal-buffer-timeout") elements.item(0).textContent }</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool.Companion$private const val ACCEPTOR_STRING = "tcp://%s?tcpSendBufferSize=1048576;tcpReceiveBufferSize=1048576;protocols=CORE,AMQP;useEpoll=true;amqpCredits=1000;amqpLowCredits=300;sslEnabled=true;keyStorePath=%s;keyStorePassword=%s;trustStorePath=%s;trustStorePassword=%s;needClientAuth=true;enabledCipherSuites=TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;enabledProtocols=TLSv1.2"</ID>
    <ID>MaxLineLength:ArtemisConfigurationTool.kt$ArtemisConfigurationTool.Companion$private const val CONNECTOR_STRING = "tcp://%s?sslEnabled=true;keyStorePath=%s;keyStorePassword=%s;trustStorePath=%s;trustStorePassword=%s"</ID>
    <ID>MaxLineLength:ArtemisConfigurationToolTest.kt$ArtemisConfigurationToolTest$allLines.contains("&lt;acceptor name=\"artemis\"&gt;tcp://fbantesting-notary:11005?tcpSendBufferSize=1048576;tcpReceiveBufferSize=1048576;protocols=CORE,AMQP;useEpoll=true;amqpCredits=1000;amqpLowCredits=300;sslEnabled=true;keyStorePath=artemis.jks;keyStorePassword=artemisStorePass;trustStorePath=artemis-truststore.jks;trustStorePassword=artemisTrustpass;needClientAuth=true;enabledCipherSuites=TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;enabledProtocols=TLSv1.2&lt;/acceptor&gt;")</ID>
    <ID>MaxLineLength:ArtemisConfigurationToolTest.kt$ArtemisConfigurationToolTest$allLines.contains("keyStorePath=../bridge/artemiscerts/artemis.jks;keyStorePassword=artemisStorePass123;trustStorePath=../bridge/artemiscerts/artemis-truststore.jks;trustStorePassword=artemisTrustpass123")</ID>
    <ID>MaxLineLength:ArtemisConnectionTest.kt$ArtemisConnectionTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = true)).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:ArtemisConnectionTest.kt$ArtemisConnectionTest$return CryptoServiceSigningService(conf.artemisCryptoServiceConfig, DUMMY_BANK_A_NAME, artemisSSlConfiguration, conf.sslHandshakeTimeout, name = "Artemis")</ID>
    <ID>MaxLineLength:ArtemisConnectionTest.kt$ArtemisConnectionTest$val artemisServer = ArtemisMessagingServer(artemisConfig, NetworkHostAndPort("0.0.0.0", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:ArtemisConnectionTest.kt$ArtemisConnectionTest$val artemisService = BridgeArtemisConnectionServiceImpl(artemisSigningService, bridgeConfig, MAX_MESSAGE_SIZE, auditService)</ID>
    <ID>MaxLineLength:ArtemisConnectionTest.kt$ArtemisConnectionTest${ val configResource = "/net/corda/bridge/singleprocess/firewall.conf" createNetworkParams(tempFolder.root.toPath()) val bridgeConfig = createAndLoadConfigFromResource(tempFolder.root.toPath(), configResource) bridgeConfig.createBridgeKeyStores(DUMMY_BANK_A_NAME) val auditService = TestAuditService() val artemisSigningService = createArtemisSigningService(bridgeConfig) val artemisService = BridgeArtemisConnectionServiceImpl(artemisSigningService, bridgeConfig, MAX_MESSAGE_SIZE, auditService) val stateFollower = artemisService.activeChange.toBlocking().iterator // Starting artemisService on it own is not enough for it to be active. *All* the dependencies should be started as well. artemisService.start() assertEquals(false, stateFollower.next()) assertEquals(false, artemisService.active) assertNull(artemisService.started) // Starting Audit Service - but this is still not enough auditService.start() assertEquals(false, artemisService.active) assertNull(artemisService.started) // Starting Signing Service - but this is still not enough artemisSigningService.start() assertEquals(false, artemisService.active) assertNull(artemisService.started) // Finally creating Artemis bus should trigger it into the active state var artemisServer = createArtemis() try { assertEquals(true, stateFollower.next()) assertEquals(true, artemisService.active) assertNotNull(artemisService.started) // Ensure status correct after stop auditService.stop() assertEquals(false, stateFollower.next()) assertEquals(false, artemisService.active) assertNull(artemisService.started) // Ensure status correctly reflected after re-start auditService.start() assertEquals(true, stateFollower.next()) assertEquals(true, artemisService.active) assertNotNull(artemisService.started) } finally { artemisServer.stop() } // Since Artemis been stopped check status. assertEquals(false, stateFollower.next()) assertEquals(false, artemisService.active) assertNull(artemisService.started) // Re-create message bus and ensure active status correctly reflects that. artemisServer = createArtemis() try { assertEquals(true, stateFollower.next()) assertEquals(true, artemisService.active) assertNotNull(artemisService.started) } finally { artemisServer.stop() } // Ensure no longer active and tidy-up assertEquals(false, stateFollower.next()) assertEquals(false, artemisService.active) assertNull(artemisService.started) auditService.stop() artemisSigningService.stop() artemisService.stop() }</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$Started</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$callFailoverTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT)</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$callTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT)</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$private val messagingServerConnectionConfig: MessagingServerConnectionConfiguration? = null</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$val locator = ActiveMQClient.createServerLocator(backupTransports.isNotEmpty(), *(listOf(tcpTransport) + backupTransports).toTypedArray()).apply { // Never time out on our loopback Artemis connections. If we switch back to using the InVM transport this // would be the default and the two lines below can be deleted. connectionTTL = 60000 clientFailureCheckPeriod = 30000 callFailoverTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT) callTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT) minLargeMessageSize = maxMessageSize isUseGlobalPools = nodeSerializationEnv != null confirmationWindowSize = this@ArtemisMessagingClient.confirmationWindowSize producerWindowSize = -1 messagingServerConnectionConfig?.let { connectionLoadBalancingPolicyClassName = RoundRobinConnectionPolicy::class.java.canonicalName reconnectAttempts = messagingServerConnectionConfig.reconnectAttempts(isHA) retryInterval = messagingServerConnectionConfig.retryInterval().toMillis() retryIntervalMultiplier = messagingServerConnectionConfig.retryIntervalMultiplier() maxRetryInterval = messagingServerConnectionConfig.maxRetryInterval(isHA).toMillis() isFailoverOnInitialConnection = messagingServerConnectionConfig.failoverOnInitialAttempt(isHA) initialConnectAttempts = messagingServerConnectionConfig.initialConnectAttempts(isHA) } addIncomingInterceptor(ArtemisMessageSizeChecksInterceptor(maxMessageSize)) }</ID>
    <ID>MaxLineLength:ArtemisMessagingClient.kt$ArtemisMessagingClient$val session = sessionFactory!!.createSession(NODE_P2P_USER, NODE_P2P_USER, false, autoCommitSends, autoCommitAcks, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion$const val PEERS_PREFIX = "${INTERNAL_PREFIX}peers." //TODO Come up with better name for common peers/services queue</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion.P2PMessagingHeaders$/** * In the operation mode where we have an out of process bridge we cannot correctly populate the Artemis validated user header * as the TLS does not terminate directly onto Artemis. We therefore use this internal only header to forward * the equivalent information from the Float. */ val bridgedCertificateSubject = SimpleString("sender-subject-name")</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.RemoteInboxAddress.Companion$require(address.startsWith(P2P_PREFIX)) { "Failed to map topic: $address to a local address as it is not in the $P2P_PREFIX namespace" }</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.RemoteInboxAddress.Companion$require(address.startsWith(PEERS_PREFIX)) { "Failed to map address: $address to a remote topic as it is not in the $PEERS_PREFIX namespace" }</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$ private fun ConfigurationImpl.configureAddressSecurity(): Configuration</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$acceptorConfigurations = mutableSetOf(p2pAcceptorTcpTransport(NetworkHostAndPort(messagingServerAddress.host, messagingServerAddress.port), config.p2pSslOptions))</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$deleteNonDurableQueue</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$deleteNonDurableQueue: Boolean = false</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalBufferSize_AIO = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalBufferSize_NIO = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalFileSize = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$private</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$securityRoles["$INTERNAL_PREFIX#"] = setOf(nodeInternalRole)</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$// Redelivery from a sender who stops and restarts (some re-sends from the sender, with sender state reset with exception of recovered checkpoints) @Test fun `re-send from different client is ignored`()</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$// Redelivery to a receiver who stops and restarts (some re-deliveries from Artemis, but with receiver state reset), but the original // messages were recorded as consumed out of order, and only the *second* message was acked. @Test fun `re-receive from different client is not ignored when acked out of order`()</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$// The try-finally causes the test to fail if there's a duplicate insert (which, naturally, is an error but otherwise gets swallowed). try { database.transaction { handle.insideDatabaseTransaction() } } finally { handle.afterDatabaseTransaction() // We ACK first so that if it fails we won't get a duplicate in [receivedMessages] receivedMessages.add(msg) }</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$database = configureDatabase(makeInternalTestDataSourceProperties(configSupplier = { ConfigFactory.empty() }), DatabaseConfig(runMigration = true), { null }, { null })</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000))).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$handle.afterDatabaseTransaction()</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$networkMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, rigorousMock()).apply { start(emptyList()) }</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$private</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$val (messagingClient, receivedMessages) = createAndStartClientAndServer(clientMaxMessageSize = 100_000, serverMaxMessageSize = 50_000)</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$val (messagingClient1, receivedMessages) = createAndStartClientAndServer(dontAckCondition = { received -&gt; String(received.data.bytes, Charsets.UTF_8) == "first msg" })</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest${ val receivedMessages = LinkedBlockingQueue&lt;ReceivedMessage&gt;() createMessagingServer(maxMessageSize = serverMaxMessageSize).start() val messagingClient = createMessagingClient(platformVersion = platformVersion) messagingClient.addMessageHandler(TOPIC) { message, _, handle -&gt; if (dontAckCondition(message)) return@addMessageHandler database.transaction { handle.insideDatabaseTransaction() } handle.afterDatabaseTransaction() // We ACK first so that if it fails we won't get a duplicate in [receivedMessages] receivedMessages.add(message) } createAndStartArtemisSigningService(null, p2pSslConfiguration) startNodeMessagingClient(maxMessageSize = clientMaxMessageSize) // Run after the handlers are added, otherwise (some of) the messages get delivered and discarded / dead-lettered. thread(isDaemon = true) { messagingClient.run() } return Pair(messagingClient, receivedMessages) }</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker$throw AddressBindingException(adminAddressOptional?.let { setOf(it, addresses.primary) } ?: setOf(addresses.primary))</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker$val serverConfiguration = RpcBrokerConfiguration(baseDirectory, maxMessageSize, jmxEnabled, addresses.primary, adminAddressOptional, sslOptions, useSsl, nodeConfiguration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.&lt;no name provided&gt;$return arrayOf(AppConfigurationEntry(name, AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, options))</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$fun withSsl(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, sslOptions: BrokerRpcSslOptions, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean): ArtemisBroker</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$fun withoutSsl(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean): ArtemisBroker</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$return ArtemisRpcBroker(address, adminAddress, null, false, securityManager, maxMessageSize, jmxEnabled, baseDirectory, configuration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$return ArtemisRpcBroker(address, adminAddress, sslOptions, true, securityManager, maxMessageSize, jmxEnabled, baseDirectory, configuration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$ArtemisRpcBroker.withSsl(nodeSSlconfig, address, adminAddress, brokerSslOptions!!, securityManager, maxMessageSize, jmxEnabled, baseDirectory, false)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$ArtemisRpcBroker.withoutSsl(nodeSSlconfig, address, adminAddress, securityManager, maxMessageSize, jmxEnabled, baseDirectory, false)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$InternalRPCMessagingClient&lt;TestRpcOps&gt;(nodeSSlconfig, adminAddress, maxMessageSize, CordaX500Name("MegaCorp", "London", "GB"), RPCServerConfiguration.DEFAULT, artemisSigningServiceName(nodeSSlconfig))</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$private</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$( // Basic TCP target details. TransportConstants.HOST_PROP_NAME to hostAndPort.host, TransportConstants.PORT_PROP_NAME to hostAndPort.port, // Turn on AMQP support, which needs the protocol jar on the classpath. // Unfortunately we cannot disable core protocol as artemis only uses AMQP for interop. // It does not use AMQP messages for its own messages e.g. topology and heartbeats. // TODO further investigate how to ensure we use a well defined wire level protocol for Node to Node communications. TransportConstants.PROTOCOLS_PROP_NAME to "CORE,AMQP", TransportConstants.USE_GLOBAL_WORKER_POOL_PROP_NAME to (nodeSerializationEnv != null), TransportConstants.REMOTING_THREADS_PROPNAME to (if (nodeSerializationEnv != null) -1 else 1), // turn off direct delivery in Artemis - this is latency optimisation that can lead to //hick-ups under high load (CORDA-1336) TransportConstants.DIRECT_DELIVER to false)</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, config: MutualSslConfiguration?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, keyStore: FileBasedCertificateStoreSupplier?, trustStore: FileBasedCertificateStoreSupplier?, enableSSL: Boolean = true, useOpenSsl: Boolean = false): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pConnectorTcpTransport(hostAndPort: NetworkHostAndPort, config: MutualSslConfiguration?, enableSSL: Boolean = true, keyStoreProvider: String? = null): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pConnectorTcpTransport(hostAndPort: NetworkHostAndPort, keyStore: FileBasedCertificateStoreSupplier?, trustStore: FileBasedCertificateStoreSupplier?, enableSSL: Boolean = true, useOpenSsl: Boolean = false, keyStoreProvider: String? = null): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pConnectorTcpTransportFromList(hostAndPortList: List&lt;NetworkHostAndPort&gt;, config: MutualSslConfiguration?, enableSSL: Boolean = true, keyStoreProvider: String? = null): List&lt;TransportConfiguration&gt;</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, config: BrokerRpcSslOptions?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcConnectorTcpTransport(hostAndPort: NetworkHostAndPort, config: ClientRpcSslOptions?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcConnectorTcpTransportsFromList(hostAndPortList: List&lt;NetworkHostAndPort&gt;, config: ClientRpcSslOptions?, enableSSL: Boolean = true): List&lt;TransportConfiguration&gt;</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcInternalAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, config: SslConfiguration, keyStoreProvider: String? = null): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcInternalClientTcpTransport(hostAndPort: NetworkHostAndPort, config: SslConfiguration, keyStoreProvider: String? = null): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$internal val acceptorFactoryClassName = "org.apache.activemq.artemis.core.remoting.impl.netty.NettyAcceptorFactory"</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$options[TransportConstants.HANDSHAKE_TIMEOUT] = 0</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$options[TransportConstants.SSL_PROVIDER] = if (useOpenSsl) TransportConstants.OPENSSL_PROVIDER else TransportConstants.DEFAULT_SSL_PROVIDER</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$private</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return TransportConfiguration(acceptorFactoryClassName, defaultArtemisOptions(hostAndPort) + defaultSSLOptions + config.toTransportOptions() + (TransportConstants.HANDSHAKE_TIMEOUT to 0) + asMap(keyStoreProvider))</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return TransportConfiguration(connectorFactoryClassName, defaultArtemisOptions(hostAndPort) + defaultSSLOptions + config.toTransportOptions() + asMap(keyStoreProvider))</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return keyStoreProvider?.let {mutableMapOf(TransportConstants.KEYSTORE_PROVIDER_PROP_NAME to it)} ?: emptyMap()</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return p2pAcceptorTcpTransport(hostAndPort, config?.keyStore, config?.trustStore, enableSSL = enableSSL, useOpenSsl = config?.useOpenSsl ?: false)</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return p2pConnectorTcpTransport(hostAndPort, config?.keyStore, config?.trustStore, enableSSL = enableSSL, useOpenSsl = config?.useOpenSsl ?: false, keyStoreProvider = keyStoreProvider)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$&lt;no name provided&gt;$override val keyStore = FileBasedCertificateStoreSupplier(artemisCertDir / ARTEMIS_KEYSTORE, keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$&lt;no name provided&gt;$override val keyStore = FileBasedCertificateStoreSupplier(certificateDir / "sslkeystore.jks", keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$&lt;no name provided&gt;$override val trustStore = FileBasedCertificateStoreSupplier(artemisCertDir / ARTEMIS_TRUSTSTORE, truststorePassword, truststorePassword)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$&lt;no name provided&gt;$override val trustStore = FileBasedCertificateStoreSupplier(certificateDir / "truststore.jks", truststorePass, truststorePass)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$RoundRobinConnectionPolicy : ConnectionLoadBalancingPolicy</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$acceptorConfigurations = mutableSetOf(ArtemisTcpTransport.p2pAcceptorTcpTransport(NetworkHostAndPort("0.0.0.0", p2pPort), p2pSslOptions))</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$config.configureDevKeyAndTrustStores(x500Name, nodeKeystore, certificateDir, cryptoService?.let { ManagedCryptoService(it) })</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$deleteNonDurableQueue</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$deleteNonDurableQueue: Boolean = false</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$fun createArtemis(baseDir: Path, artemisPort: Int, keyStorePassword: String = DEV_CA_KEY_STORE_PASS, truststorePassword: String = DEV_CA_TRUST_STORE_PASS): ActiveMQServer</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$fun createNodeDevCertificates(x500Name: CordaX500Name, nodePath: Path, keyStorePassword: String = DEV_CA_KEY_STORE_PASS, truststorePass: String = DEV_CA_TRUST_STORE_PASS, cryptoService: CryptoService? = null)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$journalBufferSize_AIO = MAX_MESSAGE_SIZE + ArtemisMessagingComponent.JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$journalBufferSize_NIO = MAX_MESSAGE_SIZE + ArtemisMessagingComponent.JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$journalFileSize = MAX_MESSAGE_SIZE + ArtemisMessagingComponent.JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$private</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$require(messageSize &lt;= limit) { "Message exceeds maxMessageSize network parameter, maxMessageSize: [$limit], message size: [$messageSize]" }</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$securityRoles["${ArtemisMessagingComponent.INTERNAL_PREFIX}#"] = setOf(nodeInternalRole)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$securityRoles["${ArtemisMessagingComponent.P2P_PREFIX}#"] = setOf(nodeInternalRole, restrictedRole(BrokerJaasLoginModule.PEER_ROLE, send = true))</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$val nodeKeystore = FileBasedCertificateStoreSupplier(certificateDir / "nodekeystore.jks", keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$val rolesPropertiesFilePath = ConfigTest::class.java.getResource("/net/corda/bridge/artemis/artemis-roles.properties").path</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$val securityManager = ActiveMQJAASSecurityManager(TextFileCertificateLoginModule::class.java.name, securityConfiguration)</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$val usersPropertiesFilePath = ConfigTest::class.java.getResource("/net/corda/bridge/artemis/artemis-users.properties").path</ID>
    <ID>MaxLineLength:AssociatedList.kt$AssociatedList&lt;K, out A, B&gt; : ReadOnlyBackedObservableMapBase</ID>
    <ID>MaxLineLength:AsyncLoadTestFlow.kt$AsyncLoadTestFlow$logger.info("Committed $transactionCount transactions in $duration ms, avg ${duration.toDouble() / transactionCount} ms")</ID>
    <ID>MaxLineLength:AsyncLoggerContextSelectorNoThreadLocal.kt$AsyncLoggerContextSelectorNoThreadLocal.Companion$return AsyncLoggerContextSelectorNoThreadLocal::class.java.name == PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR)</ID>
    <ID>MaxLineLength:Attachment.kt$Attachment$/** * The parties that have correctly signed the whole attachment. * Even though this returns a list of party objects, it is not required that these parties exist on the network, but rather they are a mapping from the signing key to the X.500 name. * * Note: Anyone can sign attachments, not only Corda parties. It's recommended to use [signerKeys]. */ @Deprecated("Use signerKeys. There is no requirement that attachment signers are Corda parties.") val signers: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AttachmentConstraint$ fun isSatisfiedBy(attachment: Attachment): Boolean</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AutomaticPlaceholderConstraint : AttachmentConstraint</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$AutomaticPlaceholderConstraint$throw UnsupportedOperationException("Contracts cannot be satisfied by an AutomaticPlaceholderConstraint placeholder.")</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$HashAttachmentConstraint$log.warn("Hash constraint check failed: $attachmentId does not match contract attachment JAR ${attachment.id} or contract attachment JAR is untrusted")</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$NoConstraintPropagation</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$SignatureAttachmentConstraint$log.debug("Checking signature constraints: verifying $key in contract attachment signer keys: ${attachment.signerKeys}")</ID>
    <ID>MaxLineLength:AttachmentContract.kt$AttachmentContract$require(tx.attachments.any { it.id == state.hash }) {"At least one attachment in transaction must match hash ${state.hash}"}</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$require</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$require(connection.contentType == APPLICATION_OCTET_STREAM) { "Content-Type header was ${connection.contentType}" }</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$val bankBParty = rpc.partiesFromName("Bank B", false).firstOrNull() ?: throw IllegalArgumentException("Couldn't find Bank B party")</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$val connection = URL("http://localhost:$webPort/attachments/${state.hash}").openConnection() as HttpURLConnection</ID>
    <ID>MaxLineLength:AttachmentDemo.kt$val notaryParty = rpc.partiesFromName("Notary", false).firstOrNull() ?: throw IllegalArgumentException("Couldn't find notary party")</ID>
    <ID>MaxLineLength:AttachmentDemoTest.kt$AttachmentDemoTest$// run with a 10,000,000 bytes in-memory zip file. In practice, a slightly bigger file will be used (~10,002,000 bytes). @Test fun `attachment demo using a 10MB zip file`()</ID>
    <ID>MaxLineLength:AttachmentDemoTest.kt$AttachmentDemoTest$cordappsForAllNodes = listOf(findCordapp("net.corda.attachmentdemo.contracts"), findCordapp("net.corda.attachmentdemo.workflows"))</ID>
    <ID>MaxLineLength:AttachmentDownloadServlet.kt$AttachmentDownloadServlet$log.warn("404 Not Found whilst trying to handle attachment download request for ${servletContext.contextPath}/$reqPath")</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$assertThatThrownBy { alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow() }</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$assertThatThrownBy { alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow() } // ConsumeAndBroadcastResponderFlow re-throws any non-FlowExceptions with just their class name in the message so that // we can verify here Bob threw the correct exception .hasMessage(TransactionVerificationException.UntrustedAttachmentsException::class.java.name)</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$"contaminate the tests. This is a known issue with the driver and we must work around it until it's fixed."</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$"isolated module cannot be on the classpath as otherwise it will be pulled into the nodes the driver creates and "</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$val issuanceFlowClass: Class&lt;FlowLogic&lt;StateRef&gt;&gt; = uncheckedCast(loadFromIsolated("net.corda.isolated.workflows.IsolatedIssuanceFlow"))</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.ConsumeAndBroadcastFlow${ val notary = serviceHub.networkMapCache.notaryIdentities[0] val stateAndRef = serviceHub.toStateAndRef&lt;ContractState&gt;(stateRef) val stx = serviceHub.signInitialTransaction( TransactionBuilder(notary) .addInputState(stateAndRef) .addOutputState(ConsumeContract.State()) .addCommand(Command(ConsumeContract.Cmd, ourIdentity.owningKey)) ) stx.verify(serviceHub, checkSufficientSignatures = false) val session = initiateFlow(otherSide) subFlow(FinalityFlow(stx, session)) // It's important we wait on this dummy receive, as otherwise it's possible we miss any errors the other side throws session.receive&lt;String&gt;().unwrap { require(it == "OK") { "Not OK: $it"} } }</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$Attachment</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$assertEquals("hacked", rebootClientAndGetAttachmentContent(false))</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$client.hackAttachment(attachmentId, "hacked")</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$client.internals.disableDBCloseOnStop()</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$return (client.smm.allStateMachines[0].stateMachine.resultFuture.apply { mockNet.runNetwork() }.getOrThrow() as ClientResult).attachmentContent</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.&lt;no name provided&gt;$override fun start()</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.CustomAttachmentLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.FetchAttachmentLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.OpenAttachmentLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.ServerLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$val attachment = session.get&lt;NodeAttachmentService.DBAttachment&gt;(NodeAttachmentService.DBAttachment::class.java, attachmentId.toString())</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$ @Deprecated("More attachment information is required", replaceWith = ReplaceWith("importAttachment(jar, uploader, filename)")) @Throws(FileAlreadyExistsException::class, IOException::class) fun importAttachment(jar: InputStream): AttachmentId</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$ fun getLatestContractAttachments(contractClassName: String, minContractVersion: Int = DEFAULT_CORDAPP_VERSION): List&lt;AttachmentId&gt;</ID>
    <ID>MaxLineLength:AttachmentStorage.kt$AttachmentStorage$@Deprecated("More attachment information is required", replaceWith = ReplaceWith("importAttachment(jar, uploader, filename)"))</ID>
    <ID>MaxLineLength:AttachmentStorageInternal.kt$AttachmentStorageInternal$ fun getAllAttachmentsByCriteria(criteria: AttachmentQueryCriteria = AttachmentQueryCriteria.AttachmentsQueryCriteria()): Stream&lt;Pair&lt;String?, Attachment&gt;&gt;</ID>
    <ID>MaxLineLength:AttachmentStorageInternal.kt$AttachmentStorageInternal$ fun privilegedImportAttachment(jar: InputStream, uploader: String, filename: String?): AttachmentId</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests$private</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests$val corruptAttachment = NodeAttachmentService.DBAttachment(attId = id.toString(), content = attachment, version = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests.InitiatingFetchAttachmentsFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:AttachmentTrustCalculator.kt$AttachmentTrustCalculator$ fun calculate(attachment: Attachment): Boolean</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentB)!!), "Contract $attachmentB should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentC)!!), "Contract $attachmentC should not be trusted (no chain of trust)")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial contract $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Other attachment $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Upgraded contract $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachment)!!), "Contract $attachment should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentA)!!), "Contract $attachmentA should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentB)!!), "Contract $attachmentB should inherit trust")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentId)!!), "Attachment $attachmentId should be trusted but isn't")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(signedId)!!), "Signed contract $signedId should be trusted but isn't")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(unsignedId)!!), "Unsigned contract $unsignedId should be trusted but isn't")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial contract $v1Id should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Other attachment $v2Id should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Upgraded contract $v2Id should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$val alias = "testAlias" val password = "testPassword" // Directly use the ContractJarTestUtils version of makeTestJar to ensure jars are created in the right place, in order to sign // them. var counter = 0 val jarV1 = path / "$counter.jar" ContractJarTestUtils.makeTestJar(jarV1.outputStream()) counter++ val jarV2 = path / "$counter.jar" // Ensure that the first and second jars do not have the same hash ContractJarTestUtils.makeTestJar(jarV2.outputStream(), entries = listOf(Pair("foo", "bar"))) path.generateKey(alias, password) val key1 = path.signJar(jarV1.toAbsolutePath().toString(), alias, password) val key2 = path.signJar(jarV2.toAbsolutePath().toString(), alias, password) val v1Id = jarV1.read { storage.privilegedImportAttachment(it, "app", "dummy-attachment.jar") } val v2Id = jarV2.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-attachment-2.jar") } // Sanity check. assertEquals(key1, key2, "Different public keys used to sign jars") assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should be trusted") assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Other attachment $v2Id should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$val alias = "testAlias" val password = "testPassword" // Directly use the ContractJarTestUtils version of makeTestJar to ensure jars are created in the right place, in order to sign // them. var counter = 0 val jarV1 = path / "$counter.jar" ContractJarTestUtils.makeTestJar(jarV1.outputStream()) counter++ val jarV2 = path / "$counter.jar" // Ensure that the first and second jars do not have the same hash ContractJarTestUtils.makeTestJar(jarV2.outputStream(), entries = listOf(Pair("foo", "bar"))) path.generateKey(alias, password) val key1 = path.signJar(jarV1.toAbsolutePath().toString(), alias, password) val key2 = path.signJar(jarV2.toAbsolutePath().toString(), alias, password) val v1Id = jarV1.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-attachment.jar") } val v2Id = jarV2.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-attachment-2.jar") } // Sanity check. assertEquals(key1, key2, "Different public keys used to sign jars") assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should not be trusted") assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Other attachment $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$val attachmentB = jarSignedByAB.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-contract.jar") }</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$val attachmentC = jarSignedByBC.read { storage.privilegedImportAttachment(it, "untrusted", "dummy-contract.jar") }</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.error("$msg skipped, network parameters not retrieved, could not determine node base directory due to system property $NODE_BASE_DIR_KEY being not set.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.info("$msg skipped, network parameters not found in $path, but there are no available attachments to migrate.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.info("$msg using network parameters from $path, whitelistedContractImplementations: ${networkParameters.whitelistedContractImplementations}.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.warn("Several versions based on whitelistedContractImplementations position are available: ${versions.toSet()}. $updateVersionMsg")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$val versions = networkParameters.whitelistedContractImplementations.values.map { it.indexOfFirst { aid -&gt; aid.toString() == attachmentId } }.filter { it &gt;= 0 }</ID>
    <ID>MaxLineLength:AttachmentWithContext.kt$AttachmentWithContext$"This AttachmentWithContext was not initialised properly. Please ensure all Corda contracts extending existing Corda contracts also implement the Contract base class."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader : URLClassLoader</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$(path == "meta-inf/services/net.corda.core.serialization.serializationwhitelist") -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$// This calculates the hash of the current entry because the JarInputStream returns only the current entry. fun entryHash()</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$currentHash == previousFileHash -&gt; log.debug { "Duplicate entry $path has same content hash $currentHash" }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$else -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id)</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$log</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$path.startsWith("meta-inf/services") -&gt; true</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$targetPlatformVersion &lt; 4 &amp;&amp; ignoreDirectories.any { path.startsWith(it) } -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ // Make some preliminary checks to ensure that we're not loading invalid attachments. // All attachments need to be valid JAR or ZIP files. for (attachment in attachments) { if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id) } // Until we have a sandbox to run untrusted code we need to make sure that any loaded class file was whitelisted by the node administrator. val untrusted = attachments .filter(::containsClasses) .filterNot(isAttachmentTrusted) .map(Attachment::id) if (untrusted.isNotEmpty()) { log.warn("Cannot verify transaction $sampleTxId as the following attachment IDs are untrusted: $untrusted." + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") throw TransactionVerificationException.UntrustedAttachmentsException(sampleTxId, untrusted) } // Enforce the no-overlap and package ownership rules. checkAttachments(attachments) }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ val entry = jar.nextJarEntry ?: break if (entry.isDirectory) continue // We already verified that paths are not strange/game playing when we inserted the attachment // into the storage service. So we don't need to repeat it here. // // We forbid files that differ only in case, or path separator to avoid issues for Windows/Mac developers where the // filesystem tries to be case insensitive. This may break developers who attempt to use ProGuard. // // Also convert to Unix path separators as all resource/class lookups will expect this. val path = entry.name.toLowerCase(Locale.US).replace('\\', '/') // Namespace ownership. We only check class files: resources are loaded relative to a JAR anyway. if (path.endsWith(".class")) { // Get the package name from the file name. Inner classes separate their names with $ not / // in file names so they are not a problem. val pkgName = path .dropLast(".class".length) .replace('/', '.') .split('.') .dropLast(1) .joinToString(".") for ((namespace, pubkey) in params.packageOwnership) { // Note that due to the toLowerCase() call above, we'll be comparing against a lowercased // version of the ownership claim. val ns = namespace.toLowerCase(Locale.US) // We need an additional . to avoid matching com.foo.Widget against com.foobar.Zap if (pkgName == ns || pkgName.startsWith("$ns.")) { if (pubkey !in signers) throw PackageOwnershipException(sampleTxId, attachment.id, path, pkgName) } } } // Some files don't need overlap checking because they don't affect the way the code runs. if (!shouldCheckForNoOverlap(path, targetPlatformVersion)) continue // This calculates the hash of the current entry because the JarInputStream returns only the current entry. fun entryHash() = ByteArrayOutputStream().use { jar.copyTo(it) it.toByteArray() }.sha256() // If 2 entries are identical, it means the same file is present in both attachments, so that is ok. val currentHash = entryHash() val previousFileHash = classLoaderEntries[path] when { previousFileHash == null -&gt; { log.debug { "Adding new entry for $path" } classLoaderEntries[path] = currentHash } currentHash == previousFileHash -&gt; log.debug { "Duplicate entry $path has same content hash $currentHash" } else -&gt; { log.debug { "Content hash differs for $path" } throw OverlappingAttachmentsException(sampleTxId, path) } } }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader.Companion$log.warn("The URLStreamHandlerFactory was already set in the JVM. Please be aware that this is not recommended.")</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$ fun &lt;T&gt; withAttachmentsClassloaderContext(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T): T</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$private</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$val serializers = createInstancesOfClassesImplementing(transactionClassLoader, SerializationCustomSerializer::class.java)</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val att2 = storage.importAttachment(fakeAttachment("file2.txt", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val state = (contract as DummyContractBackdoor).generateInitial(MEGA_CORP.ref(1), 1, DUMMY_NOTARY).outputStates().first()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests.Companion$val ISOLATED_CONTRACTS_JAR_PATH: URL = AttachmentsClassLoaderSerializationTests::class.java.getResource("/isolated.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$doReturn(it.cordappProvider.getContractAttachmentID(AttachmentDummyContract.ATTACHMENT_PROGRAM_ID)).whenever(attachment).id</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$return JarScanningCordappLoader.fromJarUrls(listOf(cordappWithPackages(*packages.toTypedArray()).jarFile.toUri().toURL()))</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$val cordappProviderImpl = CordappProviderImpl(cordappLoaderForPackages(listOf("net.corda.nodeapi.internal")), MockCordappConfigProvider(), MockAttachmentStorage())</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract$TransactionBuilder(notary) .withItems(StateAndContract(state, ATTACHMENT_PROGRAM_ID), Command(Commands.Create(), owner.party.owningKey))</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract.Companion$const val ATTACHMENT_PROGRAM_ID = "net.corda.nodeapi.internal.AttachmentsClassLoaderStaticContractTests\$AttachmentDummyContract"</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$import net.corda.nodeapi.internal.AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract.Companion.ATTACHMENT_PROGRAM_ID</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed by a trusted uploader - intersection of keys match existing attachment`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if it is signed by a blacklisted key even if there is another attachment signed by the same keys that is trusted`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if no other attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("/folder1/foldera/file1.txt", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("file1.txt", "same data", "file2.txt", "same other data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("meta-inf/services/com.example.something", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("meta-inf/services/net.corda.core.serialization.SerializationWhitelist", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("\\folder1\\folderb\\file2.txt", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("file1.txt", "same data", "file3.txt", "same totally different").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("meta-inf/services/com.example.something", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("meta-inf/services/net.corda.core.serialization.SerializationWhitelist", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("net/corda/finance/contracts/isolated/AnotherDummyContract\$State.class", "some attackdata").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = storage.importAttachment(fakeAttachment("file1.txt", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val isolatedSignedId = importAttachment(signedJar.first.toUri().toURL().openStream(), "app", "isolated-signed.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val trustedClassJar = importAttachment(fakeAttachment("/com/example/something/VirtuousClass.class", "some other data").inputStream(), "app", "file3.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val trustedResourceJar = importAttachment(fakeAttachment("file1.txt", "some data").inputStream(), "app", "file0.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val untrustedClassJar = importAttachment(fakeAttachment("/com/example/something/MaliciousClass.class", "some malicious data").inputStream(), "untrusted", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val untrustedResourceJar = importAttachment(fakeAttachment("file2.txt", "some malicious data").inputStream(), "untrusted", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests${ val keyPairA = Crypto.generateKeyPair() val keyPairB = Crypto.generateKeyPair() val keyPairC = Crypto.generateKeyPair() val classJar = fakeAttachment( "/com/example/something/TrustedClass.class", "Signed by someone untrusted with the same keys" ).inputStream() storage.importContractAttachment( listOf("TrustedClass.class"), "app", classJar, signers = listOf(keyPairA.public) ) val inheritedTrustClassJar = fakeAttachment( "/com/example/something/UntrustedClass.class", "Signed by someone who inherits trust" ).inputStream() val inheritedTrustAttachment = storage.importContractAttachment( listOf("UntrustedClass.class"), "untrusted", inheritedTrustClassJar, signers = listOf(keyPairB.public, keyPairA.public) ) val untrustedClassJar = fakeAttachment( "/com/example/something/UntrustedClass.class", "Signed by someone untrusted" ).inputStream() val untrustedAttachment = storage.importContractAttachment( listOf("UntrustedClass.class"), "untrusted", untrustedClassJar, signers = listOf(keyPairB.public, keyPairC.public) ) // pass the inherited trust attachment through the classloader first to ensure it does not affect the next loaded attachment createClassloader(inheritedTrustAttachment) assertFailsWith(TransactionVerificationException.UntrustedAttachmentsException::class) { createClassloader(untrustedAttachment) } }</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests.Companion$val ISOLATED_CONTRACTS_JAR_PATH_V4: URL = AttachmentsClassLoaderTests::class.java.getResource("isolated-4.0.jar")</ID>
    <ID>MaxLineLength:AuditService.kt$AuditEvent</ID>
    <ID>MaxLineLength:AuditService.kt$FlowPermissionAuditEvent : AuditEventFlowAuditInfo</ID>
    <ID>MaxLineLength:AuthDBTests.kt$"bar" to "\$shiro1\$SHA-256$500000\$Q6dmdY1uVMm0LYAWaOHtCA==\$u7NbFaj9tHf2RTW54jedLPiOiGjJv0RVEPIjVquJuYY="</ID>
    <ID>MaxLineLength:AuthDBTests.kt$"foo" to "\$shiro1\$SHA-256$500000\$WSiEVj6q8d02sFcCk1dkoA==\$MBkU/ghdD9ovoDerdzNfkXdP9Bdhmok7tidvVIqGzcA="</ID>
    <ID>MaxLineLength:AuthDBTests.kt$"test" to "\$shiro1\$SHA-256$500000\$F6CWSFDDxGTlzvREwih8Gw==\$DQhyAPoUw3RdvNYJ1aubCnzEIXm+szGQ3HplaG+euz8="</ID>
    <ID>MaxLineLength:AuthDBTests.kt$PasswordEncryption.SHIRO_1_CRYPT -&gt; hashedPasswords[format]!![s] ?: DefaultPasswordService().encryptPassword(s.toCharArray())</ID>
    <ID>MaxLineLength:AuthDBTests.kt$UsersDB$private</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$/** * Returns the RPC protocol version, which is the same the node's Platform Version. Exists since version 1 so guaranteed * to be present. * * TODO: Why is this logic duplicated vs the actual implementation? */ override val protocolVersion: Int get() = delegate.nodeInfo().platformVersion</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$internal</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$override</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.Companion$return Proxy.newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.PermissionsEnforcingInvocationHandler$override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?)</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.PermissionsEnforcingInvocationHandler$private</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$private</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$private fun &lt;RESULT&gt; guard(methodName: String, context: () -&gt; RpcAuthContext, action: () -&gt; RESULT)</ID>
    <ID>MaxLineLength:AutoAcceptable.kt$AutoAcceptable</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow$ReportToRegulatorFlow : FlowLogic</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester$val notary = serviceHub.networkMapCache.notaryIdentities.first() // TODO We should pass the notary as a parameter to the flow, not leave it to random choice.</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester$val otherParty = excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, dealToBeOffered.participants)).keys.single()</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester.Companion$// We vend a progress tracker that already knows there's going to be a TwoPartyTradingFlow involved at some // point: by setting up the tracker in advance, the user can see what's coming in more detail, instead of being // surprised when it appears as a new set of tasks below the current one. fun tracker()</ID>
    <ID>MaxLineLength:AzureBackend.kt$AzureBackend.Companion$azure.resourceGroups().define(resourceGroupName).withRegion(context.extraParams[Constants.REGION_ARG_NAME]).create()</ID>
    <ID>MaxLineLength:AzureBackend.kt$AzureBackend.Companion$val azureInstantiatorFuture = azureNetworkStore.thenCombine(registryLocatorFuture) { azureVolume, registryLocator -&gt; AzureInstantiator(azure, registryLocator.registry, azureVolume, resourceGroup) }</ID>
    <ID>MaxLineLength:AzureBackend.kt$AzureBackend.Companion$val resourceGroupName = context.networkName.replace(Constants.ALPHA_NUMERIC_DOT_AND_UNDERSCORE_ONLY_REGEX, "")</ID>
    <ID>MaxLineLength:AzureInstantiator.kt$AzureInstantiator.&lt;no name provided&gt;$LOG.info("Completed instantiation: $instanceName is running at $fqdn with port(s) $portsToOpen exposed")</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService$ override fun generateKeyPair(alias: String, scheme: SignatureScheme): PublicKey</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService$detailedLogger.trace { "CryptoService(action=signing_start;alias=$alias;algorithm=${signAlgorithm ?: "SHA-256"})" }</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService$else -&gt; throw java.lang.IllegalArgumentException("Unsupported (by Azure keyvault) Hash algo [${hashAlgo.nameString}]")</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService$override</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService${ checkAlias(alias) detailedLogger.trace { "CryptoService(action=signing_start;alias=$alias;algorithm=${signAlgorithm ?: "SHA-256"})" } // KeyVault can only sign over hashed data. val hashAlgo = getHashAlgorithmFromSignatureAlgorithm(signAlgorithm) ?: DigestAlgo.SHA256 val digest = MessageDigest.getInstance(hashAlgo.nameString) digest.update(data) val hash = digest.digest() // Signing requires us to make two calls to KeyVault. First, we need to get the key to look up // its type, which we need to specify when making the call for the actual signing operation. // TODO if we can make absolutely sure that only the default algorithm is used here, we could skip the first call. val keyBundle = keyVaultClient.getKey(createIdentifier(alias)) val keyType = keyBundle.key().kty() val algorithm = determineAlgorithm(keyBundle, hashAlgo) val transformedHash = transformHash(hashAlgo, hash, keyType) val result = keyVaultClient.sign(createIdentifier(alias), algorithm, transformedHash) detailedLogger.trace { "CryptoService(action=signing_end;alias=$alias;algorithm=$signAlgorithm)" } return when (keyType) { JsonWebKeyType.RSA, JsonWebKeyType.RSA_HSM -&gt; result.result() JsonWebKeyType.EC, JsonWebKeyType.EC_HSM -&gt; toSupportedSignature(result.result()) else -&gt; throw IllegalStateException("Key type $keyType not supported.") } }</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.&lt;no name provided&gt;$private val publicKey: PublicKey = getPublicKey(alias) ?: throw CryptoServiceException("No key found for alias $alias", isRecoverable = false)</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$ fun createKeyVaultClient(path: String, password: String, alias: String, clientId: String): KeyVaultClient</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$is ConfigException, is UnknownConfigurationKeysException -&gt; throw Exception("Error in ${configFile.toFile().absolutePath} : ${e.message}")</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$require(alias.matches("^[0-9a-zA-Z-]{1,127}$".toRegex())) { "Alias $alias is not valid. Alias must conform to the following pattern: ^[0-9a-zA-Z-]{1,127}\$" }</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$throw FileNotFoundException("Configured crypto configuration file [${configFile.toFile().absolutePath}] does not exist")</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$val keyVaultClient: KeyVaultClient = createKeyVaultClient(config.path, config.password, config.alias, config.clientId)</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion.AzureKeyVaultConfig$data</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoService.kt$net.corda.nodeapi.internal.cryptoservice.azure.AzureKeyVaultCryptoService.kt</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$@Test fun `Generate key with the default legal identity scheme, then sign using SHA512WITHECDSA (checking case) and verify data`()</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$assertFailsWith&lt;IllegalArgumentException&gt; { cryptoService.generateKeyPair(tooLong, cryptoService.defaultIdentitySignatureScheme()) }</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$assertFailsWith&lt;IllegalArgumentException&gt; { cryptoService.generateKeyPair(withIllegalChar, cryptoService.defaultIdentitySignatureScheme()) }</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val cryptoService = AzureKeyVaultCryptoService(keyVaultClient, premiumVault, AzureKeyVaultCryptoService.Protection.HARDWARE)</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val cryptoService = AzureKeyVaultCryptoService(keyVaultClient, vaultURL, AzureKeyVaultCryptoService.Protection.HARDWARE)</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val cryptoService = AzureKeyVaultCryptoService(keyVaultClient, vaultURL, AzureKeyVaultCryptoService.Protection.SOFTWARE)</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val otherWebKeyString = "{\"kid\":\"none\",\"kty\":\"EC\",\"key_ops\":[\"sign\"],\"n\":null,\"e\":null,\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":\"P-256\",\"x\":\"UIrB2wluAJlDnQCFtwM5AUBPbdDqQeQ2dVlJPcusbes\",\"y\":\"NyTF4r03wnmboUoNhLTRs0gUgmRTnF1rRffxACfQdEc\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"EMrnqe0JNgbPp2A420Tlaiqeh0w45HNIrL62isRXcnbrPs9YnfiCyJ2ubYn-KgvmrHr-xs1Q9AqYkIAJEW-8JQ\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"HNKQKM75ip-BQiDysK3wP9uxYwUxVH_m8OpG4mXOfAhxa9c-3n_lqJmoe7nHj1ebBt5dXurXO1UhKdg7xw36og\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"Lo-FW2f2Voj7as4zLHJeY-oQ412ma30eMJKXAqQTLUHSG4qEXtFHIMn35b_fpv8kc7-heocp2M6XbhNRHA-5uA\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"i6wWbOjFI5BLXF_iNbOw4bYeD3gnWIbx6_jhttTRD4bPTFq4GJlapLN1mYH9S0p0oDVpoXfAOYEzrL4dpVtN5viY_Tm1nVKO0eFNqgnSmNDl6h4PjE8cj5Jf1WnpAdoY1cz57j6tjQNrBAV-vCtHwfZSRfRVxwcs0Qm5LhL-FgWhvBint-2ROdwtY1g6yWy_8EvkqFN0npcjn8z4ggZA2nqzEFjW102mNlcTIFxXGFs9LCrsB8MKY4ve4psgsdNTmv30dK8LGeoOYf8SVPMdnR2fLe55X7hnACUAvD8YmeIvXVxtlF_xXCOAuyXrjbSc5od4RrjymfO_1z5ivwmKpxDLJXIs8-BaOmZdpF10RPQ6aq3EtRVZTiDd00Gq1DA3qUUvxCXWnU9dY0pwQBdtRSa5F9We7RoTLTI015ZCx6zDEOpT9-HMlD4S84deT1m2u--Xyo53HoloJSbXMmj6nGW7_GBuQxERozD5cNwVgks6V9ufROYYnPdzJZyc2h2Y\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"kyXAs9MK3XYEQIWxar8UqyjxRIvHJfzXsX_Ahy1zrwNbeReOXYItz8zN0oT5x6CHDQ69IHdnF72y2SRrH8WvTqqxKC2Wqh0v8JO-qqaz6hAtKb7ziwndEUp4EBwFOLTfSLk61N9c7BNsQcidl8XfjrGG91oWC0sy6mhiHNq7molRtIU6R-wM77w9e5ablEbs0IKd2iMzn0lB8FvW0vJfEBqPTAgCWY5aUtvQfew5Ej3FwoJlJqVSg1yFZc84lmtIFZY7IDgrKOldjeQVowgqPA0bhbhHNHERZtbl7hZ6oMlLKvEKdmfGbcckSyCzULOTC0MSATJYogTro4aqk02jIWztO2J_XwjNo62wL782AwBi9J5Z-0F1TtndWeHluVuj5gRjGeRkhySVPa0Rh6OIS5kRxyQazAGnBjZ80HenXRr8fwxwVz6PGAvCYTthR0W5maCrpWLIijs663vimvhGxFXjtc85O_7XZZYUV6YZbcH9z4P6k3yrs2cJrS24H58z\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"nr3k8MvlqN2ycg-gJmRyS9VKCEffh4d8FKBqqi9UV2R6MKrpTokc4R1_8lBRBC9JLweRz6V--PKQPu4i8WH9NA\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val resultString = "{\"kid\":\"none\",\"value\":\"nvrVKgmfDa3MSAStp4PfiB9VkPJfLVR-m7hzgGYpL2qcoI2QxF4H54dkMC798ff-3YLqcHN6PX7v3nxvJR-QYg\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"EC-HSM\",\"key_ops\":[\"sign\"],\"n\":null,\"e\":null,\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":\"P-256K\",\"x\":\"tjHBJXJ0G3qcUpThhb5fShKTJKB-rWoHaqhBVG7aZtQ\",\"y\":\"5UcAc_okBnbJRG5vzzFGiFq7I-t4pIyHiVvufQkLjlA\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"EC-HSM\",\"key_ops\":[\"sign\"],\"n\":null,\"e\":null,\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":\"P-256\",\"x\":\"Q9sEtdtbb2tb2XJHXtgD80BO5RcUpL3Q2xoca7CQZ7E\",\"y\":\"eDZP2RTd6_Nyk-uJ7Zs6MDaxzQ2RtQZJyWVXE15Dflg\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"EC\",\"key_ops\":[\"sign\",\"verify\"],\"n\":null,\"e\":null,\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":\"P-256K\",\"x\":\"Vk7oIWrB3N2cnzAPej1-d_8UkSiRsZPgb4Cg98p-U4I\",\"y\":\"lngidTj8RU-iIIZARZ_T8C71qCR-ukFsovH1HdI5Sn8\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"EC\",\"key_ops\":[\"sign\",\"verify\"],\"n\":null,\"e\":null,\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":\"P-256\",\"x\":\"7rFaNa9LyFGYDxk6QSPWNTyq0XjqOIIWgxuTBPzU2R8\",\"y\":\"NEPAf9aZYbyYDa42Xjq6QvGlfX7nEew7Fs-AO3vYrNg\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"EC\",\"key_ops\":[\"sign\"],\"n\":null,\"e\":null,\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":\"P-256\",\"x\":\"jj2KEEaO5WzwB6FEDhxGk1wRUvql34Obs9vOOMJvnl4\",\"y\":\"SgzL1qbL3YoyMZkkJe_FX54sxV9AQV_QbeYMEt_vdQ0\"}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"RSA-HSM\",\"key_ops\":[\"sign\"],\"n\":\"6rpVAz49zNP6kFCyrtDU3LZDFnDIT5haqpRuSUn_osE5Z08ZQkbTypT_yXUI11QUzr9VHZ4rPuXyh_uyNo_e4eswpkpfV3za5ynvjA_zn9Nfnj9otD4c18Vf3OsoRofGAary-TiOkNDEy67ikdi6-lmU613HjeUN8QJJ_jSdh8F1M8D33yKhivGZORxvX_Lab0ge5qwRAY9SL7MKomPm4HEXJvbDKQLjOtRDyvePtpuzmxEjp8Zbb0T323hFxWMSvzuNSXuYtuWVzNAtUEisldEQIenPJrCWHqI3UbworqhvGl6cEScILGum-olylvZW6fd5XsL2jmJgNp0043cH_HrjVsUtNU_EdZTpFplFVu2wXqZeAChO34VZ6LwnDqKeZbvuzYhrieXL1zcWs2w4fR_-ICBrE0aYZUFB-qyqTWt3wa-dcJv7HKjIwBOK2nT4zzOeOR36HKzGd_mBKNyOY0Sc0O9Jg6Xi3M4mLp6ipnyKqbQg6DvnTOmObjajkXqx\",\"e\":\"AAEAAQ\",\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":null,\"x\":null,\"y\":null}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest$val webKeyString = "{\"kid\":\"none\",\"kty\":\"RSA-HSM\",\"key_ops\":[\"sign\"],\"n\":\"vXSPsJTkek-MTTloTP8j84rFVImXKPQXuqELbVKL2bd5DHJXBHHTZunBxSx9Q4UhH8yBsVmgcrn8orbFioNDrmPeeoFUKbG9yZIqsHPXUJgbf1Iv2RUZ9pPYxgyzwRBFiiZs2oAlXTj5iRLdizkYFePhnAZP0MV9WpZhCz0U6Tvc8AVPbyCuOU1Kyq2fHAR1tYMFeS88Q5y3dLUcXReVbQZ9WWYh6QNbyfjYJ91w8Bpso4YW2UsskEsnUDvBfeVUvajEWMYhWBcVHwYlETh_NG36sDOY42YCQ8pqd0fmDTHQDFn09uwxXLldCziFPWgss1z0tFs2ztsYEx5V_yYZSBQfpgcJOA36RrpWKgMs2J8Wb6jioGeoKgLEpcvgKb_EFXRBMM_E9iJGm_WIClp0Pir44GCmCHgTWiEgx5F5FTGrjcPrkU-XzrJZ2thEkx2mMqKheixFbS7_Qr0bJCgCf6rcDOZls_SZl0qXhlN7N9Y6cVSYQRM8Jj-pemzaUgLX\",\"e\":\"AAEAAQ\",\"d\":null,\"dp\":null,\"dq\":null,\"qi\":null,\"p\":null,\"q\":null,\"k\":null,\"key_hsm\":null,\"crv\":null,\"x\":null,\"y\":null}"</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$net.corda.node.services.keys.cryptoservice.azure.AzureKeyVaultCryptoServiceTest.kt</ID>
    <ID>MaxLineLength:AzureKeyVaultCryptoServiceTest.kt$private</ID>
    <ID>MaxLineLength:AzureRegistryLocator.kt$RegistryLocator$LOG.info("Did not find existing container registry - creating new registry with name ${resourceGroup.restFriendlyName()}")</ID>
    <ID>MaxLineLength:AzureRegistryLocator.kt$RegistryLocator$val found = azure.containerRegistries().getByResourceGroup(resourceGroup.name(), resourceGroup.restFriendlyName())</ID>
    <ID>MaxLineLength:AzureSmbVolume.kt$AzureSmbVolume$networkParamsFile.uploadFromByteArray(networkParameters.signWithCert(keyPair.private, networkMapCert).serialize().bytes)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService : CryptoService</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$/** * JKS keystore does not support storage for secret keys, so the existing keystore cannot be re-used. * JCEKS keystore supports storage of symmetric keys according to the spec, but there are several issues around classloaders and deserialization filtering (see links below). * - https://stackoverflow.com/questions/49990904/what-is-the-cause-of-java-security-unrecoverablekeyexception-rejected-by-the-j * - https://stackoverflow.com/questions/50393533/java-io-ioexception-invalid-secret-key-format-when-opening-jceks-key-store-wi * Thus, PKCS12 is used for storing the wrapping key. */ private val wrappingKeyStore: KeyStore by lazy { loadOrCreateKeyStore(wrappingKeyStorePath!!, certificateStore.password, "PKCS12") }</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$certificateStore.query { setPrivateKey(alias, keyPair.private, listOf(cert), certificateStore.entryPassword) }</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$null -&gt; Crypto.doSign(certificateStore.query { getPrivateKey(alias, certificateStore.entryPassword) }, data)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$override</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$return ContentSignerBuilder.build(signatureScheme, privateKey, Crypto.findProvider(signatureScheme.providerName), newSecureRandom())</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$throw CryptoServiceException("Cannot generate key for alias $alias and signature scheme ${scheme.schemeCodeName} (id ${scheme.schemeNumberID})", e)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$throw CryptoServiceException("Cannot sign using the key with alias $alias. SHA256 of data to be signed: ${data.sha256()}", e)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$val privateKey = cipher.unwrap(wrappedPrivateKey.keyMaterial, keyAlgorithmFromScheme(wrappedPrivateKey.signatureScheme), Cipher.PRIVATE_KEY) as PrivateKey</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$wrappingKeyStore.setEntry(alias, KeyStore.SecretKeyEntry(wrappingKey), KeyStore.PasswordProtection(certificateStore.entryPassword.toCharArray()))</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService${ // Store a self-signed certificate, as Keystore requires to store certificates instead of public keys. // We could probably add a null cert, but we store a self-signed cert that will be used to retrieve the public key. detailedLogger.trace { "CryptoService(action=key_import;alias=$alias)" } val cert = X509Utilities.createSelfSignedCACertificate(legalName, keyPair) certificateStore.query { setPrivateKey(alias, keyPair.private, listOf(cert), certificateStore.entryPassword) } }</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$@Test fun `cryptoService can generate wrapped key pair and sign with the private key successfully, using default algorithm`()</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$@Test fun `cryptoService fails when asked to generate wrapped key pair or sign, but the master key specified does not exist`()</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$Crypto.supportedSignatureSchemes().filter { it != Crypto.COMPOSITE_KEY }.forEach { generateKeyAndSignForScheme(cryptoService, it) }</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$private</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$val cryptoService = BCCryptoService(ALICE_NAME.x500Principal, createKeystore(alias, keyPair), wrappingKeyStorePath)</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$private</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$fun startBftClusterAndNode(clusterSize: Int, mockNet: InternalMockNetwork, exposeRaces: Boolean = false): Pair&lt;Party, TestStartedNode&gt;</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false))))</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion${ (Paths.get("config") / "currentView").deleteIfExists() // XXX: Make config object warn if this exists? val replicaIds = (0 until clusterSize) val serviceLegalName = CordaX500Name("BFT", "Zurich", "CH") val notaryIdentity = DevIdentityGenerator.generateDistributedNotaryCompositeIdentity( replicaIds.map { mockNet.baseDirectory(mockNet.nextNodeId + it) }, serviceLegalName) val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false)))) val clusterAddresses = replicaIds.map { NetworkHostAndPort("localhost", 11000 + it * 10) } val nodes = replicaIds.map { replicaId -&gt; mockNet.createUnstartedNode(InternalMockNodeParameters(configOverrides = { val notary = NotaryConfig( validating = false, bftSMaRt = BFTSmartConfig(replicaId, clusterAddresses, exposeRaces = exposeRaces), serviceLegalName = serviceLegalName ) doReturn(notary).whenever(it).notary })) } + mockNet.createUnstartedNode() // MockNetwork doesn't support BFT clusters, so we create all the nodes we need unstarted, and then install the // network-parameters in their directories before they're started. val node = nodes.map { node -&gt; networkParameters.install(mockNet.baseDirectory(node.id)) node.start() }.last() return Pair(notaryIdentity, node) }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart$Client : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart$ClusterResponse</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$ private fun buildExtractor(): Extractor</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$log.debug { "BFT Client $clientId: number of replicas accepted the commit: ${accepted.size}, rejected: ${rejected.size}" }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$private val sessionTable = (proxy.communicationSystem as NettyClientServerCommunicationSystemClientSide).declaredField&lt;Map&lt;Int, NettyClientServerSession&gt;&gt;("sessionTable").value</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client${ // TODO: Hopefully we only need to wait for the client's initial connection to the cluster, and this method can be moved to some startup code. // TODO: Investigate ConcurrentModificationException in this method. while (true) { val inactive = sessionTable.entries.mapNotNull { if (it.value.channel.isActive) null else it.key } if (inactive.isEmpty()) break log.info("Client-replica channels not yet active: $clientId to $inactive") Thread.sleep((inactive.size * 100).toLong()) } }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.CordaServiceReplica$private</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$checkConflict(conflictingStates, references, StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$private</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val (committedStates, requests) = bytes.deserialize&lt;Pair&lt;LinkedHashMap&lt;StateRef, SecureHash&gt;, List&lt;NotaryEntities.Request&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica.&lt;no name provided&gt;$if (exposeStartupRace) Thread.sleep(20000)</ID>
    <ID>MaxLineLength:BFTSmartConfigInternal.kt$BFTSmartConfigInternal : PathManager</ID>
    <ID>MaxLineLength:BFTSmartConfigInternal.kt$BFTSmartConfigInternal$val systemConfig = String.format(javaClass.getResource("system.config.printf").readText(), n, maxFaultyReplicas(n), if (debug) 1 else 0, (0 until n).joinToString(","))</ID>
    <ID>MaxLineLength:BFTSmartConfigTests.kt$BFTSmartConfigTests$assertThatThrownBy { config(11001, 11000).use {} } .isInstanceOf(IllegalArgumentException::class.java) .hasMessage(portIsClaimedFormat.format("localhost:11001", setOf("localhost:11001", "localhost:11002", "localhost:11000")))</ID>
    <ID>MaxLineLength:BFTSmartConfigTests.kt$BFTSmartConfigTests$fun config(vararg ports: Int)</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$?:</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$CommittedState : BaseComittedState</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$client</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.&lt;no name provided&gt;$log.warn("A BFT replica may still be initializing, in which case the upcoming consensus change may cause it to spin.")</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$createMap: () -&gt; AppendOnlyPersistentMap&lt;StateRef, SecureHash, CommittedState, PersistentStateRef&gt;</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$notaryIdentityKey: PublicKey</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$private</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$val response = verifyAndCommitTx(commitRequest.payload.coreTransaction, commitRequest.callerIdentity, commitRequest.payload.requestSignature)</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow$private</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow${ // TODO: here we assume that all error will be the same, but there might be invalid onces from mailicious nodes val responseError = response.errors.first().verified() throw NotaryException(responseError, payload.coreTransaction.id) }</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$ fun determineStartNode(amount: Int, payFromNode: TransferNode, startUnitSize: Int) : TransferNode</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$finalAmtStr = BackchainOperation(BackchainOpCode.TRANSFER, transferAmount, fromNode, testInfo).toString()</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$get() = setOf(notary, otherPartyA, otherPartyB, finalParty, coinSelection, anonymousIdentities, initialAmount, initialUnitSize, sendFinalPaymentFromB)</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("Round [$xferRound]: Final transfer for round reduced to $transferAmount (from $unitSize) as initial amount is not 2^n")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("Round [$xferRound]: Starting Op generation for transfers from '${fromNode.toString()}' to '${fromNode.inverse().toString()}': Total to transfer: $quantityRemaining, unit size: $unitSize")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("Round[$xferRound] Total amount transferred (in blocks of $unitSize) is $totalTransferred, num transfer Ops for round = $index")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("Will not allocate transfers (either initial amount ($initStartAmount) or unit size ($initUnitSize) is zero).")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("determineStartNode(): If we start from 'A', I conclude the final payment to 'C' would be from node '${currentFromNode.toString()}'")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("determineStartNode(): Inversion is required, we need to issue to node 'B' to start with, to pay 'C' from node '${payFromNode.toString()}'.")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("determineStartNode(): NO inversion is required, we can issue to node 'A' to start with, to pay 'C' from node '${payFromNode.toString()}'.")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("determineStartNode(): Round=$round ('${currentFromNode.toString()}' =&gt; '${currentFromNode.inverse().toString()}'): size=$unitSize, tran_count=$count")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.info("determineStartNode(startAmt=$amount, payNode=${payFromNode.toString()}, startUnitSize=$startUnitSize): Will see where we end up starting with 'A'.")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$log.trace { "Round [$xferRound]: Index[$index]: Generating transfer (${fromNode.toString()}-&gt;${fromNode.inverse().toString()}): xfer_amt=$transferAmount, total=$totalTransferred, remaining=$quantityRemaining" }</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$override</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$return BaseFlowSampler.FlowInvoke&lt;CashIssueFlow&gt;(CashIssueFlow::class.java, arrayOf(amount, OpaqueBytes.of(1), notaryIdentity))</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$return BaseFlowSampler.FlowInvoke&lt;CashPaymentFlow&gt;(CashPaymentFlow::class.java, arrayOf(amount, recipient, useAnonymousIdentities))</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$useAnonymousIdentities = testContext.getParameter(anonymousIdentities.name, anonymousIdentities.value).toBoolean()</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$val recipient = if (op.fromNode == TransferNode.NODE_A) { counterPartyToA } else if (op.fromNode == TransferNode.NODE_B) { counterPartyToB } else { counterPartyFinal }</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$val testInfo = "[$xrpo] ${fromNode.toString()} pays ${fromNode.inverse().toString()} $transferAmount GBP"</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler$var ex = Exception("Too many iterations at max index [$invocationCount], ran off the end of operations to perform, adjust 'Thread Group': Loop Count to $invocationCount")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler.JMeterProperties$val anonymousIdentities = Argument("anonymousIdentities", "false", "&lt;meta&gt;", "True to use anonymous identities and false (or anything else) to use well known identities.")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler.JMeterProperties$val coinSelection = Argument("useCoinSelection-NOT-IMPLEMENTED", "false", "&lt;meta&gt;", "True to use coin selection and false (or anything else) to avoid coin selection.")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler.JMeterProperties$val initialAmount = Argument("initialAmount", "2", "&lt;meta&gt;", "The initial amount of currency to be transferred in unit sized blocks.")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackChainResolutionSampler.JMeterProperties$val sendFinalPaymentFromB = Argument("sendFinalPaymentFromB", "false", "&lt;meta&gt;", "True to send final payment from B to C (else A pays C).")</ID>
    <ID>MaxLineLength:BackChainResolutionSampler.kt$BackchainOperation</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$else -&gt; throw throw IllegalArgumentException("We were expecting a ${ReceiveType::class.java.name} or WaitTimeUpdate but we instead got a ${unwrapped.javaClass.name} ($unwrapped)")</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$is ReceiveType</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow$logger.info("Counterparty [${session.counterparty}] is busy - TimedFlow $runId has been asked to wait for an additional ${update.waitTime} seconds for completion.")</ID>
    <ID>MaxLineLength:BackpressureAwareTimedFlow.kt$BackpressureAwareTimedFlow&lt;ResultType&gt; : FlowLogicTimedFlow</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTest$TestNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTest$assertEquals(waitETA.seconds, (gauge as HealthCheckFlow.NotaryClientFlow.WaitTimeLatchedGauge).currentWaitTime.get())</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTest.Companion$/** The notary nodes don't run any consensus protocol, so 2 nodes are sufficient for the purpose of this test. */ private val globalRule = BackpressureHandlingTestRule(2)</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTest.TestNotaryService$@Suspendable override</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTest.TestNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTest.TestNotaryService.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTestRule$val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false))))</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTestRule$val retryConfig = FlowTimeoutConfiguration(BackpressureHandlingTest.defaultFlowTimeout, 3, 1.0)</ID>
    <ID>MaxLineLength:BackpressureHandlingTest.kt$BackpressureHandlingTestRule${ val replicaIds = (0 until clusterSize) val serviceLegalName = CordaX500Name("Custom Notary", "Zurich", "CH") val notaryIdentity = DevIdentityGenerator.generateDistributedNotaryCompositeIdentity( replicaIds.map { mockNet.baseDirectory(mockNet.nextNodeId + it) }, serviceLegalName) val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false)))) val notaryConfig = NotaryConfig( serviceLegalName = serviceLegalName, validating = false, className = BackpressureHandlingTest.TestNotaryService::class.java.name ) val notaryNodes = (0 until clusterSize).map { mockNet.createUnstartedNode(InternalMockNodeParameters(configOverrides = { doReturn(notaryConfig).whenever(it).notary })) } val aliceNode = mockNet.createUnstartedNode( InternalMockNodeParameters( legalName = CordaX500Name("Alice", "AliceCorp", "GB"), configOverrides = { conf: NodeConfiguration -&gt; val retryConfig = FlowTimeoutConfiguration(BackpressureHandlingTest.defaultFlowTimeout, 3, 1.0) doReturn(retryConfig).whenever(conf).flowTimeout } ) ) // MockNetwork doesn't support notary clusters, so we create all the nodes we need unstarted, and then install the // network-parameters in their directories before they're started. val nodes = (notaryNodes + aliceNode).map { node -&gt; networkParameters.install(mockNet.baseDirectory(node.id)) node.start() } return Pair(notaryIdentity, nodes.last()) }</ID>
    <ID>MaxLineLength:BankOfCordaClientApi.kt$BankOfCordaClientApi$ fun requestRPCIssue(rpcAddress: NetworkHostAndPort, params: IssueRequestParams): SignedTransaction</ID>
    <ID>MaxLineLength:BankOfCordaClientApi.kt$BankOfCordaClientApi$ fun requestRPCIssueHA(availableRpcServers: List&lt;NetworkHostAndPort&gt;, params: IssueRequestParams): SignedTransaction</ID>
    <ID>MaxLineLength:BankOfCordaClientApi.kt$BankOfCordaClientApi$return rpc.startFlow(::CashIssueAndPaymentFlow, params.amount, issuerBankPartyRef, issueToParty, anonymous, notaryLegalIdentity) .returnValue.getOrThrow().stx</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$?:</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$rpc.startFlow(::CashIssueAndPaymentFlow, params.amount, issuerBankPartyRef, issueToParty, anonymous, notaryParty).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$rpc.wellKnownPartyFromX500Name(params.issuerBankName) ?: return Response.status(Response.Status.FORBIDDEN).entity("Unable to locate ${params.issuerBankName} in identity service").build()</ID>
    <ID>MaxLineLength:BaseFlowSampler.kt$BaseFlowSampler$protected open</ID>
    <ID>MaxLineLength:BaseFlowSampler.kt$BaseFlowSampler$rpcParams = RPCParams(NetworkHostAndPort(context.getParameter(host.name), context.getIntParameter(port.name)), context.getParameter(username.name), context.getParameter(password.name))</ID>
    <ID>MaxLineLength:BaseFlowSampler.kt$BaseFlowSampler.Companion$RPCClient</ID>
    <ID>MaxLineLength:BaseFlowSampler.kt$BaseFlowSampler.Companion$val host = Argument("host", "localhost", "&lt;meta&gt;", "The remote network address (hostname or IP address) to connect to for RPC.")</ID>
    <ID>MaxLineLength:BaseFlowSampler.kt$BaseFlowSampler.Companion$val label = Argument("label", "\${__samplerName}", "&lt;meta&gt;", "The value in the label column in the resulting CSV file to dissambiguate this test run from others.")</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; filterOutRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; filterOutputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; outRef(index: Int): StateAndRef&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$ fun &lt;T : ContractState&gt; outputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:BaseTransaction.kt$BaseTransaction$/** * Helper property to return a list of [ContractState] objects, rather than the often less convenient [TransactionState] */ val outputStates: List&lt;ContractState&gt; get() = outputs.map { it.data }</ID>
    <ID>MaxLineLength:BaseTransactions.kt$CoreTransaction$/** * Hash of the network parameters that were in force when the transaction was notarised. Null means, that the transaction * was created on older version of Corda (before 4), resolution will default to initial parameters. */ abstract val networkParametersHash: SecureHash?</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$"Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]"</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$/** * Network parameters that were in force when this transaction was created. Resolved from the hash of network parameters on the corresponding * wire transaction. */ abstract val networkParameters: NetworkParameters?</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$// Network parameters will never be null if the transaction is resolved from a CoreTransaction rather than constructed directly. networkParameters?.let { parameters -&gt; val notaryWhitelist = parameters.notaries.map { it.identity } check(notaryParty in notaryWhitelist) { "Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]" } }</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$check(notaries.single() == notary) { "The specified notary must be the one specified by all inputs and input references" }</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService : SingletonSerializeAsTokenKeyManagementServiceInternal</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$DigitalSignature.WithKey(signingPublicKey, wrappingCryptoService!!.sign(wrappingKeyAlias!!, genericPrivateKey.wrappedPrivateKey!!, bytes))</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$pkToIdCache: WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$private val pkToIdCache: WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$require(it.private is AliasPrivateKey) { "${this.javaClass.name} supports AliasPrivateKeys only, but ${it.private.algorithm} key was found" }</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$val signatureBytes = wrappingCryptoService!!.sign(wrappingKeyAlias!!, genericPrivateKey.wrappedPrivateKey!!, signableData.serialize().bytes)</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService.Companion$fromPersistentEntity = { Pair(Crypto.decodePublicKey(it.publicKey), GenericPrivateKey.fromPersistentKey(it)) }</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService.Companion$fun createKeyMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;PublicKey, GenericPrivateKey, PersistentKey, String&gt;</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService.GenericPrivateKey.Companion$GenericPrivateKey(WrappedPrivateKey(persistentKey.privateWrappedKey!!, Crypto.findSignatureScheme(persistentKey.schemeCodeName!!)))</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService.PersistentKey$constructor(publicKey: PublicKey, wrappedPrivateKey: WrappedPrivateKey) : this(publicKey.toStringShort(), publicKey.encoded, null, wrappedPrivateKey.keyMaterial, wrappedPrivateKey.signatureScheme.schemeCodeName)</ID>
    <ID>MaxLineLength:BitSetSerializer.kt$BitSetSerializer : Proxy</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$?:</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$@Option(names = ["--input-format"], paramLabel = "type", description = ["Input format. If the file can't be decoded with the given value it's auto-detected, so you should never normally need to specify this. Possible values: [BINARY, HEX, BASE64]"])</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$@Parameters(index = "0", paramLabel = "SOURCE", description = ["URL or file path to the blob"], converter = [SourceConverter::class])</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$description = ["Display the owningKey and certPath properties of Party and PartyAndReference objects respectively"]</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$val envelope = DeserializationInput.getEnvelope(bytes.sequence(), SerializationDefaults.STORAGE_CONTEXT.encodingWhitelist)</ID>
    <ID>MaxLineLength:BlobInspectorTest.kt$BlobInspectorTest$assertThat(output) .startsWith(SignedDataWithCert::class.java.name) .contains(NetworkParameters::class.java.name) .contains(CordaX500Name("Notary Service", "Zurich", "CH").toString())</ID>
    <ID>MaxLineLength:BlobWriter.kt$File("../cpp-serializer/bin/blob-inspector/test/_i_is__").writeBytes(_i_is__(1, _is_ (2, "three")).serialize().bytes)</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$assertThatThrownBy { devModeNode.attemptJavaDeserialization() }.isInstanceOf(CordaRuntimeException::class.java)</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val alice = startNode(providedName = ALICE_NAME).getOrThrow() val aliceCertDir = alice.baseDirectory / "certificates" (aliceCertDir / "nodekeystore.jks").delete() val cert = CertificateStoreStubs.Signing.withCertificatesDirectory(aliceCertDir).get(true) // Creating a new certificate store does not populate that store with the node certificate path. If the node certificate path is // missing, the node will fail to start but not because the legal identity is missing. To test that a missing legal identity // prevents the node from starting, the node certificate path must be installed. cert.installDevNodeCaCertPath(ALICE_NAME) alice.stop() // The node shouldn't start, and the logs should indicate that the failure is due to a missing identity key assertThatThrownBy { startNode(providedName = ALICE_NAME).getOrThrow() } val logFolder = alice.baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME val logFile = logFolder.list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() } val lines = logFile.readLines { lines -&gt; lines.filter { "$NODE_IDENTITY_ALIAS_PREFIX-private-key" in it }.toArray() } assertTrue(lines.count() &gt; 0)</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val lines = logFile.readLines { lines -&gt; lines.filter { "$NODE_IDENTITY_ALIAS_PREFIX-private-key" in it }.toArray() }</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val logFile = logFolder.list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() }</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val numberOfNodesThatLogged = logFile.readLines { it.filter { NodeStartup.LOGS_CAN_BE_FOUND_IN_STRING in it }.count() }</ID>
    <ID>MaxLineLength:BootTests.kt$ObjectInputStreamFlow$val data = ByteArrayOutputStream().apply { ObjectOutputStream(this).use { it.writeObject(object : Serializable {}) } }.toByteArray()</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView$nodeAdder.addNode(context, nodeToAdd, x500ToUse?.let { CordaX500Name.parse(it) })</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView$return Pair(mapOf(Constants.REGION_ARG_NAME to ChoiceDialog&lt;Region&gt;(Region.EUROPE_WEST, Region.values().toList().sortedBy { it.name() }).showAndWait().get().name()), networkName1)</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView.State$var hasNodesOrNotaries = Bindings.size(foundNotaries).greaterThan(0).or(Bindings.size(foundNotaries).greaterThan(0))</ID>
    <ID>MaxLineLength:BridgeAMQPListenerServiceImpl.kt$BridgeAMQPListenerServiceImpl$override</ID>
    <ID>MaxLineLength:BridgeAMQPListenerServiceImpl.kt$BridgeAMQPListenerServiceImpl$private val extSourceSupplier: (() -&gt; ExternalCrlSource)? = null</ID>
    <ID>MaxLineLength:BridgeAMQPListenerServiceImpl.kt$BridgeAMQPListenerServiceImpl.&lt;no name provided&gt;$override val revocationConfig: RevocationConfig = conf.revocationConfig.enrichExternalCrlSource(extSourceSupplier)</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionService.kt$BridgeArtemisConnectionService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionService.kt$BridgeArtemisConnectionService$ fun bounce()</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$// Never time out on our loopback Artemis connections. If we switch back to using the InVM transport this // would be the default and the two lines below can be deleted. connectionTTL = 60000 clientFailureCheckPeriod = 30000 callFailoverTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT) callTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT) minLargeMessageSize = maxMessageSize isUseGlobalPools = nodeSerializationEnv != null confirmationWindowSize = conf.p2pConfirmationWindowSize producerWindowSize = -1</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$callFailoverTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT)</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$callTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT)</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$log.info("Try create session factory ${transport.params[TransportConstants.HOST_PROP_NAME]}:${transport.params[TransportConstants.PORT_PROP_NAME]}")</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$val brokerAddresses = listOf(outboundConf.artemisBrokerAddress) + outboundConf.alternateArtemisBrokerAddresses</ID>
    <ID>MaxLineLength:BridgeConfigHelper.kt$BridgeConfigHelper$internal val BRIDGE_NAME = CordaX500Name(commonName = "Bridge", organisation = "Corda", locality = "London", country = "GB")</ID>
    <ID>MaxLineLength:BridgeConfigHelper.kt$BridgeConfigHelper$internal val FLOAT_NAME = CordaX500Name(commonName = "Float", organisation = "Corda", locality = "London", country = "GB")</ID>
    <ID>MaxLineLength:BridgeConfigHelper.kt$BridgeConfigHelper$log</ID>
    <ID>MaxLineLength:BridgeConfigHelper.kt$BridgeConfigHelper$passwordRegex.matches(key) &amp;&amp; value.valueType() == ConfigValueType.STRING -&gt; config.withoutKey(key).withValue(key, maskedValue)</ID>
    <ID>MaxLineLength:BridgeConfigHelper.kt$BridgeConfigHelper$return ConfigFactory.parseMap(toProperties().filterKeys { (it as String).startsWith(BRIDGE_PROPERTY_PREFIX) }.mapKeys { (it.key as String).removePrefix(BRIDGE_PROPERTY_PREFIX) })</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$AMQPBridgeManager(keyStore, trustStore, useOpenSSL, proxyConfig, maxMessageSize, revocationConfig, enableSNI, artemisMessageClientFactory, bridgeMetricsService, trace, sslHandshakeTimeout)</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$LoopbackBridgeManager(keyStore, trustStore, useOpenSSL, proxyConfig, maxMessageSize, revocationConfig, enableSNI, artemisMessageClientFactory, bridgeMetricsService, this::validateReceiveTopic, trace, sslHandshakeTimeout)</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$bridgeManager.deployBridge(controlMessage.nodeIdentity, controlMessage.bridgeInfo.queueName, controlMessage.bridgeInfo.targets, controlMessage.bridgeInfo.legalNames.toSet())</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$bridgeManager.deployBridge(controlMessage.nodeIdentity, outQueue.queueName, outQueue.targets, outQueue.legalNames.toSet())</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$log.error("Fatal Error! Two bridges have been configured simultaneously! Check the enterpriseConfiguration.externalBridge status")</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$log.error("Fatal error! Bridge not configured with keystore for node with legal name ${controlMessage.nodeIdentity}.")</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$proxy: ProxyConfig? = null</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$return queueName.startsWith(P2P_PREFIX) &amp;&amp; artemis!!.started!!.session.queueQuery(SimpleString(queueName)).isExists</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$return queueName.startsWith(PEERS_PREFIX) &amp;&amp; artemis!!.started!!.session.queueQuery(SimpleString(queueName)).isExists</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$val notifyMessage = data.deserialize&lt;BridgeControl.BridgeToNodeSnapshotRequest&gt;(context = SerializationDefaults.P2P_CONTEXT)</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$val startupMessage = BridgeControl.BridgeToNodeSnapshotRequest(bridgeId).serialize(context = SerializationDefaults.P2P_CONTEXT) .bytes</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$validInboundQueues.addAll(artemisSession.addressQuery(SimpleString("$P2P_PREFIX#")).queueNames.map { it.toString() })</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$BridgeHealthCheck : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$Create : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$Delete : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$NodeToBridgeSnapshot : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl.BridgeHealthCheck$@CordaSerializable data</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl.NodeToBridgeSnapshot$@CordaSerializable data</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeEntry</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeEntry$@CordaSerializable data</ID>
    <ID>MaxLineLength:BridgeDriver.kt$"trustStorePassword" to truststorePassword</ID>
    <ID>MaxLineLength:BridgeDriver.kt$&lt;no name provided&gt;$override val keyStore = FileBasedCertificateStoreSupplier(artemisCertDir / ARTEMIS_KEYSTORE, keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$&lt;no name provided&gt;$override val trustStore = FileBasedCertificateStoreSupplier(artemisCertDir / ARTEMIS_TRUSTSTORE, truststorePassword, truststorePassword)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$artemis.session.createQueue(ArtemisMessagingComponent.BRIDGE_NOTIFY, RoutingType.ANYCAST, ArtemisMessagingComponent.BRIDGE_NOTIFY, false)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$private</ID>
    <ID>MaxLineLength:BridgeDriver.kt$return waitAndCopyCertificateDir("$ALICE_NAME keystore creation", nodeDirectory / "certificates", bridgeBaseDir / "certificates").flatMap { startSingleProcessBridgeAndFloat(bridgeBaseDir, bridgePort, brokerPort, configOverrides, keystorePassword = DEV_CA_KEY_STORE_PASS, truststorePassword = DEV_CA_TRUST_STORE_PASS) }</ID>
    <ID>MaxLineLength:BridgeDriver.kt$startBridge(baseDirectory, p2pPort, brokerPort, floatPort, configOverrides, artemisCertDir, keystorePassword, truststorePassword)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$startFloat(baseDirectory.parent / "float", p2pPort, brokerPort, floatPort, configOverrides, artemisCertDir!!, keystorePassword, truststorePassword)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$startSingleProcessBridgeAndFloat(baseDirectory, p2pPort, brokerPort, configOverrides, artemisCertDir, keystorePassword, truststorePassword)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$startSingleProcessBridgeAndFloat(bridgeBaseDir, bridgePort, brokerPort, configOverrides, keystorePassword = DEV_CA_KEY_STORE_PASS, truststorePassword = DEV_CA_TRUST_STORE_PASS)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val artemisClient = ArtemisMessagingClient(artemisSSLConfig, NetworkHostAndPort("localhost", artemisPort), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val bridge = startBridge(bridgePath, advertisedP2PPort, artemisPort, configOverrides + mapOf("sslKeystore" to (bridgeCertPath / BRIDGE_KEYSTORE).toString(), "keyStorePassword" to keyStorePassword, "trustStoreFile" to "$bridgeCertPath/truststore.jks", "trustStorePassword" to truststorePassword), artemisCertDir, floatPort, keyStorePassword, truststorePassword)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val bridgeControl = BridgeControl.NodeToBridgeSnapshot(DUMMY_BANK_A_NAME.toString(), listOf(inboxAddress.toString()), outEntry)</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val initialConfig = ConfigFactory.parseResources(ConfigTest::class.java, "/net/corda/bridge/singleprocess/firewall.conf")</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val initialConfig = ConfigFactory.parseResources(ConfigTest::class.java, "/net/corda/bridge/withfloat/bridge/firewall.conf")</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val initialConfig = ConfigFactory.parseResources(ConfigTest::class.java, "/net/corda/bridge/withfloat/float/firewall.conf")</ID>
    <ID>MaxLineLength:BridgeDriver.kt$val outEntry = listOf(BridgeEntry(dummyOutQueue.toString(), listOf(NetworkHostAndPort("localhost", 0)), listOf(DUMMY_BANK_A_NAME), serviceAddress = false))</ID>
    <ID>MaxLineLength:BridgeDriver.kt${ val bridgePath = baseDir / "bridge" val artemisCertDir = baseDir / "artemis" val bridgeCertPath = bridgePath / "certificates" // Create bridge identity SSL keystore by combining nodes' SSL keystore. if(nodeSSLKeystores.isNotEmpty()){ createBridgeKeystore(bridgeCertPath, *nodeSSLKeystores) (nodeSSLKeystores.first().parent / "truststore.jks").copyToDirectory(bridgeCertPath) } // Starting the bridge at the end, to test the NodeToBridgeSnapshot message's AMQP bridge convert to Loopback bridge code path. val bridge = startBridge(bridgePath, advertisedP2PPort, artemisPort, configOverrides + mapOf("sslKeystore" to (bridgeCertPath / BRIDGE_KEYSTORE).toString(), "keyStorePassword" to keyStorePassword, "trustStoreFile" to "$bridgeCertPath/truststore.jks", "trustStorePassword" to truststorePassword), artemisCertDir, floatPort, keyStorePassword, truststorePassword) val artemisSSLConfig = object : MutualSslConfiguration { override val useOpenSsl: Boolean = false override val keyStore = FileBasedCertificateStoreSupplier(artemisCertDir / ARTEMIS_KEYSTORE, keyStorePassword, keyStorePassword) override val trustStore = FileBasedCertificateStoreSupplier(artemisCertDir / ARTEMIS_TRUSTSTORE, truststorePassword, truststorePassword) } // Sending dummy NodeToBridgeSnapshot to fully start the bridge/float val artemisClient = ArtemisMessagingClient(artemisSSLConfig, NetworkHostAndPort("localhost", artemisPort), MAX_MESSAGE_SIZE) artemisClient.start() installBridgeControlResponder(artemisClient) return bridge.map { artemisClient.stop() it } }</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$"artemisCryptoServiceConfig" to mapOf("name" to "UTIMACO", "conf" to bridgeArtemisUtimacoConfig)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$CryptoServiceConfigImpl : CryptoServiceConfig</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$configOverrides</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$internalDriver</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val artemisKeyStore = CertificateStore.fromFile(artemisCertDir / ARTEMIS_HSM_KEYSTORE, DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS, createNew = true)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val bridgeArtemisCryptoService = makeCryptoService(CryptoServiceConfigImpl(SupportedCryptoServices.UTIMACO, Paths.get(bridgeArtemisUtimacoConfig)), DUMMY_BANK_A_NAME)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val bridgeCryptoService = makeCryptoService(CryptoServiceConfigImpl(SupportedCryptoServices.UTIMACO, Paths.get(bridgeUtimacoConfig)), DUMMY_BANK_C_NAME)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val bridgeKeystore = CertificateStore.fromFile(bridgeCertPath / "bridge.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS, true)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val c = startNode(providedName = DUMMY_BANK_C_NAME, rpcUsers = listOf(demoUser), customOverrides = mapOf("p2pAddress" to "localhost:${portAllocation.nextPort()}", "baseDirectory" to "$bankCPath")).getOrThrow()</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val cert = X509Utilities.createCertificate(CertificateType.TLS, root.certificate, root.keyPair, "CN=artemis,O=Corda,L=London,C=GB".let { X500Name(it).asX500Principal()}, publicKey)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val nodeAcryptoService = makeCryptoService(CryptoServiceConfigImpl(SupportedCryptoServices.UTIMACO, Paths.get(nodeAUtimacoConfig)), DUMMY_BANK_A_NAME)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val nodeBCryptoService = makeCryptoService(CryptoServiceConfigImpl(SupportedCryptoServices.UTIMACO, Paths.get(nodeBUtimacoConfig)), DUMMY_BANK_B_NAME)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val nodeKeystore = X509KeyStore.fromFile(path / "certificates" / "nodekeystore.jks", DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val publicKey = bridgeArtemisCryptoService.generateKeyPair(X509Utilities.CORDA_CLIENT_TLS, X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME)</ID>
    <ID>MaxLineLength:BridgeHSMTest.kt$BridgeHSMTest$val rootCertStore = CertificateStore.fromFile(artemisCertDir / "artemis-root.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS, false)</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$"--node-keystores"</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = true)).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$private</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val artemisServer = ArtemisMessagingServer(artemisConfig, NetworkHostAndPort("0.0.0.0", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val bridgeConfig = createAndLoadConfigFromResource(bridgeFolder, bridgeConfigResource) as FirewallConfigurationImpl</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val bridgeControl = BridgeControl.NodeToBridgeSnapshot(DUMMY_BANK_A_NAME.toString(), listOf(inboxAddress.toString()), outEntry)</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, DEV_INTERMEDIATE_CA.certificate, DEV_INTERMEDIATE_CA.keyPair, name.x500Principal, nodeCAKey.public)</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val outEntry = listOf(BridgeEntry(dummyOutQueue.toString(), listOf(NetworkHostAndPort("localhost", 7890)), listOf(DUMMY_BANK_A_NAME), serviceAddress = false))</ID>
    <ID>MaxLineLength:BridgeIntegrationDiffSslTest.kt$BridgeIntegrationDiffSslTest$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKey, name.x500Principal, tlsKey.public)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$artemisClient.started!!.session.createQueue(SimpleString("${P2P_PREFIX}12345"), RoutingType.ANYCAST, SimpleString("${P2P_PREFIX}12345"), true)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$assertEquals(listOf(NetworkHostAndPort("localhost", 12005)), bridgeConfig.outboundConfig!!.alternateArtemisBrokerAddresses)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$assertEquals(listOf(NetworkHostAndPort("localhost", 12005)), config.outboundConfig!!.alternateArtemisBrokerAddresses)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = true)).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$for (i in 0 until 5) { // The event signalling bridge down is pretty immediate, but the cascade of events leading to socket close can take a while socketState = serverListening("localhost", 10005) if (!socketState) break Thread.sleep(100) }</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$listOf(bridgeConfig.publicSSLConfiguration, bridgeConfig.bridgeInnerConfig?.tunnelSSLConfiguration).forEach { it?.createBridgeKeyStores(DUMMY_BANK_A_NAME) }</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$listOf(floatConfig.publicSSLConfiguration, floatConfig.floatOuterConfig?.tunnelSSLConfiguration).forEach { it?.createBridgeKeyStores(DUMMY_BANK_A_NAME) }</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", 12005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", 7890), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val artemisServer = ArtemisMessagingServer(artemisConfig, NetworkHostAndPort("0.0.0.0", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val artemisServer = ArtemisMessagingServer(artemisConfig, NetworkHostAndPort("0.0.0.0", 12005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val bridgeControl = BridgeControl.NodeToBridgeSnapshot(DUMMY_BANK_A_NAME.toString(), listOf(inboxAddress.toString()), outEntry)</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$val outEntry = listOf(BridgeEntry(dummyOutQueue.toString(), listOf(NetworkHostAndPort("localhost", 7890)), listOf(DUMMY_BANK_A_NAME), serviceAddress = false))</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest$while (artemisServer3.serverControl.connectionCount &lt; 2 &amp;&amp; bridgeTimeout &lt; 10) { // wait for outgoing bridge to start ++bridgeTimeout Thread.sleep(1000L) }</ID>
    <ID>MaxLineLength:BridgeIntegrationTest.kt$BridgeIntegrationTest${ val configResource = "/net/corda/bridge/singleprocess/firewall.conf" createNetworkParams(tempFolder.root.toPath()) val config = createAndLoadConfigFromResource(tempFolder.root.toPath(), configResource) config.createBridgeKeyStores(DUMMY_BANK_A_NAME) // Override some properties from the resource and use dynamically allocated ports val healthCheckPhrase = "ISpeakAMQP!" val sslHandshakeTimeout = 1000L val inboundPort = portAllocation.nextPort() // Use partial mocking to substitute overridden properties; note: they won't be reflected in log when loading config val inboundConfig = Mockito.spy(config.inboundConfig) whenever(inboundConfig?.listeningAddress).thenReturn(NetworkHostAndPort("0.0.0.0", inboundPort)) val configMock = Mockito.spy(config) whenever(configMock.sslHandshakeTimeout).thenReturn(sslHandshakeTimeout) whenever(configMock.healthCheckPhrase).thenReturn(healthCheckPhrase) whenever(configMock.inboundConfig).thenReturn(inboundConfig) whenever(configMock.networkParametersPath).thenReturn(tempFolder.root.toPath() / NETWORK_PARAMS_FILE_NAME) val (artemisServer, artemisClient) = createArtemis() try { installBridgeControlResponder(artemisClient) val bridge = FirewallInstance(configMock, FirewallVersionInfo(1, "1.1", "Dummy", "Test")) val stateFollower = bridge.activeChange.toBlocking().iterator assertEquals(false, stateFollower.next()) assertEquals(false, bridge.active) bridge.start() assertEquals(true, stateFollower.next()) assertEquals(true, bridge.active) assertEquals(true, serverListening("localhost", inboundPort)) val address = InetSocketAddress("localhost", inboundPort) // NORMAL_MODE: socket should be closed by SSL handshake timeout AsynchronousSocketChannel.open().use { it.connect(address).get() it.write(ByteBuffer.wrap("XXXX".toByteArray())) assertEquals(-1, it.read(ByteBuffer.allocate(32)).get(2*sslHandshakeTimeout, TimeUnit.MILLISECONDS)) } // ECHO_MODE: SSH handshake timeout is not applicable here AsynchronousSocketChannel.open().use { it.connect(address).get() it.write(ByteBuffer.wrap(healthCheckPhrase.toByteArray())) val buf = ByteBuffer.allocate(32) assertEquals(healthCheckPhrase.length, it.read(buf).get(sslHandshakeTimeout, TimeUnit.MILLISECONDS)) assertEquals(healthCheckPhrase, String(buf.array(), 0, healthCheckPhrase.length)) val nextBytes = it.read(buf) Thread.sleep((sslHandshakeTimeout * 3) / 2) assertEquals(false, nextBytes.isDone) // Make sure that socket is still alive after timeout } bridge.stop() assertEquals(false, stateFollower.next()) assertEquals(false, bridge.active) assertEquals(false, serverListening("localhost", inboundPort)) } finally { artemisClient.stop() artemisServer.stop() } }</ID>
    <ID>MaxLineLength:BridgeManager.kt$BridgeManager$fun deployBridge(sourceX500Name: String, queueName: String, targets: List&lt;NetworkHostAndPort&gt;, legalNames: Set&lt;CordaX500Name&gt;)</ID>
    <ID>MaxLineLength:BridgeMasterService.kt$BridgeMasterService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:BridgeReceiverService.kt$BridgeReceiverService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool : HAToolBase</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$@Option(names = ["--node-keystore-passwords"], arity = "1..*", paramLabel = "PASSWORDS", description = ["The password(s) of the node SSL keystore(s)"], required = true)</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$@Option(names = ["--node-keystores"], arity = "1..*", paramLabel = "FILES", description = ["The path to the node SSL keystore(s)"], required = true)</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$@Option(names = ["-b", BASE_DIR], paramLabel = "FOLDER", description = ["The working directory where all the files are kept."])</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$@Option(names = ["-k", "--bridge-keystore"], paramLabel = "FILES", description = ["The path to the bridge SSL keystore."])</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$@Option(names = ["-p", "--bridge-keystore-password"], paramLabel = "PASSWORD", description = ["The password of the bridge SSL keystore."], required = true)</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$logger.info("Added new SSL key with alias '$alias', for identity '${certChain.first().subjectX500Principal}'")</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$logger.info("Finish adding keys to keystore '$bridgeKeystore', keystore contains ${aliases().asSequence().count()} entries.")</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$require(passwords.size == nodeKeystore.size) { "Number of passwords doesn't match the number of keystores, got ${passwords.size} passwords for ${nodeKeystore.size} keystores." }</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$throw Exception("Error encountered when processing the following keystore(s) : $skippedKeystore , please check the inputs and rerun the key importing tool if necessary.")</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$val passwords = if (nodeKeystorePasswords.size == 1) MutableList(nodeKeystore.size) { nodeKeystorePasswords.first() }.toTypedArray() else nodeKeystorePasswords</ID>
    <ID>MaxLineLength:BridgeSSLKeyTool.kt$BridgeSSLKeyTool${ logger.info("Importing SSL key from $keystore") require(keystore.exists()) { "Invalid keystore path : $keystore" } val tlsKeystore = X509KeyStore.fromFile(keystore, password, createNew = false) val tlsKey = tlsKeystore.getPrivateKey(X509Utilities.CORDA_CLIENT_TLS, password) val certChain = tlsKeystore.getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) // Alias must be lower case to stay consistent with HSM alias after .JKS file forces to lower case on insert. val alias = x500PrincipalToTLSAlias(certChain.first().subjectX500Principal) // Key password need to be same as the keystore password setPrivateKey(alias, tlsKey, certChain, bridgeKeystorePassword) logger.info("Added new SSL key with alias '$alias', for identity '${certChain.first().subjectX500Principal}'") }</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$artemis.session.createQueue(ArtemisMessagingComponent.BRIDGE_NOTIFY, RoutingType.ANYCAST, ArtemisMessagingComponent.BRIDGE_NOTIFY, false)</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = true)).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$intermediateCa: CertificateAndKeyPair = DEV_INTERMEDIATE_CA</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$private</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$val artemisServer = ArtemisMessagingServer(artemisConfig, NetworkHostAndPort("0.0.0.0", 11005), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$val bridgeControl = BridgeControl.NodeToBridgeSnapshot(DUMMY_BANK_A_NAME.toString(), listOf(inboxAddress.toString()), emptyList())</ID>
    <ID>MaxLineLength:BridgeSmokeTest.kt$BridgeSmokeTest$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, nodeCaCert, nodeCaKeyPair, legalName.x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:BridgeSupervisorService.kt$BridgeSupervisorService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$InProcessBridgeReceiverService(maxMessageSize, auditService, haService, signingService, inProcessAMQPListenerService!!, filterService)</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$TunnelingBridgeReceiverService(conf, maxMessageSize, auditService, haService, tunnelingSigningService, signingService, filterService)</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$artemisSigningService = CryptoServiceSigningService(conf.artemisCryptoServiceConfig, legalName, artemisSSlConfiguration, conf.sslHandshakeTimeout, name = "Artemis")</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$require(conf.revocationConfig.mode != RevocationConfig.Mode.EXTERNAL_SOURCE) { "The BridgeInner and SenderReceiver modes do not support Revocation from External sources" }</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$require(inProcessAMQPListenerService == null) { "Should not have an in process instance of the AMQPListenerService" }</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$senderService = DirectBridgeSenderService(conf, maxMessageSize, signingService, auditService, haService, artemisService)</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$signingService = CryptoServiceSigningService(conf.p2pTlsSigningCryptoServiceConfig, legalName, conf.publicSSLConfiguration, conf.sslHandshakeTimeout, name = "P2P")</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl$tunnelingSigningService = CryptoServiceSigningService(conf.tunnelingCryptoServiceConfig, legalName, controlLinkSSLConfiguration, name = "Tunnel")</ID>
    <ID>MaxLineLength:BridgeSupervisorServiceImpl.kt$BridgeSupervisorServiceImpl${ require(conf.revocationConfig.mode != RevocationConfig.Mode.EXTERNAL_SOURCE) { "The BridgeInner and SenderReceiver modes do not support Revocation from External sources" } val artemisSSlConfiguration = conf.outboundConfig?.artemisSSLConfiguration ?: conf.publicSSLConfiguration // The fact that we pass BRIDGE_NAME has no effect as Crypto service obtained will only be used to sign data and never to create new key pairs val legalName = BRIDGE_NAME artemisSigningService = CryptoServiceSigningService(conf.artemisCryptoServiceConfig, legalName, artemisSSlConfiguration, conf.sslHandshakeTimeout, name = "Artemis") artemisService = BridgeArtemisConnectionServiceImpl(artemisSigningService, conf, maxMessageSize, auditService) haService = if (conf.haConfig == null) { SingleInstanceMasterService(conf, auditService) } else { ExternalMasterElectionService(conf, auditService, artemisService) } // TODO: get keystore public data from crypto service? or from config? signingService = CryptoServiceSigningService(conf.p2pTlsSigningCryptoServiceConfig, legalName, conf.publicSSLConfiguration, conf.sslHandshakeTimeout, name = "P2P") val controlLinkSSLConfiguration = conf.bridgeInnerConfig?.tunnelSSLConfiguration ?: conf.publicSSLConfiguration tunnelingSigningService = CryptoServiceSigningService(conf.tunnelingCryptoServiceConfig, legalName, controlLinkSSLConfiguration, name = "Tunnel") senderService = DirectBridgeSenderService(conf, maxMessageSize, signingService, auditService, haService, artemisService) filterService = SimpleMessageFilterService(conf, auditService, artemisService, senderService) receiverService = if (conf.firewallMode == FirewallMode.SenderReceiver) { InProcessBridgeReceiverService(maxMessageSize, auditService, haService, signingService, inProcessAMQPListenerService!!, filterService) } else { require(inProcessAMQPListenerService == null) { "Should not have an in process instance of the AMQPListenerService" } TunnelingBridgeReceiverService(conf, maxMessageSize, auditService, haService, tunnelingSigningService, signingService, filterService) } statusFollower = ServiceStateCombiner(listOf(haService, senderService, receiverService, filterService)) activeChange.subscribe({ consoleLogger.info("BridgeSupervisorService: active = $it") }, { log.error("Error in state change", it) }) }</ID>
    <ID>MaxLineLength:BridgeTestHelper.kt$inline fun &lt;reified T&gt; createPartialMock()</ID>
    <ID>MaxLineLength:BridgeTestHelper.kt$intermediateCa: CertificateAndKeyPair = DEV_INTERMEDIATE_CA</ID>
    <ID>MaxLineLength:BridgeTestHelper.kt$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, nodeCaCert, nodeCaKeyPair, legalName.x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:BridgeToolTest.kt$BridgeToolTest$"--node-keystores"</ID>
    <ID>MaxLineLength:BridgeToolTest.kt$BridgeToolTest$val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, DEV_INTERMEDIATE_CA.certificate, DEV_INTERMEDIATE_CA.keyPair, name.x500Principal, nodeCAKey.public)</ID>
    <ID>MaxLineLength:BridgeToolTest.kt$BridgeToolTest$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKey, name.x500Principal, tlsKey.public)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BaseBrokerJaasLoginModule$override</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule : BaseBrokerJaasLoginModule</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$CertificateChainCheckPolicy.LeafMustMatch.createCheck(nodeJaasConfig.keyStore, nodeJaasConfig.trustStore).checkCertificateChain(certificates!!)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$CertificateChainCheckPolicy.RootMustMatch.createCheck(p2pJaasConfig!!.keyStore, p2pJaasConfig!!.trustStore).checkCertificateChain(certificates!!)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$Pair(username, listOf(RolePrincipal(RPC_ROLE), RolePrincipal("${RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX}.$username")))</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$fun requireTls(certificates: Array&lt;X509Certificate&gt;?)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$if (e is IllegalArgumentException &amp;&amp; e.stackTrace.any { it.className == "org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASL" }) { log.trace("SASL Login failed.") } else { log.warn("Login failed: ${e.message}") }</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$override</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$private</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule${ // This is a known problem, so we swallow this exception. A peer will attempt to connect without presenting client certificates during SASL if (e is IllegalArgumentException &amp;&amp; e.stackTrace.any { it.className == "org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASL" }) { log.trace("SASL Login failed.") } else { log.warn("Login failed: ${e.message}") } if (e is LoginException) { throw e } else { throw FailedLoginException(e.message) } }</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$RPCJaasConfig$val loginListener: LoginListener</ID>
    <ID>MaxLineLength:BuiltNode.kt$BuiltNode$return PushedNode(configFile, baseDirectory, copiedNodeConfig, copiedNodeDir, nodeConfig, localImageId, remoteImageName)</ID>
    <ID>MaxLineLength:BuiltNode.kt$BuiltNode$val nodeConfig: NodeConfiguration</ID>
    <ID>MaxLineLength:BullyLeader.kt$BullyLeaderClient$if ((state == BullyState.LEADER) &amp;&amp; (currentLeader != nodeId)) { // shouldn't happen, but reset now!! log.error("$nodeId unexpected leader announcement") state = BullyState.FOLLOWER }</ID>
    <ID>MaxLineLength:BullyLeader.kt$BullyLeaderClient$override fun isLeader(): Boolean</ID>
    <ID>MaxLineLength:BullyLeader.kt$BullyLeaderClient$pollTimer = newScheduler.scheduleAtFixedRate(::timerEvent, 0L, LEADER_TIMEOUT_MSEC / 2L, TimeUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:BullyLeader.kt$BullyLeaderClient${ log.info("$nodeId Leader missing start election") currentLeader = null leaderPriority = null state = BullyState.INITIATE_ELECTION }</ID>
    <ID>MaxLineLength:BullyLeader.kt$BullyLeaderClient.ArtemisMessageSession.Companion$fun connectToArtemis(electionPath: String, locator: ServerLocator, factory: ClientSessionFactory, onMessage: (LeaderMessage) -&gt; Unit): ArtemisMessageSession</ID>
    <ID>MaxLineLength:BullyLeaderTest.kt$BullyLeaderTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = true)).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:BullyLeaderTest.kt$BullyLeaderTest$leader2.requestLeadership()</ID>
    <ID>MaxLineLength:BullyLeaderTest.kt$BullyLeaderTest$val artemisRetryLoop1 = Thread({ artemisReconnectionLoop(artemisClient1, running) }, "Artemis Connector Thread").apply { isDaemon = true }</ID>
    <ID>MaxLineLength:BullyLeaderTest.kt$BullyLeaderTest$val artemisRetryLoop2 = Thread({ artemisReconnectionLoop(artemisClient2, running) }, "Artemis Connector Thread").apply { isDaemon = true }</ID>
    <ID>MaxLineLength:ByteArrays.kt$ByteSequence$ @Suppress("MemberVisibilityCanBePrivate") fun subSequence(offset: Int, size: Int): ByteSequence</ID>
    <ID>MaxLineLength:ByteArrays.kt$ByteSequence$ fun slice(start: Int = 0, end: Int = size): ByteBuffer</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytes$/** * The bytes are always cloned so that this object becomes immutable. This has been done * to prevent tampering with entities such as [net.corda.core.crypto.SecureHash] and [net.corda.core.contracts.PrivacySalt], as well as * preserve the integrity of our hash constants [net.corda.core.crypto.SecureHash.zeroHash] and [net.corda.core.crypto.SecureHash.allOnesHash]. * * Cloning like this may become a performance issue, depending on whether or not the JIT * compiler is ever able to optimise away the clone. In which case we may need to revisit * this later. */ final override val bytes: ByteArray = bytes get() = field.clone()</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence : ByteSequence</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(offset &gt;= 0 &amp;&amp; offset &lt; bytes.size) { "Offset must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(size &gt;= 0 &amp;&amp; offset + size &lt;= bytes.size) { "Sub-sequence size must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:ByteBufferStreams.kt$ByteBufferOutputStream.Companion$private</ID>
    <ID>MaxLineLength:CacheTracingTest.kt$CacheTracingTest$val wrappedCache = wrap(cache, CacheTracing.CacheTracingConfig(true, tempDir.toPath(), { key: Any? -&gt; key as Long }), "test")</ID>
    <ID>MaxLineLength:CacheTracingTest.kt$CacheTracingTest$val wrappedCache = wrap(cache, CacheTracing.CacheTracingConfig(true, tempDir.toPath().resolve("foo/bar"), { key: Any? -&gt; key as Long }), "test")</ID>
    <ID>MaxLineLength:CaffeineStatsCounter.kt$ fun &lt;K, V&gt; Caffeine&lt;in K, in V&gt;.buildNamed(registry: MetricRegistry, metricsPrefix: String): Cache&lt;K, V&gt;</ID>
    <ID>MaxLineLength:CaffeineStatsCounter.kt$fun &lt;K, V&gt; Caffeine&lt;in K, in V&gt;.buildNamed(registry: MetricRegistry, metricsPrefix: String, loader: CacheLoader&lt;K, V&gt;): LoadingCache&lt;K, V&gt;</ID>
    <ID>MaxLineLength:CaffeineStatsCounter.kt$private fun &lt;K, V&gt; Caffeine&lt;in K, in V&gt;.addMetrics(registry: MetricRegistry, metricsPrefix: String): Caffeine&lt;in K, in V&gt;</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01").plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$val floating = interest(notional, "act/365", fix("LIBOR", start, Tenor("3M")), start, end)</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("6M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$val floating = interest(notional, "act/365", fix("LIBOR", tradeDate, Tenor("6M")), "2016-04-01", "2016-10-01")</ID>
    <ID>MaxLineLength:CarpentryDependencyGraph.kt$CarpentryDependencyGraph$/** * A map of inbound edges by node. * * A [RemoteTypeInformation] map key is a type that requires other types to have been constructed before it can be * constructed. * * Each [RemoteTypeInformation] in the corresponding [Set] map value is one of the types that the key-type depends on. * * No key ever maps to an empty set: types with no dependencies are not included in this map. */ private val dependencies = mutableMapOf&lt;RemoteTypeInformation, MutableSet&lt;RemoteTypeInformation&gt;&gt;()</ID>
    <ID>MaxLineLength:CarpentryDependencyGraph.kt$CarpentryDependencyGraph$if (dependencies.isEmpty()) newlyIndependent.asSequence() else topologicalSort(remaining, newlyIndependent)</ID>
    <ID>MaxLineLength:CarpentryDependencyGraph.kt$CarpentryDependencyGraph${ // Types which still have dependencies. val remaining = dependencies.keys.toSet() // Remove the types which have no dependencies from the dependencies of the remaining types, and identify // those types which have no dependencies left after we've done this. val newlyIndependent = dependencies.asSequence().mapNotNull { (dependent, dependees) -&gt; dependees.removeAll(noDependencies) if (dependees.isEmpty()) dependent else null }.toSet() // If there are still types with dependencies, and we have no dependencies we can remove, then we can't continue. if (newlyIndependent.isEmpty() &amp;&amp; dependencies.isNotEmpty()) { throw NotSerializableException( "Cannot build dependencies for " + dependencies.keys.map { it.typeIdentifier.prettyPrint(false) }) } // Remove the types which have no dependencies remaining, maintaining the invariant that no key maps to an // empty set. dependencies.keys.removeAll(newlyIndependent) // Return the types that had no dependencies, then recurse to process the remainder. return noDependencies.asSequence() + if (dependencies.isEmpty()) newlyIndependent.asSequence() else topologicalSort(remaining, newlyIndependent) }</ID>
    <ID>MaxLineLength:Cash.kt$Cash$ fun generateIssue(tx: TransactionBuilder, tokenDef: Issued&lt;Currency&gt;, pennies: Long, owner: AbstractParty, notary: Party)</ID>
    <ID>MaxLineLength:Cash.kt$Cash$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:Cash.kt$Cash$override</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).filter { it.value.amount.token == key }.singleOrNull()</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group")</ID>
    <ID>MaxLineLength:Cash.kt$Cash${ val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group") val outputAmount = outputs.sumCashOrZero(Issued(issuer, currency)) // If we want to remove cash from the ledger, that must be signed for by the issuer. // A mis-signed or duplicated exit command will just be ignored here and result in the exit amount being zero. val exitKeys: Set&lt;PublicKey&gt; = inputs.flatMap { it.exitKeys }.toSet() val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).filter { it.value.amount.token == key }.singleOrNull() val amountExitingLedger = exitCommand?.value?.amount ?: Amount(0, Issued(issuer, currency)) requireThat { "there are no zero sized inputs" using inputs.none { it.amount.quantity == 0L } "for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}" using (inputAmount == outputAmount + amountExitingLedger) } verifyMoveCommand&lt;Commands.Move&gt;(inputs, tx.commands) }</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$ @JvmStatic @Throws(InsufficientBalanceException::class) @Suspendable @Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)")) fun generateSpend(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet())</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$ @JvmStatic @Throws(InsufficientBalanceException::class) @Suspendable @Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)")) fun generateSpend(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet())</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$ @JvmStatic @Throws(InsufficientBalanceException::class) @Suspendable fun generateSpend(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, ourIdentity: PartyAndCertificate, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet()): Pair&lt;TransactionBuilder, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$ @JvmStatic @Throws(InsufficientBalanceException::class) @Suspendable fun generateSpend(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet()): Pair&lt;TransactionBuilder, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$@Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)"))</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$onlyFromParties: Set&lt;AbstractParty&gt; = emptySet()</ID>
    <ID>MaxLineLength:Cash.kt$Cash.Companion$val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(deposit: PartyAndReference)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(party: AbstractParty)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun withDeposit(deposit: PartyAndReference): Cash.State</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$override</ID>
    <ID>MaxLineLength:CashConfigDataFlow.kt$ConfigHolder : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:CashConfigDataFlowTest.kt$CashConfigDataFlowTest$additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP.withConfig(mapOf("issuableCurrencies" to listOf("EUR", "USD"))))</ID>
    <ID>MaxLineLength:CashExceptionSerialisationTest.kt$CashExceptionSerialisationTest$val action = { node.rpc.startFlow(CashExceptionSerialisationTest::CashExceptionThrowingFlow).returnValue.getOrThrow() }</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount)</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val changeOwner = exitStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount)</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow${ progressTracker.currentStep = GENERATING_TX val builder = TransactionBuilder(notary = null) val issuer = ourIdentity.ref(issuerRef) val exitStates = AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference)) val signers = try { val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount) Cash().generateExit( builder, amount.issuedBy(issuer), exitStates, changeOwner) } catch (e: InsufficientBalanceException) { throw CashException("Exiting more cash than exists", e) } // Work out who the owners of the burnt states were (specify page size so we don't silently drop any if &gt; DEFAULT_PAGE_SIZE) val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states val participantSessions = inputStates .asSequence() .mapNotNull { serviceHub.identityService.wellKnownPartyFromAnonymous(it.state.data.owner) } .filterNot(serviceHub.myInfo::isLegalIdentity) .distinct() .map(::initiateFlow) .toList() // Sign transaction progressTracker.currentStep = SIGNING_TX val tx = serviceHub.signInitialTransaction(builder, signers) // Commit the transaction progressTracker.currentStep = FINALISING_TX val notarised = finaliseTx(tx, participantSessions, "Unable to notarise exit") return Result(notarised, null) }</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow${ progressTracker.currentStep = GENERATING_TX val builder = TransactionBuilder(notary = null) val issuer = ourIdentity.ref(issuerRef) val exitStates = AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference)) val signers = try { val changeOwner = exitStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount) Cash().generateExit( builder, amount.issuedBy(issuer), exitStates, changeOwner ) } catch (e: InsufficientBalanceException) { throw CashException("Exiting more cash than exists", e) } // Work out who the owners of the burnt states were (specify page size so we don't silently drop any if &gt; DEFAULT_PAGE_SIZE) val inputStates = serviceHub.vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = builder.inputStates()), PageSpecification(pageNumber = DEFAULT_PAGE_NUM, pageSize = builder.inputStates().size)).states // TODO: Is it safe to drop participants we don't know how to contact? Does not knowing how to contact them // count as a reason to fail? val participantSessions = inputStates .asSequence() .mapNotNull { serviceHub.identityService.wellKnownPartyFromAnonymous(it.state.data.owner) } .filterNot(serviceHub.myInfo::isLegalIdentity) .distinct() .map(::initiateFlow) .toList() // Sign transaction progressTracker.currentStep = SIGNING_TX val tx = serviceHub.signInitialTransaction(builder, signers) // Commit the transaction progressTracker.currentStep = FINALISING_TX val notarised = finaliseTx(tx, participantSessions, "Unable to notarise exit") return Result(notarised.id, null) }</ID>
    <ID>MaxLineLength:CashExitFlowTests.kt$CashExitFlowTests$mockNet = MockNetwork(MockNetworkParameters(servicePeerAllocationStrategy = RoundRobin(), cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$@Suspendable override</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty)</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$protected constructor(creator: AbstractCashIssueAndDoublePaymentFlow) : this(creator.amount, creator.issueRef, creator.notary, creator.anonymous, creator.recipient, creator.progressTracker)</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$val (spendTx1, keysForSigning1) = OnLedgerAsset.generateSpend(builder1, listOf(PartyAndAmount(maybeAnonymousRecipient, amount)), listOf(cashStateAndRef), changeIdentity.party.anonymise(), { state, quantity, owner -&gt; deriveState(state, quantity, owner) }, { Cash().generateMoveCommand() })</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$val (spendTx2, keysForSigning2) = OnLedgerAsset.generateSpend(builder2, listOf(PartyAndAmount(maybeAnonymousRecipient, amount)), listOf(cashStateAndRef), changeIdentity.party.anonymise(), { state, quantity, owner -&gt; deriveState(state, quantity, owner) }, { Cash().generateMoveCommand() })</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$val cashStateAndRef: StateAndRef&lt;Cash.State&gt; = uncheckedCast(serviceHub.loadStates(setOf(StateRef(issueResult.id, 0))).single())</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$AbstractCashIssueAndDoublePaymentResponderFlow$abstract</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$CashIssueAndDoublePayment$constructor(amount: Amount&lt;Currency&gt;, issueRef: OpaqueBytes, payTo: Party, anonymous: Boolean, notary: Party) : this(amount, issueRef, payTo, anonymous, notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$CashIssueAndDoublePayment$constructor(request: CashIssueAndPaymentFlow.IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$CashIssueAndDoublePayment$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$CashIssueAndDoublePaymentAnonymous : AbstractCashIssueAndDoublePaymentFlow</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$CashIssueAndDoublePaymentAnonymousResponderFlow : AbstractCashIssueAndDoublePaymentResponderFlow</ID>
    <ID>MaxLineLength:CashIssueAndDoublePayment.kt$CashIssueAndDoublePaymentResponderFlow : AbstractCashIssueAndDoublePaymentResponderFlow</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentFlow$@Suspendable override</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentFlow$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty)</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentFlow$protected constructor(creator: AbstractCashIssueAndDuplicatePaymentFlow) : this(creator.amount, creator.issueRef, creator.notary, creator.anonymous, creator.recipient, creator.progressTracker)</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentFlow$val (spendTx, keysForSigning) = OnLedgerAsset.generateSpend(builder, listOf(PartyAndAmount(maybeAnonymousRecipient, amount)), listOf(cashStateAndRef), changeIdentity.party.anonymise(), { state, quantity, owner -&gt; deriveState(state, quantity, owner) }, { Cash().generateMoveCommand() })</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentFlow$val cashStateAndRef: StateAndRef&lt;Cash.State&gt; = uncheckedCast(serviceHub.loadStates(setOf(StateRef(issueResult.id, 0))).single())</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$AbstractCashIssueAndDuplicatePaymentResponderFlow$abstract</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePayment : AbstractCashIssueAndDuplicatePaymentFlow</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePayment$constructor(amount: Amount&lt;Currency&gt;, issueRef: OpaqueBytes, payTo: Party, anonymous: Boolean, notary: Party) : this(amount, issueRef, payTo, anonymous, notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePayment$constructor(request: CashIssueAndPaymentFlow.IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePayment$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePaymentAnonymous : AbstractCashIssueAndDuplicatePaymentFlow</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePaymentAnonymousResponderFlow : AbstractCashIssueAndDuplicatePaymentResponderFlow</ID>
    <ID>MaxLineLength:CashIssueAndDuplicatePayment.kt$CashIssueAndDuplicatePaymentResponderFlow : AbstractCashIssueAndDuplicatePaymentResponderFlow</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlow.kt$CashIssueAndPaymentFlow$constructor(request: IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlow.kt$CashIssueAndPaymentFlow$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlowTests.kt$CashIssueAndPaymentFlowTests$val future = bankOfCordaNode.startFlow(CashIssueAndPaymentFlow(expectedPayment, OpaqueBytes.of(1), payTo, false, notary))</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionFlow$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty)</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionFlow$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionFlow$protected constructor(creator: AbstractCashIssueAndPaymentNoSelectionFlow) : this(creator.amount, creator.issueRef, creator.notary, creator.anonymous, creator.recipient, creator.progressTracker)</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionFlow$val (spendTx, keysForSigning) = OnLedgerAsset.generateSpend(builder, listOf(PartyAndAmount(maybeAnonymousRecipient, amount)), listOf(cashStateAndRef), changeIdentity.party.anonymise(), { state, quantity, owner -&gt; deriveState(state, quantity, owner) }, { Cash().generateMoveCommand() })</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionFlow$val cashStateAndRef: StateAndRef&lt;Cash.State&gt; = uncheckedCast(serviceHub.loadStates(setOf(StateRef(issueResult.id, 0))).single())</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$AbstractCashIssueAndPaymentNoSelectionResponderFlow$abstract</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$CashIssueAndPaymentNoSelection$constructor(amount: Amount&lt;Currency&gt;, issueRef: OpaqueBytes, payTo: Party, anonymous: Boolean, notary: Party) : this(amount, issueRef, payTo, anonymous, notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$CashIssueAndPaymentNoSelection$constructor(request: CashIssueAndPaymentFlow.IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$CashIssueAndPaymentNoSelection$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$CashIssueAndPaymentNoSelectionAnonymous : AbstractCashIssueAndPaymentNoSelectionFlow</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$CashIssueAndPaymentNoSelectionResponderAnonymousFlow : AbstractCashIssueAndPaymentNoSelectionResponderFlow</ID>
    <ID>MaxLineLength:CashIssueAndPaymentNoSelection.kt$CashIssueAndPaymentNoSelectionResponderFlow : AbstractCashIssueAndPaymentNoSelectionResponderFlow</ID>
    <ID>MaxLineLength:CashIssueFlowTests.kt$CashIssueFlowTests$mockNet = MockNetwork(MockNetworkParameters(servicePeerAllocationStrategy = RoundRobin(), cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$AbstractCashPaymentFlow$@Suspendable override</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$AbstractCashPaymentFlow$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$AbstractCashPaymentFlow$protected constructor(creator: AbstractCashPaymentFlow) : this(creator.amount, creator.issuerConstraint, creator.anonymous, creator.recipient, creator.progressTracker)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$AbstractCashPaymentFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$AbstractCashPaymentResponderFlow$abstract</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$/** A straightforward constructor that constructs spends using cash states of any issuer. */ constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean) : this(amount, recipient, anonymous, tracker())</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean, notary: Party) : this(amount, recipient, anonymous, tracker(), notary = notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(request: PaymentRequest) : this(request.amount, request.recipient, request.anonymous, tracker(), request.issuerConstraint)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(request: PaymentRequest) : this(request.amount, request.recipient, request.anonymous, tracker(), request.issuerConstraint, request.notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$issuerConstraint: Set&lt;Party&gt; = emptySet()</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashPaymentFlowTests.kt$CashPaymentFlowTests$mockNet = MockNetwork(MockNetworkParameters(servicePeerAllocationStrategy = RoundRobin(), cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$// Used by anonymous code path. constructor(creator: AbstractCashPaymentFromKnownStatesFlow) : this(creator.inputs, creator.numberOfStates, creator.numberOfChangeStates, creator.amountPerState, creator.recipient, creator.anonymous, creator.progressTracker)</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$@Suspendable override</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty)</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$override fun makeAnonymousFlow(): AbstractCashPaymentFromKnownStatesFlow</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$progressTracker: ProgressTracker</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$val amounts = ArrayList(Collections.nCopies(numberOfStates, PartyAndAmount(maybeAnonymousRecipient, amountPerState)))</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesFlow$val sessionsForFinality = if (serviceHub.myInfo.isLegalIdentity(recipient)) emptyList() else listOf(recipientSession)</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$AbstractCashPaymentFromKnownStatesResponderFlow$abstract</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$CashPaymentFromKnownStatesAnonymousFlow : AbstractCashPaymentFromKnownStatesFlow</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$CashPaymentFromKnownStatesFlow$( inputs: Set&lt;StateRef&gt;, numberOfStates: Int, numberOfChangeStates: Int, amountPerState: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean, progressTracker: ProgressTracker )</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$CashPaymentFromKnownStatesResponderAnonymousFlow : AbstractCashPaymentFromKnownStatesResponderFlow</ID>
    <ID>MaxLineLength:CashPaymentFromKnownStatesFlow.kt$CashPaymentFromKnownStatesResponderFlow : AbstractCashPaymentFromKnownStatesResponderFlow</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$logger.info("#$iterNo.2 - Success: normal -&gt; ha, amount: ${transferQuantity}p, TX ID: ${firstPayment.stx.id}")</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$logger.info("#$iterNo.4 - Success: ha -&gt; normal, amount: ${transferBackQuantity}p, TX ID: ${secondPayment.stx.id}")</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$private</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$require(allPayments.size == (iterCount * 2)) { "Expected number of payments is ${iterCount * 2}, actual number of payments: ${allPayments.size}" }</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$require(transactionId in allStatesForParty) { "States for party: $recipient should contain reference: $transactionId" }</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$return verifyPaymentsAndStatesTally(allPayments, mapOf(normalNodeParty to normalStates, haNodeParty to haStates))</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$val allStatesForParty = hashesByParty[recipient] ?: throw IllegalArgumentException("Cannot find states for party: $recipient in transaction: $transactionId")</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$val firstPayment = normalNodeRpcOps.startFlow(::CashPaymentFlow, Amount(transferQuantity, currency), haNodeParty, false).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$val hashesByParty: Map&lt;Party, Set&lt;SecureHash&gt;&gt; = statesByParty.mapValues { entry -&gt; entry.value.states.map { state -&gt; state.ref.txhash }.toSet() }</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$val issueOutcome = normalNodeRpcOps.startFlow(::CashIssueFlow, issueAmount, OpaqueBytes(issuerBankPartyRef), notary).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CashScenarioRunner.kt$CashScenarioRunner$val secondPayment = haNodeRpcOps.startFlowWithRetryAndGet(::CashPaymentFlow, Amount(transferBackQuantity, currency), normalNodeParty, false)</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$override</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$psSelectJoin.setObject(++pIndex, onlyFromIssuerParties.map { it.owningKey.toStringShort() as Any}.toTypedArray() )</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl${ connection.createStatement().use { it.execute("CALL SET(@t, CAST(0 AS BIGINT));") } // state_status = 0 -&gt; UNCONSUMED. // is_relevant = 0 -&gt; RELEVANT. val selectJoin = """ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id FROM vault_states AS vs, contract_cash_states AS ccs WHERE vs.transaction_id = ccs.transaction_id AND vs.output_index = ccs.output_index AND vs.state_status = 0 AND vs.relevancy_status = 0 AND ccs.ccy_code = ? and @t &lt; ? AND (vs.lock_id = ? OR vs.lock_id is null) """ + (if (notary != null) " AND vs.notary_name = ?" else "") + (if (onlyFromIssuerParties.isNotEmpty()) { val repeats = generateSequence { "?" }.take(onlyFromIssuerParties.size).joinToString(",") " AND ccs.issuer_key_hash IN ($repeats)" } else "") + (if (withIssuerRefs.isNotEmpty()) { val repeats = generateSequence { "?" }.take(withIssuerRefs.size).joinToString(",") " AND ccs.issuer_ref IN ($repeats)" } else "") // Use prepared statement for protection against SQL Injection (http://www.h2database.com/html/advanced.html#sql_injection) connection.prepareStatement(selectJoin).use { psSelectJoin -&gt; var pIndex = 0 psSelectJoin.setString(++pIndex, amount.token.currencyCode) psSelectJoin.setLong(++pIndex, amount.quantity) psSelectJoin.setString(++pIndex, lockId.toString()) if (notary != null) psSelectJoin.setString(++pIndex, notary.name.toString()) onlyFromIssuerParties.forEach { psSelectJoin.setString(++pIndex, it.owningKey.toStringShort()) } withIssuerRefs.forEach { psSelectJoin.setBytes(++pIndex, it.bytes) } log.debug { psSelectJoin.toString() } psSelectJoin.executeQuery().use { rs -&gt; return withResultSet(rs) } } }</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl${ connection.createStatement().use { it.execute("CALL SET(@t, CAST(0 AS BIGINT));") } val selectJoin = """ SELECT vs.transaction_id, vs.output_index, ccs.pennies, SET(@t, ifnull(@t,0)+ccs.pennies) total_pennies, vs.lock_id FROM vault_states AS vs, contract_pt_cash_states AS ccs WHERE vs.transaction_id = ccs.transaction_id AND vs.output_index = ccs.output_index AND vs.state_status = 0 AND ccs.ccy_code = ? and @t &lt; ? AND (vs.lock_id = ? OR vs.lock_id is null) """ + (if (notary != null) " AND vs.notary_name = ?" else "") + (if (onlyFromIssuerParties.isNotEmpty()) " AND ccs.issuer_key_hash IN (?)" else "") + (if (withIssuerRefs.isNotEmpty()) " AND ccs.issuer_ref IN (?)" else "") // Use prepared statement for protection against SQL Injection (http://www.h2database.com/html/advanced.html#sql_injection) connection.prepareStatement(selectJoin).use { psSelectJoin -&gt; var pIndex = 0 psSelectJoin.setString(++pIndex, amount.token.currencyCode) psSelectJoin.setLong(++pIndex, amount.quantity) psSelectJoin.setString(++pIndex, lockId.toString()) if (notary != null) psSelectJoin.setString(++pIndex, notary.name.toString()) if (onlyFromIssuerParties.isNotEmpty()) psSelectJoin.setObject(++pIndex, onlyFromIssuerParties.map { it.owningKey.toStringShort() as Any}.toTypedArray() ) if (withIssuerRefs.isNotEmpty()) psSelectJoin.setObject(++pIndex, withIssuerRefs.map { it.bytes.toHexString() as Any }.toTypedArray()) log.debug { psSelectJoin.toString() } psSelectJoin.executeQuery().use { rs -&gt; return withResultSet(rs) } } }</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$( // Tweak connections to be minimal to make this easier (1 results in a hung node during start up, so use 2 connections). configOverrides = MockNodeConfigOverrides(extraDataSourceProperties = mapOf("maximumPoolSize" to "2")) )</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$private val mockNet = MockNetwork(MockNetworkParameters(threadPerNode = true, cordappsForAllNodes = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$val paymentResult = node.startFlow(CashPaymentFlow(999.POUNDS, node.info.legalIdentities[0], false)).getOrThrow()</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$val request = CashPaymentFlow.PaymentRequest(1.POUNDS, node.info.legalIdentities[0], true, setOf(node.info.legalIdentities[0], mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest${ val bankA = mockNet.createNode(MockNodeParameters( // Tweak connections to be minimal to make this easier (1 results in a hung node during start up, so use 2 connections). configOverrides = MockNodeConfigOverrides(extraDataSourceProperties = mapOf("maximumPoolSize" to "2")) )) val notary = mockNet.defaultNotaryIdentity // Start more cash spends than we have connections. If spend leaks a connection on retry, we will run out of connections. val flow1 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) val flow2 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) val flow3 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) assertThatThrownBy { flow1.getOrThrow() }.isInstanceOf(CashException::class.java) assertThatThrownBy { flow2.getOrThrow() }.isInstanceOf(CashException::class.java) assertThatThrownBy { flow3.getOrThrow() }.isInstanceOf(CashException::class.java) }</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest${ val node = mockNet.createNode() // The amount has to split across at least two states, probably to trigger the H2 accumulator variable during the // spend operation below. // Issuing Integer.MAX_VALUE will not cause an exception since PersistentCashState.pennies is a long nCopies(2, Integer.MAX_VALUE).map { issueAmount -&gt; node.startFlow(CashIssueFlow(issueAmount.POUNDS, OpaqueBytes.of(1), mockNet.defaultNotaryIdentity)) }.transpose().getOrThrow() // The spend must be more than the size of a single cash state to force the accumulator onto the second state. node.startFlow(CashPaymentFlow((Integer.MAX_VALUE + 1L).POUNDS, node.info.legalIdentities[0])).getOrThrow() }</ID>
    <ID>MaxLineLength:CashSelectionH2Test.kt$CashSelectionH2Test$( // Tweak connections to be minimal to make this easier (1 results in a hung node during start up, so use 2 connections). extraDataSourceProperties = mapOf("maximumPoolSize" to "2"))</ID>
    <ID>MaxLineLength:CashSelectionH2Test.kt$CashSelectionH2Test${ val bankA = mockNet.createNode(MockNodeParameters(configOverrides = MockNodeConfigOverrides( // Tweak connections to be minimal to make this easier (1 results in a hung node during start up, so use 2 connections). extraDataSourceProperties = mapOf("maximumPoolSize" to "2")))) val notary = mockNet.defaultNotaryIdentity // Start more cash spends than we have connections. If spend leaks a connection on retry, we will run out of connections. val flow1 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) val flow2 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) val flow3 = bankA.startFlow(CashPaymentFlow(amount = 100.DOLLARS, anonymous = false, recipient = notary)) assertThatThrownBy { flow1.getOrThrow() }.isInstanceOf(CashException::class.java) assertThatThrownBy { flow2.getOrThrow() }.isInstanceOf(CashException::class.java) assertThatThrownBy { flow3.getOrThrow() }.isInstanceOf(CashException::class.java) }</ID>
    <ID>MaxLineLength:CashSelectionH2Test.kt$CashSelectionH2Test${ val node = mockNet.createNode() // The amount has to split across at least two states, probably to trigger the H2 accumulator variable during the // spend operation below. // Issuing Integer.MAX_VALUE will not cause an exception since PersistentCashState.pennies is a long nCopies(2, Integer.MAX_VALUE).map { issueAmount -&gt; node.startFlow(CashIssueFlow(issueAmount.POUNDS, OpaqueBytes.of(1), mockNet.defaultNotaryIdentity)) }.transpose().getOrThrow() // The spend must be more than the size of a single cash state to force the accumulator onto the second state. node.startFlow(CashPaymentFlow((Integer.MAX_VALUE + 1L).POUNDS, node.info.legalIdentities[0])).getOrThrow() }</ID>
    <ID>MaxLineLength:CashSelectionMySQLImpl.kt$CashSelectionMySQLImpl$override</ID>
    <ID>MaxLineLength:CashSelectionOracleImpl.kt$CashSelectionOracleImpl$(if (onlyFromIssuerParties.isNotEmpty()) "issuer_key_hash IN ${onlyFromIssuerParties.map { it.owningKey.toStringShort() as Any }.toTypedArray()}" else "")</ID>
    <ID>MaxLineLength:CashSelectionOracleImpl.kt$CashSelectionOracleImpl$(if (withIssuerRefs.isNotEmpty()) "issuer_ref IN ${withIssuerRefs.map { it.bytes.toHexString() as Any }.toTypedArray()}" else "")</ID>
    <ID>MaxLineLength:CashSelectionOracleImpl.kt$CashSelectionOracleImpl$onlyFromIssuerParties: Set&lt;AbstractParty&gt;</ID>
    <ID>MaxLineLength:CashSelectionOracleImpl.kt$CashSelectionOracleImpl${ val selectJoin = """ WITH entry(transaction_id, output_index, pennies, total, lock_id) AS ( SELECT vs.transaction_id, vs.output_index, ccs.pennies, SUM(ccs.pennies) OVER (ORDER BY ccs.transaction_id, ccs.output_index), vs.lock_id FROM contract_cash_states ccs, vault_states vs WHERE vs.transaction_id = ccs.transaction_id AND vs.output_index = ccs.output_index AND vs.state_status = 0 AND vs.relevancy_status = 0 AND ccs.ccy_code = ? AND (vs.lock_id = ? OR vs.lock_id is null) """+ (if (notary != null) " AND vs.notary_name = ?" else "") + (if (onlyFromIssuerParties.isNotEmpty()) { val repeats = generateSequence { "?" } .take(onlyFromIssuerParties.size) .joinToString (",") " AND ccs.issuer_key_hash IN ($repeats)" } else { "" }) + (if (withIssuerRefs.isNotEmpty()) { val repeats = generateSequence { "?" } .take(withIssuerRefs.size) .joinToString (",") " AND ccs.issuer_ref IN ($repeats)" } else { "" }) + """) SELECT transaction_id, output_index, pennies, total, lock_id FROM entry where total &lt; ? + pennies""" // Use prepared statement for protection against SQL Injection (http://www.h2database.com/html/advanced.html#sql_injection) connection.prepareStatement(selectJoin).use { statement -&gt; var pIndex = 0 statement.setString(++pIndex, amount.token.currencyCode) statement.setString(++pIndex, lockId.toString()) if (notary != null) statement.setString(++pIndex, notary.name.toString()) onlyFromIssuerParties.map { it.owningKey.toStringShort() }.forEach { statement.setObject(++pIndex, it) } withIssuerRefs.map { it.bytes }.forEach { statement.setBytes(++pIndex, it) } statement.setLong(++pIndex, amount.quantity) // https://stackoverflow.com/questions/2683214/get-query-from-java-sql-preparedstatement log.trace { """$selectJoin Prepared statement parameter values: ccy_code = ${amount.token.currencyCode} lock_id = $lockId """ + (if (notary != null) "notary = ${notary.name}" else "") + (if (onlyFromIssuerParties.isNotEmpty()) "issuer_key_hash IN ${onlyFromIssuerParties.map { it.owningKey.toStringShort() as Any }.toTypedArray()}" else "") + (if (withIssuerRefs.isNotEmpty()) "issuer_ref IN ${withIssuerRefs.map { it.bytes.toHexString() as Any }.toTypedArray()}" else "") + "total &lt;= ${amount.quantity}" } statement.executeQuery().use { rs -&gt; return withResultSet(rs) } } }</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$ coalesce((SUM(ccs.pennies) OVER (PARTITION BY 1 ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)), 0)</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$override</ID>
    <ID>MaxLineLength:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$onlyFromIssuerParties: Set&lt;AbstractParty&gt;</ID>
    <ID>MaxLineLength:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$statement.setObject(++pIndex, onlyFromIssuerParties.map { it.owningKey.toBase58String() as Any }.toTypedArray())</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$AbstractCashSelection .getInstance { node.services.jdbcSession().metaData } .unconsumedCashStatesForSpending(node.services, exitedAmount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$issuance.addOutputState(TransactionState(Cash.State(coin, nodeIdentity), Cash.PROGRAM_ID, mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$issuance.addOutputState(TransactionState(Cash.State(it, nodeIdentity), "net.corda.finance.contracts.asset.Cash", mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$node.services.startFlow(CashIssueFlow(issuedAmount, issuerRef, mockNet.defaultNotaryIdentity)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$(miniCorpServices.myInfo.legalIdentitiesAndCerts + megaCorpServices.myInfo.legalIdentitiesAndCerts + notaryServices.myInfo.legalIdentitiesAndCerts)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateExit(tx, Amount(amount.quantity, Issued(issuer.ref(depositRef), amount.token)), WALLET, payChangeTo)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateIssue(ptx, 100.DOLLARS `issued by` MINI_CORP.ref(12, 34), owner = MINI_CORP, notary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateIssue(this, 100.DOLLARS `issued by` MINI_CORP.ref(12, 34), owner = AnonymousParty(ALICE_PUBKEY), notary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash.generateSpend(ourServices, tx, 80.DOLLARS, ourServices.myInfo.singleIdentityAndCert(), ALICE, setOf(MINI_CORP))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$TransactionState(Cash.State(amount `issued by` issuer.ref(depositRef), ourIdentity), Cash.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$amount = Amount(amount.quantity, token = amount.token.copy(amount.token.issuer.copy(reference = OpaqueBytes.of(ref))))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState.state.data.copy(owner = miniCorpAnonymised, amount = 10.DOLLARS `issued by` defaultIssuer), wtx.outputs[0].data)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState0.state.data.copy(owner = miniCorpAnonymised, amount = 500.DOLLARS `issued by` defaultIssuer), wtx.getOutput(0))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState0.state.data.copy(owner = miniCorpAnonymised, amount = 500.DOLLARS `issued by` defaultIssuer), wtx.outputs[1].data)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertNotEquals((fiveThousandDollarsFromMega withDeposit defaultIssuer).amount.token, fiveThousandDollarsFromMega.amount.token)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertNotEquals(fiveThousandDollarsFromMega.amount.token, (fiveThousandDollarsFromMega withDeposit defaultIssuer).amount.token)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$listOf("com.r3.corda.enterprise.perftestcordapp.contracts.asset", "com.r3.corda.enterprise.perftestcordapp.schemas")</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, DUMMY_CASH_ISSUER_IDENTITY, DUMMY_NOTARY_IDENTITY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$megaCorpServices = MockServices(listOf("com.r3.corda.enterprise.perftestcordapp.contracts.asset", "com.r3.corda.enterprise.perftestcordapp.schemas"), MEGA_CORP.name, mock(), MEGA_CORP_KEY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$miniCorpServices</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = megaCorpServices, ownedBy = ourIdentity, issuedBy = MEGA_CORP.ref(1), howMuch = 100.DOLLARS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = megaCorpServices, ownedBy = ourIdentity, issuedBy = MEGA_CORP.ref(1), howMuch = 100.POUNDS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = megaCorpServices, ownedBy = ourIdentity, issuedBy = MEGA_CORP.ref(1), howMuch = 400.DOLLARS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = megaCorpServices, ownedBy = ourIdentity, issuedBy = MEGA_CORP.ref(1), howMuch = 400.POUNDS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = miniCorpServices, ownedBy = ourIdentity, issuedBy = MINI_CORP.ref(1), howMuch = 80.DOLLARS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = miniCorpServices, ownedBy = ourIdentity, issuedBy = MINI_CORP.ref(1), howMuch = 80.POUNDS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$ourServices.fillWithSomeTestCash(issuerServices = miniCorpServices, ownedBy = ourIdentity, issuedBy = MINI_CORP.ref(1), howMuch = 80.SWISS_FRANCS, outputNotary = DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, "MEGA_CORP cash 2", "MEGA_CORP cash".output&lt;Cash.State&gt;().copy(owner = AnonymousParty(ALICE_PUBKEY)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, "MEGA_CORP cash 3", "MEGA_CORP cash".output&lt;Cash.State&gt;().copy(owner = ALICE))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, inState.copy(owner = AnonymousParty(BOB_PUBKEY), amount = 2000.DOLLARS `issued by` defaultIssuer))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)) issuedBy MINI_CORP)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(owner = MINI_CORP, amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$private</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$this `fails with` "required com.r3.corda.enterprise.perftestcordapp.contracts.asset.Cash.Commands.Move command"</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$val expectedChange = WALLET[0].state.data.copy(amount = WALLET[0].state.data.amount.copy(quantity = expectedChangeAmount), owner = actualChange.owner)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$val notaryServices = MockServices(listOf("com.r3.corda.enterprise.perftestcordapp.contracts.asset", "com.r3.corda.enterprise.perftestcordapp.schemas"), DUMMY_NOTARY.name, rigorousMock(), DUMMY_NOTARY_KEY)</ID>
    <ID>MaxLineLength:CashTests.kt$cash.generateIssue(issuance, Amount(howMuch.quantity, Issued(issuedBy.copy(reference = ref), howMuch.token)), anonParty, outputNotary)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$@Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)"))</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt;</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$return generateSpend(services, tx, listOf(PartyAndAmount(to, amount)), services.myInfo.legalIdentitiesAndCerts.single(), onlyFromParties)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils${ fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt; { return txState.copy(data = txState.data.copy(amount = amt, owner = owner)) } // Retrieve unspent and unlocked cash states that meet our spending criteria. val totalAmount = payments.map { it.amount }.sumOrThrow() val cashSelection = AbstractCashSelection.getInstance { services.jdbcSession().metaData } val acceptableCoins = cashSelection.unconsumedCashStatesForSpending(services, totalAmount, onlyFromParties, tx.notary, tx.lockId) val revocationEnabled = false // Revocation is currently unsupported // If anonymous is true, generate a new identity that change will be sent to for confidentiality purposes. This means that a // third party with a copy of the transaction (such as the notary) cannot identify who the change was // sent to val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party return OnLedgerAsset.generateSpend( tx, payments, acceptableCoins, changeIdentity, ::deriveState, Cash()::generateMoveCommand ) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$"Issuer" to { state, text -&gt; state.resolveIssuer().value?.name?.organisation?.contains(text, true) == true }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates))</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) } /** * Now that we have all nodes per currency, we sum the exchanged amounts, to be displayed in the * "&lt;currency&gt; Equiv" column, this time on the issuer level. */ val equivAmounts = currencyNodes.map { it.value.equivAmount }.flatten() val equivSumAmount = reportingCurrency.bind { currency -&gt; equivAmounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) } /** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates)) /** * Bind the children in the TreeTable structure. * * TODO Perhaps we shouldn't do this here, but rather have a generic way of binding nodes to the treetable once. */ treeItem.isExpanded = true val children: List&lt;TreeItem&lt;out ViewerNode.IssuerNode&gt;&gt; = treeItem.children Bindings.bindContent(children, currencyNodes) treeItem</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * This is where we aggregate the list of cash states into the TreeTable structure. */ val cashViewerIssueNodes: ObservableList&lt;TreeItem&lt;out ViewerNode.IssuerNode&gt;&gt; = /** * First we group the states based on the issuer. [memberStates] is all states holding currency issued by [issuer] */ AggregatedList(searchField.filteredData, { it.state.data.amount.token.issuer.party }) { issuer, memberStates -&gt; /** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) } /** * Now that we have all nodes per currency, we sum the exchanged amounts, to be displayed in the * "&lt;currency&gt; Equiv" column, this time on the issuer level. */ val equivAmounts = currencyNodes.map { it.value.equivAmount }.flatten() val equivSumAmount = reportingCurrency.bind { currency -&gt; equivAmounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) } /** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates)) /** * Bind the children in the TreeTable structure. * * TODO Perhaps we shouldn't do this here, but rather have a generic way of binding nodes to the treetable once. */ treeItem.isExpanded = true val children: List&lt;TreeItem&lt;out ViewerNode.IssuerNode&gt;&gt; = treeItem.children Bindings.bindContent(children, currencyNodes) treeItem }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * We allow filtering by both issuer and currency. We do this by filtering by both at the same time and picking the * one which produces more results, which seems to work, as the set of currency strings don't really overlap with * issuer strings. */ val searchField = SearchField(cashStates, "Currency" to { state, text -&gt; state.state.data.amount.token.product.toString().contains(text, true) }, "Issuer" to { state, text -&gt; state.resolveIssuer().value?.name?.organisation?.contains(text, true) == true } )</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$AggregatedList</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$is ViewerNode.IssuerNode -&gt; SimpleStringProperty(node.issuer.nameOrNull()?.let { PartyNameFormatter.short.format(it) } ?: "Anonymous")</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$itemsProperty().bind(selectedNode.map { it?.states?.map { StateRow(LocalDateTime.now(), it) } ?: ObservableListWrapper(emptyList()) })</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$setCellValueFactory { val node = it.value.value when (node) { is ViewerNode.IssuerNode -&gt; null.lift() is ViewerNode.CurrencyNode -&gt; node.amount.map { it } } } cellFactory = currencyCellFactory /** * We must set this, otherwise on sort an exception will be thrown, as it will try to compare Amounts of differing currency */ isSortable = false</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.CashWidget$if(lastTimeStamp != null &amp;&amp; currentTimeStamp - lastTimeStamp.toLong() &lt; 1.seconds.toMillis()) { data.safelyTransition { remove(size - 1, size) } }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.CashWidget$private</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.CashWidget${ // If update arrived in very close succession to the previous one - kill the last point received to eliminate un-necessary noise on the graph. if(lastTimeStamp != null &amp;&amp; currentTimeStamp - lastTimeStamp.toLong() &lt; 1.seconds.toMillis()) { data.safelyTransition { remove(size - 1, size) } } // Add a new data point. data(currentTimeStamp, currAmount) // Limit population of data points to make graph painting faster. data.safelyTransition { if (size &gt; 300) remove(0, 1) } }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.StateRowGraphic$issuerValueLabel.apply { tooltip(resolvedIssuer.nameOrNull()?.let { PartyNameFormatter.full.format(it) } ?: "Anonymous") }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.StateRowGraphic$val resolvedIssuer: AbstractParty = stateRow.stateAndRef.resolveIssuer().value ?: stateRow.stateAndRef.state.data.amount.token.issuer.party</ID>
    <ID>MaxLineLength:CertHoldingKeyManagerFactoryWrapper.kt$CertHoldingKeyManagerFactorySpiWrapper : KeyManagerFactorySpi</ID>
    <ID>MaxLineLength:CertHoldingKeyManagerFactoryWrapper.kt$CertHoldingKeyManagerFactorySpiWrapper$else -&gt; throw UnsupportedOperationException("Supported key manager types are: X509ExtendedKeyManager, X509KeyManager. Provided ${keyManager::class.java.name}")</ID>
    <ID>MaxLineLength:CertHoldingKeyManagerFactoryWrapper.kt$CertHoldingKeyManagerFactorySpiWrapper$val engineInitMethod = KeyManagerFactorySpi::class.java.getDeclaredMethod("engineInit", KeyStore::class.java, CharArray::class.java)</ID>
    <ID>MaxLineLength:CertHoldingKeyManagerFactoryWrapper.kt$CertHoldingKeyManagerFactorySpiWrapper$val engineInitMethod = KeyManagerFactorySpi::class.java.getDeclaredMethod("engineInit", ManagerFactoryParameters::class.java)</ID>
    <ID>MaxLineLength:CertHoldingKeyManagerFactoryWrapper.kt$CertHoldingKeyManagerFactoryWrapper : KeyManagerFactory</ID>
    <ID>MaxLineLength:CertPathSerializer.kt$CertPathSerializer : Proxy</ID>
    <ID>MaxLineLength:CertRole.kt$CertRole : ASN1Encodable</ID>
    <ID>MaxLineLength:CertRole.kt$CertRole$enum</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { confidentialCertRole.isValidParent(doormanCertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { confidentialCertRole.isValidParent(nodeCACertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { legalIDCertFromDoormanRole.isValidParent(tlsCertFromDoormanRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertFalse { tlsCertFromNodeCARole.isValidParent(legalIDCertFromNodeCARole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertTrue { confidentialCertRole.isValidParent(legalIDCertFromNodeCARole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertTrue { doormanCertRole.isValidParent(intermediateRootCertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$assertTrue { legalIDCertFromDoormanRole.isValidParent(doormanCertRole) }</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val confidentialCert = X509Utilities.createCertificate(CertificateType.CONFIDENTIAL_LEGAL_IDENTITY, legalIDCertFromNodeCA, legalIDKeyPairFromNodeCA, nodeSubject, confidentialKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val doormanCert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, intermediateRootCert, intermediateRootKeyPair, doormanSubject, doormanKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val intermediateRootCert = X509Utilities.createCertificate(CertificateType.ROOT_CA, rootCert, rootKeyPair, intermediateRootSubject, intermediateRootKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val legalIDCertFromDoorman = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, doormanCert, doormanKeyPair, nodeSubject, legalIDKeyPairFromDoorman.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val legalIDCertFromNodeCA = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCACert, nodeCAKeyPair, nodeSubject, legalIDKeyPairFromNodeCA.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, doormanCert, doormanKeyPair, nodeSubject, nodeCAKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val tlsCertFromDoorman = X509Utilities.createCertificate(CertificateType.TLS, doormanCert, doormanKeyPair, nodeSubject, tlsKeyPairFromDoorman.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val tlsCertFromNodeCA = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKeyPair, nodeSubject, tlsKeyPairFromNodeCA.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests${ // Testing for various certificate hierarchies (with or without NodeCA). // ROOT -&gt; Intermediate Root -&gt; Doorman -&gt; NodeCA -&gt; Legal Identity cert -&gt; Confidential key cert // -&gt; NodeCA -&gt; TLS // -&gt; Legal Identity cert -&gt; Confidential key cert // -&gt; TLS val rootSubject = X500Principal("CN=Root,O=R3 Ltd,L=London,C=GB") val intermediateRootSubject = X500Principal("CN=Intermediate Root,O=R3 Ltd,L=London,C=GB") val doormanSubject = X500Principal("CN=Doorman,O=R3 Ltd,L=London,C=GB") val nodeSubject = X500Principal("CN=Node,O=R3 Ltd,L=London,C=GB") val rootKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val rootCert = X509Utilities.createSelfSignedCACertificate(rootSubject, rootKeyPair) val rootCertRole = CertRole.extract(rootCert) val intermediateRootKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) // Note that [CertificateType.ROOT_CA] is used for both root and intermediate root. val intermediateRootCert = X509Utilities.createCertificate(CertificateType.ROOT_CA, rootCert, rootKeyPair, intermediateRootSubject, intermediateRootKeyPair.public) val intermediateRootCertRole = CertRole.extract(intermediateRootCert) val doormanKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) // Note that [CertificateType.INTERMEDIATE_CA] has actually role = CertRole.DOORMAN_CA, see [CertificateType] in [X509Utilities]. val doormanCert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, intermediateRootCert, intermediateRootKeyPair, doormanSubject, doormanKeyPair.public) val doormanCertRole = CertRole.extract(doormanCert)!! val nodeCAKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, doormanCert, doormanKeyPair, nodeSubject, nodeCAKeyPair.public) val nodeCACertRole = CertRole.extract(nodeCACert)!! val tlsKeyPairFromNodeCA = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val tlsCertFromNodeCA = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKeyPair, nodeSubject, tlsKeyPairFromNodeCA.public) val tlsCertFromNodeCARole = CertRole.extract(tlsCertFromNodeCA)!! val tlsKeyPairFromDoorman = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val tlsCertFromDoorman = X509Utilities.createCertificate(CertificateType.TLS, doormanCert, doormanKeyPair, nodeSubject, tlsKeyPairFromDoorman.public) val tlsCertFromDoormanRole = CertRole.extract(tlsCertFromDoorman)!! val legalIDKeyPairFromNodeCA = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val legalIDCertFromNodeCA = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCACert, nodeCAKeyPair, nodeSubject, legalIDKeyPairFromNodeCA.public) val legalIDCertFromNodeCARole = CertRole.extract(legalIDCertFromNodeCA)!! val legalIDKeyPairFromDoorman = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val legalIDCertFromDoorman = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, doormanCert, doormanKeyPair, nodeSubject, legalIDKeyPairFromDoorman.public) val legalIDCertFromDoormanRole = CertRole.extract(legalIDCertFromDoorman)!! val confidentialKeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val confidentialCert = X509Utilities.createCertificate(CertificateType.CONFIDENTIAL_LEGAL_IDENTITY, legalIDCertFromNodeCA, legalIDKeyPairFromNodeCA, nodeSubject, confidentialKeyPair.public) val confidentialCertRole = CertRole.extract(confidentialCert)!! assertNull(rootCertRole) assertNull(intermediateRootCertRole) assertEquals(tlsCertFromNodeCARole, tlsCertFromDoormanRole) assertEquals(legalIDCertFromNodeCARole, legalIDCertFromDoormanRole) assertTrue { doormanCertRole.isValidParent(intermediateRootCertRole) } // Doorman is signed by Intermediate Root. assertTrue { nodeCACertRole.isValidParent(doormanCertRole) } // NodeCA is signed by Doorman. assertTrue { tlsCertFromNodeCARole.isValidParent(nodeCACertRole) } // TLS is signed by NodeCA. assertTrue { tlsCertFromDoormanRole.isValidParent(doormanCertRole) } // TLS can also be signed by Doorman. assertTrue { legalIDCertFromNodeCARole.isValidParent(nodeCACertRole) } // Legal Identity is signed by NodeCA. assertTrue { legalIDCertFromDoormanRole.isValidParent(doormanCertRole) } // Legal Identity can also be signed by Doorman. assertTrue { confidentialCertRole.isValidParent(legalIDCertFromNodeCARole) } // Confidential key cert is signed by Legal Identity. assertFalse { legalIDCertFromDoormanRole.isValidParent(tlsCertFromDoormanRole) } // Legal Identity cannot be signed by TLS. assertFalse { tlsCertFromNodeCARole.isValidParent(legalIDCertFromNodeCARole) } // TLS cannot be signed by Legal Identity. assertFalse { confidentialCertRole.isValidParent(nodeCACertRole) } // Confidential key cert cannot be signed by NodeCA. assertFalse { confidentialCertRole.isValidParent(doormanCertRole) } // Confidential key cert cannot be signed by Doorman. }</ID>
    <ID>MaxLineLength:CertificateChainCheckPolicy.kt$CertificateChainCheckPolicy.UsernameMustMatchCommonNameCheck$if (!theirChain.any { certificate -&gt; CordaX500Name.parse(certificate.subjectDN.name).commonName == username }) { throw CertificateException("Client certificate does not match login username.") }</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$@Test fun `AMPQ Client to Server connection rejected when client certificate is revoked and external CRL source is used`()</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$return createClient(targetPort, crlCheckSoftFail.toRevocationConfig(), nodeCrlDistPoint, tlsCrlDistPoint, maxMessageSize)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$return createServer(port, name, crlCheckSoftFail.toRevocationConfig(), nodeCrlDistPoint, tlsCrlDistPoint, maxMessageSize)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$server = CrlServer(NetworkHostAndPort("localhost", 0), crlServerHitCount, ROOT_CA, { INTERMEDIATE_CA }, revokedNodeCerts, revokedIntermediateCerts)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val nodeCert = (signingCertificateStore to p2pSslConfiguration).recreateNodeCaAndTlsCertificates(nodeCrlDistPoint, tlsCrlDistPoint, ROOT_CA, INTERMEDIATE_CA)</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore$ operator fun get(alias: String): X509Certificate</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromFile(storePath: Path, password: String, entryPassword: String, createNew: Boolean): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromInputStream(stream: InputStream, password: String, entryPassword: String): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromResource(storeResourceName: String, password: String, entryPassword: String, classLoader: ClassLoader = Thread.currentThread().contextClassLoader): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun of(store: X509KeyStore, password: String, entryPassword: String): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$DelegatingCertificateStore : CertificateStore</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$@JvmStatic fun withBaseDirectory(baseDirectory: Path, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD): MutualSslConfiguration</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$@JvmStatic fun withCertificatesDirectory(certificatesDirectory: Path, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD, trustStoreKeyPassword: String = TrustStore.DEFAULT_KEY_PASSWORD, @Suppress("UNUSED_PARAMETER") useOpenSsl: Boolean = false): MutualSslConfiguration</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$@Suppress("UNUSED_PARAMETER") useOpenSsl: Boolean = false</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$keyPassword: String = keyStorePassword</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$return withCertificatesDirectory(baseDirectory / certificatesDirectoryName, keyStoreFileName, keyStorePassword, keyPassword, trustStoreFileName, trustStorePassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$val keyStore = FileBasedCertificateStoreSupplier(certificatesDirectory / keyStoreFileName, keyStorePassword, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$val trustStore = FileBasedCertificateStoreSupplier(certificatesDirectory / trustStoreFileName, trustStorePassword, trustStoreKeyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$@JvmStatic fun withBaseDirectory(baseDirectory: Path, password: String = DEFAULT_STORE_PASSWORD, keyPassword: String = password, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME): FileBasedCertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$@JvmStatic fun withCertificatesDirectory(certificatesDirectory: Path, password: String = DEFAULT_STORE_PASSWORD, keyPassword: String = password, certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME): FileBasedCertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$return FileBasedCertificateStoreSupplier(certificatesDirectory / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$@JvmStatic fun withBaseDirectory(baseDirectory: Path, password: String = DEFAULT_STORE_PASSWORD, keyPassword: String = DEFAULT_KEY_PASSWORD, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME): FileBasedCertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$keyPassword: String = DEFAULT_KEY_PASSWORD</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$return FileBasedCertificateStoreSupplier(certificatesDirectory / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$@JvmStatic fun withBaseDirectory(baseDirectory: Path, password: String = DEFAULT_STORE_PASSWORD, keyPassword: String = password, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME): FileBasedCertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$keyPassword: String = password</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$return FileBasedCertificateStoreSupplier(certificatesDirectory / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreSupplier.kt$FileBasedCertificateStoreSupplier : CertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificatesUtils.kt$fun saveToKeyStore(keyStorePath: Path, rpcKeyPair: KeyPair, selfSignCert: X509Certificate, password: String = "password", alias: String = "Key"): Path</ID>
    <ID>MaxLineLength:CertificatesUtils.kt$fun saveToTrustStore(trustStorePath: Path, selfSignCert: X509Certificate, password: String = "password", alias: String = "Key"): Path</ID>
    <ID>MaxLineLength:CertificatesUtils.kt$validityWindow: Pair&lt;Duration, Duration&gt; = X509Utilities.DEFAULT_VALIDITY_WINDOW</ID>
    <ID>MaxLineLength:CheatingSecurityProvider.kt$CheatingSecurityProvider : ProviderAutoCloseable</ID>
    <ID>MaxLineLength:CheatingSecurityProvider.kt$CheatingSecurityProvider$CheatingSecureRandomService : Service</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashIssueAndDoublePayment, 1.DOLLARS, OpaqueBytes.of(0), bob!!.nodeInfo.legalIdentities[0], false, defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashIssueAndDoublePayment, 1.DOLLARS, OpaqueBytes.of(0), bob!!.nodeInfo.legalIdentities[0], true, defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashIssueAndDuplicatePayment, 1.DOLLARS, OpaqueBytes.of(0), bob!!.nodeInfo.legalIdentities[0], false, defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashIssueAndPaymentFlow, 1.DOLLARS, OpaqueBytes.of(0), bob!!.nodeInfo.legalIdentities[0], false, defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashIssueAndPaymentNoSelection, 1.DOLLARS, OpaqueBytes.of(0), bob!!.nodeInfo.legalIdentities[0], false, defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashIssueFlow, 1.DOLLARS, OpaqueBytes.of(0), defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashPaymentFlow, 1.DOLLARS, bob!!.nodeInfo.legalIdentities[0], false).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashPaymentFromKnownStatesFlow, inputStates, 1, 1, 1.DOLLARS, bob!!.nodeInfo.legalIdentities[0], false)</ID>
    <ID>MaxLineLength:CheckTestFlows.kt$CheckAllTheTestFlows$connection.proxy.startFlow(::CashPaymentFromKnownStatesFlow, inputStates, 1, 1, 1.DOLLARS, bob!!.nodeInfo.legalIdentities[0], true)</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointAgent.Companion$println("Running Checkpoint agent with following arguments: instrumentClassname=$instrumentClassname, instrumentType=$instrumentType, minimumSize=$minimumSize, maximumSize=$maximumSize, graphDepth=$graphDepth, printOnce=$printOnce\n")</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook : ClassFileTransformer</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$builder.append("${statsTree.className} (hash:${statsTree.value?.hashCode()}) (count:${identityInfo.refCount})")</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$if (parameterTypeNames == listOf("com.esotericsoftware.kryo.Kryo", "com.esotericsoftware.kryo.io.Input", "java.lang.Class")) { if (method.isEmpty) continue log.debug { "Instrumenting on read: ${clazz.name}" } method.insertBefore("$hookClassName.${this::readEnter.name}($2, $3);") method.insertAfter("$hookClassName.${this::readExit.name}($2, $3, (java.lang.Object)\$_);") return clazz } else if (parameterTypeNames == listOf("com.esotericsoftware.kryo.io.Input", "java.lang.Object")) { if (method.isEmpty) continue log.debug { "Instrumenting on field read: ${clazz.name}" } method.insertBefore("$hookClassName.${this::readFieldEnter.name}((java.lang.Object)this);") method.insertAfter("$hookClassName.${this::readFieldExit.name}($2, (java.lang.Object)this);") return clazz }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$if (parameterTypeNames == listOf("com.esotericsoftware.kryo.Kryo", "com.esotericsoftware.kryo.io.Output", "java.lang.Object")) { if (method.isEmpty) continue log.debug { "Instrumenting on write: ${clazz.name}" } method.insertBefore("$hookClassName.${this::writeEnter.name}($2, $3);") method.insertAfter("$hookClassName.${this::writeExit.name}($2, $3);") return clazz }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "readFieldExit basic type value: ${that.field.name}:${that.field.type} = ${arrayValue ?: value}" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "writeEnter: adding event for clazz: ${obj.javaClass.name} (strandId: ${Strand.currentStrand().id})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "writeExit: clazz[${obj.javaClass.name}], strandId[${Strand.currentStrand().id}], eventCount[$count]" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$log.debug { "writeExit: clearing event for clazz: ${obj.javaClass.name} (strandId: ${Strand.currentStrand().id})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$fun readTree(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt; = IdentityHashMap()): Pair&lt;Int, IdentityInfo&gt;</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.Enter: ${exit.value} (hashcode:${exit.value!!.hashCode()}) (count:${idMap[exit.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.Exit: ${event.value} (hashcode:${event.value!!.hashCode()}) (count:${idMap[event.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.ObjectField: ${event.value} (hashcode:${event.value.hashCode()}) (count:${idMap[event.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$trees += StatsInfo(event.fieldName, event.fieldType) to IdentityInfo(StatsTree.BasicType(event.fieldValue), 1)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$is WaitForStateConsumption -&gt; SuspendedOn(waitForStateConsumption = (operation as WaitForStateConsumption).stateRefs)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$it.secondsSpentWaiting = TimeUnit.MILLISECONDS.toSeconds(Duration.between(suspendedTimestamp, now).toMillis())</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$serialisedCheckpoint.checkpointDeserialize(context = checkpointSerializationContext)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper$val file = baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME / "checkpoints_dump-${TIME_FORMATTER.format(now)}.zip"</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper${ // Poke into Quasar's stack and find the object references to the sub-flows so that we can correctly get the current progress // step for each sub-call. val stackObjects = fiber.getQuasarStack() subFlowStack.map { it.toJson(stackObjects) } }</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.AttachmentSerializer$override fun serialize(value: Attachment, gen: JsonGenerator, serializers: SerializerProvider)</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.CheckpointDumperBeanModifier$beanProperties: MutableList&lt;BeanPropertyWriter&gt;</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.CheckpointDumperBeanModifier$it.type.isTypeOrSubTypeOf(ProgressTracker::class.java) || it.name == "_stateMachine" || it.name == "deprecatedPartySessionMap"</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.CheckpointDumperBeanModifier${ // Do not serialise node singletons // TODO This will cause the singleton to appear as an empty object. Ideally we don't want it to appear at all but this will // have to do for now. beanProperties.clear() }</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.FlowLogicMixin$@JsonAutoDetect(getterVisibility = Visibility.NONE, isGetterVisibility = Visibility.NONE, fieldVisibility = Visibility.ANY)</ID>
    <ID>MaxLineLength:CheckpointDumperTest.kt$CheckpointDumperTest$val checkpoint = Checkpoint.create(InvocationContext.shell(), FlowStart.Explicit, logic.javaClass, frozenLogic, myself.identity.party, SubFlowVersion.CoreFlow(version), false) .getOrThrow()</ID>
    <ID>MaxLineLength:CheckpointSerializationAPI.kt$CheckpointSerializationContext$/** * A whitelist that determines (mostly for security purposes) whether a particular encoding may be used when deserializing. */ val encodingWhitelist: EncodingWhitelist</ID>
    <ID>MaxLineLength:CheckpointSerializationScheme.kt$CheckpointSerializationContextImpl$override fun withEncodingWhitelist(encodingWhitelist: EncodingWhitelist)</ID>
    <ID>MaxLineLength:CheckpointSerializationScheme.kt$CheckpointSerializationContextImpl$override val encodingWhitelist: EncodingWhitelist = NullEncodingWhitelist</ID>
    <ID>MaxLineLength:CheckpointSerializationTestHelpers.kt$CheckpointSerializationEnvironmentRule.Companion$Executors.newCachedThreadPool(testThreadFactory(true)) // Close enough to what InVMConnector makes normally.</ID>
    <ID>MaxLineLength:CheckpointSerializationTestHelpers.kt$CheckpointSerializationEnvironmentRule.Companion$InVMConnector::class.staticField&lt;ExecutorService&gt;("threadPoolExecutor").value</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException$FlowVersionIncompatibleException : CheckpointIncompatibleException</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException$SubFlowCoreVersionIncompatibleException : CheckpointIncompatibleException</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CannotBeDeserialisedException$"Found checkpoint that cannot be deserialised using the current Corda version. Please revert to the previous version of Corda, "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CannotBeDeserialisedException$"drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again. Cause: ${e.message}"</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CordappNotInstalledException$"Found checkpoint for CorDapp that is no longer installed. Specifically, could not find class $classNotFound. Please install the "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CordappNotInstalledException$"missing CorDapp, drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again."</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.FlowVersionIncompatibleException$"Found checkpoint for flow: $flowClass that is incompatible with the current installed version of ${cordapp.name}. "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException$"Found checkpoint for flow: $flowClass that is incompatible with the current Corda platform. Please revert to the previous "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException$"version of Corda (version $oldVersion), drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again."</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier$private</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier$throw CheckpointIncompatibleException.FlowVersionIncompatibleException(subFlow.flowClass, matchingCordapp, subFlowVersion.corDappHash)</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier$throw CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException(subFlow.flowClass, subFlowVersion.platformVersion)</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier${ // If we don't then see if the flow exists in any of the CorDapps so that we can give the user a more useful error message val matchingCordapp = currentCordappsByHash.values.find { subFlow.flowClass in it.allFlows } if (matchingCordapp != null) { throw CheckpointIncompatibleException.FlowVersionIncompatibleException(subFlow.flowClass, matchingCordapp, subFlowVersion.corDappHash) } else { throw CheckpointIncompatibleException.CordappNotInstalledException(subFlow.flowClass.name) } }</ID>
    <ID>MaxLineLength:ChosenList.kt$ChosenList&lt;E&gt; : ObservableListBase</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$ClassCarpenterImpl$/** Returns a snapshot of the currently loaded classes as a map of full class name (package names+dots) -&gt; class object */ val loaded: Map&lt;String, Class&lt;*&gt;&gt; = HashMap(_loaded)</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$ClassCarpenterImpl$if (fieldNameFromItf.isEmpty() &amp;&amp; SimpleFieldAccess::class.java in schema.interfaces) continue@methodLoop</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$ClassCarpenterImpl$visitMethodInsn(INVOKEVIRTUAL, toStringHelper, "add", "(L$jlString;${field.type})L$toStringHelper;", false)</ID>
    <ID>MaxLineLength:ClassCarpenter.kt$InterfaceMismatchMissingAMQPFieldException$"Interface ${clazz.name} requires a field named $field but that isn't found in the schema or any superclass schemas"</ID>
    <ID>MaxLineLength:ClassCarpenterTest.kt$ClassCarpenterTest$ @Test fun `superclasses with double-size primitive constructor parameters`()</ID>
    <ID>MaxLineLength:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$properties = properties.mapValues { (_, property) -&gt; property.copy(type = property.type.rename(from, to)) }</ID>
    <ID>MaxLineLength:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$protected</ID>
    <ID>MaxLineLength:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$is TypeIdentifier.Unparameterised -&gt; RemoteTypeInformation.Unparameterised(typeIdentifier.prettyPrint(), typeIdentifier)</ID>
    <ID>MaxLineLength:ClassGraphUtils.kt$ fun ClassGraph.pooledScan(): ScanResult</ID>
    <ID>MaxLineLength:ClassLoadingUtils.kt$ @StubOutForDJVM fun &lt;T: Any&gt; createInstancesOfClassesImplementing(classloader: ClassLoader, clazz: Class&lt;T&gt;): Set&lt;T&gt;</ID>
    <ID>MaxLineLength:ClassLoadingUtils.kt$ fun &lt;T: Any&gt; createInstancesOfClassesImplementing(@Suppress("UNUSED_PARAMETER") classloader: ClassLoader, @Suppress("UNUSED_PARAMETER") clazz: Class&lt;T&gt;): Set&lt;T&gt;</ID>
    <ID>MaxLineLength:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$val classes = createInstancesOfClassesImplementing(BaseInterface::class.java.classLoader, BaseInterface::class.java)</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$AbstractMutableClassWhitelist$sealed</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$AbstractMutableClassWhitelist${ /** * There are certain delegates like [net.corda.serialization.internal.AllButBlacklisted] * which may throw when asked whether the type is listed. * In such situations - it may be a good idea to ask [delegate] first before making a check against own [whitelist]. */ return delegate.hasListed(type) || (type.name in whitelist) }</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$TransientClassWhiteList : AbstractMutableClassWhitelist</ID>
    <ID>MaxLineLength:ClearNetworkCacheCli.kt$ClearNetworkCacheCli : NodeCliCommand</ID>
    <ID>MaxLineLength:CliParser.kt$CliParser$@Option(names = ["-c", "--command"], required = true, description = ["Command to run, one of startAll, stopAll, start, stop"])</ID>
    <ID>MaxLineLength:CliParser.kt$CliParser$@Option(names = ["-n", "--notary"], description = ["X500 name of the notary for the node to monitor, will default to the target if no provided"])</ID>
    <ID>MaxLineLength:CliParser.kt$CliParser$@Option(names = ["-o", "--wait-for-outstanding-flows"], description = ["Time to wait for an outstanding response before rechecking"])</ID>
    <ID>MaxLineLength:ClientCacheFactory.kt$ClientCacheFactory$override</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Mark Twain: Clothes make the man. Naked people have little or no influence on society.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Mark Twain: I have never let my schooling interfere with my education.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Oscar Wilde: Always forgive your enemies - nothing annoys them so much.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertThat(clientQuotes.take()).isEqualTo("Quote by Mark Twain: I have never let my schooling interfere with my education.")</ID>
    <ID>MaxLineLength:ClientRpcSslOptions.kt$ClientRpcSslOptions</ID>
    <ID>MaxLineLength:ClientRpcSslOptions.kt$ClientRpcSslOptions$data</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$PrintOrVisualise</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$driver</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$val (transactions: List&lt;SignedTransaction&gt;, futureTransactions: Observable&lt;SignedTransaction&gt;) = proxy.internalVerifiedTransactionsFeed()</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant()), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant(), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant().minus(1.hours)), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant().minus(1.hours), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(testClock, advancedClock.instant()), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(testClock, advancedClock.instant(), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertTrue(NodeSchedulerService.awaitWithDeadline(stoppedClock, advancedClock.instant(), future), "Should not have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertTrue(NodeSchedulerService.awaitWithDeadline(testClock, advancedClock.instant(), future), "Should not have reached deadline")</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignatureFlow : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$else -&gt; throw IllegalArgumentException("Signatures can only be collected from Party or AnonymousParty, not $destination")</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$override val progressTracker: ProgressTracker = CollectSignaturesFlow.tracker()</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$require(it.value.size == 1) { "There are multiple sessions initiated for party key ${it.key.toStringShort()}" }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$val wellKnownParty = checkNotNull(keyToSigningParty[it]) { "Could not find a session or wellKnown party for key ${it.toStringShort()}" }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow${ // setOfAllSessionKeys has already checked for valid destination types so we can safely cast to AnonoymousParty here. // This session was not initiated by a wellKnownParty so must directly exist in the unsigned. (it.destination as AnonymousParty).owningKey in unsigned }</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$SignTransactionFlow$override val progressTracker: ProgressTracker = SignTransactionFlow.tracker()</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$SignTransactionFlow${ progressTracker.currentStep = RECEIVING // Receive transaction and resolve dependencies, check sufficient signatures is disabled as we don't have all signatures. val stx = subFlow(ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = false)) // Receive the signing key that the party requesting the signature expects us to sign with. Having this provided // means we only have to check we own that one key, rather than matching all keys in the transaction against all // keys we own. val signingKeys = otherSideSession.receive&lt;List&lt;PublicKey&gt;&gt;().unwrap { keys -&gt; // TODO: We should have a faster way of verifying we own a single key serviceHub.keyManagementService.filterMyKeys(keys) } progressTracker.currentStep = VERIFYING // Check that the Responder actually needs to sign. checkMySignaturesRequired(stx, signingKeys) // Check the signatures which have already been provided. Usually the Initiators and possibly an Oracle's. checkSignatures(stx) stx.tx.toLedgerTransaction(serviceHub).verify() // Perform some custom verification over the transaction. try { checkTransaction(stx) } catch (e: Exception) { if (e is IllegalStateException || e is IllegalArgumentException || e is AssertionError) throw FlowException(e) else throw e } // Sign and send back our signature to the Initiator. progressTracker.currentStep = SIGNING val mySignatures = signingKeys.map { key -&gt; serviceHub.createSignature(stx, key) } otherSideSession.send(mySignatures) // Return the additionally signed transaction. return stx + mySignatures }</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$AnonymousSessionTestFlow$val sessionsToCollectFrom = cis.filter { it.name != ourIdentity.name }.map { initiateFlow(AnonymousParty(it.owningKey)) }</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$val future = aliceNode.startFlow(MixAndMatchAnonymousSessionTestFlow(owners, keysToLookup.toSet(), keysToKeepAnonymous.toSet())) .resultFuture</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$val keysToLookup = listOf(bConfidentialIdentity1.owningKey, bConfidentialIdentity2.owningKey, cConfidentialIdentity1.owningKey)</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$val owners = listOf(aConfidentialIdentity1, bConfidentialIdentity1, bConfidentialIdentity2, cConfidentialIdentity1)</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.Companion$private val miniCorpServices = MockServices(listOf("net.corda.testing.contracts"), miniCorp, rigorousMock&lt;IdentityService&gt;())</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow$Initiator : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow.Initiator$val builder = TransactionBuilder(notary).withItems(StateAndContract(state, DummyContract.PROGRAM_ID), command)</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow.Initiator$val sessions = excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, state.owners)).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$MixAndMatchAnonymousSessionTestFlow$private val keysToKeepAnonymous: Set&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$MixAndMatchAnonymousSessionTestFlow$val resolvedParties = keysToLookUp.map { serviceHub.identityService.wellKnownPartyFromAnonymous(AnonymousParty(it))!! }.toSet()</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer$private val typeNotation: TypeNotation = RestrictedType(AMQPTypeIdentifiers.nameForType(declaredType), null, emptyList(), "list", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$ fun resolveDeclared(declaredTypeInformation: LocalTypeInformation.ACollection): LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$fun resolveActual(actualClass: Class&lt;*&gt;, declaredTypeInformation: LocalTypeInformation.ACollection): LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$is TypeIdentifier.Parameterised -&gt; erasedInformation.withElementType(declaredTypeInformation.elementType)</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$private</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$private val supportedTypeIdentifiers = supportedTypes.keys.asSequence().map { TypeIdentifier.forClass(it) }.toSet()</ID>
    <ID>MaxLineLength:CommandLineCompatibilityCheckerTest.kt$CommandLineCompatibilityCheckerTest$val breaks = CommandLineCompatibilityChecker().checkBackwardsCompatibility(CommandLine(Dummy()), CommandLine(Dummy2()))</ID>
    <ID>MaxLineLength:CommandLineCompatibilityCheckerTest.kt$CommandLineCompatibilityCheckerTest$val breaks = CommandLineCompatibilityChecker().checkBackwardsCompatibility(CommandLine(value1), CommandLine(value2))</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandDescription</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$?:</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$EnumOptionsChangedError(it.key + " on command ${old.commandName} previously accepted: $oldEnums, and now is missing $toPrint}")</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$PositionalArgumentsChangedError("Positional Parameter [ ${it.parameterName} ] has been removed from subcommand: ${old.commandName}")</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllCommandsArePresent(old: List&lt;CommandDescription&gt;, new: List&lt;CommandDescription&gt;): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllOptionsArePresent(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllParamsAreOfTheSameType(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllPositionalCharactersArePresent(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkBackwardsCompatibility(old: CommandLine, new: CommandLine): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkCommandLineIsBackwardsCompatible(commandLineToCheck: Class&lt;*&gt;): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$private</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$return objectMapper.readValue&lt;List&lt;CommandDescription&gt;&gt;(inputStream, object : TypeReference&lt;List&lt;CommandDescription&gt;&gt;() {})</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$val potentiallyChanged = oldAcceptableTypes.filter { newAcceptableTypes[it.key] != null &amp;&amp; newAcceptableTypes[it.key]!!.toSet() != it.value.toSet() }</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$ParameterDescription</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$"${instance.reachableAddress} {ssh:${instance.portMapping[Constants.NODE_SSHD_PORT]}, "</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$NetworkBuilder.instance() .withBasedir(baseDir) .withNetworkName(networkName) .onNodeBuild { builtNode -&gt; println("Built node: ${builtNode.name} to image: ${builtNode.localImageId}") }</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$NetworkBuilder.instance() .withBasedir(baseDir) .withNetworkName(networkName) .onNodeBuild { builtNode -&gt; println("Built node: ${builtNode.name} to image: ${builtNode.localImageId}") } .onNodePushed { pushedNode -&gt; println("Pushed node: ${pushedNode.name} to: ${pushedNode.remoteImageName}") }</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$nodeAdder.addNode(context, Constants.ALPHA_NUMERIC_ONLY_REGEX.replace(it.key.toLowerCase(), ""), CordaX500Name.parse(it.value))</ID>
    <ID>MaxLineLength:CommandParsers.kt$CliParser$@Option(names = ["--add"], split = ":", description = ["The node to add. Format is &lt;Name&gt;:&lt;X500&gt;. Eg; \"Node1:O=Bank A, L=New York, C=US, OU=Org Unit, CN=Service Name\""])</ID>
    <ID>MaxLineLength:CommandParsers.kt$CliParser$@Option(names = ["-b", "--backend"], description = ["The backend to use when instantiating nodes. Valid values: LOCAL_DOCKER and AZURE."])</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper : Contract</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$ @Throws(InsufficientBalanceException::class) @Suspendable fun generateRedeem(tx: TransactionBuilder, paper: StateAndRef&lt;State&gt;, services: ServiceHub, ourIdentity: PartyAndCertificate)</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$"the transaction is signed by the owner of the CP" using (input.owner.owningKey in command.signers)</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$Cash.generateSpend(services, tx, paper.state.data.faceValue.withoutIssuer(), ourIdentity, paper.state.data.owner)</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$return TransactionBuilder(notary = notary).withItems(StateAndContract(state, CP_PROGRAM_ID), Command(Commands.Issue(), issuance.party.owningKey))</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper$val time = timeWindow?.fromTime ?: throw IllegalArgumentException("Redemptions must have a time-window")</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.Commands$Issue : TypeOnlyCommandDataCommands</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$// Although kotlin is smart enough not to need these, as we are using the ICommercialPaperState, we need to declare them explicitly for use later, fun withOwner(newOwner: AbstractParty): State</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun toString()</ID>
    <ID>MaxLineLength:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$constructor(amount: Amount&lt;Currency&gt;, issueRef: OpaqueBytes, recipient: Party, notary: Party) : this(amount, issueRef, recipient, notary, tracker())</ID>
    <ID>MaxLineLength:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$val tx = CommercialPaperUtils.generateIssue(ourIdentity.ref(issueRef), amount `issued by` ourIdentity.ref(issueRef), Instant.now() + 10.days, notary)</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$output(thisTest.getContract(), "alice's paper", "paper".output&lt;CommercialPaper.State&gt;().withOwner(ALICE))</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$ @JvmStatic fun generateIssue(issuance: PartyAndReference, faceValue: Amount&lt;Issued&lt;Currency&gt;&gt;, maturityDate: Instant, notary: Party): TransactionBuilder</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$ @Throws(InsufficientBalanceException::class) @JvmStatic @Suspendable fun generateRedeem(tx: TransactionBuilder, paper: StateAndRef&lt;CommercialPaper.State&gt;, services: ServiceHub, ourIdentity: PartyAndCertificate)</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$CashUtils.generateSpend(services, tx, paper.state.data.faceValue.withoutIssuer(), ourIdentity, paper.state.data.owner)</ID>
    <ID>MaxLineLength:CommonSerializationTestHelpers.kt$fun &lt;T&gt; SerializationEnvironment.asContextEnv(inheritable: Boolean = false, callable: (SerializationEnvironment) -&gt; T): T</ID>
    <ID>MaxLineLength:CompatibilityTest.kt$CompatibilityTest$fail</ID>
    <ID>MaxLineLength:CompatibilityTest.kt$CompatibilityTest$val (serializedBytes, schema) = output.serializeAndReturnSchema(transaction, SerializationDefaults.STORAGE_CONTEXT)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$ComponentGroup(SIGNERS_GROUP.ordinal, twoCommandsforKey1.map { it.signers.serialize() }.subList(0, 1))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$allCommandsNoKey1Ftx.checkCommandVisibility(DUMMY_KEY_1.public)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxInputs.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA, WireTransaction(componentGroups = shuffledComponentGroupsA, privacySalt = privacySalt))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.merkleTree.hash, MerkleTree.getMerkleTree(wireTransactionA.accessGroupHashes()).hash)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.availableComponentGroups, wireTransactionA.availableComponentGroups)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.componentGroups.map { it.groupIndex }.max()!!, ftxCompatibleNoInputs.groupHashes.size - 1)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.componentGroups.size - 1, ftxCompatibleNoInputs.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFails { ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoSignersKey1SamePMT, key1CommandsFtx.groupHashes) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastCommandAndSigners.checkCommandVisibility(DUMMY_KEY_1.public) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;ComponentVisibilityException&gt; { noCommandsFtx.checkAllComponentsVisible(SIGNERS_GROUP) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;IllegalStateException&gt; { WireTransaction(componentGroups = componentGroupsCompatible, privacySalt = PrivacySalt()) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;IllegalStateException&gt; { WireTransaction(componentGroups = componentGroupsLessSigners, privacySalt = PrivacySalt()) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotEquals(wireTransactionA.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotEquals(wireTransactionCompatibleA, wireTransactionA)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$is Command&lt;*&gt; -&gt; elem.signers.size == 1</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$key1CommandsFtx.checkAllComponentsVisible(SIGNERS_GROUP)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$key1CommandsFtx.filteredComponentGroups[1].partialMerkleTree</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$oneKey1CommandFtxA.checkAllComponentsVisible(SIGNERS_GROUP)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$oneKey1CommandFtxB.checkAllComponentsVisible(SIGNERS_GROUP)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val attachmentGroup by lazy { ComponentGroup(ATTACHMENTS_GROUP.ordinal, attachments.map { it.serialize() }) } // The list is empty.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val newUnknownComponentGroup = ComponentGroup(100, listOf(OpaqueBytes(secureRandomBytes(4)), OpaqueBytes(secureRandomBytes(8))))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val wireTransactionA by lazy { WireTransaction(componentGroups = componentGroupsA, privacySalt = privacySalt) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val alterSignerComponents = signerComponents.subList(0, 2) + signerComponents[1] // Third one is removed and the 2nd command is added twice.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val alterSignersHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!!.subList(0, 2) + componentHash(key1CommandsFtx.filteredComponentGroups[1].nonces[2], alterSignerComponents[2])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val attachments = ComponentGroup(ATTACHMENTS_GROUP.ordinal, listOf(paramsHash.serialize())) // Same hash as network parameters</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxAlterSigner = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxAlterSignerB = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes.subList(0, 6) + alterMTree.hash)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxCompatibleAll = wireTransactionCompatibleA.buildFilteredTransaction(Predicate { true }) // All filtered, including the unknown component.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastCommandAndSigners = ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoLastCommandAndSigners, key1CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastSigner = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2SamePMT, key2CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastSignerB = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2, key2CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxOneInput = wireTransactionA.buildFilteredTransaction(Predicate(::filteringOneInput)) // First input only filtered.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val groups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val twoCommandsforKey1 = listOf(dummyCommand(DUMMY_KEY_1.public, DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_1.public))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey1SamePMT = listOf(key1CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey2 = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroup)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey2SamePMT = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val wireTransaction1ShuffledInputs = WireTransaction(componentGroups = componentGroupsB, privacySalt = privacySalt)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val wireTransactionOtherPrivacySalt = WireTransaction(componentGroups = componentGroupsA, privacySalt = PrivacySalt())</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Filter out all of the components. val ftxNothing = wireTransactionA.buildFilteredTransaction(Predicate { false }) // Nothing filtered. // Although nothing filtered, we still receive the group hashes for the top level Merkle tree. // Note that attachments are not sent, but group hashes include the allOnesHash flag for the attachment group hash; that's why we expect +1 group hashes. assertEquals(wireTransactionA.componentGroups.size + 1, ftxNothing.groupHashes.size) ftxNothing.verify() // Include all of the components. val ftxAll = wireTransactionA.buildFilteredTransaction(Predicate { true }) // All filtered. ftxAll.verify() ftxAll.checkAllComponentsVisible(INPUTS_GROUP) ftxAll.checkAllComponentsVisible(OUTPUTS_GROUP) ftxAll.checkAllComponentsVisible(COMMANDS_GROUP) ftxAll.checkAllComponentsVisible(ATTACHMENTS_GROUP) ftxAll.checkAllComponentsVisible(NOTARY_GROUP) ftxAll.checkAllComponentsVisible(TIMEWINDOW_GROUP) ftxAll.checkAllComponentsVisible(SIGNERS_GROUP) ftxAll.checkAllComponentsVisible(PARAMETERS_GROUP) // Filter inputs only. fun filtering(elem: Any): Boolean { return when (elem) { is StateRef -&gt; true else -&gt; false } } val ftxInputs = wireTransactionA.buildFilteredTransaction(Predicate(::filtering)) // Inputs only filtered. ftxInputs.verify() ftxInputs.checkAllComponentsVisible(INPUTS_GROUP) assertEquals(1, ftxInputs.filteredComponentGroups.size) // We only add component groups that are not empty, thus in this case: the inputs only. assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) // All 3 inputs are present. assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) // And their corresponding nonces. assertNotNull(ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) // And the Merkle tree. // Filter one input only. fun filteringOneInput(elem: Any) = elem == inputs[0] val ftxOneInput = wireTransactionA.buildFilteredTransaction(Predicate(::filteringOneInput)) // First input only filtered. ftxOneInput.verify() assertFailsWith&lt;ComponentVisibilityException&gt; { ftxOneInput.checkAllComponentsVisible(INPUTS_GROUP) } assertEquals(1, ftxOneInput.filteredComponentGroups.size) // We only add component groups that are not empty, thus in this case: the inputs only. assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) // 1 input is present. assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) // And its corresponding nonce. assertNotNull(ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) // And the Merkle tree. // The old client (receiving more component types than expected) is still compatible. val componentGroupsCompatibleA = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentGroup // A new unknown component with ordinal 100 that we cannot process. ) val wireTransactionCompatibleA = WireTransaction(componentGroupsCompatibleA, privacySalt) val ftxCompatible = wireTransactionCompatibleA.buildFilteredTransaction(Predicate(::filtering)) ftxCompatible.verify() assertEquals(ftxInputs.inputs, ftxCompatible.inputs) assertEquals(wireTransactionCompatibleA.id, ftxCompatible.id) assertEquals(1, ftxCompatible.filteredComponentGroups.size) assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) assertNotNull(ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) assertNull(wireTransactionCompatibleA.networkParametersHash) assertNull(ftxCompatible.networkParametersHash) // Now, let's allow everything, including the new component type that we cannot process. val ftxCompatibleAll = wireTransactionCompatibleA.buildFilteredTransaction(Predicate { true }) // All filtered, including the unknown component. ftxCompatibleAll.verify() assertEquals(wireTransactionCompatibleA.id, ftxCompatibleAll.id) // Check we received the last element that we cannot process (backwards compatibility). assertEquals(wireTransactionCompatibleA.componentGroups.size, ftxCompatibleAll.filteredComponentGroups.size) // Hide one component group only. // Filter inputs only. fun filterOutInputs(elem: Any): Boolean { return when (elem) { is StateRef -&gt; false else -&gt; true } } val ftxCompatibleNoInputs = wireTransactionCompatibleA.buildFilteredTransaction(Predicate(::filterOutInputs)) ftxCompatibleNoInputs.verify() assertFailsWith&lt;ComponentVisibilityException&gt; { ftxCompatibleNoInputs.checkAllComponentsVisible(INPUTS_GROUP) } assertEquals(wireTransactionCompatibleA.componentGroups.size - 1, ftxCompatibleNoInputs.filteredComponentGroups.size) assertEquals(wireTransactionCompatibleA.componentGroups.map { it.groupIndex }.max()!!, ftxCompatibleNoInputs.groupHashes.size - 1) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Merkle tree computation is deterministic if the same salt and ordering are used. val wireTransactionB = WireTransaction(componentGroups = componentGroupsA, privacySalt = privacySalt) assertEquals(wireTransactionA, wireTransactionB) // Merkle tree computation will change if privacy salt changes. val wireTransactionOtherPrivacySalt = WireTransaction(componentGroups = componentGroupsA, privacySalt = PrivacySalt()) assertNotEquals(wireTransactionA, wireTransactionOtherPrivacySalt) // Full Merkle root is computed from the list of Merkle roots of each component group. assertEquals(wireTransactionA.merkleTree.hash, MerkleTree.getMerkleTree(wireTransactionA.accessGroupHashes()).hash) // Trying to add an empty component group (not allowed), e.g. the empty attachmentGroup. val componentGroupsEmptyAttachment = listOf( inputGroup, outputGroup, commandGroup, attachmentGroup, notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroups = componentGroupsEmptyAttachment, privacySalt = privacySalt) } // Ordering inside a component group matters. val inputsShuffled = listOf(stateRef2, stateRef1, stateRef3) val inputShuffledGroup = ComponentGroup(INPUTS_GROUP.ordinal, inputsShuffled.map { it -&gt; it.serialize() }) val componentGroupsB = listOf( inputShuffledGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) val wireTransaction1ShuffledInputs = WireTransaction(componentGroups = componentGroupsB, privacySalt = privacySalt) // The ID has changed due to change of the internal ordering in inputs. assertNotEquals(wireTransaction1ShuffledInputs, wireTransactionA) // Inputs group Merkle roots are not equal. assertNotEquals(wireTransactionA.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal]) // But outputs group Merkle leaf (and the rest) remained the same. assertEquals(wireTransactionA.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal]) assertEquals(wireTransactionA.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal]) assertNull(wireTransactionA.accessGroupMerkleRoots()[ATTACHMENTS_GROUP.ordinal]) assertNull(wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[ATTACHMENTS_GROUP.ordinal]) // Group leaves (components) ordering does not affect the id. In this case, we added outputs group before inputs. val shuffledComponentGroupsA = listOf( outputGroup, inputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) assertEquals(wireTransactionA, WireTransaction(componentGroups = shuffledComponentGroupsA, privacySalt = privacySalt)) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Required to call the private constructor. val ftxConstructor = FilteredTransaction::class.constructors.first() // 1st and 3rd commands require a signature from KEY_1. val twoCommandsforKey1 = listOf(dummyCommand(DUMMY_KEY_1.public, DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_1.public)) val componentGroups = listOf( inputGroup, outputGroup, ComponentGroup(COMMANDS_GROUP.ordinal, twoCommandsforKey1.map { it.value.serialize() }), notaryGroup, timeWindowGroup, ComponentGroup(SIGNERS_GROUP.ordinal, twoCommandsforKey1.map { it.signers.serialize() }) ) val wtx = WireTransaction(componentGroups = componentGroups, privacySalt = PrivacySalt()) // Filter KEY_1 commands (commands 1 and 3). fun filterKEY1Commands(elem: Any): Boolean { return when (elem) { is Command&lt;*&gt; -&gt; DUMMY_KEY_1.public in elem.signers else -&gt; false } } // Filter KEY_2 commands (commands 1 and 2). fun filterKEY2Commands(elem: Any): Boolean { return when (elem) { is Command&lt;*&gt; -&gt; DUMMY_KEY_2.public in elem.signers else -&gt; false } } val key1CommandsFtx = wtx.buildFilteredTransaction(Predicate(::filterKEY1Commands)) val key2CommandsFtx = wtx.buildFilteredTransaction(Predicate(::filterKEY2Commands)) // val commandDataComponents = key1CommandsFtx.filteredComponentGroups[0].components val commandDataHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.COMMANDS_GROUP.ordinal]!! val noLastCommandDataPMT = PartialMerkleTree.build( MerkleTree.getMerkleTree(commandDataHashes), commandDataHashes.subList(0, 1) ) val noLastCommandDataComponents = key1CommandsFtx.filteredComponentGroups[0].components.subList(0, 1) val noLastCommandDataNonces = key1CommandsFtx.filteredComponentGroups[0].nonces.subList(0, 1) val noLastCommandDataGroup = FilteredComponentGroup( COMMANDS_GROUP.ordinal, noLastCommandDataComponents, noLastCommandDataNonces, noLastCommandDataPMT ) val signerComponents = key1CommandsFtx.filteredComponentGroups[1].components val signerHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!! val noLastSignerPMT = PartialMerkleTree.build( MerkleTree.getMerkleTree(signerHashes), signerHashes.subList(0, 2) ) val noLastSignerComponents = key1CommandsFtx.filteredComponentGroups[1].components.subList(0, 2) val noLastSignerNonces = key1CommandsFtx.filteredComponentGroups[1].nonces.subList(0, 2) val noLastSignerGroup = FilteredComponentGroup( SIGNERS_GROUP.ordinal, noLastSignerComponents, noLastSignerNonces, noLastSignerPMT ) val noLastSignerGroupSamePartialTree = FilteredComponentGroup( SIGNERS_GROUP.ordinal, noLastSignerComponents, noLastSignerNonces, key1CommandsFtx.filteredComponentGroups[1].partialMerkleTree) // We don't update that, so we can catch the index mismatch. val updatedFilteredComponentsNoSignersKey2 = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroup) val updatedFilteredComponentsNoSignersKey2SamePMT = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree) // There are only two components in key1CommandsFtx (commandData and signers). assertEquals(2, key1CommandsFtx.componentGroups.size) // Remove last signer for which there is a pointer from a visible commandData. This is the case of Key1. // This will result to an invalid transaction. // A command with no corresponding signer detected // because the pointer of CommandData (3rd leaf) cannot find a corresponding (3rd) signer. val updatedFilteredComponentsNoSignersKey1SamePMT = listOf(key1CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree) assertFails { ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoSignersKey1SamePMT, key1CommandsFtx.groupHashes) } // Remove both last signer (KEY1) and related command. // Update partial Merkle tree for signers. val updatedFilteredComponentsNoLastCommandAndSigners = listOf(noLastCommandDataGroup, noLastSignerGroup) val ftxNoLastCommandAndSigners = ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoLastCommandAndSigners, key1CommandsFtx.groupHashes) // verify() will pass as the transaction is well-formed. ftxNoLastCommandAndSigners.verify() // checkCommandVisibility() will not pass, because checkAllComponentsVisible(ComponentGroupEnum.SIGNERS_GROUP) will fail. assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastCommandAndSigners.checkCommandVisibility(DUMMY_KEY_1.public) } // Remove last signer for which there is no pointer from a visible commandData. This is the case of Key2. // Do not change partial Merkle tree for signers. // This time the object can be constructed as there is no pointer mismatch. val ftxNoLastSigner = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2SamePMT, key2CommandsFtx.groupHashes) // verify() will fail as we didn't change the partial Merkle tree. assertFailsWith&lt;FilteredTransactionVerificationException&gt; { ftxNoLastSigner.verify() } // checkCommandVisibility() will not pass. assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastSigner.checkCommandVisibility(DUMMY_KEY_2.public) } // Remove last signer for which there is no pointer from a visible commandData. This is the case of Key2. // Update partial Merkle tree for signers. val ftxNoLastSignerB = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2, key2CommandsFtx.groupHashes) // verify() will pass, the transaction is well-formed. ftxNoLastSignerB.verify() // But, checkAllComponentsVisible() will not pass. assertFailsWith&lt;ComponentVisibilityException&gt; { ftxNoLastSignerB.checkCommandVisibility(DUMMY_KEY_2.public) } // Modify last signer (we have a pointer from commandData). // Update partial Merkle tree for signers. val alterSignerComponents = signerComponents.subList(0, 2) + signerComponents[1] // Third one is removed and the 2nd command is added twice. val alterSignersHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!!.subList(0, 2) + componentHash(key1CommandsFtx.filteredComponentGroups[1].nonces[2], alterSignerComponents[2]) val alterMTree = MerkleTree.getMerkleTree(alterSignersHashes) val alterSignerPMTK = PartialMerkleTree.build( alterMTree, alterSignersHashes ) val alterSignerGroup = FilteredComponentGroup( SIGNERS_GROUP.ordinal, alterSignerComponents, key1CommandsFtx.filteredComponentGroups[1].nonces, alterSignerPMTK ) val alterFilteredComponents = listOf(key1CommandsFtx.filteredComponentGroups[0], alterSignerGroup) // Do not update groupHashes. val ftxAlterSigner = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes) // Visible components in signers group cannot be verified against their partial Merkle tree. assertFailsWith&lt;FilteredTransactionVerificationException&gt; { ftxAlterSigner.verify() } // Also, checkAllComponentsVisible() will not pass (groupHash matching will fail). assertFailsWith&lt;ComponentVisibilityException&gt; { ftxAlterSigner.checkCommandVisibility(DUMMY_KEY_1.public) } // Update groupHashes. val ftxAlterSignerB = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes.subList(0, 6) + alterMTree.hash) // Visible components in signers group cannot be verified against their partial Merkle tree. assertFailsWith&lt;FilteredTransactionVerificationException&gt; { ftxAlterSignerB.verify() } // Also, checkAllComponentsVisible() will not pass (top level Merkle tree cannot be verified against transaction's id). assertFailsWith&lt;ComponentVisibilityException&gt; { ftxAlterSignerB.checkCommandVisibility(DUMMY_KEY_1.public) } }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ val groups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null) val wireTransactionOldConstructor = WireTransaction(groups, privacySalt) assertEquals(wireTransactionA, wireTransactionOldConstructor) // Malformed tx - attachments is not List&lt;SecureHash&gt;. For this example, we mistakenly added input-state (StateRef) serialised objects with ATTACHMENTS_GROUP.ordinal. val componentGroupsB = listOf( inputGroup, outputGroup, commandGroup, ComponentGroup(ATTACHMENTS_GROUP.ordinal, inputGroup.components), notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsB, privacySalt).attachments.toList() } // Malformed tx - duplicated component group detected. val componentGroupsDuplicatedCommands = listOf( inputGroup, outputGroup, commandGroup, // First commandsGroup. commandGroup, // Second commandsGroup. notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsDuplicatedCommands, privacySalt) } // Malformed tx - inputs is not a serialised object at all. val componentGroupsC = listOf( ComponentGroup(INPUTS_GROUP.ordinal, listOf(OpaqueBytes(ByteArray(8)))), outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsC, privacySalt) } val componentGroupsCompatibleA = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentGroup // A new unknown component with ordinal 100 that we cannot process. ) // The old client (receiving more component types than expected) is still compatible. val wireTransactionCompatibleA = WireTransaction(componentGroupsCompatibleA, privacySalt) assertEquals(wireTransactionCompatibleA.availableComponentGroups, wireTransactionA.availableComponentGroups) // The known components are the same. assertNotEquals(wireTransactionCompatibleA, wireTransactionA) // But obviously, its Merkle root has changed Vs wireTransactionA (which doesn't include this extra component). // The old client will throw if receiving an empty component (even if this is unknown). val componentGroupsCompatibleEmptyNew = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentEmptyGroup // A new unknown component with ordinal 101 that we cannot process. ) assertFails { WireTransaction(componentGroupsCompatibleEmptyNew, privacySalt) } }</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$AMQPPropertyReadStrategy$override</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$ComposableTypePropertySerializer.Companion$ fun make(name: String, propertyInformation: LocalPropertyInformation, factory: LocalSerializerFactory): PropertySerializer</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$ComposableTypePropertySerializer.Companion$ fun makeForEvolution(name: String, isCalculated: Boolean, typeIdentifier: TypeIdentifier, type: Type): PropertySerializer</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$ComposableTypePropertySerializer.Companion$PropertyReadStrategy.make(name, propertyInformation.type.typeIdentifier, propertyInformation.type.observedType)</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$DescribedTypeReadStrategy : PropertyReadStrategy</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$DescribedTypeReadStrategy$override</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$EvolutionPropertyWriteStrategy$override</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyReadStrategy$ fun readProperty(obj: Any?, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext): Any?</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyReader</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyReader.Companion$is LocalPropertyInformation.PrivateConstructorPairedProperty -&gt; FieldReader(propertyInformation.observedField)</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyWriteStrategy$ fun writeProperty(obj: Any?, data: Data, output: SerializationOutput, context: SerializationContext, debugIndent: Int)</ID>
    <ID>MaxLineLength:ComposableTypePropertySerializer.kt$PropertyWriteStrategy.Companion$ fun make(name: String, propertyInformation: LocalPropertyInformation, factory: LocalSerializerFactory): PropertyWriteStrategy</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey$ fun isFulfilledBy(keysToCheck: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey$return SubjectPublicKeyInfo(AlgorithmIdentifier(CordaObjectIdentifier.COMPOSITE_KEY), DERSequence(keyVector)).encoded</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$ fun build(threshold: Int? = null): PublicKey</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder$require(threshold == null || threshold &gt; 0) { "Threshold must not be specified or its value must be greater than zero" }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder${ "Trying to build invalid CompositeKey, threshold value different than weight of single child node." }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.Builder${ require(threshold == null || threshold == children.first().weight) { "Trying to build invalid CompositeKey, threshold value different than weight of single child node." } // Returning the only child node which is [PublicKey] itself. We need to avoid single-key [CompositeKey] instances, // as there are scenarios where developers expected the underlying key and its composite versions to be equivalent. children.first().node }</ID>
    <ID>MaxLineLength:CompositeKey.kt$CompositeKey.NodeAndWeight$if (weight == other.weight) // TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal. node.encoded.sequence().compareTo(other.node.encoded.sequence()) else weight.compareTo(other.weight)</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$// By lazy is required so that the serialisers are configured before vals initialisation takes place (they internally invoke serialise). private val aliceSignature by lazy { aliceKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(alicePublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key validation with graph cycle detection`()</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertFalse { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, brokenBobSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, bobSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, bobSignature, charlieSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(aliceSignature, charlieSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$assertTrue { engine.verify(CompositeSignaturesWithKeys(listOf(bobSignature, charlieSignature)).serialize().bytes) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private val bobSignature by lazy { bobKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(bobPublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private val charlieSignature by lazy { charlieKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(charliePublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val EdSignature = keyPairEd.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairEd.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val K1Signature = keyPairK1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairK1.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val R1Signature = keyPairR1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairR1.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val RSASignature = keyPairRSA.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairRSA.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val SPSignature = keyPairSP.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairSP.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val brokenBobSignature = TransactionSignature(aliceSignature.bytes, bobSignature.by, SignatureMetadata(1, Crypto.findSignatureScheme(bobSignature.by).schemeNumberID))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val composite1 = CompositeKey.Builder().addKeys(pub1, pub2, pub3, pub4, pub5, pub6, pub7).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val composite2 = CompositeKey.Builder().addKeys(pub7, pub6, pub5, pub4, pub3, pub2, pub1).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val compositeKey = CompositeKey.Builder().addKeys(keyPairRSA.public, keyPairK1.public, keyPairR1.public, keyPairEd.public, keyPairSP.public).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val compositeKeyCert = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, ca, caKeyPair, caName, compositeKey)</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val twoOfThree = CompositeKey.Builder().addKeys(alicePublicKey, bobPublicKey, charliePublicKey).build(threshold = 2)</ID>
    <ID>MaxLineLength:CompositeMemberCompositeSchemaToClassCarpenterTests.kt$CompositeMembers$val mangledMap = envelope.typeInformation.values.find { it.typeIdentifier.name == "java.util.Map" }!!.mangle&lt;C&gt;()</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw InvalidKeyException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw SignatureException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature.Companion$@JvmStatic fun getService(provider: Provider)</ID>
    <ID>MaxLineLength:CompositeSignaturesWithKeys.kt$CompositeSignaturesWithKeys</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList$val permutedOffset = (if (permutedListIndex == 0) 0 else newSubNestedIndexOffsets[permutedListIndex - 1])</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList${ // If a nested element is updated we simply propagate the update by offsetting the nested element index // by the startingOffsetOf the nested list. val listIndex = indexMap[wrapped]!!.first val startingOffset = startingOffsetOf(listIndex) for (i in change.from until change.to) { nextUpdate(startingOffset + i) } }</ID>
    <ID>MaxLineLength:ConcatenatedList.kt$ConcatenatedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:ConcatenatedListTest.kt$ConcatenatedListTest$sourceList = FXCollections.observableArrayList&lt;ObservableList&lt;String&gt;&gt;(FXCollections.observableArrayList("hello"))</ID>
    <ID>MaxLineLength:ConcurrencyUtils.kt$ fun &lt;V, W&gt; firstOf(vararg futures: CordaFuture&lt;out V&gt;, handler: (CordaFuture&lt;out V&gt;) -&gt; W)</ID>
    <ID>MaxLineLength:ConcurrencyUtils.kt$internal</ID>
    <ID>MaxLineLength:ConfigExporter.kt$ConfigExporter$fileWriter.write(configToWrite.root().render(ConfigRenderOptions.concise().setFormatted(true).setJson(false)))</ID>
    <ID>MaxLineLength:ConfigExporter.kt$ConfigExporter$ourParsedConfig = ourParsedConfig.withValue("keyStorePassword", testNetParsedConfig.getValue("keyStorePassword"))</ID>
    <ID>MaxLineLength:ConfigExporter.kt$ConfigExporter$ourParsedConfig = ourParsedConfig.withValue("trustStorePassword", testNetParsedConfig.getValue("trustStorePassword"))</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$ @Throws(DeobfuscationFailedException::class) fun deobfuscateConfiguration(config: String, hardwareAddress: ByteArray? = null, seed: ByteArray? = null): DeobfuscationResult</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$ fun obfuscateConfiguration(config: String, hardwareAddress: ByteArray? = null, seed: ByteArray? = null, inputDelegate: ((String) -&gt; String)? = null): ObfuscationResult</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$"${match.groupValues[1]}&lt;{${encryptedValue.initializationVector.asBase64()}:${encryptedValue.bytes.asBase64()}}&gt;"</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$DeobfuscationFailedException : IllegalArgumentException</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$DeobfuscationFailedForPathException : IllegalArgumentException</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$private</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$val commandBlobRegex = "^(.*?)&lt;encrypt\\{(.*)\\}&gt;".toRegex(setOf(RegexOption.IGNORE_CASE, RegexOption.MULTILINE))</ID>
    <ID>MaxLineLength:ConfigObfuscator.kt$ConfigObfuscator$val seedSource = if (seed?.size ?: 0 == 0) { null } else { seed } ?: byteArrayOf('C'.toByte(), 'o'.toByte(), 'r'.toByte(), 'd'.toByte(), 'a'.toByte())</ID>
    <ID>MaxLineLength:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$val deobfuscatedConfiguration = ConfigObfuscator.deobfuscateConfiguration(obfuscatedConfiguration, hardwareAddress).content</ID>
    <ID>MaxLineLength:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$val obfuscatedConfiguration = ConfigObfuscator.obfuscateConfiguration(configuration, hardwareAddress, byteArrayOf(1, 2, 3, 4)).content</ID>
    <ID>MaxLineLength:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$val obfuscatedConfiguration = ConfigObfuscator.obfuscateConfiguration(configuration, hardwareAddress, seed).content</ID>
    <ID>MaxLineLength:ConfigObfuscatorTest.kt$ConfigObfuscatorTest$val obfuscatedConfiguration = ConfigObfuscator.obfuscateConfiguration(configuration, null) { overriddenSecret }.content</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$assertThatThrownBy { configuration.parseAs&lt;TypedConfiguration&gt;() }</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$private inline</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;InstantData, InstantListData, Instant&gt;(Instant.now(), Instant.now().plusMillis(100), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;LocalDateData, LocalDateListData, LocalDate&gt;(LocalDate.now(), LocalDate.now().plusDays(1), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;URLData, URLListData, URL&gt;(URL("http://localhost:1234"), URL("http://localhost:1235"), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;X500PrincipalData, X500PrincipalListData, X500Principal&gt;(X500Principal("C=US, L=New York, CN=Corda Root CA, OU=Corda, O=R3 HoldCo LLC"), X500Principal("O=Bank A,L=London,C=GB"), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$val config = config("value" to mapOf("key" to ConfigObfuscator.obfuscateConfiguration("&lt;encrypt{prop}&gt;").content))</ID>
    <ID>MaxLineLength:ConfigSections.kt$CertChainPolicyConfigSpec$@Suppress("DEPRECATION") internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$CryptoServiceConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val exportHibernateJMXStatistics by boolean().optional().withDefaultValue(DatabaseConfig.Defaults.exportHibernateJMXStatistics)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val initialiseAppSchema by enum(SchemaInitializationType::class).optional().withDefaultValue(DatabaseConfig.Defaults.initialiseAppSchema)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val mappedSchemaCacheSize by long().optional().withDefaultValue(DatabaseConfig.Defaults.mappedSchemaCacheSize)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val transactionIsolationLevel by enum(TransactionIsolationLevel::class).optional().withDefaultValue(DatabaseConfig.Defaults.transactionIsolationLevel)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$return valid(DatabaseConfig(config[runMigration], config[initialiseSchema], config[initialiseAppSchema], config[transactionIsolationLevel], config[schema], config[exportHibernateJMXStatistics], config[hibernateDialect], config[mappedSchemaCacheSize]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$DevModeOptionsSpec$private val allowCompatibilityZone by boolean().optional().withDefaultValue(DevModeOptions.Defaults.allowCompatibilityZone)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DevModeOptionsSpec$private val disableCheckpointChecker by boolean().optional().withDefaultValue(DevModeOptions.Defaults.disableCheckpointChecker)</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$private val enableCacheTracing by boolean().optional().withDefaultValue(EnterpriseConfiguration.Defaults.enableCacheTracing)</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$private val messagingServerBackupAddresses by string().mapValid(::toNetworkHostAndPort).list().optional().withDefaultValue(EnterpriseConfiguration.Defaults.messagingServerBackupAddresses)</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$private val messagingServerConnectionConfiguration by enum(MessagingServerConnectionConfiguration::class).optional().withDefaultValue(EnterpriseConfiguration.Defaults.messagingServerConnectionConfiguration)</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$private val traceTargetDirectory by string().mapValid(::toPath).optional().withDefaultValue(EnterpriseConfiguration.Defaults.traceTargetDirectory)</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$private val tuning by nested(PerformanceTuningSpec).optional().withDefaultValue(EnterpriseConfiguration.Defaults.tuning)</ID>
    <ID>MaxLineLength:ConfigSections.kt$EnterpriseConfigurationSpec$private val useMultiThreadedSMM by boolean().optional().withDefaultValue(EnterpriseConfiguration.Defaults.useMultiThreadedSMM)</ID>
    <ID>MaxLineLength:ConfigSections.kt$FlowTimeoutConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$FreshIdentitiesConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$FreshIdentitiesConfigurationSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$FreshIdentitiesConfigurationSpec$return valid(FreshIdentitiesConfiguration(config[mode], config[cryptoServiceConfiguration], config[masterKeyAlias]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$GraphiteOptionsSpec$private</ID>
    <ID>MaxLineLength:ConfigSections.kt$MessagingServerSslConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$MessagingServerSslConfigurationSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$MessagingServerSslConfigurationSpec$return valid(MessagingServerSslConfiguration(config[sslKeystore], config[keyStorePassword], config[trustStoreFile], config[trustStorePassword], config[useOpenSsl]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$MutualExclusionConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$MutualExclusionConfigurationSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$MutualExclusionConfigurationSpec$return valid(MutualExclusionConfiguration(config[on], config[machineName], config[updateInterval], config[waitInterval]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$MySQLNotaryConfigSpec$return valid(MySQLNotaryConfig(config[dataSource], config[connectionRetries], config[backOffIncrement], config[backOffBase], config[maxBatchSize], config[maxBatchInputStates], config[batchTimeoutMs], config[maxQueueSize]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NetworkServicesConfigSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$NetworkServicesConfigSpec$return valid(NetworkServicesConfig(config[doormanURL], config[networkMapURL], config[pnm], config[inferred], config[proxyType], config[proxyAddress], config[proxyUser], config[proxyPassword]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NodeRpcSettingsSpec$return valid(NodeRpcSettings(config[address], config[adminAddress], config[standAloneBroker], config[useSsl], config[ssl]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NotaryConfigSpec$private val etaMessageThresholdSeconds by int().optional().withDefaultValue(NotaryServiceFlow.defaultEstimatedWaitTime.seconds.toInt())</ID>
    <ID>MaxLineLength:ConfigSections.kt$NotaryConfigSpec$private val useUnspentStatesCache by boolean().optional().withDefaultValue(NotaryConfig.Defaults.useUnspentStatesCache)</ID>
    <ID>MaxLineLength:ConfigSections.kt$NotaryConfigSpec$return valid(NotaryConfig(config[validating], config[serviceLegalName], config[className], config[etaMessageThresholdSeconds], config[extraConfig], config[raft], config[bftSMaRt], config[mysql], config[jpa], config[useUnspentStatesCache]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$PerformanceTuningSpec$return valid(PerformanceTuning(config[flowThreadPoolSize], config[maximumMessagingBatchSize], config[rpcThreadPoolSize], config[p2pConfirmationWindowSize], config[brokerConnectionTtlCheckIntervalMs]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$ProcessedMessageCleanupSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$RelayConfigurationSpec$return valid(RelayConfiguration(config[relayHost], config[remoteInboundPort], config[username], config[privateKeyFile], config[publicKeyFile], config[sshPort]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$SSHDConfigurationSpec$override fun parseValid(configuration: Config, options: Configuration.Options): Valid&lt;SSHDConfiguration&gt;</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec$dataSource.type == AuthDataSourceType.INMEMORY &amp;&amp; authServiceOptions?.cache != null -&gt; badValue("no cache supported for \"INMEMORY\" data provider")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$else -&gt; valid(SecurityConfiguration.AuthService.DataSource(type, passwordEncryption, connection, users))</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$private</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$private val passwordEncryption by enum(PasswordEncryption::class).optional().withDefaultValue(SecurityConfiguration.AuthService.DataSource.Defaults.passwordEncryption)</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$type == AuthDataSourceType.DB &amp;&amp; (users != null || connection == null) -&gt; badValue("\"DB\" data source type requires \"connection\" and cannot specify \"users\"")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$type == AuthDataSourceType.INMEMORY &amp;&amp; (users == null || connection != null) -&gt; badValue("\"INMEMORY\" data source type requires \"users\" and cannot specify \"connection\"")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private val expireAfterSecs by long().mapValid { value -&gt; if (value &gt;= 0) validValue(value) else badValue("cannot be less than 0'") }</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private val maxEntries by long().mapValid { value -&gt; if (value &gt;= 0) validValue(value) else badValue("cannot be less than 0'") }</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$return valid(SecurityConfiguration.AuthService.Options.Cache(config[expireAfterSecs], config[maxEntries]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryConfigSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryConfigSpec$private val backOffIncrement by int().optional().withDefaultValue(StandaloneJPANotaryConfig.Defaults.backOffIncrement)</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryConfigSpec$private val connectionRetries by int().optional().withDefaultValue(StandaloneJPANotaryConfig.Defaults.connectionRetries)</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryConfigSpec$private val maxBatchInputStates by int().optional().withDefaultValue(StandaloneJPANotaryConfig.Defaults.maxBatchInputStates)</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryConfigSpec$private val maxDBTransactionRetryCount by int().optional().withDefaultValue(StandaloneJPANotaryConfig.Defaults.maxDBTransactionRetryCount)</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryConfigSpec$return valid(StandaloneJPANotaryConfig(config[dataSource], config[databaseConfig], config[connectionRetries], config[backOffIncrement], config[backOffBase], config[maxBatchSize], config[maxBatchInputStates], config[batchTimeoutMs], config[maxQueueSize], config[maxDBTransactionRetryCount]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryDatabaseConfigSpec$internal</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryDatabaseConfigSpec$override</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryDatabaseConfigSpec$private val initialiseSchema by enum(net.corda.notary.standalonejpa.SchemaInitializationType::class).optional().withDefaultValue(StandaloneJPANotaryDatabaseConfig.Defaults.initialiseSchema)</ID>
    <ID>MaxLineLength:ConfigSections.kt$StandaloneJPANotaryDatabaseConfigSpec$return valid(StandaloneJPANotaryDatabaseConfig(config[initialiseSchema], config[schema], config[hibernateDialect]))</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(CordaX500Name.parse("O=Bank A, L=London, C=GB"), config.bridgeInnerConfig!!.expectedCertificateSubject)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(CordaX500Name.parse("O=Bank A, L=London, C=GB"), config.floatOuterConfig!!.expectedCertificateSubject)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(baseDirectory.resolve(Paths.get("customcerts/mysslkeystore.jks")), config.publicSSLConfiguration.keyStore.path)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(baseDirectory.resolve(Paths.get("customcerts/mytruststore.jks")), config.publicSSLConfiguration.trustStore.path)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(baseDirectory.resolve(Paths.get("outboundcerts/outboundkeys.jks")), artemisSSLConfiguration.keyStore.path)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(baseDirectory.resolve(Paths.get("outboundcerts/outboundtrust.jks")), artemisSSLConfiguration.trustStore.path)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(baseDirectory.resolve(Paths.get("tunnelcerts/tunnelkeys.jks")), tunnelSSLConfiguration.keyStore.path)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertEquals(baseDirectory.resolve(Paths.get("tunnelcerts/tunneltrust.jks")), tunnelSSLConfiguration.trustStore.path)</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$assertTrue(ConfigHelper.loadConfig(it.parent, it).parseAsNodeConfiguration().isValid, "Invalid config $it")</ID>
    <ID>MaxLineLength:ConfigTest.kt$ConfigTest$createAndLoadConfigFromResource(tempFolder.root.toPath() / "err1", "/net/corda/bridge/withaudit/badconfig/badInterval.conf")</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ // TODO Move this to KeyStoreConfigHelpers. fun NodeConfiguration.configureWithDevSSLCertificate(cryptoService: ManagedCryptoService? = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ fun parseToDbSchemaFriendlyName(value: String)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$// Problems: // - Forces you to have a primary constructor with all fields of name and type matching the configuration file structure. // - Encourages weak bean-like types. // - Cannot support a many-to-one relationship between configuration file structures and configuration domain type. This is essential for versioning of the configuration files. // - It's complicated and based on reflection, meaning problems with it are typically found at runtime. // - It doesn't support validation errors in a structured way. If something goes wrong, it throws exceptions, which doesn't support good usability practices like displaying all the errors at once. fun &lt;T : Any&gt; Config.parseAs(clazz: KClass&lt;T&gt;, onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle, nestedPath: String? = null, baseDirectory: Path? = null): T</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: ManagedCryptoService? = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$@Suppress("UNCHECKED_CAST") private</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$// 30 is a temporary max to prevent issues with max server-side allowed database connections, until we switch to proper pooling. private const val FLOW_THREAD_POOL_SIZE_MAX = 30</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$configOverrides // Add substitution values here .withFallback(configOf("custom.nodeOrganizationName" to parseToDbSchemaFriendlyName(baseDirectory.fileName?.toString() ?: "root")))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$configOverrides // Add substitution values here .withFallback(configOf("custom.nodeOrganizationName" to parseToDbSchemaFriendlyName(baseDirectory.fileName?.toString() ?: "root"))) //for database integration tests .withFallback(systemOverrides) //for database integration tests .withFallback(environmentOverrides) //for database integration tests .withFallback(configOf("baseDirectory" to baseDirectory.toString())) .withFallback(databaseConfig) //for database integration tests .withFallback(appConfig) .withFallback(devModeConfig)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$configOverrides // Add substitution values here .withFallback(configOf("custom.nodeOrganizationName" to parseToDbSchemaFriendlyName(baseDirectory.fileName?.toString() ?: "root"))) //for database integration tests .withFallback(systemOverrides) //for database integration tests .withFallback(environmentOverrides) //for database integration tests .withFallback(configOf("baseDirectory" to baseDirectory.toString())) .withFallback(databaseConfig) //for database integration tests .withFallback(appConfig) .withFallback(devModeConfig) // this needs to be after the appConfig, so it doesn't override the configured devMode .withFallback(multiThreadingConfig)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$return ConfigFactory.parseMap(toProperties().filterKeys { (it as String).startsWith(CORDA_PROPERTY_PREFIX) }.mapKeys { (it.key as String).removePrefix(CORDA_PROPERTY_PREFIX) })</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$val databaseConfig = ConfigFactory.parseResources(System.getProperty("custom.databaseProvider") + ".conf", parseOptions.setAllowMissing(true))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$val multiThreadingConfig = configOf("enterpriseConfiguration.tuning.flowThreadPoolSize" to flowThreadPoolSize.toString(), "enterpriseConfiguration.tuning.rpcThreadPoolSize" to (coreCount).toString())</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$val smartDevMode = CordaSystemUtils.isOsMac() || (CordaSystemUtils.isOsWindows() &amp;&amp; !CordaSystemUtils.getOsName().toLowerCase().contains("server"))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper${ val parseOptions = ConfigParseOptions.defaults() val defaultConfig = ConfigFactory.parseResources("reference.conf", parseOptions.setAllowMissing(false)) val appConfig = ConfigFactory.parseFile(configFile.toFile(), parseOptions.setAllowMissing(allowMissingConfig)) val databaseConfig = ConfigFactory.parseResources(System.getProperty("custom.databaseProvider") + ".conf", parseOptions.setAllowMissing(true)) // Detect the underlying OS. If mac or windows non-server then we assume we're running in devMode. Unless specified otherwise. val smartDevMode = CordaSystemUtils.isOsMac() || (CordaSystemUtils.isOsWindows() &amp;&amp; !CordaSystemUtils.getOsName().toLowerCase().contains("server")) val devModeConfig = ConfigFactory.parseMap(mapOf("devMode" to smartDevMode)) // Detect the number of cores val coreCount = Runtime.getRuntime().availableProcessors() val flowThreadPoolSize = min(2 * coreCount, FLOW_THREAD_POOL_SIZE_MAX) val multiThreadingConfig = configOf("enterpriseConfiguration.tuning.flowThreadPoolSize" to flowThreadPoolSize.toString(), "enterpriseConfiguration.tuning.rpcThreadPoolSize" to (coreCount).toString()) val systemOverrides = systemProperties().cordaEntriesOnly() val environmentOverrides = systemEnvironment().cordaEntriesOnly() val finalConfig = configOverrides // Add substitution values here .withFallback(configOf("custom.nodeOrganizationName" to parseToDbSchemaFriendlyName(baseDirectory.fileName?.toString() ?: "root"))) //for database integration tests .withFallback(systemOverrides) //for database integration tests .withFallback(environmentOverrides) //for database integration tests .withFallback(configOf("baseDirectory" to baseDirectory.toString())) .withFallback(databaseConfig) //for database integration tests .withFallback(appConfig) .withFallback(devModeConfig) // this needs to be after the appConfig, so it doesn't override the configured devMode .withFallback(multiThreadingConfig) // this needs to be after the appConfig, so it doesn't override the configured threading. .withFallback(defaultConfig) .resolve() val entrySet = finalConfig.entrySet().filter { entry -&gt; entry.key.contains("\"") } for ((key) in entrySet) { log.error("Config files should not contain \" in property names. Please fix: $key") } return finalConfig }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$FileBasedCertificateStoreSupplier(signingCertificateStore.path, signingCertificateStore.storePassword, signingCertificateStore.entryPassword).get(true)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException : IllegalArgumentException</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException$require(unknownKeys.isNotEmpty()) { "Absence of unknown keys should not raise UnknownConfigurationKeysException." }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException.Companion$fun of(offendingKeys: Set&lt;String&gt;): UnknownConfigurationKeysException</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$UnknownConfigurationKeysException.Companion$private fun message(offendingKeys: Set&lt;String&gt;)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$fun Any?.toConfigValue(): ConfigValue</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$getConfig(path).parseAs(typeClass, onUnknownKeys, nestedPath?.let { "$it.$path" } ?: path, baseDirectory = baseDirectory)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$inline fun &lt;reified T : Any&gt; Config.parseAs(noinline onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle): T</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$private</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$private fun parseEnum(enumType: Class&lt;*&gt;, name: String): Enum&lt;*&gt;</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$require(clazz.isData) { "Only Kotlin data classes or class annotated with CustomConfigParser can be parsed. Offending: ${clazz.qualifiedName}" }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$return getValueInternal(metadata.name, metadata.returnType, UnknownConfigKeysPolicy.IGNORE::handle, nestedPath = null, baseDirectory = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$return uncheckedCast(if (type.arguments.isEmpty()) getSingleValue(path, type, onUnknownKeys, nestedPath, baseDirectory) else getCollectionValue(path, type, onUnknownKeys, nestedPath, baseDirectory))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$setPrivateKey(it, serviceKeystore.getPrivateKey(it, DEV_CA_KEY_STORE_PASS), serviceKeystore.getCertificateChain(it), signingKeyStore.entryPassword)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$val elementClass = type.arguments[0].type?.jvmErasure ?: throw IllegalArgumentException("Cannot work with star projection: $type")</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$val publicKey = cryptoService.generateKeyPair(CORDA_CLIENT_CA, cryptoService.defaultIdentitySignatureScheme())</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$val signingKeyStore = FileBasedCertificateStoreSupplier(signingCertificateStore.path, signingCertificateStore.storePassword, signingCertificateStore.entryPassword).get(true) .also { it.installDevNodeCaCertPath(myLegalName) }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // These types are supported by Config as use as is value }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // These types make sense to be represented as Strings and the exact inverse parsing function for use in parseAs value.toString() }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // if baseDirectory been specified try resolving path against it. Note if `pathFromConfig` is an absolute path - this instruction has no effect. baseDirectory.resolve(path) }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ val signingKeyStore = FileBasedCertificateStoreSupplier(signingCertificateStore.path, signingCertificateStore.storePassword, signingCertificateStore.entryPassword).get(true) .also { it.installDevNodeCaCertPath(myLegalName) } // Move distributed service composite key (generated by IdentityGenerator.generateToDisk) to keystore if exists. val distributedServiceKeystore = certificatesDirectory / "distributedService.jks" if (distributedServiceKeystore.exists()) { val serviceKeystore = X509KeyStore.fromFile(distributedServiceKeystore, DEV_CA_KEY_STORE_PASS) signingKeyStore.update { serviceKeystore.aliases().forEach { if (serviceKeystore.internal.isKeyEntry(it)) { setPrivateKey(it, serviceKeystore.getPrivateKey(it, DEV_CA_KEY_STORE_PASS), serviceKeystore.getCertificateChain(it), signingKeyStore.entryPassword) } else { setCertificate(it, serviceKeystore.getCertificate(it)) } } } } }</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$ fun deobfuscate(rawValue: String, hardwareAddress: ByteArray?, seed: ByteArray?, path: String): String</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Describer</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Schema : ValidatorDescriber</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Validator : Validator</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Describer$ fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue = { value -&gt; ConfigValueFactory.fromAnyRef(value.toString()) }, options: Options): ConfigValue?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Definition&lt;TYPE&gt; : MetadataValidatorExtractorDescriberParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Metadata</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$Single&lt;TYPE&gt; : Definition</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$override</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun boolean(key: String, sensitive: Boolean = false): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun double(key: String, sensitive: Boolean = false): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun duration(key: String, sensitive: Boolean = false): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun float(key: String, sensitive: Boolean = false): Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun int(key: String, sensitive: Boolean = false): Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun nestedObject(key: String, schema: Schema? = null, sensitive: Boolean = false): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun string(key: String, sensitive: Boolean = false): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ private fun Config.deobfuscateStringList(path: String, hardwareAddress: ByteArray?, seed: ByteArray?): List&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Float, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of(key, Float::class.javaObjectType.simpleName, "Provided value exceeds Float range."))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Int, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of("Provided value exceeds Integer range [${Int.MIN_VALUE}, ${Int.MAX_VALUE}].", key, Int::class.javaObjectType.simpleName))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$modifiedObject = modifiedObject.withValue(key, ConfigValueFactory.fromAnyRef(deobfuscatedValue))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$modifiedObject = modifiedObject.withValue(key, deobfuscateObject("$path.$key", value, hardwareAddress, seed))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$private</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Validation.Error&gt;): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Validated&lt;MAPPED, Validation.Error&gt;): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue, options: Configuration.Options): ConfigValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(name: String? = null, builder: Property.Definition.Companion.() -&gt; Iterable&lt;Property.Definition&lt;*&gt;&gt;): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(name: String? = null, properties: Iterable&lt;Property.Definition&lt;*&gt;&gt;): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(vararg properties: Property.Definition&lt;*&gt;, name: String? = null): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String? = null, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun boolean(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun double(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun duration(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun float(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun int(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun long(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun nestedObject(schema: Schema? = null, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun string(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ protected abstract fun parseValid(configuration: Config, options: Options): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$abstract</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$final override fun parse(configuration: Config, options: Options): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue, options: Configuration.Options)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadPath : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MalformedStructure : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MissingValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$Unknown : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$UnsupportedVersion : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$WrongType : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal abstract fun with(keyName: String = this.keyName ?: UNKNOWN, typeName: String = this.typeName ?: UNKNOWN): Configuration.Validation.Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal fun withContainingPathPrefix(vararg containingPath: String): Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$sealed</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun with(keyName: String, typeName: String): BadPath</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): BadPath</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun with(keyName: String, typeName: String): BadValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): BadValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun with(keyName: String, typeName: String): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun with(keyName: String, typeName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$fun forKey(keyName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown.Companion$fun of(keyName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): Unknown</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.UnsupportedVersion$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun with(keyName: String, typeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun forKey(keyName: String, expectedTypeName: String, actualTypeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value$Parser&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigObfuscator.DeobfuscationFailedForPathException::class) fun valueIn(configuration: Config, options: Options): TYPE</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigObfuscator.DeobfuscationFailedForPathException::class) fun valueInOrNull(configuration: Config, options: Options): TYPE?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$@Throws(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigObfuscator.DeobfuscationFailedForPathException::class)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$@Throws(ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigObfuscator.DeobfuscationFailedForPathException::class)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Parser$ fun parse(configuration: Config, options: Options = Options.defaults): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Version.Extractor.Companion$ fun fromPath(versionPath: String, versionDefaultValue: Int = DEFAULT_VERSION_VALUE): Configuration.Version.Extractor</ID>
    <ID>MaxLineLength:ConfigurationCollector.kt$ConfigurationCollector : TrackedCollector</ID>
    <ID>MaxLineLength:ConnectionChange.kt$ConnectionChange$data</ID>
    <ID>MaxLineLength:ConnectionChange.kt$ConnectionChange$return "ConnectionChange remoteAddress: $remoteAddress connected state: $connected cert subject: ${remoteCert?.subjectDN} cert ok: ${!badCert}"</ID>
    <ID>MaxLineLength:ConnectionManager.kt$ fun &lt;A&gt; connectToNodes(remoteNodes: List&lt;RemoteNode&gt;, tunnelPortAllocation: PortAllocation, withConnections: (List&lt;NodeConnection&gt;) -&gt; A): A</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$logDebugWithMDC { "Put tag ${delivery.tag.toHexString()} on wire uuid: ${nextMessage.applicationProperties["_AMQ_DUPL_ID"]}" }</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$sender.send(messageBuf.array(), messageBuf.arrayOffset() + messageBuf.readerIndex(), messageBuf.readableBytes())</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$val pending = transport.pending() // Note this drives frame generation, which the susbsequent writes push to the socket</ID>
    <ID>MaxLineLength:Console.kt$Console$private</ID>
    <ID>MaxLineLength:Constants.kt$/** * constants in this file are generated by gradle * to change this file, edit src/main/template/kotlin/net/corda/common/logging/Constants.kt * the generated file does not need to be committed to source control (originally added to source control for ease of use) */ internal const val CURRENT_MAJOR_RELEASE = "4.3-SNAPSHOT"</ID>
    <ID>MaxLineLength:Constants.kt$/** * constants in this file are generated by gradle * to change this file, edit src/main/template/kotlin/net/corda/common/logging/Constants.kt * the generated file does not need to be committed to source control (originally added to source control for ease of use) */ internal const val CURRENT_MAJOR_RELEASE = "@corda_release_version@"</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Fail early in the TransactionBuilder when attempting to change the hash of the HashConstraint on the spending transaction`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `On contract annotated with NoConstraintPropagation there is no platform check for propagation, but the transaction builder can't use the AutomaticPlaceholderConstraint`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Switching from the WhitelistConstraint to the Signature Constraint fails if the signature constraint does not inherit all jar signatures`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Switching from the WhitelistConstraint to the Signature Constraint is possible if the attachment satisfies both constraints, and the signature constraint inherits all jar signatures`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `When the constraint of the output state is a valid transition from the input state, transaction validation works`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$SignableData(wireTransaction.id, SignatureMetadata(4, Crypto.findSignatureScheme(nodeKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFailsWith&lt;IllegalArgumentException&gt; { AutomaticPlaceholderConstraint.canBeTransitionedFrom(AutomaticPlaceholderConstraint, attachment) }</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(AlwaysAcceptAttachmentConstraint.canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(AlwaysAcceptAttachmentConstraint.canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(AlwaysAcceptAttachmentConstraint.canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(AlwaysAcceptAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(AlwaysAcceptAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(HashAttachmentConstraint(allOnesHash), attachmentSigned))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(BOB_PUBKEY).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(BOB_PUBKEY).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(AlwaysAcceptAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "1"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "2"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "3"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "1"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "2"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "3"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$ledgerServices.attachments.importContractAttachment(cordapp.contractClassNames, "rpc", signedJarStream, null, listOf(jarAndSigner.second))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$ledgerServices.attachments.importContractAttachment(cordapp.contractClassNames, "rpc", unsignedJarStream, null)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(allOnesHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(unsignedAttachmentId), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, HashAttachmentConstraint(allOnesHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c3", DUMMY_NOTARY, null, SignatureAttachmentConstraint(ALICE_PUBKEY), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c3", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(2000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c4", DUMMY_NOTARY, null, AlwaysAcceptAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w1", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(ALICE_PUBKEY), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c2", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c3", DUMMY_NOTARY, null, AutomaticPlaceholderConstraint, NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$val jarAndSigner = ContractJarTestUtils.signContractJar(cordapp.jarPath, copyFirst = true, keyStoreDir = keyStoreDir.path)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests.&lt;no name provided&gt;$override fun loadContractAttachment(stateRef: StateRef)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests.Companion$hashToSignatureConstraintsKey = keyStoreDir.path.generateKey("testAlias", "testPassword", ALICE_NAME.toString())</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ internal fun ContractClassName.contractHasAutomaticConstraintPropagation(classLoader: ClassLoader? = null): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input.isAutomaticHashConstraint() || output.isAutomaticHashConstraint() -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$log.warnOnce("Found state ${state.contract} that is constrained by the insecure: AlwaysAcceptAttachmentConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$require(state.constraint::class in validConstraints) { "Found state ${state.contract} with an illegal constraint: ${state.constraint}" }</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$val Attachment.contractVersion: Version get() = if (this is ContractAttachment) version else CordappImpl.DEFAULT_CORDAPP_VERSION</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$when { // These branches should not happen, as this has been already checked. input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.") input.isAutomaticHashConstraint() || output.isAutomaticHashConstraint() -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.") // Transition to the same constraint. input == output -&gt; true // You can't transition from the AlwaysAcceptAttachmentConstraint to anything else, as it could hide something illegal. input is AlwaysAcceptAttachmentConstraint &amp;&amp; output !is AlwaysAcceptAttachmentConstraint -&gt; false // Nothing can be migrated from the HashConstraint except a HashConstraint with the same Hash. (This check is redundant, but added for clarity) input is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; input == output // Anything (except the AlwaysAcceptAttachmentConstraint) can be transformed to a HashAttachmentConstraint. input !is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; true // The SignatureAttachmentConstraint allows migration from a Signature constraint with the same key. // TODO - we don't support currently third party signers. When we do, the output key will have to be stronger then the input key. input is SignatureAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; input.key == output.key // HashAttachmentConstraint can be transformed to a SignatureAttachmentConstraint when hash constraint verification checking disabled. HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true // You can transition from the WhitelistConstraint to the SignatureConstraint only if all signers of the JAR are required to sign in the future. input is WhitelistedByZoneAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; attachment.signerKeys.isNotEmpty() &amp;&amp; output.key.keys.containsAll(attachment.signerKeys) else -&gt; false }</ID>
    <ID>MaxLineLength:ContentSignerBuilder.kt$ContentSignerBuilder$fun build(signatureScheme: SignatureScheme, privateKey: PrivateKey, provider: Provider, random: SecureRandom? = null): ContentSigner</ID>
    <ID>MaxLineLength:ContentSignerBuilder.kt$ContentSignerBuilder.SignatureOutputStream$private fun checkNotSigned(func: () -&gt; Unit)</ID>
    <ID>MaxLineLength:Context.kt$Context</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment : Attachment</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment$return "ContractAttachment(attachment=${attachment.id}, contracts='$allContracts', uploader='$uploader', signed='$isSigned', version='$version')"</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment$uploader: String? = null</ID>
    <ID>MaxLineLength:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$return ContractAttachment.create(proxy.attachment, proxy.contract, proxy.contracts, proxy.uploader, proxy.signers, proxy.version)</ID>
    <ID>MaxLineLength:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$return ContractAttachmentProxy(GeneratedAttachment(bytes, obj.uploader), obj.contract, obj.additionalContracts, obj.uploader, obj.signerKeys, obj.version)</ID>
    <ID>MaxLineLength:ContractAttachmentSerializer.kt$ContractAttachmentSerializer.ContractAttachmentProxy$@KeepForDJVM data</ID>
    <ID>MaxLineLength:ContractAttachmentSerializerTest.kt$ContractAttachmentSerializerTest$val contractAttachment = ContractAttachment(GeneratedAttachment(EMPTY_BYTE_ARRAY, "test"), DummyContract.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ContractFunctions.kt$fun swap(partyA: Party, amountA: BigDecimal, currencyA: Currency, partyB: Party, amountB: BigDecimal, currencyB: Currency)</ID>
    <ID>MaxLineLength:ContractFunctions.kt$swap(partyA, BigDecimal(notional * strike), domesticCurrency, partyB, BigDecimal(notional), foreignCurrency)</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$PrepareTransaction : FlowLogic</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$aliceNode.services.startFlow(PrepareTransaction(bob, notary, IndirectContract.State())).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$mockNet = InternalMockNetwork(networkSendManuallyPumped = false, threadPerNode = true, cordappsForAllNodes = listOf(enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest.PrepareTransaction$val command = Command(IndirectContract.Create(), listOf(serviceHub.myInfo.singleIdentity().owningKey, otherSide.owningKey))</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest.PrepareTransaction$val txB = TransactionBuilder(notary = notary, outputs = mutableListOf(txState), commands = mutableListOf(command))</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$@JvmOverloads fun makeTestContractJar(workingDir: Path, contractName: String, signed: Boolean = false, version: Int = 1, versionSeed: Int = 0): Path</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$@JvmOverloads fun makeTestContractJar(workingDir: Path, contractNames: List&lt;String&gt;, signed: Boolean = false, version: Int = 1, generateManifest: Boolean = true, jarFileName : String? = null): Path</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$@JvmOverloads fun makeTestSignedContractJar(workingDir: Path, contractName: String, version: Int = 1, versionSeed: Int = 0): Pair&lt;Path, PublicKey&gt;</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$fun signContractJar(jarURL: URL, copyFirst: Boolean, keyStoreDir: Path? = null, alias: String = "testAlias", pwd: String = "testPassword"): Pair&lt;Path, PublicKey&gt;</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$private</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$val outFile = fileManager.getFileForInput(StandardLocation.CLASS_OUTPUT, packages.joinToString("."), "$className.class")</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$val source = object : SimpleJavaFileObject(URI.create("string:///${packages.joinToString("/")}/$className.java"), JavaFileObject.Kind.SOURCE) { override fun getCharContent(ignoreEncodingErrors: Boolean): CharSequence { return newClass } }</ID>
    <ID>MaxLineLength:ContractStateModel.kt$ContractStateModel$val cashStates: ObservableList&lt;StateAndRef&lt;Cash.State&gt;&gt; = cashStatesDiff.fold(FXCollections.observableArrayList()) { list: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;, (added, removed) -&gt; list.removeIf { it in removed } list.addAll(added) }.distinctBy { it.ref }</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow$Authorise : FlowLogic</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$( originalState: StateAndRef&lt;OldState&gt;, newContractClass: Class&lt;out UpgradedContract&lt;OldState, NewState&gt;&gt; )</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest$has&lt;ContractUpgradeLedgerTransaction, Any&gt;("input data", { it.inputs.single().state.data }, isA&lt;T&gt;(anything))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$and</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest$has&lt;ContractUpgradeLedgerTransaction, Any&gt;("input data", { it.inputs.single().state.data }, isA&lt;T&gt;(anything))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest${ // Create dummy contract. val signedByA = aliceNode.signDummyContract(alice.ref(1), 0, bob.ref(1)) val stx = bobNode.addSignatureTo(signedByA) aliceNode.finalise(stx, bob) val aliceTx = aliceNode.getValidatedTransaction(stx) val bobTx = bobNode.getValidatedTransaction(stx) // The request is expected to be rejected because party B hasn't authorised the upgrade yet. assertThat( aliceNode.initiateContractUpgrade(aliceTx, DummyContractV2::class), willThrow&lt;UnexpectedFlowEndException&gt;()) // Party B authorises the contract state upgrade, and immediately de-authorises the same. assertThat(bobNode.authoriseContractUpgrade(bobTx, DummyContractV2::class), willReturn()) assertThat(bobNode.deauthoriseContractUpgrade(bobTx), willReturn()) // The request is expected to be rejected because party B has subsequently de-authorised a previously authorised upgrade. assertThat( aliceNode.initiateContractUpgrade(aliceTx, DummyContractV2::class), willThrow&lt;UnexpectedFlowEndException&gt;()) // Party B authorises the contract state upgrade. assertThat(bobNode.authoriseContractUpgrade(bobTx, DummyContractV2::class), willReturn()) // Party A initiates contract upgrade flow, expected to succeed this time. assertThat( aliceNode.initiateContractUpgrade(aliceTx, DummyContractV2::class), willReturn( aliceNode.hasContractUpgradeTransaction&lt;DummyContract.State, DummyContractV2.State&gt;() and bobNode.hasContractUpgradeTransaction&lt;DummyContract.State, DummyContractV2.State&gt;())) val upgradedState = aliceNode.getStateFromVault(DummyContractV2.State::class) // We now test that the upgraded state can be upgraded further, to V3. // Party B authorises the contract state upgrade. assertThat(bobNode.authoriseContractUpgrade(upgradedState, DummyContractV3::class), willReturn()) // Party A initiates contract upgrade flow which is expected to succeed. assertThat( aliceNode.initiateContractUpgrade(upgradedState, DummyContractV3::class), willReturn( aliceNode.hasContractUpgradeTransaction&lt;DummyContractV2.State, DummyContractV3.State&gt;() and bobNode.hasContractUpgradeTransaction&lt;DummyContractV2.State, DummyContractV3.State&gt;())) }</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$@BelongsToContract(CashV2::class) data</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Currency&gt;&gt;, newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractUpgradeServiceImpl.kt$ContractUpgradeServiceImpl : ContractUpgradeServiceSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:ContractUpgradeServiceImpl.kt$ContractUpgradeServiceImpl$override</ID>
    <ID>MaxLineLength:ContractUpgradeServiceImpl.kt$ContractUpgradeServiceImpl.Companion$fun createContractUpgradesMap(cacheFactory: NamedCacheFactory): PersistentMap&lt;String, String, DBContractUpgrade, String&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeFilteredTransaction : CoreTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractClassName: ContractClassName, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$@Deprecated("ContractUpgradeLedgerTransaction should not be created directly, use ContractUpgradeWireTransaction.resolve instead.")</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$ContractUpgradeLedgerTransaction(inputs, notary, legacyContractAttachment, upgradedContractClassName, upgradedContractAttachment, id, privacySalt, sigs, networkParameters)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$return "ContractUpgradeLedgerTransaction(inputs=$inputs, notary=$notary, legacyContractAttachment=$legacyContractAttachment, upgradedContractAttachment=$upgradedContractAttachment, id=$id, privacySalt=$privacySalt, sigs=$sigs, networkParameters=$networkParameters, upgradedContract=$upgradedContract, references=$references, legacyContractClassName='$legacyContractClassName', outputs=$outputs)"</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$return ContractUpgradeLedgerTransaction(inputs, notary, legacyContractAttachment, upgradedContractAttachment, id, privacySalt, sigs, networkParameters, upgradedContract)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$val cordappLoader = services.cordappProvider::class.java.getMethod("getCordappLoader").invoke(services.cordappProvider)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ @CordaInternal internal fun resolveOutputComponent(services: ServicesForResolution, stateRef: StateRef, params: NetworkParameters): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun buildFilteredTransaction(): ContractUpgradeFilteredTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$PARAMETERS_HASH.ordinal to FilteredComponent(serializedComponents[PARAMETERS_HASH.ordinal], nonces[PARAMETERS_HASH.ordinal])</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$classLoader.loadClass(className).asSubclass(UpgradedContract::class.java).newInstance() as UpgradedContract&lt;ContractState, ContractState&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$private</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val binaryInput: SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt; = resolveStateRefBinaryComponent(inputs[stateRef.index], services)!!</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val legacyContractAttachmentId: SecureHash by lazy { serializedComponents[LEGACY_ATTACHMENT.ordinal].deserialize&lt;SecureHash&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val resolvedNetworkParameters = services.networkParametersService.lookup(hashToResolve) ?: throw TransactionResolutionException(id)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractAttachmentId: SecureHash by lazy { serializedComponents[UPGRADED_ATTACHMENT.ordinal].deserialize&lt;SecureHash&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractClassName: ContractClassName by lazy { serializedComponents[UPGRADED_CONTRACT.ordinal].deserialize&lt;ContractClassName&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction${ (services as ServiceHubCoreInternal).attachmentTrustCalculator.calculate(it) }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractsDSL.kt$inline</ID>
    <ID>MaxLineLength:ContractsDSL.kt$mapNotNull { if (klass.isInstance(it.value)) uncheckedCast&lt;CommandWithParties&lt;CommandData&gt;, CommandWithParties&lt;C&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt; -&gt; commands.requireSingleCommand(TestCommands::class.java) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt; -&gt; commands.requireSingleCommand&lt;TestCommands&gt;() }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signers: Collection&lt;PublicKey&gt;?, party: Collection&lt;Party&gt;? -&gt; commands.select(TestCommands::class.java, signers, party) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signers: Collection&lt;PublicKey&gt;?, party: Collection&lt;Party&gt;? -&gt; commands.select&lt;TestCommands&gt;(signers, party) }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signer: PublicKey?, party: AbstractParty? -&gt; commands.select(TestCommands::class.java, signer, party) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signer: PublicKey?, party: AbstractParty? -&gt; commands.select&lt;TestCommands&gt;(signer, party) }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$val validCommandOne = CommandWithParties(listOf(megaCorp.publicKey, miniCorp.publicKey), listOf(megaCorp.party, miniCorp.party), TestCommands.CommandOne())</ID>
    <ID>MaxLineLength:ContractsScanning.kt$// When scanning of the CorDapp Jar is performed without "corda-core.jar" being in the classpath, there is no way to appreciate // relationships between those interfaces, therefore they have to be listed explicitly. val coreContractClasses = setOf(Contract::class, UpgradedContractWithLegacyConstraint::class, UpgradedContract::class)</ID>
    <ID>MaxLineLength:Converters.kt$CordaConverterProvider$override</ID>
    <ID>MaxLineLength:CopiedNode.kt$CopiedNode$return BuiltNode(this.configFile, this.baseDirectory, this.copiedNodeConfig, this.copiedNodeDir, nodeConfig, localImageId)</ID>
    <ID>MaxLineLength:CorDappInfoServlet.kt$CorDappInfoServlet$private</ID>
    <ID>MaxLineLength:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin : CRaSHPluginAuthenticationPlugin</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$// We don't allow the annotation for classes in attachments for now. The class will be on the main classpath if we have the CorDapp installed. // We also do not allow extension of KryoSerializable for annotated classes, or combination with @DefaultSerializer for custom serialisation. // TODO: Later we can support annotations on attachment classes and spin up a proxy via bytecode that we know is harmless. private fun checkForAnnotation(type: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$if (type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))) return null</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$kotlin.jvm.internal.Lambda::class.java.isAssignableFrom(targetType)</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$throw KryoException("Class ${Util.className(type)} is not annotated or on the whitelist, so cannot be used in serialization")</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver${ // If call path has disabled whitelisting (see [CordaKryo.register]), just return without checking. if (!whitelistEnabled) return null // If array, recurse on element type if (type.isArray) return checkClass(type.componentType) // Specialised enum entry, so just resolve the parent Enum type since cannot annotate the specialised entry. if (!type.isEnum &amp;&amp; Enum::class.java.isAssignableFrom(type)) return checkClass(type.superclass) // Allow primitives, abstracts and interfaces. Note that we can also create abstract Enum types, // but we don't want to whitelist those here. if (type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))) return null // It's safe to have the Class already, since Kryo loads it with initialisation off. // If we use a whitelist with blacklisting capabilities, whitelist.hasListed(type) may throw an IllegalStateException if input class is blacklisted. // Thus, blacklisting precedes annotation checking. if (!whitelist.hasListed(type) &amp;&amp; !checkForAnnotation(type)) { throw KryoException("Class ${Util.className(type)} is not annotated or on the whitelist, so cannot be used in serialization") } return null }</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver${ val targetType = typeForSerializationOf(type) val objectInstance = targetType.kotlinObjectInstance // We have to set reference to true, since the flag influences how String fields are treated and we want it to be consistent. val references = kryo.references try { kryo.references = true val serializer = when { objectInstance != null -&gt; KotlinObjectSerializer(objectInstance) kotlin.jvm.internal.Lambda::class.java.isAssignableFrom(targetType) -&gt; // Kotlin lambdas extend this class and any captured variables are stored in synthetic fields FieldSerializer&lt;Any&gt;(kryo, targetType).apply { setIgnoreSyntheticFields(false) } Throwable::class.java.isAssignableFrom(targetType) -&gt; ThrowableSerializer(kryo, targetType) else -&gt; kryo.getDefaultSerializer(targetType) } return register(Registration(targetType, serializer, NAME.toInt())) } finally { kryo.references = references } }</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$CordaSerializableHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$SubHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$SubSubHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superinterface java.sql.Connection of net.corda.serialization.internal.CordaClassResolverTests\$ConnectionImpl is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superinterface java.sql.Connection of net.corda.serialization.internal.CordaClassResolverTests\$SubConnectionImpl is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private fun importJar(storage: AttachmentStorage, uploader: String = DEPLOYED_CORDAPP_UPLOADER)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private val allButBlacklistedContext: CheckpointSerializationContext = CheckpointSerializationContextImpl(this.javaClass.classLoader, AllButBlacklisted, emptyMap(), true, null)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private val emptyWhitelistContext: CheckpointSerializationContext = CheckpointSerializationContextImpl(this.javaClass.classLoader, EmptyWhitelist, emptyMap(), true, null)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$val classLoader = AttachmentsClassLoader(arrayOf(attachmentHash).map { storage.openAttachment(it)!! }, testNetworkParameters(), SecureHash.zeroHash, { attachmentTrustCalculator.calculate(it) })</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$// Override this function with the actual method to be run once all the arguments have been parsed. The return number // is the exit code to be returned abstract fun runProgram(): Int</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$// Raw args are provided for use in logging - this is a lateinit var rather than a constructor parameter as the class // needs to be parameterless for autocomplete to work. lateinit var args: Array&lt;String&gt;</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$// This needs to be called before loggers (See: NodeStartup.kt:51 logger called by lazy, initLogging happens before). // Node's logging is more rich. In corda configurations two properties, defaultLoggingLevel and consoleLogLevel, are usually used. open fun initLogging(): Boolean</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$@Option(names = ["-v", "--verbose", "--log-to-console"], description = ["If set, prints logging to the console as well as to a file."])</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CliWrapperBase$System.setProperty("defaultLogLevel", specifiedLogLevel)</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$CordaCliWrapper : CliWrapperBase</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE)</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt$Validated</ID>
    <ID>MaxLineLength:CordaCliWrapper.kt${ val defaultAnsiMode = if (CordaSystemUtils.isOsWindows()) { Help.Ansi.ON } else { Help.Ansi.AUTO } val results = cmd.parseWithHandlers(RunLast().useOut(System.out).useAnsi(defaultAnsiMode), DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE), *args) // If an error code has been returned, use this and exit results?.firstOrNull()?.let { if (it is Int) { exitProcess(it) } else { exitProcess(ExitCodes.FAILURE) } } // If no results returned, picocli ran something without invoking the main program, e.g. --help or --version, so exit successfully exitProcess(ExitCodes.SUCCESS) }</ID>
    <ID>MaxLineLength:CordaClock.kt$CordaClock$@Deprecated("Do not use this. Instead seek to use ZonedDateTime methods.", level = DeprecationLevel.ERROR) override</ID>
    <ID>MaxLineLength:CordaClock.kt$MutableClock$ protected fun notifyMutationObservers()</ID>
    <ID>MaxLineLength:CordaClosureSerializer.kt$CordaClosureSerializer$const val ERROR_MESSAGE = "Unable to serialize Java Lambda expression, unless explicitly declared e.g., Runnable r = (Runnable &amp; Serializable) () -&gt; System.out.println(\"Hello world!\");"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaException$if (originalMessage == null) "$originalExceptionClassName" else "$originalExceptionClassName: $originalMessage"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaException$private var _cause: Throwable? = null</ID>
    <ID>MaxLineLength:CordaException.kt$CordaRuntimeException$if (originalMessage == null) "$originalExceptionClassName" else "$originalExceptionClassName: $originalMessage"</ID>
    <ID>MaxLineLength:CordaException.kt$CordaRuntimeException$private var _cause: Throwable?</ID>
    <ID>MaxLineLength:CordaExceptionTest.kt$CordaExceptionTest$val ex = assertFailsWith&lt;ConflictingAttachmentsRejection&gt; { throw ConflictingAttachmentsRejection(TX_ID, CONTRACT_CLASS) }</ID>
    <ID>MaxLineLength:CordaExceptionTest.kt$CordaExceptionTest$val ex = assertFailsWith&lt;NotaryChangeInWrongTransactionType&gt; { throw NotaryChangeInWrongTransactionType(TX_ID, ALICE, BOB) }</ID>
    <ID>MaxLineLength:CordaFlowToolWindow.kt$CordaFlowToolWindow.FlowTreeRenderer$override</ID>
    <ID>MaxLineLength:CordaFlowToolWindow.kt$CordaFlowToolWindow.SnapshotTreeRenderer$override</ID>
    <ID>MaxLineLength:CordaFuture.kt$CordaFuture&lt;V&gt; : Future</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;ELEMENT&gt; CordaFuture&lt;out ELEMENT&gt;.mapError(transform: (Throwable) -&gt; Throwable): CordaFuture&lt;ELEMENT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;RESULT&gt; CordaFuture&lt;out RESULT&gt;.doOnError(accept: (Throwable) -&gt; Unit): CordaFuture&lt;RESULT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;V, W, X&gt; CordaFuture&lt;out V&gt;.thenMatch(success: (V) -&gt; W, failure: (Throwable) -&gt; X)</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;V, W&gt; CordaFuture&lt;out V&gt;.flatMap(transform: (V) -&gt; CordaFuture&lt;out W&gt;): CordaFuture&lt;W&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$CordaFutureImpl$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$internal fun &lt;V&gt; Future&lt;V&gt;.get(timeout: Duration? = null): V</ID>
    <ID>MaxLineLength:CordaInfoCollector.kt$CordaInfoCollector : TrackedCollector</ID>
    <ID>MaxLineLength:CordaInternal.kt$CordaInternal</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration : CustomTaskChange</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration$_cordaDB = createDatabase(cacheFactory, identityService, schema, database.defaultSchemaName, jdbcConnection.transactionIsolationEnum)</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration$_servicesForResolution = MigrationServicesForResolution(identityService, attachmentsService, dbTransactions, cordaDB, cacheFactory)</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration${ val configDefaults = DatabaseConfig( schema = databaseSchemaName, transactionIsolationLevel = transactionIsolationLevel, initialiseSchema = false, initialiseAppSchema = SchemaInitializationType.NONE ) // This is necessary to prevent a bug when running as part of the Database Migration Tool, where hibernate treats party instances // as mutable and attempts to look up the party in the database when copying it, which eventually results in a flush within a // persist call. JavaTypeDescriptorRegistry.INSTANCE.addDescriptor(AbstractPartyDescriptor( identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous)) val attributeConverters = listOf( PublicKeyToTextConverter(), AbstractPartyToX500NameAsStringConverter( identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous) ) // Liquibase handles closing the database connection when migrations are finished. If the connection is closed here, then further // migrations may fail. return CordaPersistence(configDefaults, schema, cacheFactory, attributeConverters, closeConnection = false) }</ID>
    <ID>MaxLineLength:CordaModule.kt$AmountBeanDeserializerModifier$override</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaModule${ super.setupModule(context) // For classes which are annotated with CordaSerializable we want to use the same set of properties as the Corda serilasation scheme. // To do that we use CordaSerializableClassIntrospector to first turn on field visibility for these classes (the Jackson default is // private fields are not included) and then we use CordaSerializableBeanSerializerModifier to remove any extra properties that Jackson // might pick up. context.setClassIntrospector(CordaSerializableClassIntrospector(context)) context.addBeanSerializerModifier(CordaSerializableBeanSerializerModifier()) context.addBeanDeserializerModifier(AmountBeanDeserializerModifier()) context.setMixInAnnotations(PartyAndCertificate::class.java, PartyAndCertificateMixin::class.java) context.setMixInAnnotations(NetworkHostAndPort::class.java, NetworkHostAndPortMixin::class.java) context.setMixInAnnotations(CordaX500Name::class.java, CordaX500NameMixin::class.java) context.setMixInAnnotations(Amount::class.java, AmountMixin::class.java) context.setMixInAnnotations(AbstractParty::class.java, AbstractPartyMixin::class.java) context.setMixInAnnotations(AnonymousParty::class.java, AnonymousPartyMixin::class.java) context.setMixInAnnotations(Party::class.java, PartyMixin::class.java) context.setMixInAnnotations(PublicKey::class.java, PublicKeyMixin::class.java) context.setMixInAnnotations(ByteSequence::class.java, ByteSequenceMixin::class.java) context.setMixInAnnotations(SecureHash.SHA256::class.java, SecureHashSHA256Mixin::class.java) context.setMixInAnnotations(SecureHash::class.java, SecureHashSHA256Mixin::class.java) context.setMixInAnnotations(SerializedBytes::class.java, SerializedBytesMixin::class.java) context.setMixInAnnotations(DigitalSignature.WithKey::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(DigitalSignatureWithCert::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(TransactionSignature::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(SignedTransaction::class.java, SignedTransactionMixin::class.java) context.setMixInAnnotations(WireTransaction::class.java, WireTransactionMixin::class.java) context.setMixInAnnotations(TransactionState::class.java, TransactionStateMixin::class.java) context.setMixInAnnotations(Command::class.java, CommandMixin::class.java) context.setMixInAnnotations(TimeWindow::class.java, TimeWindowMixin::class.java) context.setMixInAnnotations(PrivacySalt::class.java, PrivacySaltMixin::class.java) context.setMixInAnnotations(SignatureScheme::class.java, SignatureSchemeMixin::class.java) context.setMixInAnnotations(SignatureMetadata::class.java, SignatureMetadataMixin::class.java) context.setMixInAnnotations(PartialTree::class.java, PartialTreeMixin::class.java) context.setMixInAnnotations(NodeInfo::class.java, NodeInfoMixin::class.java) context.setMixInAnnotations(StateMachineRunId::class.java, StateMachineRunIdMixin::class.java) }</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaSerializableBeanSerializerModifier$// We need to pass in a SerializerFactory when scanning for properties, but don't actually do any serialisation so any will do. private val serializerFactory = SerializerFactoryBuilder.build(AllWhitelist, javaClass.classLoader)</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaSerializableBeanSerializerModifier$val propertyNames = typeInformation.propertiesOrEmptyMap.mapNotNull { if (it.value.isCalculated) null else it.key }</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaSerializableClassIntrospector$context.configOverride(type.rawClass).visibility = Value.defaultVisibility().withFieldVisibility(Visibility.ANY)</ID>
    <ID>MaxLineLength:CordaModule.kt$NetworkHostAndPortDeserializer : SimpleDeserializer</ID>
    <ID>MaxLineLength:CordaModule.kt$SignatureSchemeDeserializer$signatureSchemesByNumberID[parser.intValue] ?: throw JsonParseException(parser, "Unable to find SignatureScheme ${parser.text}")</ID>
    <ID>MaxLineLength:CordaModule.kt$SignedTransactionDeserializer$val core = wrapper.run { wire ?: filtered ?: notaryChangeWire ?: contractUpgradeWire ?: contractUpgradeFiltered!! }</ID>
    <ID>MaxLineLength:CordaModule.kt$StxJson$val count = Booleans.countTrue(wire != null, filtered != null, notaryChangeWire != null, contractUpgradeWire != null, contractUpgradeFiltered != null)</ID>
    <ID>MaxLineLength:CordaModuleBuilder.kt$CordaModuleBuilder$override fun getCustomOptionsStep(context: WizardContext, parentDisposable: Disposable?)</ID>
    <ID>MaxLineLength:CordaModuleBuilder.kt$CordaModuleBuilder$private</ID>
    <ID>MaxLineLength:CordaModuleBuilder.kt$CordaModuleBuilder$setupFile(modelContentRootDir, "$packagePath/${it.targetPath}", "${if (it.appendProjectName) config.appName else ""}${it.fileName}", it.fileName)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$// Add the subscriber to the wrapping subscriber, which will invoke the original subscribers together inside a database transaction. wrappingSubscriber.delegates.add(toBeWrappedInDbTx) // If we are the first subscriber, return the shared subscriber, otherwise return a subscriber that does nothing. if (wrappingSubscriber.delegates.size == 1) wrappingSubscriber else NoOpSubscriber(toBeWrappedInDbTx) // Clean up the shared list of subscribers when they unsubscribe.</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$ fun &lt;T&gt; transaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$ fun &lt;T&gt; transaction(recoverableFailureTolerance: Int, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$@Suppress("UNCHECKED_CAST") val connectionBag: ConcurrentBag&lt;ConcurrentBag.IConcurrentBagEntry&gt; = connectionBagField.get(pool) as ConcurrentBag&lt;ConcurrentBag.IConcurrentBagEntry&gt;</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$HibernateConfiguration(schemas, databaseConfig, attributeConverters, _jdbcUrl, cacheFactory, customClassLoader)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$error("Was not expecting to find existing database transaction on current strand when setting database: ${Strand.currentStrand()}, $it")</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$is SchemaManagementException -&gt; throw HibernateSchemaChangeException("Incompatible schema change detected. Please run the node with database.initialiseSchema=true. Reason: ${e.message}", e)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$recoverAnyNestedSQLException: Boolean</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$val transaction = contextDatabase.currentOrNew(isolationLevel) // XXX: Does this code really support statement changing the contextDatabase?</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence${ // DataSource doesn't implement AutoCloseable so we just have to hope that the implementation does so that we can close it (_dataSource as? AutoCloseable)?.close() }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence${ // We need to set the database for the current [Thread] or [Fiber] here as some tests share threads across databases. _contextDatabase.set(this) currentDBSession().flush() return contextTransaction.connection }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence${ // We need to set the database for the current [Thread] or [Fiber] here as some tests share threads across databases. _contextDatabase.set(this) return currentOrNew(isolationLevel) }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CouldNotCreateDataSourceException : Exception</ID>
    <ID>MaxLineLength:CordaPersistence.kt$currentTx.boundary.filter { !it.success }.subscribe { this.onError(DatabaseTransactionRolledBackException(it.txId)) }</ID>
    <ID>MaxLineLength:CordaPersistence.kt$return _contextDatabase.get() ?: error("Was expecting to find CordaPersistence set on current thread: ${Strand.currentStrand()}")</ID>
    <ID>MaxLineLength:CordaPersistence.kt${ var wrappingSubscriber = DatabaseTransactionWrappingSubscriber&lt;T&gt;(db) // Use lift to add subscribers to a special subscriber that wraps a database transaction around observations. // Each subscriber will be passed to this lambda when they subscribe, at which point we add them to wrapping subscriber. return this.lift { toBeWrappedInDbTx: Subscriber&lt;in T&gt; -&gt; // Add the subscriber to the wrapping subscriber, which will invoke the original subscribers together inside a database transaction. wrappingSubscriber.delegates.add(toBeWrappedInDbTx) // If we are the first subscriber, return the shared subscriber, otherwise return a subscriber that does nothing. if (wrappingSubscriber.delegates.size == 1) wrappingSubscriber else NoOpSubscriber(toBeWrappedInDbTx) // Clean up the shared list of subscribers when they unsubscribe. }.doOnUnsubscribe { wrappingSubscriber.cleanUp() // If cleanup removed the last subscriber reset the system, as future subscribers might need the stream again if (wrappingSubscriber.delegates.isEmpty()) { wrappingSubscriber = DatabaseTransactionWrappingSubscriber(db) } } }</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start(username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, gracefulReconnect: Boolean = false): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start(username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, targetLegalIdentity: CordaX500Name?, gracefulReconnect: Boolean = false): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start(username: String, password: String, gracefulReconnect: Boolean = false): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$ @JvmOverloads fun start(username: String, password: String, targetLegalIdentity: CordaX500Name, gracefulReconnect: Boolean = false): CordaRPCConnection</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$( haAddressPool: List&lt;NetworkHostAndPort&gt;, configuration: CordaRPCClientConfiguration = CordaRPCClientConfiguration.DEFAULT, sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$( hostAndPort: NetworkHostAndPort, configuration: CordaRPCClientConfiguration, sslConfiguration: ClientRpcSslOptions?, classLoader: ClassLoader? = null )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$( hostAndPort: NetworkHostAndPort, sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$@JvmOverloads constructor(hostAndPort: NetworkHostAndPort, configuration: CordaRPCClientConfiguration = CordaRPCClientConfiguration.DEFAULT) : this( hostAndPort = hostAndPort, haAddressPool = emptyList(), configuration = configuration )</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$AMQPClientSerializationScheme.initialiseSerialization(serializationClassLoader, customSerializers, serializationWhitelists, cache)</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$CordaRPCConnection(getRpcClient().start(InternalCordaRPCOps::class.java, username, password, externalTrace, impersonatedActor, targetLegalIdentity))</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$if (classLoader != null) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classLoader) else AMQP_RPC_CLIENT_CONTEXT</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$val cache = Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$val customSerializers = createInstancesOfClassesImplementing(serializationClassLoader, SerializationCustomSerializer::class.java)</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient$val serializationWhitelists = ServiceLoader.load(SerializationWhitelist::class.java, serializationClassLoader).toSet()</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClient${ val cache = Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap() // If the client has explicitly provided a classloader use this one to scan for custom serializers, otherwise use the current one. val serializationClassLoader = this.classLoader ?: this.javaClass.classLoader val customSerializers = createInstancesOfClassesImplementing(serializationClassLoader, SerializationCustomSerializer::class.java) val serializationWhitelists = ServiceLoader.load(SerializationWhitelist::class.java, serializationClassLoader).toSet() AMQPClientSerializationScheme.initialiseSerialization(serializationClassLoader, customSerializers, serializationWhitelists, cache) }</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCClientConfiguration$/** * The interval of unused observable reaping. Leaked Observables (unused ones) are detected using weak references * and are cleaned up in batches in this interval. If set too large it will waste server side resources for this * duration. If set too low it wastes client side cycles. The default is to check once per second. */ open val reapInterval: Duration = 1.seconds</ID>
    <ID>MaxLineLength:CordaRPCClient.kt$CordaRPCConnection.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$(client.start(rpcUser.username, rpcUser.password, gracefulReconnect = true).proxy as ReconnectingCordaRPCOps)</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$driver</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$rpcOps.startTrackedFlow(::CashIssueFlow, 10.DOLLARS, OpaqueBytes.of(0), defaultNotaryIdentity).returnValue.get()</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$val addresses = listOf(NetworkHostAndPort("localhost", portAllocator.nextPort()), NetworkHostAndPort("localhost", portAllocator.nextPort()))</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$// WireTransaction stores its components as blobs which are deserialised in its constructor. This test makes sure // the extra class loader given to the CordaRPCClient is used in this deserialisation, as otherwise any WireTransaction // containing Cash.State objects are not receivable by the client. // // We run the client in a separate process, without the finance module on its system classpath to ensure that the // additional class loader that we give it is used. Cash.State objects are used as they can't be synthesised fully // by the carpenter, and thus avoiding any false-positive results. @Test fun `additional class loader used by WireTransaction when it deserialises its components`()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$checkRpcNotification(update.stateMachineInfo, rpcUser.username, historicalIds, externalTrace, impersonatedActor)</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$node.services.startFlow(CashIssueFlow(100.POUNDS, OpaqueBytes.of(1), identity), InvocationContext.shell()).flatMap { it.resultFuture }.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$node.services.startFlow(CashIssueFlow(2000.DOLLARS, OpaqueBytes.of(0), identity), InvocationContext.shell()).flatMap { it.resultFuture }.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$poll(scheduler, pollName = "node's started state", check = { if (node.node.started == null) true else null })</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$private</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$proxy.startFlowDynamic(CashIssueFlow::class.java, 1000.DOLLARS, OpaqueBytes.of(0), identity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest.CloseableExecutor$private</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ @Deprecated("For automated upgrades, consider using the `gracefulShutdown` command in an SSH session instead.") fun CordaRPCOps.pendingFlowsCount(): DataFeed&lt;Int, Pair&lt;Int, Int&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // DOCSTART VaultQueryByAPI @RPCReturnsObservables fun &lt;T : ContractState&gt; vaultQueryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // DOCSTART VaultTrackByAPI @RPCReturnsObservables fun &lt;T : ContractState&gt; vaultTrackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. @RPCReturnsObservables fun networkParametersFeed(): DataFeed&lt;ParametersUpdateInfo?, ParametersUpdateInfo&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. fun acceptNewNetworkParameters(parametersHash: SecureHash)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @CordaInternal @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") @RPCReturnsObservables fun internalVerifiedTransactionsFeed(): DataFeed&lt;List&lt;SignedTransaction&gt;, SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalVerifiedTransactionsSnapshot(): List&lt;SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @RPCReturnsObservables fun stateMachineRecordedTransactionMappingFeed(): DataFeed&lt;List&lt;StateMachineTransactionMapping&gt;, StateMachineTransactionMapping&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun clearNetworkMapCache()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun nodeDiagnosticInfo(): NodeDiagnosticInfo</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun nodeInfoFromParty(party: AbstractParty): NodeInfo?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun notaryIdentities(): List&lt;Party&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun refreshNetworkMapCache()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun setFlowsDrainingModeEnabled(enabled: Boolean)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun terminate(drainPendingFlows: Boolean = false)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByCriteria(criteria: QueryCriteria, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByWithPagingSpec(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByWithSorting(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByCriteria(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByWithPagingSpec(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByWithSorting(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ParametersUpdateInfo</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$StateMachineInfo$progressTrackerStepAndUpdates: DataFeed&lt;String, String&gt;? = this.progressTrackerStepAndUpdates</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$StateMachineInfo$return copy(id = id, flowLogicClassName = flowLogicClassName, initiator = initiator, progressTrackerStepAndUpdates = progressTrackerStepAndUpdates, invocationContext = invocationContext)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$inline</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$sorting: Sort = Sort(emptySet())</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$/** * Returns the RPC protocol version, which is the same the node's platform Version. Exists since version 1 so guaranteed * to be present. */ override val protocolVersion: Int get() = nodeInfo().platformVersion</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$?:</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$contractStateType: Class&lt;out T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$hash.serialize().sign { services.keyManagementService.sign(it.bytes, services.myInfo.legalIdentities[0].owningKey) }</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$is ConnectException -&gt; throw CordaRuntimeException("There is connection problem to network map. The possible causes are incorrect configuration or network map service being down")</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$is InvocationOrigin.Scheduled -&gt; FlowInitiator.Scheduled((origin as InvocationOrigin.Scheduled).scheduledState)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun registeredFlows(): List&lt;String&gt;</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$override fun setFlowsDrainingModeEnabled(enabled: Boolean)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$pendingFlowsCount() .updates .doOnNext { (completed, total) -&gt; logger.info("Pending flows progress before shutdown: $completed / $total.") }</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$progress = stateMachine.logic.track()?.updates?.filter { !it.startsWith(STRUCTURAL_STEP_PREFIX) } ?: Observable.empty()</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$return StateMachineInfo(flowLogic.runId, flowLogic.javaClass.name, flowLogic.stateMachine.context.toFlowInitiator(), flowLogic.track(), flowLogic.stateMachine.context)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$return vaultQueryBy(QueryCriteria.VaultQueryCriteria(), PageSpecification(), Sort(emptySet()), contractStateType)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$return vaultTrackBy(QueryCriteria.VaultQueryCriteria(), PageSpecification(), Sort(emptySet()), contractStateType)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$val wellKnownParty = services.identityService.wellKnownPartyFromX500Name((origin as InvocationOrigin.Peer).party)</ID>
    <ID>MaxLineLength:CordaRPCOpsImpl.kt$CordaRPCOpsImpl${ error -&gt; logger.error("Error while waiting for pending flows to drain in preparation for shutdown. Cause was: ${error.message}", error) }</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$CURRENT_RPC_CONTEXT.set(RpcAuthContext(InvocationContext.rpc(testActor()), buildSubject("TEST_USER", emptySet())))</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$assertThatCode { rpc.startFlow(::SoftLock, cash.ref, Duration.ofSeconds(1)).returnValue.getOrThrow() }.doesNotThrowAnyException()</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$require(aliceNode.services.keyManagementService.filterMyKeys(signaturePubKeys).toList().isNotEmpty())</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$val cash = rpc.startFlow(::CashIssueFlow, 10.DOLLARS, issuerRef, notary).returnValue.getOrThrow().stx.tx.outRefsOfType&lt;Cash.State&gt;().single()</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$withPermissions</ID>
    <ID>MaxLineLength:CordaRPCProxyClient.kt$CordaRPCProxyClient$override</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$( parametersHash, // TODO When multiple identities design will be better specified this should be signature from node operator. { hash -&gt; hash.serialize().sign { services.keyManagementService.sign(it.bytes, services.myInfo.legalIdentities[0].owningKey) } } )</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$?:</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$artemisMessage.writeBodyBufferBytes(networkMapUpdateMessage.serialize(context = SerializationDefaults.RPC_CLIENT_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$artemisMessage.writeBodyBufferBytes(startFlowMessage.serialize(context = SerializationDefaults.RPC_CLIENT_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$contractStateType: Class&lt;out T&gt;</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$is ConnectException -&gt; throw CordaRuntimeException("There is connection problem to network map. The possible causes are incorrect configuration or network map service being down")</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$is InvocationOrigin.Scheduled -&gt; FlowInitiator.Scheduled((origin as InvocationOrigin.Scheduled).scheduledState)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$override</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$override fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$private val artemisClient = ArtemisMessagingClient(services.configuration.p2pSslOptions, services.configuration.messagingServerAddress!!, services.networkParameters.maxMessageSize)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$private val flowReplyStateMachineRunIdMap = ConcurrentHashMap&lt;Trace.InvocationId, SettableFuture&lt;StateMachineRunId&gt;&gt;()</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$private val flowWorkerQueueAddress = "${FlowWorker.FLOW_WORKER_QUEUE_ADDRESS_PREFIX}${services.myInfo.legalIdentities[0].owningKey.toStringShort()}"</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$private val rpcWorkerQueueAddress = "$RPC_WORKER_QUEUE_ADDRESS_PREFIX${services.myInfo.legalIdentities[0].owningKey.toStringShort()}"</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$return StateMachineInfo(flowLogic.runId, flowLogic.javaClass.name, flowLogic.stateMachine.context.toFlowInitiator(), flowLogic.track(), flowLogic.stateMachine.context)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$return vaultQueryBy(QueryCriteria.VaultQueryCriteria(), PageSpecification(), Sort(emptySet()), contractStateType)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$return vaultTrackBy(QueryCriteria.VaultQueryCriteria(), PageSpecification(), Sort(emptySet()), contractStateType)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$val context = InvocationContext.rpc(Actor(Actor.Id("Mark"), AuthServiceId("Test"), CordaX500Name("ff", "ff", "GB")))</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$val startFlowMessage = StartFlow(services.myInfo.legalIdentities.first().name, logicType, args, context, rpcWorkerQueueAddress, replyId)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$val wellKnownParty = services.identityService.wellKnownPartyFromX500Name((origin as InvocationOrigin.Peer).party)</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps${ contractStateType.checkIsA&lt;ContractState&gt;() // TODO hack, fix the way we populate contractStateTypeMappings, or else query like `net.corda.finance.contracts.GetBalances.getCashBalances(net.corda.core.messaging.CordaRPCOps)` // are not going to work (services.vaultService as NodeVaultService).bootstrapContractStateTypes() return services.vaultService._queryBy(criteria, paging, sorting, contractStateType) }</ID>
    <ID>MaxLineLength:CordaRpcWorkerOps.kt$CordaRpcWorkerOps${ hash -&gt; hash.serialize().sign { services.keyManagementService.sign(it.bytes, services.myInfo.legalIdentities[0].owningKey) } }</ID>
    <ID>MaxLineLength:CordaSSHAuthInfo.kt$CordaSSHAuthInfo : AuthInfo</ID>
    <ID>MaxLineLength:CordaSdkVersionComboBox.kt$CordaSdkVersionComboBox.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:CordaService.kt$CordaService</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest$CordaServiceThatRequiresThreadContextClassLoader : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest$mockNet = MockNetwork(MockNetworkParameters(threadPerNode = true, cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, enclosedCordapp())))</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest.CordaServiceThatRequiresThreadContextClassLoader$assertNotNull(Thread.currentThread().contextClassLoader, "thread context classloader should not be null during service initialisation")</ID>
    <ID>MaxLineLength:CordaUtils.kt$ @DeleteForDJVM fun TransactionBuilder.toLedgerTransaction(services: ServicesForResolution, serializationContext: SerializationContext): LedgerTransaction</ID>
    <ID>MaxLineLength:CordaUtils.kt$ @DeleteForDJVM fun TransactionBuilder.toWireTransaction(services: ServicesForResolution, serializationContext: SerializationContext): WireTransaction</ID>
    <ID>MaxLineLength:CordaUtils.kt$ private fun owns(packageName: String, fullClassName: String): Boolean</ID>
    <ID>MaxLineLength:CordaUtils.kt$"$requiredMinPlatformVersion. The current zone is only enforcing a minimum platform version of "</ID>
    <ID>MaxLineLength:CordaUtils.kt$AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:CordaUtils.kt$Character.isJavaIdentifierStart(token[0]) &amp;&amp; token.toCharArray().drop(1).all { Character.isJavaIdentifierPart(it) }</ID>
    <ID>MaxLineLength:CordaUtils.kt$private</ID>
    <ID>MaxLineLength:CordaVersion.kt$CordaVersion$arrayOf("Version: $releaseVersion", "Revision: $revision", "Platform Version: $platformVersion", "Vendor: $vendor")</ID>
    <ID>MaxLineLength:CordaVersion.kt$CordaVersion.Companion$internal val semanticVersion: String by lazy { if(releaseVersion == UNKNOWN) CURRENT_MAJOR_RELEASE else releaseVersion }</ID>
    <ID>MaxLineLength:CordaVersionProvider.kt$CordaVersionProvider : IVersionProvider</ID>
    <ID>MaxLineLength:CordaViewModel.kt$CordaView : View</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$/** * @param organisation name of the organisation. * @param locality locality of the organisation, typically nearest major city. * @param country country the organisation is in, as an ISO 3166-1 2-letter country code. */ constructor(organisation: String, locality: String, country: String) : this(null, null, organisation, locality, null, country)</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$require(locality.length &lt; MAX_LENGTH_LOCALITY) { "Locality attribute (L) must contain less then $MAX_LENGTH_LOCALITY characters." }</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$state?.let { require(it.length &lt; MAX_LENGTH_STATE) { "State attribute (ST) must contain less then $MAX_LENGTH_STATE characters." } }</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$this(commonName = commonName, organisationUnit = null, organisation = organisation, locality = locality, state = null, country = country)</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp$Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$ContractAndWorkflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$Workflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Contract$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Contract$override fun toString()</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Default$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Workflow$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Workflow$override fun toString()</ID>
    <ID>MaxLineLength:CordappConfigFileProviderTests.kt$CordappConfigFileProviderTests$private</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(aliceQuery.statesMetadata[0].constraintInfo!!.type()).isEqualTo(Vault.ConstraintInfo.Type.SIGNATURE)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(allStates[0].state.constraint).isInstanceOfAny(HashAttachmentConstraint::class.java, SignatureAttachmentConstraint::class.java)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(bobQuery.statesMetadata[0].constraintInfo!!.type()).isEqualTo(Vault.ConstraintInfo.Type.SIGNATURE)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val aliceQuery = alice.rpc.vaultQueryBy&lt;Cash.State&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val aliceQuery = restartedAlice.rpc.vaultQueryBy&lt;Cash.State&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx = alice.rpc.startFlow(::CashIssueFlow, 1000.DOLLARS, OpaqueBytes.of(1), defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx = alice.rpc.startFlow(::CashIssueFlow, expected, ref, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx2 = restartedNode.rpc.startFlow(::CashIssueFlow, expected, ref, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val parameters = NetworkParametersReader(DEV_ROOT_CA.certificate, null, notary.baseDirectory).read().networkParameters</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val transferTx = alice.rpc.startFlow(::CashPaymentFlow, 1000.DOLLARS, bobParty, true, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val transferTxn = restartedAlice.rpc.startFlow(::CashPaymentFlow, 1000.DOLLARS, bobParty, true, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val vaultUpdatesBob = bob.rpc.vaultTrackByCriteria(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).updates</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val vaultUpdatesBob = restartedBob.rpc.vaultTrackByCriteria(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).updates</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.Companion$@CordaInternal fun create(cordapp: Cordapp, attachmentId: SecureHash?, classLoader: ClassLoader, config: CordappConfig): CordappContext</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun get(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getBoolean(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getDouble(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getFloat(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getInt(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getLong(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getNumber(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getString(path: String)</ID>
    <ID>MaxLineLength:CordappImpl.kt$CordappImpl$val classList = rpcFlows + initiatedFlows + services + serializationWhitelists.flatMap { it.whitelist } + notaryService</ID>
    <ID>MaxLineLength:CordappProvider.kt$CordappProvider$ fun getAppContext(): CordappContext</ID>
    <ID>MaxLineLength:CordappProviderImpl.kt$CordappProviderImpl$private val attachmentStorage: AttachmentStorage</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$ @Synchronized @VisibleForTesting fun &lt;T&gt; withCordapp(minimumPlatformVersion: Int = 1, targetPlatformVersion: Int = PLATFORM_VERSION, block: () -&gt; T): T</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$CordappImpl.TEST_INSTANCE.copy(minimumPlatformVersion = minimumPlatformVersion, targetPlatformVersion = targetPlatformVersion)</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$Exception().stackTrace .mapNotNull { cordappClasses[it.className] } // in case there are multiple classes matched, we select the first one having a single CorDapp registered against it. .firstOrNull { it.size == 1 }</ID>
    <ID>MaxLineLength:CordappResolver.kt$CordappResolver$logger.error("ATTENTION: More than one CorDapp installed on the node for contract $className. Please remove the previous version when upgrading to a new version.")</ID>
    <ID>MaxLineLength:CordappResolverTest.kt$CordappResolverTest$@Test fun `when the same cordapp is registered for the same class multiple times, the resolver deduplicates and returns it as the current one`()</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$(additionalNodeInfoDir / "nodeInfo-41408E093F95EAD51F6892C34DEB65AE1A3569A4B0E5744769A1B485AF8E04B5").write(signedNodeInfo.serialize().bytes)</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$private</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$val future = connectionToAlice.proxy.startFlow(CordappSmokeTest::GatherContextsFlow, aliceIdentity).returnValue</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$val nodeInfo = createNodeInfoWithSingleIdentity(CordaX500Name(organisation = "Bob Corp", locality = "Madrid", country = "ES"), dummyKeyPair, dummyKeyPair.public)</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest${ val baseDir = factory.baseDirectory(aliceConfig) val cordappsDir = (baseDir / CORDAPPS_DIR_NAME).createDirectories() // Find the jar file for the smoke tests of this module val selfCordapp = Paths.get("build", "libs").list { it.filter { "-smokeTests" in it.toString() }.toList().single() } selfCordapp.copyToDirectory(cordappsDir) // The `nodeReadyFuture` in the persistent network map cache will not complete unless there is at least one other // node in the network. We work around this limitation by putting another node info file in the additional-node-info // folder. // TODO clean this up after we refactor the persistent network map cache / network map updater val additionalNodeInfoDir = (baseDir / "additional-node-infos").createDirectories() createDummyNodeInfo(additionalNodeInfoDir) factory.create(aliceConfig).use { alice -&gt; alice.connect(superUser).use { connectionToAlice -&gt; val aliceIdentity = connectionToAlice.proxy.nodeInfo().legalIdentitiesAndCerts.first().party val future = connectionToAlice.proxy.startFlow(CordappSmokeTest::GatherContextsFlow, aliceIdentity).returnValue val (sessionInitContext, sessionConfirmContext) = future.getOrThrow() val selfCordappName = selfCordapp.fileName.toString().removeSuffix(".jar") assertThat(sessionInitContext.appName).isEqualTo(selfCordappName) assertThat(sessionConfirmContext.appName).isEqualTo(selfCordappName) } } }</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler : Acceptor</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$"The instigator is one of the participants" using (initiatingSession.counterparty in oldStateAndRef.state.data.participants)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$"The proposed upgrade ${proposal.modification.javaClass} is a trusted upgrade path" using (proposal.modification.name == authorisedUpgrade)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$@Suspendable override</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$val authorisedUpgrade = checkNotNull(serviceHub.contractUpgradeService.getAuthorisedContractUpgrade(oldStateAndRef.ref)) { "Contract state upgrade is unauthorised. State hash : ${oldStateAndRef.ref}" }</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$val expectedTx = ContractUpgradeUtils.assembleUpgradeTx(oldStateAndRef, proposal.modification, proposedTx.privacySalt, serviceHub)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler${ // Retrieve signed transaction from our side, we will apply the upgrade logic to the transaction on our side, and // verify outputs matches the proposed upgrade. val ourSTX = requireNotNull(serviceHub.validatedTransactions.getTransaction(proposal.stateRef.txhash)) { "We don't have a copy of the referenced state" } val oldStateAndRef = ourSTX.resolveBaseTransaction(serviceHub).outRef&lt;ContractState&gt;(proposal.stateRef.index) val authorisedUpgrade = checkNotNull(serviceHub.contractUpgradeService.getAuthorisedContractUpgrade(oldStateAndRef.ref)) { "Contract state upgrade is unauthorised. State hash : ${oldStateAndRef.ref}" } val proposedTx = stx.coreTransaction as ContractUpgradeWireTransaction val expectedTx = ContractUpgradeUtils.assembleUpgradeTx(oldStateAndRef, proposal.modification, proposedTx.privacySalt, serviceHub) requireThat { "The instigator is one of the participants" using (initiatingSession.counterparty in oldStateAndRef.state.data.participants) "The proposed upgrade ${proposal.modification.javaClass} is a trusted upgrade path" using (proposal.modification.name == authorisedUpgrade) "The proposed tx matches the expected tx for this upgrade" using (proposedTx == expectedTx) } proposedTx.resolve(serviceHub, stx.sigs) }</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$FinalityHandler$logger.warnOnce("Insecure API to record finalised transaction was used by ${sender.counterparty} (${sender.getCounterpartyFlowInfo()})")</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$NotaryChangeHandler : Acceptor</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$NotaryChangeHandler${ val state = proposal.stateRef val proposedTx = stx.resolveNotaryChangeTransaction(serviceHub) // TODO: Right now all nodes will automatically approve the notary change. We need to figure out if stricter controls are necessary. if (state !in proposedTx.inputs.map { it.ref }) { throw StateReplacementException("The proposed state $state is not in the proposed transaction inputs") } val newNotary = proposal.modification val isNotary = serviceHub.networkMapCache.isNotary(newNotary) if (!isNotary) { throw StateReplacementException("The proposed node $newNotary does not run a Notary service") } }</ID>
    <ID>MaxLineLength:CouldNotStartFlowException.kt$CouldNotStartFlowException : RPCException</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappOptions$description = ["The name of the config file. By default 'node.conf' for a simple node and 'network-management.conf' for a doorman."]</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli : CliWrapperBase</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$//use System.out directly instead of logger as we MUST output to screen due to user input requirement System.out.println("##### ${it.fileName} #####") it.copyTo(System.out) System.out.println("Is this output as expected? [y/N]") validateUserResponse()</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$@Parameters(arity = "0..1", description = ["You can specify the fully qualified name of the `MappedSchema` class. If not specified it will generate the migration for all schemas that don't have migrations."])</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$liquiBaseOutput = MigrationExporter(db.baseDirectory, db.config.dataSourceProperties, db.classLoader, it).generateMigrationForCorDapp(schemaClass)</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$migrationLogger.info("Creating database migration files for schema: $schemaClass into ${(db.baseDirectory / "migration").toString().trim()}")</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$migrationLogger.info("Schema: ${it.javaClass.name} already contains the database migration script, the file creation skipped.")</ID>
    <ID>MaxLineLength:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$outputSchemaMigrations.addAll(withoutMigration.mapNotNull { generateMigrationFileForSchema(it.javaClass.name) }.toList())</ID>
    <ID>MaxLineLength:CrlFetcher.kt$CrlFetcher$private val proxySettings: ProxySettings = proxyConfig?.let { ProxyUtils.fromConfig(it) } ?: ProxySettings(Proxy.NO_PROXY, null)</ID>
    <ID>MaxLineLength:CrlFetcher.kt$CrlFetcher$val crlUrls = generalNames.filter { it.tagNo == GeneralName.uniformResourceIdentifier}.map { DERIA5String.getInstance(it.name).string }.toSet().map { URL(it) }</ID>
    <ID>MaxLineLength:CrlFetcher.kt$CrlFetcher$val dpNames = distPoint.distributionPoints.mapNotNull { it.distributionPoint }.filter { it.type == DistributionPointName.FULL_NAME }</ID>
    <ID>MaxLineLength:CrlFetcher.kt$CrlFetcher.Companion$// Theoretically, there might be multiple CrlFetchers operating at the same time. Since we are setting static variable via `Authenticator.setDefault()` // it is a good idea to protect the remote call with synchronized block on class level. @Synchronized private fun retrieveCrl(url: URL, proxySettings: ProxySettings): X509CRL?</ID>
    <ID>MaxLineLength:CrlFetcher.kt$CrlFetcher.Companion$conn.connectTimeout = Integer.getInteger("net.corda.bridge.services.crl.fetcher.connectTimeoutMs", 60 * 1000)</ID>
    <ID>MaxLineLength:CrlFetcherTest.kt$CrlFetcherTest$server = CrlServer(NetworkHostAndPort("localhost", 0), crlServerHitCount, ROOT_CA, { INTERMEDIATE_CA }, revokedNodeCerts, revokedIntermediateCerts)</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServer : Closeable</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServer$private val revokedNodeCerts: MutableSet&lt;BigInteger&gt;</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServer$register(CrlServlet(crlServer, crlServerHitCount, ROOT_CA, intermediateCaFunc, revokedNodeCerts, revokedIntermediateCerts))</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet$private val revokedNodeCerts: MutableSet&lt;BigInteger&gt;</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$Pair(Date(System.currentTimeMillis() - 5.minutes.toMillis()), Date(System.currentTimeMillis() + 10.days.toMillis()))</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$builder.addCRLEntry(it, Date(System.currentTimeMillis() - 10.minutes.toMillis()), ReasonFlags.certificateHold)</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$fun Pair&lt;CertificateStoreSupplier, MutualSslConfiguration&gt;.recreateNodeCaAndTlsCertificates(nodeCaCrlDistPoint: String, tlsCrlDistPoint: String?, ROOT_CA: CertificateAndKeyPair, INTERMEDIATE_CA: CertificateAndKeyPair): X509Certificate</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$fun replaceCrlDistPointCaCertificate(currentCaCert: X509Certificate, certType: CertificateType, issuerKeyPair: KeyPair, crlDistPoint: String?, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, nodeKeys.private, nodeCertChain, nodeKeyStore.entryPassword)</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val (nodeCert, nodeKeys) = nodeKeyStore.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, nodeKeyStore.entryPassword) }</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val (tlsCert, tlsKeys) = sslKeyStore.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_TLS, sslKeyStore.entryPassword) }</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val builder = JcaX509v2CRLBuilder(caCertificate.subjectX500Principal, Date(System.currentTimeMillis() - 1.minutes.toMillis()))</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, it)))</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val issuingDistPoint = IssuingDistributionPoint(DistributionPointName(GeneralNames(issuingDistPointName)), indirect, false)</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val newNodeCert = replaceCrlDistPointCaCertificate(nodeCert, CertificateType.NODE_CA, INTERMEDIATE_CA.keyPair, nodeCaCrlDistPoint)</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val newTlsCert = replaceCrlDistPointCaCertificate(tlsCert, CertificateType.TLS, nodeKeys, tlsCrlDistPoint, X500Name.getInstance(ROOT_CA.certificate.subjectX500Principal.encoded))</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val nodeCertChain = listOf(newNodeCert, INTERMEDIATE_CA.certificate, *nodeKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }.drop(2).toTypedArray())</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val signer = JcaContentSignerBuilder(signatureAlgorithm).setProvider(Crypto.findProvider("BC")).build(caPrivateKey)</ID>
    <ID>MaxLineLength:CrlServer.kt$CrlServlet.Companion$val sslCertChain = listOf(newTlsCert, newNodeCert, INTERMEDIATE_CA.certificate, *sslKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) }.drop(3).toTypedArray())</ID>
    <ID>MaxLineLength:CrossCashTest.kt$"Divergence detected, the remote state doesn't match any of our possible predictions."</ID>
    <ID>MaxLineLength:CrossCashTest.kt$fun searchForStateHelper(state: Map&lt;A, Long&gt;, diffIx: Int, consumedTxs: HashMap&lt;A, Int&gt;, matched: ArrayList&lt;Map&lt;A, Int&gt;&gt;)</ID>
    <ID>MaxLineLength:CrossCashTest.kt$is IssueAndPaymentRequest -&gt; command.node.proxy.startFlow(::CashIssueAndPaymentFlow, request).returnValue</ID>
    <ID>MaxLineLength:CrossCashTest.kt$it.value.toDouble() / 1000 to generateMove(it.value, USD, node.mainIdentity, possibleRecipients)</ID>
    <ID>MaxLineLength:CrossCashTest.kt$listOf(1.0 to generateIssue(10000, USD, notaryIdentity, possibleRecipients)) + moves + exits</ID>
    <ID>MaxLineLength:CrossCashTest.kt$val minimumMatches = matches.fold&lt;Map&lt;AbstractParty, Int&gt;, HashMap&lt;AbstractParty, Int&gt;?&gt;(null) { minimum, next -&gt; if (minimum == null) { HashMap(next) } else { next.forEach { minimum.merge(it.key, it.value, Math::min) } minimum } }!!</ID>
    <ID>MaxLineLength:CrossCashTest.kt${ log.warn( "Divergence detected, the remote state doesn't match any of our possible predictions." + "\nPredicted state/queues:\n$previousState" + "\nActual gathered state:\n${CrossCashState(currentNodeVaults, mapOf())}" ) // TODO We should terminate here with an exception, we cannot carry on as we have an inconsistent model. We carry on currently because we always diverge due to notarisation failures return@LoadTest CrossCashState(currentNodeVaults, mapOf()) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmOverloads @JvmStatic fun generateKeyPair(signatureScheme: SignatureScheme = DEFAULT_SIGNATURE_SCHEME): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doSign(privateKey: PrivateKey, clearData: ByteArray): ByteArray</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic fun generateKeyPair(schemeCodeName: String): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(schemeCodeName: String, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(txId: SecureHash, transactionSignature: TransactionSignature): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeySpecException::class) fun decodePrivateKey(schemeCodeName: String, encodedKey: ByteArray): PrivateKey</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeySpecException::class) fun decodePublicKey(schemeCodeName: String, encodedKey: ByteArray): PublicKey</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(SignatureException::class) fun isValid(txId: SecureHash, transactionSignature: TransactionSignature): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPair(privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPair(signatureScheme: SignatureScheme, privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPairFromEntropy(entropy: BigInteger): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun deriveKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun findSignatureScheme(schemeCodeName: String): SignatureScheme</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun publicKeyOnCurve(signatureScheme: SignatureScheme, publicKey: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$// Check if a public key satisfies algorithm specs (for ECC: key should lie on the curve and not being point-at-infinity). private fun validatePublicKey(signatureScheme: SignatureScheme, key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$// Note that deterministic signature schemes, such as EdDSA, original SPHINCS-256 and RSA PKCS#1, do not require // extra randomness, but we have to ensure that non-deterministic algorithms (i.e., ECDSA) use non-blocking // SecureRandom implementation. Also, SPHINCS-256 implementation in BouncyCastle 1.60 fails with // ClassCastException if we invoke initSign with a SecureRandom as an input. // TODO Although we handle the above issue here, consider updating to BC 1.61+ which provides a fix. if (signatureScheme == EDDSA_ED25519_SHA512 || signatureScheme == SPHINCS256_SHA256 || signatureScheme == RSA_SHA256) { signature.initSign(privateKey) } else { // The rest of the algorithms will require a SecureRandom input (i.e., ECDSA or any new algorithm for which // we don't know if it's deterministic). signature.initSign(privateKey, newSecureRandom()) } signature.update(clearData) signature.sign()</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$AlgorithmIdentifier(BCObjectIdentifiers.sphincs256_with_SHA512, DLSequence(arrayOf(ASN1Integer(0), SHA512_256)))</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ECDSA_SECP256R1_SHA256, ECDSA_SECP256K1_SHA256 -&gt; deriveKeyPairECDSA(signatureScheme.algSpec as ECParameterSpec, privateKey, seed)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$else -&gt; throw InvalidKeyException("Key type ${privateKey.algorithm} is not supported for deterministic key derivation")</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$else -&gt; throw UnsupportedOperationException("Although supported for signing, deterministic key derivation is " + "not currently implemented for ${signatureScheme.schemeCodeName}")</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCECPublicKey -&gt; publicKey.parameters == signatureScheme.algSpec &amp;&amp; !publicKey.q.isInfinity &amp;&amp; publicKey.q.isValid</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPrivateKey, is BCSphincs256PrivateKey -&gt; true</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPublicKey -&gt; key.modulus.bitLength() &gt;= 2048</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is EdDSAPublicKey -&gt; publicKey.params == signatureScheme.algSpec &amp;&amp; !isEdDSAPointAtInfinity(publicKey) &amp;&amp; publicKey.a.isOnCurve</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$listOf(AlgorithmIdentifier(BCObjectIdentifiers.sphincs256, DLSequence(arrayOf(ASN1Integer(0), SHA512_256))))</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$private</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$require(txId.sha256() in usedHashes) { "Transaction with id:$txId is not a leaf in the provided partial Merkle tree" }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$return publicKey.a.toP3() == (EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec).curve.getZero(GroupElement.Representation.P3)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$throw InvalidKeySpecException("This private key cannot be decoded, please ensure it is PKCS8 encoded and that " + "it corresponds to the input scheme's code name.", ikse)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$throw throw InvalidKeySpecException("This public key cannot be decoded, please ensure it is X509 encoded and " + "that it corresponds to the input scheme's code name.", ikse)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val bytes = entropy.toByteArray().copyOf(params.curve.field.getb() / 8) // Need to pad the entropy to the valid seed length.</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val keyPairGenerator = KeyPairGenerator.getInstance(signatureScheme.algorithmName, providerMap[signatureScheme.providerName])</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val signableData = SignableData(originalSignedHash(txId, transactionSignature.partialMerkleTree), transactionSignature.signatureMetadata)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ // Compute HMAC(privateKey, seed). val macBytes = deriveHMAC(privateKey, seed) // Get the first EC curve fieldSized-bytes from macBytes. // According to recommendations from the deterministic ECDSA rfc, see https://tools.ietf.org/html/rfc6979 // performing a simple modular reduction would induce biases that would be detrimental to security. // Thus, the result is not reduced modulo q and similarly to BIP32, EC curve fieldSized-bytes are utilised. val fieldSizeMacBytes = macBytes.copyOf(parameterSpec.curve.fieldSize / 8) // Calculate value d for private key. val deterministicD = BigInteger(1, fieldSizeMacBytes) // Key generation checks follow the BC logic found in // https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java // There is also an extra check to align with the BIP32 protocol, according to which // if deterministicD &gt;= order_of_the_curve the resulted key is invalid and we should proceed with another seed. // TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key. // Although our hashing approach seems reasonable, we should check if there are alternatives, // especially if we use counters as well. if (deterministicD &lt; ECConstants.TWO || WNafUtil.getNafWeight(deterministicD) &lt; parameterSpec.n.bitLength().ushr(2) || deterministicD &gt;= parameterSpec.n) { // Instead of throwing an exception, we retry with SHA256(seed). return deriveKeyPairECDSA(parameterSpec, privateKey, seed.sha256().bytes) } val privateKeySpec = ECPrivateKeySpec(deterministicD, parameterSpec) val privateKeyD = BCECPrivateKey(privateKey.algorithm, privateKeySpec, BouncyCastleProvider.CONFIGURATION) // Compute the public key by scalar multiplication. // Note that BIP32 uses masterKey + mac_derived_key as the final private key and it consequently // requires an extra point addition: master_public + mac_derived_public for the public part. // In our model, the mac_derived_output, deterministicD, is not currently added to the masterKey and it // it forms, by itself, the new private key, which in turn is used to compute the new public key. val pointQ = FixedPointCombMultiplier().multiply(parameterSpec.g, deterministicD) // This is unlikely to happen, but we should check for point at infinity. if (pointQ.isInfinity) { // Instead of throwing an exception, we retry with SHA256(seed). return deriveKeyPairECDSA(parameterSpec, privateKey, seed.sha256().bytes) } val publicKeySpec = ECPublicKeySpec(pointQ, parameterSpec) val publicKeyD = BCECPublicKey(privateKey.algorithm, publicKeySpec, BouncyCastleProvider.CONFIGURATION) return KeyPair(publicKeyD, privateKeyD) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ // The rest of the algorithms will require a SecureRandom input (i.e., ECDSA or any new algorithm for which // we don't know if it's deterministic). signature.initSign(privateKey, newSecureRandom()) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto${ val sigKey: SignatureScheme = Crypto.findSignatureScheme(keyPair.private) val sigMetaData: SignatureScheme = Crypto.findSignatureScheme(signableData.signatureMetadata.schemeNumberID) // Special handling if the advertised SignatureScheme is CompositeKey. // TODO fix notaries that advertise [CompositeKey] in their signature Metadata. Currently, clustered notary nodes // mention Crypto.COMPOSITE_KEY in their SignatureMetadata, but they are actually signing with a leaf-key // (and if they refer to it as a Composite key, then we lose info about the actual type of their signing key). // In short, their metadata should be the leaf key-type, until we support CompositeKey signatures. require(sigKey == sigMetaData || sigMetaData == Crypto.COMPOSITE_KEY) { "Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}." } val signatureBytes = doSign(sigKey.schemeCodeName, keyPair.private, signableData.serialize().bytes) return TransactionSignature(signatureBytes, keyPair.public, signableData.signatureMetadata) }</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoService$ fun createWrappingKey(alias: String, failIfExists: Boolean = true)</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoService$ fun generateWrappedKeyPair(masterKeyAlias: String, childKeyScheme: SignatureScheme = defaultWrappingSignatureScheme()): Pair&lt;PublicKey, WrappedPrivateKey&gt;</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoService$ fun getWrappingMode(): WrappingMode?</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoServiceException$open</ID>
    <ID>MaxLineLength:CryptoService.kt$SignOnlyCryptoService$ fun defaultIdentitySignatureScheme(): SignatureScheme</ID>
    <ID>MaxLineLength:CryptoService.kt$SignOnlyCryptoService$ fun defaultTLSSignatureScheme(): SignatureScheme</ID>
    <ID>MaxLineLength:CryptoService.kt$WrappingMode$DEGRADED_WRAPPED</ID>
    <ID>MaxLineLength:CryptoService.kt$WrappingMode$WRAPPED</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$SupportedCryptoServices.FUTUREX -&gt; FutureXCryptoService.fromConfigurationFile(legalName.x500Principal, cryptoServiceConf)</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$SupportedCryptoServices.GEMALTO_LUNA -&gt; GemaltoLunaCryptoService.fromConfigurationFile(legalName.x500Principal, cryptoServiceConf)</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$SupportedCryptoServices.PRIMUS_X -&gt; PrimusXCryptoService.fromConfigurationFile(legalName.x500Principal, cryptoServiceConf)</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$fun makeCryptoService(csConf: CryptoServiceConfig?, legalName: CordaX500Name, keyStoreSupplier: FileBasedCertificateStoreSupplier? = null): CryptoService</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$return ManagedCryptoService(makeCryptoService(cryptoServiceName, legalName, signingCertificateStore, cryptoServiceConf, wrappingKeyStorePath), timeout)</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$throw IllegalArgumentException("A valid signing certificate store is required to create a BouncyCastle crypto service.")</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$val configPath = requireNotNull(cryptoServiceConf) { "When cryptoServiceName is set to AZURE_KEY_VAULT, cryptoServiceConf must specify the path to the configuration file."}</ID>
    <ID>MaxLineLength:CryptoServiceSigningService.kt$CryptoServiceSigningService$// Make TLS handshake timeout when error instead of throwing exception, this will allow TLS to retry connection. // Throwing exception here will cause netty to terminate the connection and the client will receive a fatal alert which will block the connection. sleep(sslHandshakeTimeout + SSL_HANDSHAKE_TIMEOUT_EXTRA_MILLIS)</ID>
    <ID>MaxLineLength:CryptoServiceSigningService.kt$CryptoServiceSigningService$private val makeCryptoService: () -&gt; CryptoService = { CryptoServiceFactory.makeCryptoService(csConfig, legalName, sslConfig.keyStore) }</ID>
    <ID>MaxLineLength:CryptoServiceSigningService.kt$CryptoServiceSigningService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:CryptoServiceSigningService.kt$CryptoServiceSigningService$val signedTestPhrase = requireNotNull(sign(alias, testPhraseClearText, defaultTLSSignatureScheme().signatureName)) { "Failed to sign " + msgSuffixFn() }</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$ @Ignore @Test fun testLifecycleWithGemalto()</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$ private fun testLifecycleWithLiveHSM(csName: SupportedCryptoServices, csConfigText: String)</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$CryptoServiceMock</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$assertNotNull(instance.sign(existingAlias, bouncyCryptoService.defaultTLSSignatureScheme().signatureName, "testPhrase".toByteArray()))</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$val cryptoService = CryptoServiceFactory.makeCryptoService(csConfig, dummyLegalName, sslConfiguration.keyStore)</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest$val mock = CryptoServiceMock { CryptoServiceFactory.makeCryptoService(null, dummyLegalName, sslConfiguration.keyStore) }</ID>
    <ID>MaxLineLength:CryptoServiceSigningServiceUnitTest.kt$CryptoServiceSigningServiceUnitTest.Companion$val certificateAndKeyPair = X509KeyStore.fromFile(keyStoreFile, keyStorePassword).internal.getCertificateAndKeyPair(alias, entryPassword)</ID>
    <ID>MaxLineLength:CryptoServiceSpec.kt$CryptoServiceSpec$@Test fun `cryptoService can generate wrapped key pair and sign with the private key successfully, using default algorithm`()</ID>
    <ID>MaxLineLength:CryptoServiceSpec.kt$CryptoServiceSpec$@Test fun `cryptoService fails when asked to generate wrapped key pair or sign, but the master key specified does not exist`()</ID>
    <ID>MaxLineLength:CryptoSignUtils.kt$CryptoSignUtils</ID>
    <ID>MaxLineLength:CryptoSignUtils.kt$CryptoSignUtils$"Metadata schemeCodeName: ${sigMetaData.schemeCodeName} is not aligned with the key type: ${sigKey.schemeCodeName}."</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ // TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`. @Throws(SignatureException::class, InvalidKeyException::class) fun PublicKey.verify(content: ByteArray, signature: DigitalSignature)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun newSecureRandom(): SecureRandom</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun secureRandomBytes(numOfBytes: Int): ByteArray</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM fun random63BitValue(): Long</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun KeyPair.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun PublicKey.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(SignatureException::class, InvalidKeyException::class) fun PublicKey.isValid(content: ByteArray, signature: DigitalSignature): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun &lt;T : Any&gt; serializedHash(x: T): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun PublicKey.isFulfilledBy(otherKeys: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun componentHash(nonce: SecureHash, opaqueBytes: OpaqueBytes): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun componentHash(opaqueBytes: OpaqueBytes, privacySalt: PrivacySalt, componentGroupIndex: Int, internalIndex: Int): SecureHash</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun computeNonce(privacySalt: PrivacySalt, groupIndex: Int, internalIndex: Int)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$throw IllegalStateException("Verification of CompositeKey signatures currently not supported.")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$assertEquals("DL9yJfiNGqteRrKPjGUkRQkeqzuQ4kwcYQWMCi5YKuUHrk", keyPairBiggerThan256bitsV2.public.toStringShort())</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$assertEquals("DLANmjhGSVdLyghxcPHrn3KuGatscf6LtvqifUDxw7SGU8", keyPairBiggerThan256bitsV2.public.toStringShort())</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bitsV2.public.toStringShort())</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val expectedAlgSet = setOf("RSA_SHA256", "ECDSA_SECP256K1_SHA256", "ECDSA_SECP256R1_SHA256", "EDDSA_ED25519_SHA512", "SPHINCS-256_SHA512", "COMPOSITE")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val intermediateCert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, DEV_ROOT_CA.certificate, DEV_ROOT_CA.keyPair, DEV_INTERMEDIATE_CA.certificate.subjectX500Principal, DEV_INTERMEDIATE_CA.keyPair.public, crlDistPoint = "http://r3-test.com/certificate-revocation-list/root")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val nodeCA = X509Utilities.createCertificate(CertificateType.NODE_CA, intermediateCert, DEV_INTERMEDIATE_CA.keyPair, CordaX500Name("Test", "London", "GB").x500Principal, generateKeyPair().public)</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val pubKeySpec = EdDSAPublicKeySpec((EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec).curve.getZero(GroupElement.Representation.P3), EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec)</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("10")) assertEquals("DL6pYKUgH17az8MLdonvvUtUPN8TqwpCGcdgLr7vg3skCU", keyPairPositive.public.toStringShort()) // The underlying implementation uses the hash of entropy if it is out of range 2 &lt;= entropy &lt; N, where N the order of the group. val keyPairNegative = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("-10")) assertEquals("DLnpXhxece69Nyqgm3pPt3yV7ESQYDJKoYxs1hKgfBAEu", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("0")) assertEquals("DLBC28e18T6KsYwjTFfUWJfhvHjvYVapyVf6antnqUkbgd", keyPairZero.public.toStringShort()) // BigIntenger.Zero is out or range, so 1 and hash(1.toByteArray) would have the same impact. val zeroHashed = BigInteger(1, BigInteger("0").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, zeroHashed.compareTo((ECDSA_SECP256K1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairZeroHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, zeroHashed) assertEquals("DLBC28e18T6KsYwjTFfUWJfhvHjvYVapyVf6antnqUkbgd", keyPairZeroHashed.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("1")) assertEquals("DLBimRXdEQhJUTpL6f9ri9woNdsze6mwkRrhsML13Eh7ET", keyPairOne.public.toStringShort()) // BigIntenger.ONE is out or range, so 1 and hash(1.toByteArray) would have the same impact. val oneHashed = BigInteger(1, BigInteger("1").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, oneHashed.compareTo((ECDSA_SECP256K1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairOneHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, oneHashed) assertEquals("DLBimRXdEQhJUTpL6f9ri9woNdsze6mwkRrhsML13Eh7ET", keyPairOneHashed.public.toStringShort()) // 2 is in the range. val keyPairTwo = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2")) assertEquals("DLG32UWaevGw9YY7w1Rf9mmK88biavgpDnJA9bG4GapVPs", keyPairTwo.public.toStringShort()) // Try big numbers that are out of range. val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLGHsdv2xeAuM7n3sBc6mFfiphXe6VSf3YxqvviKDU6Vbd", keyPairBiggerThan256bits.public.toStringShort()) val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DL9yJfiNGqteRrKPjGUkRQkeqzuQ4kwcYQWMCi5YKuUHrk", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DL3Wr5EQGrMTaKBy5XMvG8rvSfKX1AYZLCRU8kixGbxt1E", keyPairBiggerThan512bits.public.toStringShort()) val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DL7NbssqvuuJ4cqFkkaVYu9j1MsVswESGgCfbqBS9ULwuM", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("10")) assertEquals("DLHDcxuSt9J3cbjd2Dsx4rAgYYA7BAP7A8VLrFiq1tH9yy", keyPairPositive.public.toStringShort()) // The underlying implementation uses the hash of entropy if it is out of range 2 &lt; entropy &lt; N, where N the order of the group. val keyPairNegative = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("-10")) assertEquals("DLBASmjiMZuu1g3EtdHJxfSueXE8PRoUWbkdU61Qcnpamt", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("0")) assertEquals("DLH2FEHEnsT3MpCJt2gfyNjpqRqcBxeupK4YRPXvDsVEkb", keyPairZero.public.toStringShort()) // BigIntenger.Zero is out or range, so 1 and hash(1.toByteArray) would have the same impact. val zeroHashed = BigInteger(1, BigInteger("0").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, zeroHashed.compareTo((ECDSA_SECP256R1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairZeroHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, zeroHashed) assertEquals("DLH2FEHEnsT3MpCJt2gfyNjpqRqcBxeupK4YRPXvDsVEkb", keyPairZeroHashed.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("1")) assertEquals("DLHrtKwjv6onq9HcrQDJPs8Cgtai5mZU5ZU6sb1ivJjx3z", keyPairOne.public.toStringShort()) // BigIntenger.ONE is out or range, so 1 and hash(1.toByteArray) would have the same impact. val oneHashed = BigInteger(1, BigInteger("1").toByteArray().sha256().bytes) // Check oneHashed &lt; N (order of the group), otherwise we would need an extra hash. assertEquals(-1, oneHashed.compareTo((ECDSA_SECP256R1_SHA256.algSpec as ECNamedCurveParameterSpec).n)) val keyPairOneHashed = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, oneHashed) assertEquals("DLHrtKwjv6onq9HcrQDJPs8Cgtai5mZU5ZU6sb1ivJjx3z", keyPairOneHashed.public.toStringShort()) // 2 is in the range. val keyPairTwo = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2")) assertEquals("DLFoz6txJ3vHcKNSM1vFxHJUoEQ69PorBwW64dHsAnEoZB", keyPairTwo.public.toStringShort()) // Try big numbers that are out of range. val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLBv6fZqaCTbE4L7sgjbt19biXHMgU9CzR5s8g8XBJjZ11", keyPairBiggerThan256bits.public.toStringShort()) val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DLANmjhGSVdLyghxcPHrn3KuGatscf6LtvqifUDxw7SGU8", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DL9sKwMExBTD3MnJN6LWGqo496Erkebs9fxZtXLVJUBY9Z", keyPairBiggerThan512bits.public.toStringShort()) val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DLBwjWwPJSF9E7b1NWaSbEJ4oK8CF7RDGWd648TiBhZoL1", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("10")) assertEquals("DLBL3iHCp9uRReWhhCGfCsrxZZpfAm9h9GLbfN8ijqXTq", keyPairPositive.public.toStringShort()) val keyPairNegative = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("-10")) assertEquals("DLC5HXnYsJAFqmM9hgPj5G8whQ4TpyE9WMBssqCayLBwA2", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("0")) assertEquals("DL4UVhGh4tqu1G86UVoGNaDDNCMsBtNHzE6BSZuNNJN7W2", keyPairZero.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("1")) assertEquals("DL8EZUdHixovcCynKMQzrMWBnXQAcbVDHi6ArPphqwJVzq", keyPairOne.public.toStringShort()) val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bits.public.toStringShort()) // The underlying implementation uses the first 256 bytes of the entropy. Thus, 2^258-10 and 2^258-50 and 2^514-10 have the same impact. val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan512bits.public.toStringShort()) // Try another big number. val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DL5tEFVMXMGrzwjfCAW34JjkhsRkPfFyJ38iEnmpB6L2Z9", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:Currencies.kt$infix fun Amount&lt;Currency&gt;.issuedBy(deposit: PartyAndReference)</ID>
    <ID>MaxLineLength:CurrencyParameterSensitivitiesSerializer.kt$CurrencyParameterSensitivitiesSerializer$override fun fromProxy(proxy: Proxy): CurrencyParameterSensitivities</ID>
    <ID>MaxLineLength:CurrencyParameterSensitivitySerialiser.kt$CurrencyParameterSensitivitySerializer$override fun toProxy(obj: CurrencyParameterSensitivity)</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp : TestCordappInternal</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp$jos.addEntry(testEntry(JarFile.MANIFEST_NAME)) { createTestManifest(name, versionId, targetPlatformVersion).write(jos) } // The same resource may be found in different locations (this will happen when running from gradle) so just // pick the first one found. scanResult.allResources.asMap().forEach { path, resourceList -&gt; jos.addEntry(testEntry(path), resourceList[0].open()) }</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp$return ZipEntry(name).setCreationTime(epochFileTime).setLastAccessTime(epochFileTime).setLastModifiedTime(epochFileTime)</ID>
    <ID>MaxLineLength:CustomCordapp.kt$CustomCordapp.Companion$val filename = it.run { "${name.replace(whitespace, "-")}_${versionId}_${targetPlatformVersion}_${UUID.randomUUID()}.jar" }</ID>
    <ID>MaxLineLength:CustomCordappTest.kt$CustomCordappTest$val cordapp = cordappWithPackages("net.corda.testing.node.internal").copy(targetPlatformVersion = 123, name = "CustomCordappTest")</ID>
    <ID>MaxLineLength:CustomNotaryTest.kt$CustomNotaryTest$CustomNotaryService : NotaryService</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$/** * This exists purely for documentation and cross-platform purposes. It is not used by our serialization / deserialization * code path. */ abstract val schemaForDocumentation: Schema</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$Implements&lt;T : Any&gt; : CustomSerializerImp</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$Proxy&lt;T : Any, P : Any&gt; : CustomSerializerImp</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer$SubClass&lt;T : Any&gt; : CustomSerializer</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.CustomSerializerImp$abstract</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.CustomSerializerImp$override fun isSerializerFor(clazz: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.Proxy$override fun isSerializerFor(clazz: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.Proxy$private val proxySerializer: ObjectSerializer by lazy { ObjectSerializer.make(factory.getTypeInformation(proxyClass), factory) }</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.Proxy$withInheritance: Boolean = true</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.ToString$listOf</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.ToString$private</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$CustomSerializerIdentifier</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$constructor(descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry) : this(descriptorBasedSerializerRegistry, emptySet())</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$logger.warn("Duplicate custom serializers detected for $clazz: ${declaredSerializers.map { it::class.qualifiedName }}")</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$logger.warn("Illegal custom serializer detected for $clazz: ${declaredSerializers.first()::class.qualifiedName}")</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private val customSerializersCache: MutableMap&lt;CustomSerializerIdentifier, CustomSerializerLookupResult&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry.CustomSerializerLookupResult$CustomSerializerFound : CustomSerializerLookupResult</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$DuplicateCustomSerializerException : Exception</ID>
    <ID>MaxLineLength:CustomSerializerRegistryTests.kt$CustomSerializerRegistryTests$TestCustomSerializer : CustomSerializer</ID>
    <ID>MaxLineLength:CustomSerializerRegistryTests.kt$CustomSerializerRegistryTests$private fun CustomSerializerRegistry.find(clazz: Class&lt;*&gt;): AMQPSerializer&lt;Any&gt;</ID>
    <ID>MaxLineLength:CustomSerializerRegistryTests.kt$CustomSerializerRegistryTests.TestCustomSerializer$override</ID>
    <ID>MaxLineLength:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuanceRequester$return initiateFlow(issuerBankParty).sendAndReceive&lt;List&lt;AbstractCashFlow.Result&gt;&gt;(topupRequest).unwrap { it }</ID>
    <ID>MaxLineLength:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer$val txn = issueCashTo(amount, topupRequest.issueToParty, topupRequest.issuerPartyRef, topupRequest.notaryParty)</ID>
    <ID>MaxLineLength:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer${ // invoke Cash subflow to issue Asset progressTracker.currentStep = ISSUING val issueCashFlow = CashIssueFlow(amount, issuerPartyRef, notaryParty) val issueTx = subFlow(issueCashFlow) // NOTE: issueCashFlow performs a Broadcast (which stores a local copy of the txn to the ledger) // short-circuit when issuing to self if (serviceHub.myInfo.isLegalIdentity(issueTo)) return issueTx // now invoke Cash subflow to Move issued assetType to issue requester progressTracker.currentStep = TRANSFERRING val moveCashFlow = CashPaymentFlow(amount, issueTo, anonymous = false) // NOTE: CashFlow PayCash calls FinalityFlow which performs a Broadcast (which stores a local copy of the txn to the ledger) return subFlow(moveCashFlow) }</ID>
    <ID>MaxLineLength:CustomVaultQueryTest.kt$CustomVaultQueryTest$mockNet = MockNetwork(threadPerNode = true, cordappPackages = listOf("net.corda.finance", IOUFlow::class.packageName, javaClass.packageName, "com.template"))</ID>
    <ID>MaxLineLength:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$CheckpointVerifier.verifyCheckpointsCompatible(checkpointStorage, emptyList(), 1, mockServices, emptyList())</ID>
    <ID>MaxLineLength:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null })</ID>
    <ID>MaxLineLength:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$val checkpoint = Checkpoint.create(InvocationContext.shell(), FlowStart.Explicit, logic.javaClass, frozenLogic, ALICE, SubFlowVersion.CoreFlow(version), false) .getOrThrow()</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage$log.warn("Tried to download historical network parameters with hash $parametersHash, but network map url isn't configured")</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage$override</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.Companion$PersistentNetworkParameters</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.Companion$fun createParametersMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;SecureHash, SignedDataWithCert&lt;NetworkParameters&gt;, PersistentNetworkParameters, String&gt;</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.PersistentNetworkParameters$( @Id @Column(name = "hash", length = MAX_HASH_HEX_SIZE, nullable = false) val hash: String = "", @Column(name = "epoch", nullable = false) val epoch: Int = 0, // Stored as serialized bytes because network parameters structure evolves over time. @Lob @Column(name = "parameters_bytes", nullable = false) val networkParametersBytes: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY, @Lob @Column(name = "signature_bytes", nullable = false) private val signature: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY, // First certificate in the certificate chain. @Lob @Column(name = "cert", nullable = false) private val certificate: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY, // Parent certificate path (the first one is stored separately), so node is agnostic to certificate hierarchy. @Lob @Column(name = "parent_cert_path", nullable = false) private val certPath: ByteArray = ArrayUtils.EMPTY_BYTE_ARRAY )</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.PersistentNetworkParameters$val signWithCert = DigitalSignatureWithCert(X509CertificateFactory().generateCertificate(certificate.inputStream()), certChain, signature)</ID>
    <ID>MaxLineLength:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$incorrectParams = createDevNetworkMapCa(DEV_INTERMEDIATE_CA).sign(testNetworkParameters(minimumPlatformVersion = 3))</ID>
    <ID>MaxLineLength:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$it.contains("Caused by: java.security.cert.CertPathValidatorException: subject/issuer name chaining check failed")</ID>
    <ID>MaxLineLength:DBNetworkParametersStorageTest.kt$DBNetworkParametersStorageTest$networkParametersService</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension : ExtensionBeforeAllCallbackAfterAllCallbackBeforeEachCallbackAfterEachCallback</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$if (annotationClass.isAssignableFrom(annotation::class.java)) sequenceOf(annotationClass.cast(annotation)) else annotation.annotationClass.java.findAnnotations(annotationClass)</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$private</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$private val AnnotatedElement.requiredSql: List&lt;String&gt; get() = findAnnotations(RequiresSql::class.java).map { it.name }.toList()</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension$val store = rootContext.getStore(ExtensionContext.Namespace.create(DBRunnerExtension::class.java.simpleName, groupName))</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage : StateMachineRecordedTransactionMappingStorage</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$cq.multiselect(from.get&lt;String&gt;(DBTransactionStorage.DBTransaction::stateMachineRunId.name), from.get&lt;String&gt;(DBTransactionStorage.DBTransaction::txId.name))</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$updates.bufferUntilDatabaseCommit().onNext(StateMachineTransactionMapping(stateMachineRunId, transactionId))</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$val flowIds = session.createQuery(cq).resultList.map { StateMachineTransactionMapping(StateMachineRunId(UUID.fromString(it[0] as String)), SecureHash.parse(it[1] as String)) }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage : WritableTransactionStorageSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage$criteriaBuilder.equal(updateRoot.get&lt;TransactionStatus&gt;(DBTransaction::status.name), TransactionStatus.UNVERIFIED)</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage$logger.debug { "Transaction ${transaction.id} is already recorded as verified, so no need to re-record" }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.Companion$return if (effectiveSerializationEnv.serializationFactory.currentContext?.useCase == SerializationContext.UseCase.Storage) { effectiveSerializationEnv.serializationFactory.currentContext!! } else { SerializationDefaults.STORAGE_CONTEXT }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.Companion$transaction = value.toSignedTx().serialize(context = contextToUse().withEncoding(SNAPPY)).bytes</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.TransactionStatus$UnexpectedStatusValueException : Exception</ID>
    <ID>MaxLineLength:DBTransactionStorageTests.kt$DBTransactionStorageTests$listOf(TransactionSignature(ByteArray(1), ALICE_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID)))</ID>
    <ID>MaxLineLength:DataSourceFactory.kt$DataSourceFactory$dataSourceProperties.propertyNames().toList() .filter { name -&gt; (name as String).startsWith("dataSource.") } .map { name -&gt; (name as String).substring("dataSource.".length) to (dataSourceProperties[name]) }</ID>
    <ID>MaxLineLength:DataSourceFactory.kt$DataSourceFactory$fun createDataSource(hikariProperties: Properties, pool: Boolean = true, metricRegistry: MetricRegistry? = null): DataSource</ID>
    <ID>MaxLineLength:DataSourceFactory.kt$DataSourceFactory$fun createDatasourceFromDriverJarFolders(dataSourceProperties: Properties, baseClassLoader: ClassLoader, driverJarsPath: List&lt;Path&gt;): DataSource</ID>
    <ID>MaxLineLength:DataSourceFactory.kt$DataSourceFactory$fun createHikariDatasourceFromDriverJarFolders(dataSourceProperties: Properties, baseClassLoader: ClassLoader, driverJarsPath: List&lt;Path&gt;): DataSource</ID>
    <ID>MaxLineLength:DataSourceFactory.kt$DataSourceFactory$return URLClassLoader(driverJarsPath.flatMap { Files.newDirectoryStream(it, "*.jar") }.map { it.toUri().toURL() }.toTypedArray(), baseClassLoader).let { driversClassLoader -&gt; val dataSourceClassName = dataSourceProperties["dataSourceClassName"] as String? val dataSourceClass = driversClassLoader.loadClass(dataSourceClassName) val dataSourceInstance = dataSourceClass.newInstance() as DataSource val props = Properties().also { it.putAll(dataSourceProperties.propertyNames().toList() .filter { name -&gt; (name as String).startsWith("dataSource.") } .map { name -&gt; (name as String).substring("dataSource.".length) to (dataSourceProperties[name]) }.toMap()) } PropertyElf.setTargetFromProperties(dataSourceInstance, props) dataSourceInstance }</ID>
    <ID>MaxLineLength:DatabaseTestContainers.kt$CockroachDBJpaContainer : JdbcDatabaseContainer</ID>
    <ID>MaxLineLength:DatabaseTestContainers.kt$DataSourceFactory$ fun startup()</ID>
    <ID>MaxLineLength:DatabaseTransaction.kt$get() = contextTransactionOrNull ?: error("Was expecting to find transaction set on current strand: ${Strand.currentStrand()}")</ID>
    <ID>MaxLineLength:DatabaseTransaction.kt$get() = if (_prohibitDatabaseAccess.get() == true) throw IllegalAccessException("Database access is disabled in this context.") else _contextTransaction.get()</ID>
    <ID>MaxLineLength:DbExceptionHandler.kt$DbExceptionHandler : UncaughtExceptionHandler</ID>
    <ID>MaxLineLength:DbExceptionHandler.kt$DbExceptionHandler$errorAndTerminate("Thread ${t!!.name} failed due to database connection error. This is unrecoverable, terminating node.", e)</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$DbManagerConfiguration$DataSourceFactory.createDatasourceFromDriverJarFolders(dataSourceProperties, classLoader, driversFolder + jarDirs)</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$DbManagerConfiguration$NotaryLoader(it, VersionInfo(PLATFORM_VERSION, CordaVersion.releaseVersion, CordaVersion.revision, CordaVersion.vendor))</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$DbManagerConfiguration$fun runMigrationCommand(schemas: Set&lt;MappedSchema&gt;, withMigration: (SchemaMigration, DataSource) -&gt; Unit): Unit</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$DbManagerConfiguration$withMigration(SchemaMigration(schemas, dataSource, config.database, cordappLoader, baseDirectory, ourName = config.myLegalName), dataSource)</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$DoormanDbManagerConfiguration$private fun classLoaderFromJar(jarPath: Path): ClassLoader</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$DoormanDbManagerConfiguration$private fun loadMappedSchema(schemaName: String, classLoader: ClassLoader)</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$JPANotaryDbManagerConfiguration$ConfigFactory.parseFile(configFile.toFile()) .withFallback(configOf("baseDirectory" to cmdLineOptions.baseDirectory.toString())) .withFallback(ConfigFactory.parseResources("reference.conf", ConfigParseOptions.defaults().setAllowMissing(true)))</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$NodeDbManagerConfiguration$ConfigFactory.parseFile(configFile.toFile()) .withFallback(configOf("baseDirectory" to cmdLineOptions.baseDirectory.toString())) .withFallback(ConfigFactory.parseResources("reference.conf", ConfigParseOptions.defaults().setAllowMissing(true)))</ID>
    <ID>MaxLineLength:DbManagerConfiguration.kt$NodeDbManagerConfiguration$override val schemas: Set&lt;MappedSchema&gt; by lazy { NodeSchemaService(extraSchemas = cordappSchemas).schemaOptions.keys }</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$DbManagerOptions$description = ["The name of the config file. By default 'node.conf' for a simple node and 'network-management.conf' for a doorman."]</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$LegacyDbManagerOptions$"You can specify the fully qualified name of the `MappedSchema` class. If not specified it will generate the migration for all schemas that don't have migrations."</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$LegacyDbManagerOptions$// --base-directory needs to be set as not required in the root command, otherwise picocli wants you to enter it twice, // once for the base command and once for the subcommand @Option( names = ["-b", "--base-directory"], description = ["DEPRECATED. The node or doorman directory."], hidden = true ) override var baseDirectory: Path? = null</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$LegacyDbManagerOptions$description = ["DEPRECATED. Releases whatever locks are on the database change log table, in case shutdown failed."]</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$LegacyDbManagerOptions$description = ["DEPRECATED. The name of the config file. By default 'node.conf' for a simple node and 'network-management.conf' for a doorman."]</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$LegacyDbManagerOptions$description = ["DEPRECATED. This option will run the database migration on the configured database. This is the only command that will actually write to the database."]</ID>
    <ID>MaxLineLength:DbManagerOptions.kt$requireNotNull(this.doormanJarPath) { "If running against the doorman you must provide the --$DOORMAN_JAR_PATH" }</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$// First clean up any remains from previous test runs persistence.transaction { session.createNativeQuery("delete from locktestobjects").executeUpdate() session.createNativeQuery("delete from otherlockobjects").executeUpdate() } // Prepare a few rows for reading in table 1 val prepMap = AppendOnlyPersistentMap&lt;TestKey, Int, MyPersistenceClass, Int&gt;( cacheFactory, "myTestCache", { k -&gt; k.value }, { e -&gt; Pair(TestKey(e.key), e.value) }, { k, v -&gt; MyPersistenceClass(k.value, v) }, MyPersistenceClass::class.java ) persistence.transaction { prepMap.set(TestKey(1), 1) prepMap.set(TestKey(2), 2) prepMap.set(TestKey(10), 10) } // the map that will read from the prepared table val testMap = AppendOnlyPersistentMap&lt;TestKey, Int, MyPersistenceClass, Int&gt;( cacheFactory, "myTestCache", { k -&gt; k.value }, { e -&gt; Pair(TestKey(e.key), e.value) }, { k, v -&gt; MyPersistenceClass(k.value, v) }, MyPersistenceClass::class.java ) // a second map that writes to another (unrelated table) val otherMap = AppendOnlyPersistentMap&lt;TestKey, Int, SecondPersistenceClass, Int&gt;( cacheFactory, "myTestCache", { k -&gt; k.value }, { e -&gt; Pair(TestKey(e.key), e.value) }, { k, v -&gt; SecondPersistenceClass(k.value, v) }, SecondPersistenceClass::class.java ) val latch1 = CyclicBarrier(2) val latch2 = CountDownLatch(1) val latch3 = CyclicBarrier(2) val otherThreadException = AtomicReference&lt;Exception?&gt;(null) // This thread will wait for the main thread to do a few things. Then it will starting to read key 2, and write a key to // the second table. This read will be buffered (not flushed) at first. The subsequent access to read value 10 fromt the // first table will cause the previous write to flush. As the row this will be writing to should be locked from the main // thread, it will wait for the main thread's db transaction to commit or rollback before proceeding with the read. val otherThread = thread(name = "testThread2") { try { log.info("Thread2 waiting") latch1.await() latch2.await() log.info("Thread2 starting transaction") persistence.transaction { log.info("Thread2 getting key 2") testMap.get(TestKey(2)) log.info("Thread2 set other value 100") otherMap.set(TestKey(100), 100) latch3.await() log.info("Thread2 getting value 10") val v = testMap.get(TestKey(10)) assertEquals(10, v) } log.info("Thread2 done") } catch (e: Exception) { log.info("Thread2 threw") // Don't log the exception though, since we expect it and check in the assertions what it is. otherThreadException.set(e) } } log.info("MainThread waiting for Thread2 to start waiting") latch1.await() // The main thread will write to the same key in the second table, and then read key 1 from the read table. As it will do that // before triggering the run on thread 2, it will get the row lock in the second table when flushing before the read, then // read and carry on. log.info("MainThread starting transaction") persistence.transaction { log.info("MainThread getting key 2") testMap.get(TestKey(2)) log.info("MainThread set other key 100") otherMap.set(TestKey(100), 100) log.info("MainThread getting key 1") testMap.get(TestKey(1)) // Then it will trigger the start of the second thread (see above) and then sleep for a bit to make sure the other // thread actually runs and beats this thread to the get(10). The test will still pass if it doesn't. log.info("MainThread signal") latch2.countDown() log.info("MainThread wait for Thread2 to be getting the same key") latch3.await() log.info("MainThread sleep for 2 seconds so ideally Thread2 reaches the get first") sleep(2000) // finally it will try to get the same value from the read table that the other thread is trying to read. // If access to reading this value from the DB is guarded by a lock, the other thread will be holding this lock // which means the threads are now deadlocked. log.info("MainThread get value 10") try { assertEquals(10, testMap.get(TestKey(10))) } catch (e: Exception) { checkException(e) } } log.info("MainThread joining with Thread2") otherThread.join() assertNotNull(otherThreadException.get()) checkException(otherThreadException.get()) log.info("MainThread done")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$// To run this test, run sql server in docker using: docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=yourStrong(!)Password' -p 1433:1433 -d microsoft/mssql-server-linux:2017-latest // and create a database called 'perftesting' in the db server. Also requires the SqlServer driver jar at runtime. @Ignore("Requires a local SqlServer running, e.g. in a docker container") @Test fun checkAppendOnlyPersistentMapForDeadlockSqlServer()</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$// We have to catch any exception thrown and check what they are - primary key constraint violations are fine, we are trying // to insert the same key twice after all. Any deadlock time outs or similar are completely not fine and should be a test failure. private fun checkException(exception: Exception?)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$it.setProperty("dataSource.url", "jdbc:h2:file:${temporaryFolder.root}/persistence;DB_CLOSE_ON_EXIT=FALSE;WRITE_DELAY=0;LOCK_TIMEOUT=10000")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$it.setProperty("dataSource.url", "jdbc:sqlserver://localhost:1433;databaseName=perftesting;encrypt=true;trustServerCertificate=true;hostNameInCertificate=*;loginTimeout=30;sendStringParametersAsUnicode=false")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$log.info("MainThread getting key 2") testMap.get(TestKey(2)) log.info("MainThread set other key 100") otherMap.set(TestKey(100), 100) log.info("MainThread getting key 1") testMap.get(TestKey(1)) // Then it will trigger the start of the second thread (see above) and then sleep for a bit to make sure the other // thread actually runs and beats this thread to the get(10). The test will still pass if it doesn't. log.info("MainThread signal") latch2.countDown() log.info("MainThread wait for Thread2 to be getting the same key") latch3.await() log.info("MainThread sleep for 2 seconds so ideally Thread2 reaches the get first") sleep(2000) // finally it will try to get the same value from the read table that the other thread is trying to read. // If access to reading this value from the DB is guarded by a lock, the other thread will be holding this lock // which means the threads are now deadlocked. log.info("MainThread get value 10") try { assertEquals(10, testMap.get(TestKey(10))) } catch (e: Exception) { checkException(e) }</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$log.info("Thread2 threw")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$startHikariPool(hikariProperties, dbConfig, schemaService.schemaOptions.keys, ourName = TestIdentity(ALICE_NAME, 70).name)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$val dbConfig = DatabaseConfig(initialiseSchema = true, transactionIsolationLevel = TransactionIsolationLevel.READ_COMMITTED)</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$LockDbSchemaV2 : MappedSchema</ID>
    <ID>MaxLineLength:DbSchemaInitialisationTest.kt$DbSchemaInitialisationTest$@Ignore</ID>
    <ID>MaxLineLength:DbScriptRunner.kt$DbScriptRunner$System.getProperties().filterKeys { (it as String).startsWith(ConfigHelper.CORDA_PROPERTY_PREFIX) } .mapKeys { (it.key as String).removePrefix(ConfigHelper.CORDA_PROPERTY_PREFIX) } .filterKeys { listOf(DATA_SOURCE_URL, DATA_SOURCE_CLASSNAME, DATA_SOURCE_USER, DATA_SOURCE_PASSWORD).contains(it) }</ID>
    <ID>MaxLineLength:DbScriptRunner.kt$DbScriptRunner$val cordaConfigs = ConfigFactory.parseMap(System.getProperties().filterKeys { (it as String).startsWith(ConfigHelper.CORDA_PROPERTY_PREFIX) } .mapKeys { (it.key as String).removePrefix(ConfigHelper.CORDA_PROPERTY_PREFIX) } .filterKeys { listOf(DATA_SOURCE_URL, DATA_SOURCE_CLASSNAME, DATA_SOURCE_USER, DATA_SOURCE_PASSWORD).contains(it) })</ID>
    <ID>MaxLineLength:DbScriptRunner.kt$DbScriptRunner$val testConfigs = ConfigFactory.parseMap(System.getProperties().filterKeys { listOf(TEST_DB_ADMIN_USER, TEST_DB_ADMIN_PASSWORD).contains(it) } .mapKeys { (it.key as String) })</ID>
    <ID>MaxLineLength:DbScriptRunner.kt$ListPopulator$if (dropUserStatement || createUser) { // log to help spotting a node still logged on database after test has finished (happens on Oracle db) logger.warn("SQLException for $statement: SQL state '" + ex.sqlState + "', error code '" + ex.errorCode + "', message [" + ex.message + "]") } else { logger.debug("SQLException for $statement", ex) }</ID>
    <ID>MaxLineLength:DbScriptRunner.kt$ListPopulator$val dropUserStatement = StringUtils.startsWithIgnoreCase(statement.trim { it &lt;= ' ' }, "drop user ")</ID>
    <ID>MaxLineLength:DbScriptRunner.kt$ListPopulator${ val dropStatement = StringUtils.startsWithIgnoreCase(statement.trim { it &lt;= ' ' }, "drop") // Ignore exception on Oracle db, as the user from the previous test maybe still logged in, and cannot be dropped val createUser = StringUtils.startsWithIgnoreCase(statement.trim { it &lt;= ' ' },"CREATE USER") if ((continueOnError || dropStatement &amp;&amp; ignoreFailedDrops) || createUser) { val dropUserStatement = StringUtils.startsWithIgnoreCase(statement.trim { it &lt;= ' ' }, "drop user ") if (dropUserStatement || createUser) { // log to help spotting a node still logged on database after test has finished (happens on Oracle db) logger.warn("SQLException for $statement: SQL state '" + ex.sqlState + "', error code '" + ex.errorCode + "', message [" + ex.message + "]") } else { logger.debug("SQLException for $statement", ex) } } else { throw ex } }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$TopologicalSort</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$logger.debug { "Downloaded ${sortedDependencies?.size} dependencies from remote peer for transactions ${flow.txHashes}" }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$val (existingTxIds, downloadedTxs) = fetchRequiredTransactions(Collections.singleton(nextRequests.first())) // Fetch first item only</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$val nextRequests = LinkedHashSet&lt;SecureHash&gt;(flow.txHashes) // Keep things unique but ordered, for unit test stability.</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver${ // Don't re-download the same tx when we haven't verified it yet but it's referenced multiple times in the // graph we're traversing. nextRequests.removeAll(topologicalSort.transactionIds) if (nextRequests.isEmpty()) { // Done early. break } // Request the standalone transaction data (which may refer to things we don't yet have). val (existingTxIds, downloadedTxs) = fetchRequiredTransactions(Collections.singleton(nextRequests.first())) // Fetch first item only // When acquiring the write locks for the transaction chain, it is important that all required locks are acquired in the same // order when recording both verified and unverified transactions. In the verified case, the transactions must be recorded in // back chain order (i.e. oldest first), so this must also happen for unverified transactions. This sort ensures that locks are // acquired in the right order in the case the transactions should be stored in the database as unverified. The main topological // sort is also updated here to ensure that this contains everything that needs locking in cases where the resolver switches // from checkpointing to storing unverified transactions in the database. val lockingSort = TopologicalSort() for (tx in downloadedTxs) { val dependencies = tx.dependencies lockingSort.add(tx.id, dependencies) topologicalSort.add(tx.id, dependencies) } var suspended = true for (downloaded in downloadedTxs) { suspended = false val dependencies = downloaded.dependencies // Do not keep in memory as this bloats the checkpoint. Write each item to the database. transactionStorage.lockObjectsForWrite(lockingSort.complete(), contextTransaction, false) { transactionStorage.addUnverifiedTransaction(downloaded) } // The write locks are only released over a suspend, so need to keep track of whether the flow has been suspended to ensure // that locks are not held beyond each while loop iteration (as doing this would result in a deadlock due to claiming locks // in the wrong order) val suspendedViaAttachments = flow.fetchMissingAttachments(downloaded) val suspendedViaParams = flow.fetchMissingNetworkParameters(downloaded) suspended = suspended || suspendedViaAttachments || suspendedViaParams // Add all input states and reference input states to the work queue. nextRequests.addAll(dependencies) } // If the flow did not suspend on the last iteration of the downloaded loop above, perform a suspend here to ensure no write // locks are held going into the next while loop iteration. if (!suspended) { FlowLogic.sleep(0.seconds) } // It's possible that the node has a transaction in storage already. Dependencies should also be present for this transaction, // so just remove these IDs from the set of next requests. nextRequests.removeAll(existingTxIds) }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver${ suspended = false val dependencies = downloaded.dependencies // Do not keep in memory as this bloats the checkpoint. Write each item to the database. transactionStorage.lockObjectsForWrite(lockingSort.complete(), contextTransaction, false) { transactionStorage.addUnverifiedTransaction(downloaded) } // The write locks are only released over a suspend, so need to keep track of whether the flow has been suspended to ensure // that locks are not held beyond each while loop iteration (as doing this would result in a deadlock due to claiming locks // in the wrong order) val suspendedViaAttachments = flow.fetchMissingAttachments(downloaded) val suspendedViaParams = flow.fetchMissingNetworkParameters(downloaded) suspended = suspended || suspendedViaAttachments || suspendedViaParams // Add all input states and reference input states to the work queue. nextRequests.addAll(dependencies) }</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver.TopologicalSort$// Note that we use a LinkedHashSet here to make the traversal deterministic (as long as the input list is). val deDupeIt = dedupe(it) forwardGraph.computeIfAbsent(deDupeIt) { LinkedHashSet() }.add(txId)</ID>
    <ID>MaxLineLength:DeduplicationChecker.kt$DeduplicationChecker</ID>
    <ID>MaxLineLength:DeduplicationId.kt$SenderDeduplicationId</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$// Store a little schema of field names in the stream the first time a class is used which increases tolerance // for change to a class. setDefaultSerializer(CompatibleFieldSerializer::class.java) // Take the safest route here and allow subclasses to have fields named the same as super classes. fieldSerializerConfig.cachedFieldNameStrategy = FieldSerializer.CachedFieldNameStrategy.EXTENDED instantiatorStrategy = CustomInstantiatorStrategy() // Required for HashCheckingStream (de)serialization. // Note that return type should be specifically set to InputStream, otherwise it may not work, i.e. val aStream : InputStream = HashCheckingStream(...). addDefaultSerializer(InputStream::class.java, InputStreamSerializer) addDefaultSerializer(SerializeAsToken::class.java, SerializeAsTokenSerializer&lt;SerializeAsToken&gt;()) addDefaultSerializer(Logger::class.java, LoggerSerializer) addDefaultSerializer(X509Certificate::class.java, X509CertificateSerializer) // WARNING: reordering the registrations here will cause a change in the serialized form, since classes // with custom serializers get written as registration ids. This will break backwards-compatibility. // Please add any new registrations to the end. // TODO: re-organise registrations into logical groups before v1.0 register(Arrays.asList("").javaClass, ArraysAsListSerializer()) register(LazyMappedList::class.java, LazyMappedListSerializer) register(SignedTransaction::class.java, SignedTransactionSerializer) register(WireTransaction::class.java, WireTransactionSerializer) register(SerializedBytes::class.java, SerializedBytesSerializer) UnmodifiableCollectionsSerializer.registerSerializers(this) ImmutableListSerializer.registerSerializers(this) ImmutableSetSerializer.registerSerializers(this) ImmutableSortedSetSerializer.registerSerializers(this) ImmutableMapSerializer.registerSerializers(this) ImmutableMultimapSerializer.registerSerializers(this) // InputStream subclasses whitelisting, required for attachments. register(BufferedInputStream::class.java, InputStreamSerializer) register(Class.forName("sun.net.www.protocol.jar.JarURLConnection\$JarURLInputStream"), InputStreamSerializer) noReferencesWithin&lt;WireTransaction&gt;() register(ECPublicKeyImpl::class.java, publicKeySerializer) register(EdDSAPublicKey::class.java, publicKeySerializer) register(EdDSAPrivateKey::class.java, PrivateKeySerializer) register(CompositeKey::class.java, publicKeySerializer) // Using a custom serializer for compactness // Exceptions. We don't bother sending the stack traces as the client will fill in its own anyway. register(Array&lt;StackTraceElement&gt;::class, read = { _, _ -&gt; emptyArray() }, write = { _, _, _ -&gt; }) // This ensures a NonEmptySetSerializer is constructed with an initial value. register(NonEmptySet::class.java, NonEmptySetSerializer) register(BitSet::class.java, BitSetSerializer()) register(Class::class.java, ClassSerializer) register(FileInputStream::class.java, InputStreamSerializer) register(CertPath::class.java, CertPathSerializer) register(X509CertPath::class.java, CertPathSerializer) register(BCECPrivateKey::class.java, PrivateKeySerializer) register(BCECPublicKey::class.java, publicKeySerializer) register(BCRSAPrivateCrtKey::class.java, PrivateKeySerializer) register(BCRSAPublicKey::class.java, publicKeySerializer) register(BCSphincs256PrivateKey::class.java, PrivateKeySerializer) register(BCSphincs256PublicKey::class.java, publicKeySerializer) register(NotaryChangeWireTransaction::class.java, NotaryChangeWireTransactionSerializer) register(PartyAndCertificate::class.java, PartyAndCertificateSerializer) // Don't deserialize PrivacySalt via its default constructor. register(PrivacySalt::class.java, PrivacySaltSerializer) // Used by the remote verifier, and will possibly be removed in future. register(ContractAttachment::class.java, ContractAttachmentSerializer) register(java.lang.invoke.SerializedLambda::class.java) register(ClosureSerializer.Closure::class.java, CordaClosureBlacklistSerializer) register(ContractUpgradeWireTransaction::class.java, ContractUpgradeWireTransactionSerializer) register(ContractUpgradeFilteredTransaction::class.java, ContractUpgradeFilteredTransactionSerializer) for (whitelistProvider in serializationWhitelists) { val types = whitelistProvider.whitelist require(types.toSet().size == types.size) { val duplicates = types.toMutableList() types.toSet().forEach { duplicates -= it } "Cannot add duplicate classes to the whitelist ($duplicates)." } for (type in types) { ((kryo.classResolver as? CordaClassResolver)?.whitelist as? MutableClassWhitelist)?.add(type) } }</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$register(Class.forName("sun.net.www.protocol.jar.JarURLConnection\$JarURLInputStream"), InputStreamSerializer)</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$return ContractAttachment.create(lazyAttachment, contract, additionalContracts, uploader, signers, version)</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.CustomInstantiatorStrategy$val strat = if (type.name.startsWith("java.") &amp;&amp; !isPublic(type.modifiers)) fallbackStrategy else defaultStrategy</ID>
    <ID>MaxLineLength:DelegatedKeystore.kt$DelegatedKeystore$override fun engineGetCertificateChain(alias: String): Array&lt;X509Certificate&gt;?</ID>
    <ID>MaxLineLength:DelegatedKeystoreProvider.kt$DelegatedKeystoreProvider.DelegatedKeyStoreService$private</ID>
    <ID>MaxLineLength:DelegatedKeystoreProvider.kt$DelegatedPrivateKey : PrivateKey</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(tlsCert, devNodeCa.certificate, intermediateCa.certificate, rootCa.certificate), PASSWORD)</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$val devNodeCa = createDevNodeCa(intermediateCa, MEGA_CORP.name, nodeKeyPair = Crypto.generateKeyPair(serverSignatureScheme))</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$val serverSocket = serverSocketFactory.createServerSocket(0) as SSLServerSocket // use 0 to get first free socket</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, devNodeCa.certificate, devNodeCa.keyPair, MEGA_CORP.name.x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$val trustStore = X509KeyStore(PASSWORD).apply { setCertificate(X509Utilities.CORDA_ROOT_CA, rootCa.certificate) }</ID>
    <ID>MaxLineLength:DelegatedSignatureProvider.kt$DelegatedSignatureProvider$DelegatedSignatureService : Service</ID>
    <ID>MaxLineLength:DelegatingSecureRandomService.kt$DelegatingSecureRandomService : Service</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$Action.SendExisting(initiatedSession.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID))</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$is FlowException -&gt; DeclaredField&lt;Party?&gt;(FlowException::class.java, "peer", exception).value = sessionState.peerParty</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$pendingDeduplicationHandlers = currentState.pendingDeduplicationHandlers + event.deduplicationHandler</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$sessions = checkpoint.sessions + (sessionId to sessionState.copy(rejectionError = flowError))</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$sessions = currentState.checkpoint.sessions + (event.sessionMessage.recipientSessionId to initiatedSession)</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$sessions = startingState.checkpoint.sessions + (event.sessionMessage.recipientSessionId to newSessionState)</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$"Existing reference type mismatch. Expected: '$type', found: '${objectRetrieved::class.java}' "</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$@VisibleForTesting @Throws(AMQPNoTypeNotSerializableException::class) fun getEnvelope(byteSequence: ByteSequence, context: SerializationContext)</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$clazz</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$if (type != TypeIdentifier.UnknownType.getLocalType() &amp;&amp; serializer.type != type &amp;&amp; with(serializer.type) { !isSubClassOf(type) &amp;&amp; !materiallyEquivalentTo(type) } ) { throw AMQPNotSerializableException( type, "Described type with descriptor ${obj.descriptor} was " + "expected to be of type $type but was ${serializer.type}") }</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput$throw NotSerializableException("Internal deserialization failure: ${e.javaClass.name}: ${e.message}").apply { initCause(e) }</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput${ // It must be a reference to an instance that has already been read, cheaply and quickly returning it by reference. val objectIndex = (obj.described as UnsignedInteger).toInt() if (objectIndex &gt;= objectHistory.size) throw AMQPNotSerializableException( type, "Retrieval of existing reference failed. Requested index $objectIndex " + "is outside of the bounds for the list of size: ${objectHistory.size}") val objectRetrieved = objectHistory[objectIndex] if (!objectRetrieved::class.java.isSubClassOf(type.asClass())) { throw AMQPNotSerializableException( type, "Existing reference type mismatch. Expected: '$type', found: '${objectRetrieved::class.java}' " + "@ $objectIndex") } objectRetrieved }</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput.Companion$@Throws(AMQPNoTypeNotSerializableException::class) fun getEnvelope(byteSequence: ByteSequence, encodingWhitelist: EncodingWhitelist = NullEncodingWhitelist): Envelope</ID>
    <ID>MaxLineLength:DeserializationInput.kt$DeserializationInput.Companion$throw AMQPNoTypeNotSerializableException(encodingNotPermittedFormat.format(encoding))</ID>
    <ID>MaxLineLength:DeserializeAndReturnEnvelopeTests.kt$DeserializeAndReturnEnvelopeTests$assertEquals(null, obj.envelope.schema.types.find { it.name == "java.lang.Comparable&lt;${classTestName("Foo")}&gt;" })</ID>
    <ID>MaxLineLength:DeserializeMapTests.kt$DeserializeMapTests$Assertions.assertThatThrownBy { TestSerializationOutput(VERBOSE, sf).serialize(c) } .isInstanceOf(IllegalArgumentException::class.java)</ID>
    <ID>MaxLineLength:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$val classInstance = outerClass.constructors.first().newInstance(nestedClass.constructors.first().newInstance("name"))</ID>
    <ID>MaxLineLength:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests${ val testVal = 10 val clazz = ClassCarpenterImpl(whitelist = AllWhitelist).build(ClassSchema(testName(), mapOf("a" to NonNullableField(Int::class.java)))) val classInstance = clazz.constructors[0].newInstance(testVal) val serialisedBytes = TestSerializationOutput(VERBOSE, sf1).serialize(classInstance) val deserializedObj1 = DeserializationInput(sf1).deserialize(serialisedBytes) assertEquals(clazz, deserializedObj1::class.java) assertEquals(testVal, deserializedObj1::class.java.getMethod("getA").invoke(deserializedObj1)) val deserializedObj2 = DeserializationInput(sf1).deserialize(serialisedBytes) assertEquals(clazz, deserializedObj2::class.java) assertEquals(deserializedObj1::class.java, deserializedObj2::class.java) assertEquals(testVal, deserializedObj2::class.java.getMethod("getA").invoke(deserializedObj2)) val deserializedObj3 = DeserializationInput(sf2).deserializeWithoutAndWithCarpenter(serialisedBytes) assertNotEquals(clazz, deserializedObj3::class.java) assertNotEquals(deserializedObj1::class.java, deserializedObj3::class.java) assertNotEquals(deserializedObj2::class.java, deserializedObj3::class.java) assertEquals(testVal, deserializedObj3::class.java.getMethod("getA").invoke(deserializedObj3)) // NOTE: There is no point attempting this without the carepenter a second time as having carpented things up once // it will, of course, just succeed even with the carpenter disabled val deserializedObj4 = DeserializationInput(sf2).deserialize(serialisedBytes) assertNotEquals(clazz, deserializedObj4::class.java) assertNotEquals(deserializedObj1::class.java, deserializedObj4::class.java) assertNotEquals(deserializedObj2::class.java, deserializedObj4::class.java) assertEquals(deserializedObj3::class.java, deserializedObj4::class.java) assertEquals(testVal, deserializedObj4::class.java.getMethod("getA").invoke(deserializedObj4)) }</ID>
    <ID>MaxLineLength:DeserializeQueryableStateTest.kt$DeserializeQueryableStateTest$val clientContext = AMQP_RPC_CLIENT_CONTEXT.copy(whitelist = AllWhitelist, deserializationClassLoader = ClassLoaderWithoutTestState(ClassLoader.getSystemClassLoader()))</ID>
    <ID>MaxLineLength:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$garbo [class </ID>
    <ID>MaxLineLength:DevCertificatesTest.kt$DevCertificatesTest$val oldNodeCaKeyStore = loadKeyStore(javaClass.classLoader.getResourceAsStream("regression-test/$OLD_NODE_DEV_KEYSTORE_FILE_NAME"), OLD_DEV_KEYSTORE_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$ fun generateDistributedNotaryCompositeIdentity(dirs: List&lt;Path&gt;, notaryName: CordaX500Name, threshold: Int = 1): Party</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$DEV_CA_KEY_STORE_PASS</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val p2pKeyStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "sslkeystore.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val p2pTrustStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "truststore.jks", DEV_CA_TRUST_STORE_PASS, DEV_CA_TRUST_STORE_PRIVATE_KEY_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val signingCertStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "nodekeystore.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert : DigitalSignature</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert$val parameters = PKIXParameters(setOf(TrustAnchor(parentCertsChain.last(), null))).apply { isRevocationEnabled = false }</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$SignedDataWithCert&lt;T : Any&gt; : NamedByHash</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$net.corda.core.internal.DigitalSignatureWithCert.kt</ID>
    <ID>MaxLineLength:DirectBridgeSenderService.kt$DirectBridgeSenderService$auditService.statusChangeEvent("Waiting for activation by at least one bridge control inbox registration")</ID>
    <ID>MaxLineLength:DirectBridgeSenderService.kt$DirectBridgeSenderService$bridgeControlListener</ID>
    <ID>MaxLineLength:DirectBridgeSenderService.kt$DirectBridgeSenderService$override fun validateReceiveTopic(topic: String, sourceLegalName: CordaX500Name): Boolean</ID>
    <ID>MaxLineLength:DirectBridgeSenderService.kt$DirectBridgeSenderService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:DirectBridgeSenderService.kt$DirectBridgeSenderService$private val statusFollower: ServiceStateCombiner = ServiceStateCombiner(listOf(auditService, artemisConnectionService, haService, signingService))</ID>
    <ID>MaxLineLength:DirectBridgeSenderService.kt$DirectBridgeSenderService.BridgeAuditServiceAdaptor${ // Too much of a hassle to translate `ClientMessage` into `ApplicationMessage?`, especially given that receiving side is likely // to be doing counting only. auditService.packetDropEvent(null, msg, RoutingDirection.OUTBOUND) }</ID>
    <ID>MaxLineLength:Disruption.kt$connection.runShellCommandGetOutput("sudo rm ${connection.remoteNode.nodeDirectory}/persistence.mv.db").getResultOrThrow()</ID>
    <ID>MaxLineLength:Disruption.kt$val shell = "for c in {1..$parallelism} ; do openssl enc -aes-128-cbc -in /dev/urandom -pass pass: -e &gt; /dev/null &amp; done &amp;&amp; JOBS=\$(jobs -p) &amp;&amp; (sleep $durationSeconds &amp;&amp; kill \$JOBS) &amp; wait"</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$// TODO Use a dummy distributed service rather than a Raft Notary Service as this test is only about Artemis' ability // to handle distributed services @Test fun `requests are distributed evenly amongst the nodes`()</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$Assume.assumeFalse(isRemoteDatabaseMode())</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$assertThat(notaryNodes.flatMap { it.nodeInfo.legalIdentities - raftNotaryIdentity }.toSet()).hasSameSizeAs(notaryNodes)</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests$proxy.stateMachinesFeed().updates.map { Pair(proxy.nodeInfo().legalIdentitiesAndCerts.first().party, it) }</ID>
    <ID>MaxLineLength:DistributedServiceTests.kt$DistributedServiceTests.Companion$@ClassRule @JvmField val databaseSchemas = IntegrationTestSchemas(DUMMY_NOTARY_NAME.toDatabaseSchemaNames("_0", "_1", "_2") + ALICE_NAME.toDatabaseSchemaName())</ID>
    <ID>MaxLineLength:DockerContainerPusher.kt$DockerContainerPusher$override</ID>
    <ID>MaxLineLength:DockerUtils.kt$DockerUtils$private</ID>
    <ID>MaxLineLength:Driver.kt$ fun &lt;A&gt; driver(defaultParameters: DriverParameters = DriverParameters(), dsl: DriverDSL.() -&gt; A): A</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$( val isDebug: Boolean = false, val driverDirectory: Path = Paths.get("build") / "node-driver" / getTimestampAsDirectoryName(), val portAllocation: PortAllocation = incrementalPortAllocation(), val debugPortAllocation: PortAllocation = incrementalPortAllocation(), val systemProperties: Map&lt;String, String&gt; = emptyMap(), val useTestClock: Boolean = false, val startNodesInProcess: Boolean = false, val waitForAllNodesToFinish: Boolean = false, val notarySpecs: List&lt;NotarySpec&gt; = listOf(NotarySpec(DUMMY_NOTARY_NAME)), @Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use cordappsForAllNodes instead.") val extraCordappPackagesToScan: List&lt;String&gt; = listOf("migration"), @Suppress("DEPRECATION") val jmxPolicy: JmxPolicy = JmxPolicy(), val networkParameters: NetworkParameters = testNetworkParameters(notaries = emptyList()), val notaryCustomOverrides: Map&lt;String, Any?&gt; = emptyMap(), val inMemoryDB: Boolean = true, val cordappsForAllNodes: Collection&lt;TestCordapp&gt;? = null, val enableSNI: Boolean = true )</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use cordappsForAllNodes instead.")</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use withCordappsForAllNodes instead.")</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use withCordappsForAllNodes instead.") fun withExtraCordappPackagesToScan(extraCordappPackagesToScan: List&lt;String&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withCordappsForAllNodes(cordappsForAllNodes: Collection&lt;TestCordapp&gt;?): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withDebugPortAllocation(debugPortAllocation: PortAllocation): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withNetworkParameters(networkParameters: NetworkParameters): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withNotaryCustomOverrides(notaryCustomOverrides: Map&lt;String, Any?&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withStartNodesInProcess(startNodesInProcess: Boolean): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withSystemProperties(systemProperties: Map&lt;String, String&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withWaitForAllNodesToFinish(waitForAllNodesToFinish: Boolean): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$InProcess$ fun &lt;T&gt; startFlow(logic: FlowLogic&lt;T&gt;): CordaFuture&lt;T&gt;</ID>
    <ID>MaxLineLength:Driver.kt$JmxPolicy</ID>
    <ID>MaxLineLength:Driver.kt$JmxPolicy$@Deprecated("The default constructor does not turn on monitoring. Simply leave the jmxPolicy parameter unspecified if you wish to not " + "have monitoring turned on.")</ID>
    <ID>MaxLineLength:Driver.kt$PortAllocation.Incremental$@Deprecated("This has been superseded by net.corda.testing.driver.SharedMemoryIncremental.INSTANCE", ReplaceWith("SharedMemoryIncremental.INSTANCE"))</ID>
    <ID>MaxLineLength:Driver.kt$PortAllocation.Incremental$@Deprecated("This has been superseded by net.corda.testing.driver.SharedMemoryIncremental.INSTANCE", ReplaceWith("net.corda.testing.driver.DriverDSL.nextPort()"))</ID>
    <ID>MaxLineLength:DriverDSL.kt$DriverDSL$ @Suppress("DEPRECATION") fun startWebserver(handle: NodeHandle): CordaFuture&lt;WebserverHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSL.kt$DriverDSL$ fun startNode( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize ): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSL.kt$DriverDSL$ fun startNode( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride ): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$CompatibilityZoneParams</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$ private fun startOutOfProcessMiniNode(config: NodeConfig, vararg extraCmdLineFlag: String): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$/** * Future which completes when the network map infrastructure is available, whether a local one or one from the CZ. * This future acts as a gate to prevent nodes from starting too early. The value of the future is a [LocalNetworkMap] * object, which is null if the network map is being provided by the CZ. */ lateinit var networkMapAvailability: CordaFuture&lt;LocalNetworkMap?&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$LocalNetworkMap</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeConfig</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeConfiguration::rpcUsers.name to if (users.isEmpty()) defaultRpcUserList else users.map { it.toConfig().root().unwrapped() }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig + customOverrides, maximumHeapSize = spec.maximumHeapSize)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig(clusterAddress))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig(nodeAddress, clusterAddress))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$OutOfProcessImpl(rpc.nodeInfo(), rpc, config.corda, webAddress, useHTTPS, debugPort, process, onNodeExit)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$_executorService = Executors.newScheduledThreadPool(2, ThreadFactoryBuilder().setNameFormat("driver-pool-thread-%d").build())</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$_notaries.map { notary -&gt; notary.map { handle -&gt; handle.nodeHandles } }.getOrThrow(notaryHandleTimeout).forEach { future -&gt; future.getOrThrow(notaryHandleTimeout) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$fun notaryConfig(nodeAddress: NetworkHostAndPort, clusterAddress: NetworkHostAndPort? = null): Map&lt;String, Any&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$override</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$override fun startNode(parameters: NodeParameters): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$paths.filter { it.fileName.toString().startsWith(NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX) }.findFirst().get()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$private</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$return (0 until spec.cluster!!.clusterSize).map { spec.name.copy(organisation = "${spec.name.organisation}-$it") }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$startNodeRegistration(name, compatibilityZone.rootCert, compatibilityZone.config(), parameters.customOverrides)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val client = OkHttpClient.Builder().connectTimeout(5, TimeUnit.SECONDS).readTimeout(60, TimeUnit.SECONDS).build()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val flowOverrideConfig = FlowOverrideConfig(parameters.flowOverrides.map { FlowOverride(it.key.canonicalName, it.value.canonicalName) })</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val jdbcUrl = "jdbc:h2:mem:persistence${inMemoryCounter.getAndIncrement()};DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=10000;WRITE_DELAY=100"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val name = parameters.providedName ?: CordaX500Name("${oneOf(names).organisation}-${p2pAddress.port}", "London", "GB")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val nodeInfo = Node(config.corda, MOCK_VERSION_INFO, initialiseSerialization = false).generateAndSaveNodeInfo()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val process = startOutOfProcessNode(config, quasarJarPath, debugPort, bytemanJarPath, bytemanPort, systemProperties, parameters.maximumHeapSize, parameters.logLevelOverride)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val processDeathFuture = poll(executorService, "process death while waiting for RPC (${config.corda.myLegalName})") { if (process.isAlive) null else process }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl${ // If no CZ is specified then the driver does the generation of the network parameters and the copying of the // node info files. startNotaryIdentityGeneration().map { notaryInfos -&gt; Pair(notaryInfos, LocalNetworkMap(notaryInfos)) } }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl${ // In this case we're dealing with the the RPCDriver or one of it's cousins which are internal and we don't care about them emptyList() }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl${ // Otherwise it's the CZ's job to distribute thse via the HTTP network map, as that is what the nodes will be expecting. val notaryInfosFuture = if (compatibilityZone.rootCert == null) { // No root cert specified so we use the dev root cert to generate the notary identities. startNotaryIdentityGeneration() } else { // With a root cert specified we delegate generation of the notary identities to the CZ. startAllNotaryRegistrations(compatibilityZone.rootCert, compatibilityZone) } notaryInfosFuture.map { notaryInfos -&gt; compatibilityZone.publishNotaries(notaryInfos) Pair(notaryInfos, null) } }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$ private fun Map&lt;String, Any&gt;.removeResolvedClasspath(): Map&lt;String, Any&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"byteMan: "</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"com.fasterxml**;com.google**;com.ibm**;com.intellij**;com.jcabi**;com.nhaarman**;com.opengamma**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"com.lmax**;picocli**;liquibase**;com.github.benmanes**;org.json**;org.postgresql**;nonapi.io.github.classgraph**;)"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"com.typesafe**;com.zaxxer**;de.javakaffee**;groovy**;groovyjarjarantlr**;groovyjarjarasm**;io.atomix**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"io.github**;io.netty**;jdk**;joptsimple**;junit**;kotlin**;net.bytebuddy**;net.i2p**;org.apache**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"org.assertj**;org.bouncycastle**;org.codehaus**;org.crsh**;org.dom4j**;org.fusesource**;org.h2**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$"org.hamcrest**;org.hibernate**;org.jboss**;org.jcp**;org.joda**;org.junit**;org.mockito**;org.objectweb**;"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$/** * A sub-set of permissions that grant most of the essential operations used in the unit/integration tests as well as * in demo application like NodeExplorer. */ @Suppress("DEPRECATION") private val DRIVER_REQUIRED_PERMISSIONS = setOf( Permissions.invokeRpc(CordaRPCOps::nodeInfo), Permissions.invokeRpc(CordaRPCOps::networkMapFeed), Permissions.invokeRpc(CordaRPCOps::networkMapSnapshot), Permissions.invokeRpc(CordaRPCOps::notaryIdentities), Permissions.invokeRpc(CordaRPCOps::stateMachinesFeed), Permissions.invokeRpc(CordaRPCOps::stateMachineRecordedTransactionMappingFeed), Permissions.invokeRpc(CordaRPCOps::nodeInfoFromParty), Permissions.invokeRpc(CordaRPCOps::internalVerifiedTransactionsFeed), Permissions.invokeRpc(CordaRPCOps::internalFindVerifiedTransaction), Permissions.invokeRpc("vaultQueryBy"), Permissions.invokeRpc("vaultTrackBy"), Permissions.invokeRpc(CordaRPCOps::registeredFlows), Permissions.invokeRpc(CordaRPCOps::killFlow) )</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$exclude.any { token -&gt; cpEntry.contains("${File.separatorChar}$token") } || cpEntry.endsWith("-tests.jar")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$if (bytemanAgent != null &amp;&amp; debugPort != null) listOf("-Dorg.jboss.byteman.verbose=true", "-Dorg.jboss.byteman.debug=true") else emptyList()</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$private operator fun Config.plus(property: Pair&lt;String, Any&gt;)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$private val defaultRpcUserList = listOf(InternalUser("default", "default", setOf("ALL")).toConfig().root().unwrapped())</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$throw IllegalStateException("No quasar agent: -javaagent:lib/quasar.jar and working directory project root might fix")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$val exclude = listOf("samples", "corda-finance", "finance", "integrationTest", "test", "corda-mock", "com.opengamma.strata")</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$val excludePattern = "x(antlr**;bftsmart**;ch**;co.paralleluniverse**;com.codahale**;com.esotericsoftware**;" + "com.fasterxml**;com.google**;com.ibm**;com.intellij**;com.jcabi**;com.nhaarman**;com.opengamma**;" + "com.typesafe**;com.zaxxer**;de.javakaffee**;groovy**;groovyjarjarantlr**;groovyjarjarasm**;io.atomix**;" + "io.github**;io.netty**;jdk**;joptsimple**;junit**;kotlin**;net.bytebuddy**;net.i2p**;org.apache**;" + "org.assertj**;org.bouncycastle**;org.codehaus**;org.crsh**;org.dom4j**;org.fusesource**;org.h2**;" + "org.hamcrest**;org.hibernate**;org.jboss**;org.jcp**;org.joda**;org.junit**;org.mockito**;org.objectweb**;" + "org.objenesis**;org.slf4j**;org.w3c**;org.xml**;org.yaml**;reflectasm**;rx**;org.jolokia**;" + "com.lmax**;picocli**;liquibase**;com.github.benmanes**;org.json**;org.postgresql**;nonapi.io.github.classgraph**;)"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion${ log.info("Starting out-of-process Node ${config.corda.myLegalName.organisation}, " + "debug port is " + (debugPort ?: "not enabled") + ", " + "byteMan: " + if (bytemanJarPath == null) "not in classpath" else "port is " + (bytemanPort ?: "not enabled")) // Write node.conf writeConfig(config.corda.baseDirectory, "node.conf", config.typesafe.toNodeOnly()) val systemProperties = mutableMapOf( "name" to config.corda.myLegalName, "visualvm.display.name" to "corda-${config.corda.myLegalName}" ) debugPort?.let { systemProperties += "log4j2.level" to "debug" systemProperties += "log4j2.debug" to "true" } systemProperties += inheritFromParentProcess() systemProperties += overriddenSystemProperties // See experimental/quasar-hook/README.md for how to generate. val excludePattern = "x(antlr**;bftsmart**;ch**;co.paralleluniverse**;com.codahale**;com.esotericsoftware**;" + "com.fasterxml**;com.google**;com.ibm**;com.intellij**;com.jcabi**;com.nhaarman**;com.opengamma**;" + "com.typesafe**;com.zaxxer**;de.javakaffee**;groovy**;groovyjarjarantlr**;groovyjarjarasm**;io.atomix**;" + "io.github**;io.netty**;jdk**;joptsimple**;junit**;kotlin**;net.bytebuddy**;net.i2p**;org.apache**;" + "org.assertj**;org.bouncycastle**;org.codehaus**;org.crsh**;org.dom4j**;org.fusesource**;org.h2**;" + "org.hamcrest**;org.hibernate**;org.jboss**;org.jcp**;org.joda**;org.junit**;org.mockito**;org.objectweb**;" + "org.objenesis**;org.slf4j**;org.w3c**;org.xml**;org.yaml**;reflectasm**;rx**;org.jolokia**;" + "com.lmax**;picocli**;liquibase**;com.github.benmanes**;org.json**;org.postgresql**;nonapi.io.github.classgraph**;)" val extraJvmArguments = systemProperties.removeResolvedClasspath().map { "-D${it.key}=${it.value}" } + "-javaagent:$quasarJarPath=$excludePattern" val loggingLevel = when { logLevelOverride != null -&gt; logLevelOverride debugPort == null -&gt; "INFO" else -&gt; "DEBUG" } val arguments = mutableListOf( "--base-directory=${config.corda.baseDirectory}", "--logging-level=$loggingLevel", "--no-local-shell").also { it += extraCmdLineFlag }.toList() val bytemanJvmArgs = { val bytemanAgent = bytemanJarPath?.let { bytemanPort?.let { "-javaagent:$bytemanJarPath=port:$bytemanPort,listener:true" } } listOfNotNull(bytemanAgent) + if (bytemanAgent != null &amp;&amp; debugPort != null) listOf("-Dorg.jboss.byteman.verbose=true", "-Dorg.jboss.byteman.debug=true") else emptyList() }.invoke() // The following dependencies are excluded from the classpath of the created JVM, so that the environment resembles a real one as close as possible. // These are either classes that will be added as attachments to the node (i.e. samples, finance, opengamma etc.) or irrelevant testing libraries (test, corda-mock etc.). // TODO: There is pending work to fix this issue without custom blacklisting. See: https://r3-cev.atlassian.net/browse/CORDA-2164. val exclude = listOf("samples", "corda-finance", "finance", "integrationTest", "test", "corda-mock", "com.opengamma.strata") val cp = ProcessUtilities.defaultClassPath.filterNot { cpEntry -&gt; exclude.any { token -&gt; cpEntry.contains("${File.separatorChar}$token") } || cpEntry.endsWith("-tests.jar") } return ProcessUtilities.startJavaProcess( className = "net.corda.node.Corda", // cannot directly get class for this, so just use string arguments = arguments, jdwpPort = debugPort, extraJvmArguments = extraJvmArguments + bytemanJvmArgs, workingDirectory = config.corda.baseDirectory, maximumHeapSize = maximumHeapSize, classPath = cp ) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.LocalNetworkMap$// TODO: this object will copy NodeInfo files from started nodes to other nodes additional-node-infos/ // This uses the FileSystem and adds a delay (~5 seconds) given by the time we wait before polling the file system. // Investigate whether we can avoid that. val nodeInfosCopier = NodeInfoFilesCopier().also { shutdownManager.registerShutdown(it::close) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$InternalDriverDSL$ fun &lt;A&gt; pollUntilNonNull(pollName: String, pollInterval: Duration = DEFAULT_POLL_INTERVAL, warnCount: Int = DEFAULT_WARN_COUNT, check: () -&gt; A?): CordaFuture&lt;A&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$InternalDriverDSL$ fun pollUntilTrue(pollName: String, pollInterval: Duration = DEFAULT_POLL_INTERVAL, warnCount: Int = DEFAULT_WARN_COUNT, check: () -&gt; Boolean): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$extraCordappPackagesToScan: List&lt;String&gt; = @Suppress("DEPRECATION") DriverParameters().extraCordappPackagesToScan</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$fun DriverDSL.startNode(providedName: CordaX500Name, devMode: Boolean, parameters: NodeParameters = NodeParameters()): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverInternal.kt$NodeHandleInternal$override val jmxAddress: NetworkHostAndPort? get() = configuration.jmxMonitoringHttpPort?.let { NetworkHostAndPort("localhost", it) }</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$driver</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$newNode(CordaX500Name(commonName = "Notary", organisation = "R3CEV", locality = "New York", country = "US"))().getOrThrow()</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$newNode(CordaX500Name(commonName = "Regulator", organisation = "R3CEV", locality = "New York", country = "US"))().getOrThrow()</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$val logFile = (baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME).list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() }</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests${ // Based on local testing, running this 3 times gives us a high confidence that we'll spot if the feature is not working repeat(3) { setUp() // R3.Corda only: Schema setup for standalone database, does nothing for H2 driver(DriverParameters(startNodesInProcess = true)) { val bob = startNode(providedName = BOB_NAME).getOrThrow() assertThat(bob.rpc.networkMapSnapshot().flatMap { it.legalIdentities }).contains(defaultNotaryIdentity) } tearDown() // R3.Corda only: Schema cleanup for standalone database, does nothing for H2 } }</ID>
    <ID>MaxLineLength:DryRunCli.kt$DryRunCli : CliWrapperBase</ID>
    <ID>MaxLineLength:DryRunCli.kt$DryRunCli$"" -&gt; FileWriter(File(baseDirectory.toFile(), "migration${SimpleDateFormat("yyyyMMddHHmmss").format(Date())}.sql"))</ID>
    <ID>MaxLineLength:DryRunCli.kt$DryRunCli$@CommandLine.Parameters(arity = "0..1", description = ["You can specify a file name or 'CONSOLE' if you want to send the output to the console."])</ID>
    <ID>MaxLineLength:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$protected open</ID>
    <ID>MaxLineLength:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$rpcParamsA = RPCParams(NetworkHostAndPort(context.getParameter(hostA.name), context.getIntParameter(portA.name)), context.getParameter(usernameA.name), context.getParameter(passwordA.name))</ID>
    <ID>MaxLineLength:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$rpcParamsB = RPCParams(NetworkHostAndPort(context.getParameter(hostB.name), context.getIntParameter(portB.name)), context.getParameter(usernameB.name), context.getParameter(passwordB.name))</ID>
    <ID>MaxLineLength:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler.Companion$RPCClient</ID>
    <ID>MaxLineLength:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler.Companion$val hostA = Argument("host_A", "localhost", "&lt;meta&gt;", "The remote network address (hostname or IP address) to connect to for RPC.")</ID>
    <ID>MaxLineLength:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler.Companion$val hostB = Argument("host_B", "localhost", "&lt;meta&gt;", "The remote network address (hostname or IP address) to connect to for RPC.")</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$ @JvmStatic fun generateInitial(magicNumber: Int, notary: Party, owner: PartyAndReference, vararg otherOwners: PartyAndReference): TransactionBuilder</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID)</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$TransactionBuilder(notary).withItems(StateAndContract(state, PROGRAM_ID), Command(Commands.Create(), owners.map { it.party.owningKey }))</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$val items = arrayOf(StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID), Command(Commands.Create(), owners.first().party.owningKey), StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID), Command(Commands.Create(), owners.first().party.owningKey))</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.SingleOwnerState$data</ID>
    <ID>MaxLineLength:DummyDealStateSchemaV1.kt$DummyDealStateSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:DummyDealStateSchemaV1.kt$DummyDealStateSchemaV1.PersistentDummyDealState$@CollectionTable(name = "dummy_deal_states_parts", joinColumns = [(JoinColumn(name = "output_index", referencedColumnName = "output_index")), (JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"))])</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$override</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one input for this group")</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract.State$override</ID>
    <ID>MaxLineLength:DummyIssueAndMove.kt$DummyIssueAndMove : FlowLogic</ID>
    <ID>MaxLineLength:DummyLinearContract.kt$DummyLinearContract.State$override fun supportedSchemas(): Iterable&lt;MappedSchema&gt;</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV1.kt$DummyLinearStateSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV1.kt$DummyLinearStateSchemaV1.PersistentDummyLinearState$@Table(name = "dummy_linear_states", indexes = [Index(name = "external_id_idx", columnList = "external_id"), Index(name = "uuid_idx", columnList = "uuid")])</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV2.kt$DummyLinearStateSchemaV2.PersistentDummyLinearState$@CollectionTable(name = "dummy_linear_states_v2_parts", joinColumns = [(JoinColumn(name = "output_index", referencedColumnName = "output_index")), (JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"))])</ID>
    <ID>MaxLineLength:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor$val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation)</ID>
    <ID>MaxLineLength:DumpHistoryOnErrorInterceptor.kt$DumpHistoryOnErrorInterceptor${ val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor) val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation) val record = records.compute(fiber.id) { _, record -&gt; (record ?: ArrayList()).apply { add(transitionRecord) } } // Just if we decide to propagate, and not if just on the way to the hospital. Only log at debug level here - the flow transition // information is often unhelpful in the logs, and the actual cause of the problem will be logged elsewhere. if (nextState.checkpoint.errorState is ErrorState.Errored &amp;&amp; nextState.checkpoint.errorState.propagating) { log.warn("Flow ${fiber.id} errored, dumping all transitions:\n${record!!.joinToString("\n")}") for (error in nextState.checkpoint.errorState.errors) { log.warn("Flow ${fiber.id} error", error.exception) } } if (nextState.isRemoved) { records.remove(fiber.id) } return Pair(continuation, nextState) }</ID>
    <ID>MaxLineLength:DurationHelper.kt$return "${if(days &gt; 0) "${days}d " else ""}${"$hours".padStart(2, '0')}:${"$minutes".padStart(2, '0')}:${"$seconds".padStart(2, '0')}.${"$millis".padStart(3, '0')}"</ID>
    <ID>MaxLineLength:DurationSerializer.kt$DurationSerializer : Proxy</ID>
    <ID>MaxLineLength:E2ETestKeyManagementService.kt$E2ETestKeyManagementService : SingletonSerializeAsTokenKeyManagementServiceInternal</ID>
    <ID>MaxLineLength:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$getPrivateKey((privateKey as AliasPrivateKey).alias, cryptoService.certificateStore.entryPassword)</ID>
    <ID>MaxLineLength:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$throw UnsupportedOperationException("This operation is only supported by persistent key management service variants.")</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$// Required to implement a custom doSign function, because Corda's Crypto.doSign does not allow empty messages (testVector1). private fun doSign(privateKey: PrivateKey, clearData: ByteArray): ByteArray</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$assertEquals(it.signatureOutputHex, doSign(privateKey, it.messageToSignHex.hexToByteArray()).toHex().toLowerCase())</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$assertNotEquals(testVectorEd25519ctx.signatureOutputHex, doSign(privateKey, testVectorEd25519ctx.messageToSignHex.hexToByteArray()).toHex().toLowerCase())</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$val privateKey = EdDSAPrivateKey(EdDSAPrivateKeySpec(testVectorEd25519ctx.privateKeyHex.hexToByteArray(), edParams))</ID>
    <ID>MaxLineLength:EfficiencyKnownUnspentCachingDriver.kt$EfficiencyKnownUnspentCachingDriver : FlowLogic</ID>
    <ID>MaxLineLength:EncodingUtils.kt$ fun parsePublicKeyBase58(base58String: String): PublicKey</ID>
    <ID>MaxLineLength:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>MaxLineLength:EnterpriseCashSelectionSQLServerImpl.kt$EnterpriseCashSelectionSQLServerImpl : AbstractCashSelection</ID>
    <ID>MaxLineLength:EnterpriseConfiguration.kt$EnterpriseConfiguration$val messagingServerConnectionConfiguration: MessagingServerConnectionConfiguration = Defaults.messagingServerConnectionConfiguration</ID>
    <ID>MaxLineLength:EnterpriseConfiguration.kt$EnterpriseConfiguration.Defaults$val messagingServerConnectionConfiguration: MessagingServerConnectionConfiguration = MessagingServerConnectionConfiguration.DEFAULT</ID>
    <ID>MaxLineLength:EnterpriseConfiguration.kt$MessagingServerSslConfiguration$override val useOpenSsl: Boolean = Defaults.useOpenSsl</ID>
    <ID>MaxLineLength:EnterpriseFlowLogicRefFactory.kt$EnterpriseFlowLogicRefFactoryImpl : FlowLogicRefFactoryImpl</ID>
    <ID>MaxLineLength:EnterpriseFlowLogicRefFactory.kt$EnterpriseFlowLogicRefFactoryImpl$ConstructorSignature</ID>
    <ID>MaxLineLength:EnterpriseFlowLogicRefFactory.kt$EnterpriseFlowLogicRefFactoryImpl$override</ID>
    <ID>MaxLineLength:EnterpriseFlowLogicRefFactory.kt$EnterpriseFlowLogicRefFactoryImpl$private</ID>
    <ID>MaxLineLength:EnterpriseFlowLogicRefFactory.kt$EnterpriseFlowLogicRefFactoryImpl$return constructorCache.get(cacheKey) ?: super.findConstructor(flowClass, argTypes).apply { constructorCache.put(cacheKey, this) }</ID>
    <ID>MaxLineLength:EnterpriseMockNamedCachedFactory.kt$EnterpriseMockNamedCachedFactory : BindableNamedCacheFactorySingletonSerializeAsToken</ID>
    <ID>MaxLineLength:EnterpriseMockNamedCachedFactory.kt$EnterpriseMockNamedCachedFactory$override</ID>
    <ID>MaxLineLength:EnterpriseMockNamedCachedFactory.kt$EnterpriseMockNamedCachedFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:EnterpriseMockNamedCachedFactory.kt$EnterpriseMockNamedCachedFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory : DefaultNamedCacheFactory</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$name == "NodeAttachmentService_attachmentContent" -&gt; caffeine.maximumWeight(defaultAttachmentCacheBound(this))</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$name == "NodeAttachmentService_attachmentPresence" -&gt; caffeine.maximumSize(defaultAttachmentPresenceCacheBound(this))</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$override</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$override val defaultCacheSize = if (nodeConfiguration == null) super.defaultCacheSize else defaultBound(nodeConfiguration)</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$private</ID>
    <ID>MaxLineLength:EnterpriseNamedCacheFactory.kt$EnterpriseNamedCacheFactory$return wrap(configuredForNamed(caffeine, name).buildNamed&lt;K, V&gt;(metricRegistry!!, name, loader), tracingConfig, name)</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$"Review the documentation to see how this can be enabled via the `freshIdentitiesConfiguration` entry. Alternatively, you can disable this warning by setting `disableFreshIdentitiesWarning` to true in the node's configuration."</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$(configuration: NodeConfiguration, versionInfo: VersionInfo, initialiseSerialization: Boolean = true, flowManager: FlowManager = NodeFlowManager(configuration.flowOverrides) )</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$GraphiteReporter.forRegistry(metrics) .prefixedWith(getGraphitePrefix(configuration)) .convertDurationsTo(TimeUnit.MILLISECONDS) .convertRatesTo(TimeUnit.SECONDS) .filter(MetricFilter.ALL) .build(PickledGraphite(configuration.graphiteOptions!!.server, configuration.graphiteOptions!!.port))</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$log.info("Multi-threaded state machine manager with ${configuration.enterpriseConfiguration.tuning.flowThreadPoolSize} threads.")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$logger.info("A wrapping key for confidential identities already exists in the configured crypto service ($wrappingCryptoServiceType) under the alias: '$masterKeyAlias'.")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$logger.info("Wrapping key for confidential identities stored in file-based keystore under the alias '$masterKeyAlias'.")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$logger.info("Wrapping key for confidential identities stored in the configured HSM ($cryptoServiceType) under the alias '$masterKeyAlias'.")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$override fun makeFlowLogicRefFactoryImpl(): FlowLogicRefFactoryImpl</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$private</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$return BasicHSMKeyManagementService(cacheFactory, identityService, database, cryptoService, wrappingCryptoService!!, masterKeyAlias, pkToIdCache)</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$return MultiThreadedStateMachineExecutor(metricRegistry, configuration.enterpriseConfiguration.tuning.flowThreadPoolSize)</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$throw ConfigurationException("The crypto service configured for fresh identities ($cryptoServiceLabel) supports the ${cryptoService.getWrappingMode()} mode, but the node is configured to use $mode")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$throw IllegalStateException("The crypto service configured for fresh identities ($wrappingCryptoServiceType) does not contain a key under the alias: $masterKeyAlias.")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$val warningMsg = "If you make use of confidential identities, there is now a more secure way of storing the associated keys, but you have to explicitly enable it with the appropriate configuration. " + "Review the documentation to see how this can be enabled via the `freshIdentitiesConfiguration` entry. Alternatively, you can disable this warning by setting `disableFreshIdentitiesWarning` to true in the node's configuration."</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode$verifyConfiguredModeIsSupported(freshIdentitiesConfig.mode, wrappingCryptoService!!, cryptoServiceConfigBlock.cryptoServiceName)</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Companion$logger.warn("Invalid graphite prefix ${customPrefix} specified in config - got mangled to ${graphiteName}. Only letters, numbers and underscores are allowed")</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Companion$return (legalName.organisation + "_" + legalName.locality + "_" + legalName.country + "_" + Inet6Address.getLocalHost().hostAddress)</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$* All rights reserved. *</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$* IF YOU DO NOT HAVE A VALID WRITTEN LICENSE WITH R3, DO NOT USE THIS SOFTWARE. *</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$* Possession, use, duplication or dissemination of the software is authorized only pursuant to a valid written license from R3. *</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$* This software is proprietary to and embodies the confidential technology of R3 LLC (</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$*************************************************************************************************************************************</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$throw IOException("Unable to set up port forwarding - is SSH on the remote host configured correctly? " + "(port forwarding is not enabled by default)", e)</ID>
    <ID>MaxLineLength:EnterpriseNode.kt$EnterpriseNode.Startup$val versionString = "--- ${versionInfo.vendor} ${versionInfo.releaseVersion} (${versionInfo.revision.take(7)}) ---"</ID>
    <ID>MaxLineLength:EnterpriseNodeTest.kt$EnterpriseNodeTest$@Test fun `when freshIdentitiesConfiguration contains setting for bouncy castle, key management service is initialised with wrapping`()</ID>
    <ID>MaxLineLength:EnterpriseNodeTest.kt$EnterpriseNodeTest$@Test fun `when freshIdentitiesConfiguration contains wrapping mode that is not supported for the configured crypto service, node exits`()</ID>
    <ID>MaxLineLength:EnterpriseNodeTest.kt$EnterpriseNodeTest$assertThatThrownBy { val node = EnterpriseNode(nodeConfig, versionInfo) } .isInstanceOf(ConfigurationException::class.java) .hasMessageContaining("The crypto service configured for fresh identities (BC_SIMPLE) supports the DEGRADED_WRAPPED mode, but the node is configured to use WRAPPED")</ID>
    <ID>MaxLineLength:EnterpriseNodeTest.kt$EnterpriseNodeTest$mutualExclusionConfiguration = MutualExclusionConfiguration(updateInterval = 0, waitInterval = 0)</ID>
    <ID>MaxLineLength:EnumEvolutionSerializer.kt$EnumEvolutionSerializer$val converted = conversions[enumName] ?: throw AMQPNotSerializableException(type, "No rule to evolve enum constant $type::$enumName")</ID>
    <ID>MaxLineLength:EnumEvolutionSerializer.kt$EnumEvolutionSerializer$val ordinal = ordinals[converted] ?: throw AMQPNotSerializableException(type, "Ordinal not found for enum value $type::$converted")</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$assertThatThrownBy { SerializationOutput(sf).serialize(C(RejectMultipleRenameFrom.A)) }.isInstanceOf(NotSerializableException::class.java) .hasToString("Unable to serialize/deserialize net.corda.serialization.internal.amqp.EnumEvolvabilityTests\$RejectMultipleRenameFrom: " + "There are multiple transformations from D, which is not allowed")</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$assertTrue(envelope.transformsSchema.types[WithUnknownTest::class.java.name]!!.containsKey(TransformTypes.Unknown))</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$val envelope = DeserializationInput(sf).deserializeAndReturnEnvelope(SerializedBytes&lt;WrapsUnknown&gt;(sb1)).envelope</ID>
    <ID>MaxLineLength:EnumSerializer.kt$EnumSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:EnumSetSerializer.kt$EnumSetSerializer : Proxy</ID>
    <ID>MaxLineLength:EnumSetSerializer.kt$EnumSetSerializer$EnumSet.complementOf(uncheckedCast&lt;EnumSet&lt;*&gt;, EnumSet&lt;MapSerializer.EnumJustUsedForCasting&gt;&gt;(set)).first().javaClass</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms$"Rename chain from $chainStart to $chainEnd does not end with a known constant in ${constants.keys}"</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms$throw InvalidEnumTransformsException("Rename from $from to $to would rename existing constant in $constants.keys")</ID>
    <ID>MaxLineLength:EnumTransforms.kt$EnumTransforms${ if (from in constants) { throw InvalidEnumTransformsException("Rename from $from to $to would rename existing constant in $constants.keys") } // If there is an existing chain, starting at the "to" node of this edge, then there is a chain from this edge's // "from" to that chain's end. val newEnd = chainStartsToEnds[to] ?: to // If there is an existing chain, ending at the "from" node of this edge, then there is a chain from that chain's start // to this edge's "to". val newStart = chainEndsToStarts[from] ?: from // If either chain ends where it begins, we have closed a loop, and detected a cycle. if (newEnd == from || newStart == to) { throw InvalidEnumTransformsException("Rename cycle detected in rename map starting from $newStart") } // Either update, or create, the chains in both directions. chainStartsToEnds[newStart] = newEnd chainEndsToStarts[newEnd] = newStart }</ID>
    <ID>MaxLineLength:ErrorCodeLoggingTests.kt$ErrorCodeLoggingTests$val linesWithErrorCode = logFile.useLines { lines -&gt; lines.filter { line -&gt; line.contains("[errorCode=") }.filter { line -&gt; line.contains("moreInformationAt=https://errors.corda.net/") }.toList() }</ID>
    <ID>MaxLineLength:ErrorCodeLoggingTests.kt$fun NodeHandle.logFile(): File</ID>
    <ID>MaxLineLength:ErrorCodeRewritePolicy.kt$ErrorCodeRewritePolicy$@Plugin(name = "ErrorCodeRewritePolicy", category = Core.CATEGORY_NAME, elementType = "rewritePolicy", printObject = false)</ID>
    <ID>MaxLineLength:ErrorFlowTransition.kt$ErrorFlowTransition$val (initiatedSessions, newSessions) = bufferErrorMessagesInInitiatingSessions(startingState.checkpoint.sessions, errorMessages)</ID>
    <ID>MaxLineLength:ErrorMessagesTests.kt$ErrorMessagesTests$"Property '$property' or its getter is non public, this renders class 'class $testname\$C' unserializable -&gt; class $testname\$C"</ID>
    <ID>MaxLineLength:ErrorMessagesTests.kt$ErrorMessagesTests$@Ignore("Current behaviour allows for the serialization of objects with private members, this will be disallowed at some point in the future")</ID>
    <ID>MaxLineLength:Event.kt$Event$GeneratedByExternalEvent</ID>
    <ID>MaxLineLength:Event.kt$Event$RetryFlowFromSafePoint : Event</ID>
    <ID>MaxLineLength:Event.kt$Event.EnterSubFlow$data</ID>
    <ID>MaxLineLength:EventGenerator.kt$ErrorFlowsEventGenerator : EventGenerator</ID>
    <ID>MaxLineLength:EventGenerator.kt$ErrorFlowsEventGenerator$private</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$open</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$protected</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$protected val currencyMap: MutableMap&lt;Currency, Long&gt; = mutableMapOf(USD to 0L, GBP to 0L) // Used for estimation of how much money we have in general.</ID>
    <ID>MaxLineLength:EventProcessor.kt$EventProcessor$val status: DeliveryState = if (completer.status == MessageStatus.Acknowledged) Accepted.getInstance() else Rejected()</ID>
    <ID>MaxLineLength:Eventually.kt$ inline fun &lt;R&gt; eventually( duration: Duration = Duration.ofSeconds(5), waitBetween: Duration = Duration.ofMillis(100), waitBefore: Duration = waitBetween, test: () -&gt; R): R</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$private</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$properties.asSequence().zip(localTypeInformation.properties.values.asSequence())</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$properties: Map&lt;String, RemotePropertyInformation&gt;</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$return EnumEvolutionSerializer(localTypeInformation.observedType, localSerializerFactory, conversions, localOrdinals)</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val bestMatchEvolutionConstructor = findEvolverConstructor(localTypeInformation.evolutionConstructors, properties)</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val convertedOrdinals = remoteOrdinals.asSequence().map { (member, ord) -&gt; ord to conversions[member]!! }.toMap()</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val localOrdinals = localTypeInformation.members.asSequence().mapIndexed { ord, member -&gt; member to ord }.toMap()</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory$val propertyTypes = properties.mapValues { (_, info) -&gt; info.type.typeIdentifier.getLocalType(classLoader).asClass() }</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$DefaultEvolutionSerializerFactory${ // The no-op case: although the fingerprints don't match for some reason, we have compatible signatures. // This might happen because of inconsistent type erasure, changes to the behaviour of the fingerprinter, // or changes to the type itself - such as adding an interface - that do not change its serialisation/deserialisation // signature. if (propertyNamesMatch(localTypeInformation)) { // Make sure types are assignment-compatible, and return the local serializer for the type. validateCompatibility(localTypeInformation) return null } // Failing that, we have to create an evolution serializer. val bestMatchEvolutionConstructor = findEvolverConstructor(localTypeInformation.evolutionConstructors, properties) val constructorForEvolution = bestMatchEvolutionConstructor?.constructor ?: localTypeInformation.constructor val evolverProperties = bestMatchEvolutionConstructor?.properties ?: localTypeInformation.properties validateEvolvability(evolverProperties) return buildComposableEvolutionSerializer(localTypeInformation, constructorForEvolution, evolverProperties) }</ID>
    <ID>MaxLineLength:EvolutionSerializerFactory.kt$EvolutionSerializerFactory$ fun getEvolutionSerializer( remote: RemoteTypeInformation, local: LocalTypeInformation): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>MaxLineLength:EvolutionSerializerFactoryTests.kt$EvolutionSerializerFactoryTests$val withNonNullTarget = DeserializationInput(nonStrictFactory).deserialize(SerializedBytes&lt;C&gt;(withoutNullUrl.readBytes()))</ID>
    <ID>MaxLineLength:EvolutionSerializerFactoryTests.kt$EvolutionSerializerFactoryTests$val withNullTarget = DeserializationInput(strictFactory).deserialize(SerializedBytes&lt;C&gt;(withNullUrl.readBytes()))</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val resource = "EvolvabilityTests.evolutionWithCarpentry" val sf = testDefaultFactory() // Uncomment to recreate // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(Evolved("dronf", NewEnum.BUCKLE_MY_SHOE)).bytes) val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserialized = DeserializationInput(sf).deserialize(SerializedBytes&lt;Evolved&gt;(sc2)) assertEquals("dronf", deserialized.fnord) }</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val resource = "EvolvabilityTests.evolutionWithPrimitives" val sf = testDefaultFactory() // Uncomment to recreate // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(ParameterizedContainer(Parameterized(10, setOf(20)))).bytes) val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserialized = DeserializationInput(sf).deserialize(SerializedBytes&lt;ParameterizedContainer&gt;(sc2)) assertEquals(10, deserialized.parameterized?.a) }</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val sf = testDefaultFactory() val resource = "EvolvabilityTests.removeParameterWithCalculatedParameter" // Original version of the class as it was serialised // data class CC(val a: Int, val b: String, val c: String, val d: Int) { // @get:SerializableCalculatedProperty // val e: String get() = "$b $c" // } // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(CC(1, "hello", "world", 2)).bytes) data class CC(val b: String, val d: Int) { @get:SerializableCalculatedProperty val e: String get() = "$b sailor" } val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserializedCC = DeserializationInput(sf).deserialize(SerializedBytes&lt;CC&gt;(sc2)) assertEquals("hello", deserializedCC.b) assertEquals(2, deserializedCC.d) assertEquals("hello sailor", deserializedCC.e) }</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests.Companion$private val DUMMY_NOTARY_PARTY = Party(DUMMY_NOTARY_NAME, Crypto.deriveKeyPairFromEntropy(Crypto.DEFAULT_SIGNATURE_SCHEME, BigInteger.valueOf(20)).public)</ID>
    <ID>MaxLineLength:ExampleConfigTest.kt$ExampleConfigTest$assertThat(ConfigHelper.loadConfig(baseDirectory = baseDirectory, configFile = it).parseAsNodeConfiguration().isValid).isTrue()</ID>
    <ID>MaxLineLength:Examples.kt$Examples$// maybe in the presence of negative interest rates you would want other side of contract to be able to take initiative as well val zero_coupon_bond_2 = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$CompositeMessage$private</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$cause != null &amp;&amp; !visited.contains(cause) -&gt; Objects.hash(*fields, cause.staticLocationBasedHash(hashedFields, visited + cause))</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$error != null &amp;&amp; level.isInRange(Level.FATAL, Level.WARN) -&gt; CompositeMessage("$formattedMessage [errorCode=${error.errorCode()}, moreInformationAt=${error.errorCodeLocationUrl()}]", format, parameters, throwable)</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$fun Throwable.errorCodeLocationUrl()</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$private</ID>
    <ID>MaxLineLength:ExceptionsSerializationTest.kt$ExceptionsSerializationTest</ID>
    <ID>MaxLineLength:ExchangeRateModel.kt$ExchangeRate$ fun exchangeAmount(amount: Amount&lt;Currency&gt;, to: Currency)</ID>
    <ID>MaxLineLength:ExecuteMigrationsCli.kt$ExecuteMigrationsCli : CliWrapperBase</ID>
    <ID>MaxLineLength:Expect.kt$ fun &lt;E&gt; parallel(expectations: List&lt;ExpectCompose&lt;E&gt;&gt;): ExpectCompose&lt;E&gt;</ID>
    <ID>MaxLineLength:Expect.kt$ fun &lt;E&gt; parallel(vararg expectations: ExpectCompose&lt;E&gt;): ExpectCompose&lt;E&gt;</ID>
    <ID>MaxLineLength:Expect.kt$ fun &lt;E&gt; sequence(vararg expectations: ExpectCompose&lt;E&gt;): ExpectCompose&lt;E&gt;</ID>
    <ID>MaxLineLength:Expect.kt$/** * Internally we create a "lazy" state automaton. The outgoing edges are state.getExpectedEvents() modulo additional * matching logic. When an event comes we extract the first edge that matches using state.nextState(event), which * returns the next state and the piece of dsl to be run on the event. If nextState() returns null it means the event * didn't match at all, in this case we either fail (if isStrict=true) or carry on with the same state (if isStrict=false) * * TODO Think about pre-compiling the state automaton, possibly introducing regexp constructs. This requires some * thinking, as the [parallel] construct blows up the state space factorially, so we need some clever lazy expansion * of states. */ var state = ExpectComposeState.fromExpectCompose(expectCompose())</ID>
    <ID>MaxLineLength:Expect.kt$/** * This file defines a simple DSL for testing non-deterministic sequence of events arriving on an [Observable]. * * [sequence] is used to impose ordering invariants on the stream, whereas [parallel] allows events to arrive in any order. * * The only restriction on [parallel] is that we should be able to discriminate which branch to take based on the * arrived event's type and optionally custom matching logic. If this is ambiguous the first matching piece of DSL will * be run. * * [sequence]s and [parallel]s can be nested arbitrarily * * Example usage: * * val stream: Observable&lt;SomeEvent&gt; = (..) * stream.expectEvents { * sequence( * expect { event: SomeEvent.A -&gt; require(event.isOk()) }, * parallel( * expect { event.SomeEvent.B -&gt; }, * expect { event.SomeEvent.C -&gt; } * ) * ) * } * * The above will test our expectation that the stream should first emit an A, and then a B and C in unspecified order. */ private val log: Logger = LoggerFactory.getLogger("Expect")</ID>
    <ID>MaxLineLength:Expect.kt$log.info("$event :: ${expectedStates.map { it.simpleName }} -&gt; ${next?.second?.getExpectedEvents()?.map { it.simpleName }}")</ID>
    <ID>MaxLineLength:Explorer.kt$Explorer${ // Make sure that the explorer has cordapps on its class path. This is only necessary because currently apps // require the original class files to deserialise states: Kryo serialisation doesn't let us write generic // tools that work with serialised data structures. But the AMQP serialisation revamp will fix this by // integrating the class carpenter, so, we can eventually get rid of this function. // // Note: does not copy dependencies because we should soon be making all apps fat jars and dependencies implicit. // // TODO: Remove this code when serialisation has been upgraded. val cordappsDir = config.explorerDir / NodeConfig.CORDAPP_DIR_NAME cordappsDir.createDirectories() config.cordappsDir.list { it.forEachOrdered { path -&gt; val destPath = cordappsDir / path.fileName.toString() try { // Try making a symlink to make things faster and use less disk space. Files.createSymbolicLink(destPath, path) } catch (e: UnsupportedOperationException) { // OS doesn't support symbolic links? path.copyTo(destPath, REPLACE_EXISTING) } catch (e: java.nio.file.FileAlreadyExistsException) { // OK, don't care ... } catch (e: IOException) { // Windows 10 might not allow this user to create a symlink log.warn("Failed to create symlink '{}' for '{}': {}", destPath, path, e.message) path.copyTo(destPath, REPLACE_EXISTING) } } } }</ID>
    <ID>MaxLineLength:ExposeJpaToFlowsTests.kt$ExposeJpaToFlowsTests$FooSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:ExposeJpaToFlowsTests.kt$ExposeJpaToFlowsTests.FooSchemaV1$PersistentFoo : Serializable</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$CordaRPCClient(NetworkHostAndPort("localhost", rpcPort)).start(aliceUser.username, aliceUser.password)</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$aliceNode.rpc.startFlow(::CashIssueFlow, 100.POUNDS, OpaqueBytes.of(0), defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$aliceNode.rpc.startFlow(::CashPaymentFlow, 5.POUNDS, bobNode.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = false)).whenever(it)</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$driver</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$private</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$private fun CordaRPCOps.vaultTotal()</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$reconnectTimeout += defaultConfig.retryInterval().toMillis() * defaultConfig.retryIntervalMultiplier().pow(it - 1)</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$startNode(providedName = ALICE_NAME, rpcUsers = listOf(aliceUser), customOverrides = nodeConfiguration).getOrThrow()</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$val aliceNode = startNode(providedName = ALICE_NAME, rpcUsers = listOf(aliceUser), customOverrides = nodeConfiguration).getOrThrow()</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$val aliceNode = startNode(providedName = ALICE_NAME, rpcUsers = listOf(aliceUser), customOverrides = nodeConfiguration).getOrThrow() // Check node is running by calling and RPC CordaRPCClient(aliceNode.rpcAddress).start(aliceUser.username, aliceUser.password).use { try { val nodeInfo = it.proxy.nodeInfo() assertEquals(nodeInfo.legalIdentities.first().name, ALICE_NAME) } catch (e: RPCException) { fail("Calling RPC nodeInfo failed. Node is not running.") } it.close() } broker.stop() val defaultConfig = MessagingServerConnectionConfiguration.FAIL_FAST var reconnectTimeout = 0.0 (1..defaultConfig.reconnectAttempts(isHa = false)).forEach { reconnectTimeout += defaultConfig.retryInterval().toMillis() * defaultConfig.retryIntervalMultiplier().pow(it - 1) } // Wait for the configured reconnection time to pass before attempting and RPC connection and check whether the node is stopped or running Thread.sleep(reconnectTimeout.toLong()) try { CordaRPCClient(aliceNode.rpcAddress).start(aliceUser.username, aliceUser.password) } catch (e: RPCException) { assertEquals("Cannot connect to server(s). Tried with all available servers.", e.message) }</ID>
    <ID>MaxLineLength:ExternalBrokerTests.kt$ExternalBrokertests$val broker = createArtemis(p2pPort, baseDir = rootDir / "broker", certificateDir = nodeBaseDir / "certificates")</ID>
    <ID>MaxLineLength:ExternalIdMappingTest.kt$ExternalIdMappingTest$vaultService.queryBy&lt;DummyState&gt;(QueryCriteria.VaultQueryCriteria(externalIds = listOf(UUID.randomUUID()))).states</ID>
    <ID>MaxLineLength:ExternalMasterElectionService.kt$ExternalMasterElectionService$BullyLeaderClient(ForwardingArtemisMessageClient(artemisService), conf.haConfig!!.haTopic, nodeId, leaderPriority)</ID>
    <ID>MaxLineLength:ExternalMasterElectionService.kt$ExternalMasterElectionService$if (zkOnly) mode = ElectorMode.ZOOKEEPER else if (bullyOnly) mode = ElectorMode.BULLY_OVER_ARTEMIS else throw IllegalArgumentException("Unsupported elector URL")</ID>
    <ID>MaxLineLength:ExternalMasterElectionService.kt$ExternalMasterElectionService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:ExternalMasterElectionService.kt$ExternalMasterElectionService$require(zkOnly xor bullyOnly) { "Only all Zookeeper HA mode 'zk://IPADDR:PORT, or Bully Algorithm mode 'bully://localhost' supported" }</ID>
    <ID>MaxLineLength:ExternalMasterElectionService.kt$ExternalMasterElectionService$val bullyOnly = (connectionStrings.size == 1) &amp;&amp; (connectionStrings.single().toLowerCase() == "bully://localhost")</ID>
    <ID>MaxLineLength:ExternalSourceRevocationChecker.kt$ExternalSourceRevocationChecker : PKIXRevocationChecker</ID>
    <ID>MaxLineLength:FastThreadLocalTest.kt$FastThreadLocalTest$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow$otherSide: FlowSession</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow${ // This can happen when another transaction will insert the same attachment during this transaction. // The outcome is the same (the attachment is imported), so we can ignore this exception. logger.debug { "Attachment ${attachment.id} already inserted." } }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment.Token$override fun fromToken(context: SerializeAsTokenContext)</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$IllegalTransactionRequest : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$MissingNetworkParameters : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$if (stx == null) toFetch += txid else // Although the full object is loaded here, only return the id. This prevents the full set of objects already present from // being checkpointed every time a request is made to download an object the node does not yet have. fromDisk += txid</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$logger.debug { "Requesting ${toFetch.size} dependency(s) for verification from ${otherSideSession.counterparty.name}" }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow${ // We skip the validation here (with unwrap { it }) because we will do it below in validateFetchResponse. // The only thing checked is the object type. It is a protocol violation to send results out of order. // TODO We need to page here after large messages will work. maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it } }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow${ logger.debug { "Requesting ${toFetch.size} dependency(s) for verification from ${otherSideSession.counterparty.name}" } // TODO: Support "large message" response streaming so response sizes are not limited by RAM. // We can then switch to requesting items in large batches to minimise the latency penalty. // This is blocked by bugs ARTEMIS-1278 and ARTEMIS-1279. For now we limit attachments and txns to 10mb each // and don't request items in batch, which is a performance loss, but works around the issue. We have // configured Artemis to not fragment messages up to 10mb so we can send 10mb messages without problems. // Above that, we start losing authentication data on the message fragments and take exceptions in the // network layer. val maybeItems = ArrayList&lt;W&gt;(toFetch.size) for (hash in toFetch) { // We skip the validation here (with unwrap { it }) because we will do it below in validateFetchResponse. // The only thing checked is the object type. It is a protocol violation to send results out of order. // TODO We need to page here after large messages will work. maybeItems += otherSideSession.sendAndReceive&lt;List&lt;W&gt;&gt;(Request.Data(NonEmptySet.of(hash), dataType)).unwrap { it } } // Check for a buggy/malicious peer answering with something that we didn't ask for. val downloaded = validateFetchResponse(UntrustworthyData(maybeItems), toFetch) logger.debug { "Fetched ${downloaded.size} elements from ${otherSideSession.counterparty.name}" } maybeWriteToDisk(downloaded) // Re-load items already present before the download procedure. This ensures these objects are not unnecessarily checkpointed. val loadedFromDisk = loadExpected(fromDisk) Result(loadedFromDisk, downloaded) }</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow$otherSide: FlowSession</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchTransactionsFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationCheckingInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:FiberMonitor.kt$FiberMonitor$val transactions = threadLocals.mapNotNull { it as? DatabaseTransaction }.flatMap { getTransactionStack(it) }</ID>
    <ID>MaxLineLength:FiberMonitor.kt$MonitorEventCorrelator</ID>
    <ID>MaxLineLength:FiberUtils.kt$// TODO: This method uses a built-in Quasar function to make a map of all ThreadLocals. This is probably inefficient, but the only API readily available. fun &lt;V, T&gt; Fiber&lt;V&gt;.swappedOutThreadLocalValue(threadLocal: ThreadLocal&lt;T&gt;): T?</ID>
    <ID>MaxLineLength:FiberUtils.kt$private fun &lt;T&gt; ThreadLocal&lt;T&gt;.initialValue(): T?</ID>
    <ID>MaxLineLength:FiberUtils.kt$private val fiberThreadLocalsField: Field = Fiber::class.java.getDeclaredField("fiberLocals").apply { this.isAccessible = true }</ID>
    <ID>MaxLineLength:FiberUtils.kt$return (@Suppress("UNCHECKED_CAST") (ThreadAccess.toMap(threadLocals)[threadLocal] as T?)) ?: threadLocal.initialValue()</ID>
    <ID>MaxLineLength:FilterServiceTest.kt$FilterServiceTest$doReturn(ArtemisMessagingComponent.Companion.P2PMessagingHeaders.whitelistedHeaders.toList()).whenever(it).whitelistedHeaders</ID>
    <ID>MaxLineLength:FilterServiceTest.kt$FilterServiceTest$doReturn(dummySession).whenever(it).createSession(ArtemisMessagingComponent.NODE_P2P_USER, ArtemisMessagingComponent.NODE_P2P_USER, false, true, true, false, ActiveMQClient.DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:FilterServiceTest.kt$FilterServiceTest$doReturn(it).whenever(it).putStringProperty(ArgumentMatchers.any&lt;SimpleString&gt;(), ArgumentMatchers.any&lt;SimpleString&gt;())</ID>
    <ID>MaxLineLength:FilterServiceTest.kt$FilterServiceTest$verify(dummyProducer, times(0)).send(ArgumentMatchers.any(), eq(dummyMessage), ArgumentMatchers.any())</ID>
    <ID>MaxLineLength:FilterServiceTest.kt$FilterServiceTest$verify(dummyProducer, times(1)).send(ArgumentMatchers.any(), eq(dummyMessage), ArgumentMatchers.any())</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$"${session.counterparty} has finished prematurely and we're trying to send them the finalised transaction. "</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$"Do not provide flow sessions for the local node. FinalityFlow will record the notarised transaction locally."</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$/** * Notarise the given transaction and broadcast it to all the participants. * * @param transaction What to commit. * @param sessions A collection of [FlowSession]s for each non-local participant of the transaction. Sessions to non-participants can * also be provided. */ @JvmOverloads constructor( transaction: SignedTransaction, sessions: Collection&lt;FlowSession&gt;, progressTracker: ProgressTracker = tracker() ) : this(transaction, emptyList(), progressTracker, sessions, true)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$/** * Notarise the given transaction and broadcast it to all the participants. * * @param transaction What to commit. * @param sessions A collection of [FlowSession]s for each non-local participant. * @param oldParticipants An **optional** collection of parties for participants who are still using the old API. * * You will only need to use this parameter if you have upgraded your CorDapp from the V3 FinalityFlow API but are required to provide * backwards compatibility with participants running V3 nodes. If you're writing a new CorDapp then this does not apply and this * parameter should be ignored. */ @Deprecated(DEPRECATION_MSG) constructor( transaction: SignedTransaction, sessions: Collection&lt;FlowSession&gt;, oldParticipants: Collection&lt;Party&gt;, progressTracker: ProgressTracker ) : this(transaction, oldParticipants, progressTracker, sessions, true)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, extraRecipients: Set&lt;Party&gt;) : this(transaction, extraRecipients, tracker(), emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, progressTracker: ProgressTracker) : this(transaction, emptySet(), progressTracker, emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$if (notary != null) transaction.verifySignaturesExcept(notary.owningKey) else transaction.verifyRequiredSignatures()</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$logger</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$require(it.isEmpty()) { "The following parties are specified both in flow sessions and in the oldParticipants list: $it" }</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$val commandDataTypes = transaction.tx.commands.asSequence().mapNotNull { it.value::class.qualifiedName }.distinct()</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow.Companion$"accept notarised transactions without first checking their relevancy. Instead, use one of the constructors "</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow.Companion$private const</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$private val statesToRecord: StatesToRecord = ONLY_RELEVANT</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$return subFlow(object : ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = true, statesToRecord = statesToRecord) { override fun checkBeforeRecording(stx: SignedTransaction) { require(expectedTxId == null || expectedTxId == stx.id) { "We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was" + "not recorded and nor its states sent to the vault." } } })</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow.&lt;no name provided&gt;$"We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was"</ID>
    <ID>MaxLineLength:FinalityFlowMigration.kt$ExistingInitiatingFlow : FlowLogic</ID>
    <ID>MaxLineLength:FinalityFlowMigration.kt$ExistingInitiatingFlow${ // Otherwise they're at least on version 2 and so we can send the finalised transaction on the existing session. subFlow(FinalityFlow(fullySignedTx, session)) }</ID>
    <ID>MaxLineLength:FinalityFlowMigration.kt$ExistingResponderFlow${ // The other side is not using the old CorDapp so call ReceiveFinalityFlow to record the finalised transaction. // If SignTransactionFlow is used then we can verify the tranaction we receive for recording is the same one // that was just signed. subFlow(ReceiveFinalityFlow(otherSide, expectedTxId = txWeJustSigned.id)) }</ID>
    <ID>MaxLineLength:FinalityFlowTests.kt$FinalityFlowTests$override val mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:FinalityHandlerTest.kt$FinalityHandlerTest$( legalName = BOB_NAME, // The node disables the FinalityHandler completely if there are no old CorDapps loaded, so we need to add // a token old CorDapp to keep the handler running. additionalCordapps = setOf(DUMMY_CONTRACTS_CORDAPP.copy(targetPlatformVersion = 3)) )</ID>
    <ID>MaxLineLength:FinalityHandlerTest.kt$FinalityHandlerTest$val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:FinalityHandlerTest.kt$FinalityHandlerTest${ // Setup a network where only Alice has the finance CorDapp and it sends a cash tx to Bob who doesn't have the // CorDapp. Bob's FinalityHandler will error when validating the tx. val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS)) var bob = mockNet.createNode(InternalMockNodeParameters( legalName = BOB_NAME, // The node disables the FinalityHandler completely if there are no old CorDapps loaded, so we need to add // a token old CorDapp to keep the handler running. additionalCordapps = setOf(DUMMY_CONTRACTS_CORDAPP.copy(targetPlatformVersion = 3)) )) val stx = alice.issueCashTo(bob) val finalityHandlerId = bob.trackFinalityHandlerId().run { alice.finaliseWithOldApi(stx) getOrThrow() } bob.assertFlowSentForObservationDueToConstraintError(finalityHandlerId) assertThat(bob.getTransaction(stx.id)).isNull() bob = mockNet.restartNode(bob) // Since we've not done anything to fix the orignal error, we expect the finality handler to be sent to the hospital // again on restart bob.assertFlowSentForObservationDueToConstraintError(finalityHandlerId) assertThat(bob.getTransaction(stx.id)).isNull() }</ID>
    <ID>MaxLineLength:FinanceJSONSupport.kt$CalendarDeserializer$StringArrayDeserializer.instance.deserialize(parser, context).fold(BusinessCalendar.EMPTY) { acc, name -&gt; acc + loadTestCalendar(name) }</ID>
    <ID>MaxLineLength:FinanceJSONSupport.kt$ExpressionSerializer$override fun serialize(expr: Expression, generator: JsonGenerator, provider: SerializerProvider)</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$BusinessCalendar(stream.reader().readText().split(",").map { BusinessCalendar.parseDateFromString(it) }.toSortedSet())</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$val stream = UnknownCalendar::class.java.getResourceAsStream("/net/corda/finance/workflows/utils/${name}HolidayCalendar.txt") ?: throw UnknownCalendar(name)</ID>
    <ID>MaxLineLength:FingerPrinterTesting.kt$FingerPrinterTestingTests$val customSerializerRegistry: CustomSerializerRegistry = CachingCustomSerializerRegistry(descriptorBasedSerializerRegistry)</ID>
    <ID>MaxLineLength:FingerPrinterTesting.kt$FingerPrinterTestingTests$val typeModel = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, customSerializerRegistry))</ID>
    <ID>MaxLineLength:FirewallAuditService.kt$FirewallAuditService$fun successfulConnectionEvent(address: InetSocketAddress, certificateSubject: String, msg: String, direction: RoutingDirection)</ID>
    <ID>MaxLineLength:FirewallAuditService.kt$FirewallAuditService$fun terminatedConnectionEvent(address: InetSocketAddress, certificateSubject: String?, msg: String, direction: RoutingDirection)</ID>
    <ID>MaxLineLength:FirewallCmdLineOptions.kt$FirewallCmdLineOptions.Companion$logger.warn("Old style config 'bridge.conf' will be used. To prevent this warning in the future, please rename to 'firewall.conf'.")</ID>
    <ID>MaxLineLength:FirewallCmdLineOptions.kt$FirewallCmdLineOptions.Companion$throw IllegalArgumentException("Neither new style config 'firewall.conf', nor old style 'bridge.conf' can be found")</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$BridgeInnerConfiguration</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$BridgeOutboundConfiguration$// Allows override of [KeyStore] details for the artemis connection, otherwise the general top level details are used. val artemisSSLConfiguration: BridgeSSLConfiguration?</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$FirewallConfiguration$// An optional Health Check Phrase which if passed through the channel will cause AMQP Server to echo it back instead of doing normal pipeline processing val healthCheckPhrase: String?</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$FirewallConfiguration$// Initial reconnect interval for link to artemis after [artemisReconnectionIntervalMin] ms the default value is 5000 ms. val artemisReconnectionIntervalMin: Int</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$FirewallConfiguration$// Internal use property which specifies whether Proxy settings, if provided, should be used for CRL retrieval when requested by Float via tunnel. // This makes sense only for Bridge. val useProxyForCrls: Boolean</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$FirewallConfiguration$// p2pConfirmationWindowSize determines the number of bytes buffered by the broker before flushing to disk and // acking the triggering send. Setting this to -1 causes session commits to immediately return, potentially // causing blowup in the broker if the rate of sends exceeds the broker's flush rate. Note also that this window // causes send latency to be around [brokerConnectionTtlCheckInterval] if the window isn't saturated. // This is relevant to bridges, because we push messages into the inbox and use the async acknowledgement responses to reply to sender. val p2pConfirmationWindowSize: Int</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$FirewallMode$FloatOuter</ID>
    <ID>MaxLineLength:FirewallConfiguration.kt$FloatOuterConfiguration</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$BridgeHAConfigImpl : BridgeHAConfig</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$BridgeInboundConfigurationImpl : BridgeInboundConfiguration</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$BridgeOutboundConfigurationImpl$override val proxyConfig: ProxyConfig? = null</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$BridgeOutboundConfigurationImpl$require(alternateArtemisBrokerAddresses.all { it.host != ZERO_ADDRESS }) { "$ZERO_ADDRESS is not allowed in alternateArtemisBrokerAddresses" }</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$CryptoServiceConfigImpl$data</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$FirewallConfigurationImpl$FirewallMode.BridgeInner -&gt; require(bridgeInnerConfig != null &amp;&amp; outboundConfig != null) { "Missing required configuration" }</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$FirewallConfigurationImpl$FirewallMode.FloatOuter -&gt; require(inboundConfig != null &amp;&amp; floatOuterConfig != null) { "Missing required configuration" }</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$FirewallConfigurationImpl$FirewallMode.SenderReceiver -&gt; require(inboundConfig != null &amp;&amp; outboundConfig != null) { "Missing required configuration" }</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$FirewallConfigurationImpl$override val whitelistedHeaders: List&lt;String&gt; = ArtemisMessagingComponent.Companion.P2PMessagingHeaders.whitelistedHeaders.toList()</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$FirewallConfigurationImpl$private</ID>
    <ID>MaxLineLength:FirewallConfigurationImpl.kt$FloatOuterConfigurationImpl$override val tunnelSSLConfiguration: BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:FirewallInstance.kt$FirewallInstance$bridgeSupervisorService = BridgeSupervisorServiceImpl(conf, maxMessageSize!!, firewallAuditService!!, floatSupervisorService!!.amqpListenerService)</ID>
    <ID>MaxLineLength:FirewallInstance.kt$FirewallInstance$bridgeSupervisorService = BridgeSupervisorServiceImpl(conf, maxMessageSize!!, firewallAuditService!!, null)</ID>
    <ID>MaxLineLength:FirewallInstance.kt$FirewallInstance$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:FirewallInstance.kt$FirewallInstance$statusFollower = ServiceStateCombiner(listOf(firewallAuditService, floatSupervisorService, bridgeSupervisorService).filterNotNull())</ID>
    <ID>MaxLineLength:FirewallInstance.kt$FirewallInstance$val networkParamsFile = requireNotNull(conf.networkParametersPath) { "networkParametersPath must be specified." }</ID>
    <ID>MaxLineLength:FirewallInstance.kt$FirewallInstance$when (conf.firewallMode) { // In the SenderReceiver mode the inbound and outbound message paths are run from within a single firewall process. // The process thus contains components that listen for bridge control messages on Artemis. // The process can then initiates TLS/AMQP 1.0 connections to remote peers and transfers the outbound messages. // The process also runs a TLS/AMQP 1.0 server socket, which is can receive connections and messages from peers, // validate the messages and then forwards the packets to the Artemis inbox queue of the node. FirewallMode.SenderReceiver -&gt; { require(maxMessageSize != null &amp;&amp; maxMessageSize!! &gt; 0) { "maxMessageSize not initialised" } floatSupervisorService = FloatSupervisorServiceImpl(conf, firewallAuditService!!) bridgeSupervisorService = BridgeSupervisorServiceImpl(conf, maxMessageSize!!, firewallAuditService!!, floatSupervisorService!!.amqpListenerService) } // In the BridgeInner mode the process runs the full outbound message path as in the SenderReceiver mode, but the inbound path is split. // This 'Bridge Inner/Bridge Controller' process runs the more trusted portion of the inbound path. // In particular the 'Bridge Inner/Bridge Controller' has access to the persisted TLS KeyStore, which it provisions dynamically into the 'Float Outer'. // Also the the 'Bridge Inner' does more complete validation of inbound messages and ensures that they correspond to legitimate // node inboxes, before transferring the message to Artemis. Potentially it might carry out deeper checks of received packets. // However, the 'Bridge Inner' is not directly exposed to the internet, or peers and does not host the TLS/AMQP 1.0 server socket. FirewallMode.BridgeInner -&gt; { require(maxMessageSize != null &amp;&amp; maxMessageSize!! &gt; 0) { "maxMessageSize not initialised" } bridgeSupervisorService = BridgeSupervisorServiceImpl(conf, maxMessageSize!!, firewallAuditService!!, null) } // In the FloatOuter mode this process runs a minimal AMQP proxy that is designed to run in a DMZ zone. // The process holds the minimum data necessary to act as the TLS/AMQP 1.0 receiver socket and tries // to minimise any state. It specifically does not persist the Node TLS keys anywhere, nor does it hold network map information on peers. // The 'Float Outer' does not initiate socket connection anywhere, so that attackers can be easily blocked by firewalls // if they try to invade the system from a compromised 'Float Outer' machine. The 'Float Outer' hosts a control TLS/AMQP 1.0 server socket, // which receives a connection from the 'Bridge Inner/Bridge controller' in the trusted zone of the organisation. // The control channel is ideally authenticated using server/client certificates that are not related to the Corda PKI hierarchy. // Once the control channel is formed it is used to RPC the methods of the BridgeAMQPListenerService to start the publicly visible // TLS/AMQP 1.0 server socket of the Corda node. Thus peer connections will directly terminate onto the activate listener socket and // be validated against the keys/certificates sent across the control tunnel. Inbound messages are given basic checks that do not require // holding potentially sensitive information and are then forwarded across the control tunnel to the 'Bridge Inner' process for more // complete validation checks. FirewallMode.FloatOuter -&gt; { floatSupervisorService = FloatSupervisorServiceImpl(conf, firewallAuditService!!) } }</ID>
    <ID>MaxLineLength:FirewallStartup.kt$FirewallStartup : CordaCliWrapper</ID>
    <ID>MaxLineLength:FirewallStartup.kt$FirewallStartup$"Please see https://docs.corda.net/troubleshooting.html#slow-localhost-resolution for information on how to fix this. "</ID>
    <ID>MaxLineLength:FirewallStartup.kt$FirewallStartup$"This is a known OpenJDK issue on some Linux distributions, please use OpenJDK from zulu.org or Oracle JDK."</ID>
    <ID>MaxLineLength:FirewallStartup.kt$FirewallStartup$"Your computer took over a second to resolve localhost due an incorrect configuration. Corda will work but start very slowly until this is fixed. "</ID>
    <ID>MaxLineLength:FirewallStartup.kt$FirewallStartup$System.`in`.read()</ID>
    <ID>MaxLineLength:FirewallStartup.kt$FirewallStartup$private</ID>
    <ID>MaxLineLength:FirewallVersionInfo.kt$FirewallVersionInfo$/** * Platform version of the firewall which is an integer value which increments on any release where any of the public * API of the entire Corda platform changes. This includes messaging, serialisation, firewall APIs, etc. */ val platformVersion: Int</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$@Suspendable override</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$override</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$val addFixing = object : RatesFixFlow(ptx, handshake.payload.oracle, fixOf, BigDecimal.ZERO, BigDecimal.ONE) { @Suspendable override fun beforeSigning(fix: Fix) { newDeal.generateFix(ptx, StateAndRef(txState, handshake.payload.ref), fix) // We set the transaction's time-window: it may be that none of the contracts need this! // But it can't hurt to have one. ptx.setTimeWindow(serviceHub.clock.instant(), 30.seconds) } @Suspendable override fun filtering(elem: Any): Boolean { return when (elem) { // Only expose Fix commands in which the oracle is on the list of requested signers // to the oracle node, to avoid leaking privacy is Command&lt;*&gt; -&gt; handshake.payload.oracle.owningKey in elem.signers &amp;&amp; elem.value is Fix else -&gt; false } } }</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.FixingRoleDecider$val counterparty = serviceHub.identityService.wellKnownPartyFromAnonymous(parties[1]) ?: throw IllegalStateException("Cannot resolve floater party")</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Floater$override val progressTracker: ProgressTracker = TwoPartyDealFlow.Primary.tracker()</ID>
    <ID>MaxLineLength:FlattenedList.kt$FlattenedList${ // TODO this assumes that if wasAdded() == true then we are adding elements to the getFrom() position val removeStart = c.from val removeRange = c.removed.size val removeEnd = c.from + removeRange val iterator = indexMap.iterator() for (entry in iterator) { val (wrapped, pair) = entry val (index, listener) = pair if (index &gt;= removeStart) { if (index &lt; removeEnd) { wrapped.observableValue.removeListener(listener) iterator.remove() } else { // Shift indices entry.setValue(Pair(index - removeRange, listener)) } } } nextRemove(removeStart, removed.map { it.value }) }</ID>
    <ID>MaxLineLength:FlattenedList.kt$FlattenedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$CertificateStore.of(loadKeyStore(controlMessage.trustStoreBytes, controlMessage.trustStorePassword), String(controlMessage.trustStorePassword), String(controlMessage.trustStorePassword)) .also { wipeKeys(controlMessage.trustStoreBytes, controlMessage.trustStorePassword) }</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$amqpListener.provisionKeysAndActivate(p2pSigningService!!.keyStore(), trustStore, maxMessageSize!!)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$auditService.packetDropEvent(message, "Message exceeds maxMessageSize network parameter, maxMessageSize: [${message.payload.size}], message size: [$maxMessageSize]. Message is acknowledged and dropped.", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$auditService.packetDropEvent(message, "Message topic is not a valid peer namespace ${message.topic}", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$auditService.packetDropEvent(receivedMessage, "Invalid control source legal name!!", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$auditService.packetDropEvent(receivedMessage, "Invalid control topic packet received on topic ${receivedMessage.topic}!!", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$connectSubscriber = controlServer.onConnection.subscribe({ onConnectToControl(it) }, { log.error("Connection event error", it) })</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$p2pSigningService</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$receivedMessage.sourceLegalName</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$tunnelExternalCrlSourceService = TunnelExternalCrlSourceService(amqpControlServer!!, floatClientName, receivedMessage.sourceLink, receivedMessage.sourceLegalName, auditService, controlMessage.bridgeCommTimeout)</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$tunnelSigningService = CryptoServiceSigningService(conf.tunnelingCryptoServiceConfig, FLOAT_NAME, sslConfiguration, name = "Tunnel")</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$val amqpForwardMessage = amqpControl.createMessage(wrappedMessage.serialize(context = SerializationDefaults.P2P_CONTEXT).bytes, FLOAT_DATA_TOPIC, forwardLegalName!!, forwardAddress!!, emptyMap())</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$val sslConfiguration: MutualSslConfiguration = conf.floatOuterConfig?.tunnelSSLConfiguration ?: conf.publicSSLConfiguration</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService$val trustStore = CertificateStore.of(loadKeyStore(controlMessage.trustStoreBytes, controlMessage.trustStorePassword), String(controlMessage.trustStorePassword), String(controlMessage.trustStorePassword)) .also { wipeKeys(controlMessage.trustStoreBytes, controlMessage.trustStorePassword) }</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService${ val sslConfiguration: MutualSslConfiguration = conf.floatOuterConfig?.tunnelSSLConfiguration ?: conf.publicSSLConfiguration // The fact that we pass FLOAT_NAME has no effect as Crypto service obtained will only be used to sign data and never to create new key pairs tunnelSigningService = CryptoServiceSigningService(conf.tunnelingCryptoServiceConfig, FLOAT_NAME, sslConfiguration, name = "Tunnel") tunnelingTruststore = sslConfiguration.trustStore.get() statusFollower = ServiceStateCombiner(listOf(auditService, amqpListener, tunnelSigningService)) }</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService.&lt;no name provided&gt;$// There is no need to have the network maxMessageSize as this value is used to control tunnel messaging. Filtering based on // the network maxMessageSize is done elsewhere override val maxMessageSize: Int = Int.MAX_VALUE</ID>
    <ID>MaxLineLength:FloatControlListenerService.kt$FloatControlListenerService.&lt;no name provided&gt;$override val revocationConfig: RevocationConfig = if (conf.revocationConfig.mode != RevocationConfig.Mode.EXTERNAL_SOURCE) conf.revocationConfig else RevocationConfigImpl(RevocationConfig.Mode.OFF)</ID>
    <ID>MaxLineLength:FloatControlService.kt$FloatControlService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:FloatSupervisorService.kt$FloatSupervisorService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:FloatSupervisorServiceImpl.kt$FloatSupervisorServiceImpl$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:FloatSupervisorServiceImpl.kt$FloatSupervisorServiceImpl$require(conf.haConfig == null) { "Float process should not have HA config, that is controlled via the bridge." }</ID>
    <ID>MaxLineLength:FlowAsyncOperationTests.kt$FlowAsyncOperationTests.WorkerServiceTask$private</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$( // The part of the log message generated by CheckpointIncompatibleException.FlowVersionIncompatibleException "that is incompatible with the current installed version of" )</ID>
    <ID>MaxLineLength:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$assertThat(defaultCordapp.jarFile.hash).isNotEqualTo(modifiedCordapp.jarFile.hash)</ID>
    <ID>MaxLineLength:FlowCheckpointVersionNodeStartupCheckTest.kt$FlowCheckpointVersionNodeStartupCheckTest$bob.rpc.stateMachinesFeed().let { it.updates.map { it.id }.startWith(it.snapshot.map { it.id }) }.toBlocking().first()</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val fullySignedTx: SignedTransaction = subFlow(CollectSignaturesFlow(twiceSignedTx, setOf(counterpartySession, regulatorSession), SIGS_GATHERING.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val notarisedTx1: SignedTransaction = subFlow(FinalityFlow(fullySignedTx, listOf(counterpartySession), FINALISATION.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val notarisedTx2: SignedTransaction = subFlow(FinalityFlow(fullySignedTx, partySessions, FINALISATION.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val otherIdentity2: PartyAndCertificate = serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false)</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val otherIdentity: PartyAndCertificate = serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false)</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val packet2: UntrustworthyData&lt;Boolean&gt; = counterpartySession.sendAndReceive&lt;Boolean&gt;("You can send and receive any class!")</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val txState: TransactionState&lt;DummyState&gt; = TransactionState(ourOutputState, DummyContract.PROGRAM_ID, specificNotary)</ID>
    <ID>MaxLineLength:FlowCookbook.kt$ResponderFlow${ // The ``ResponderFlow` has all the same APIs available. It looks // up network information, sends and receives data, and constructs // transactions in exactly the same way. /**----------------------------- * SENDING AND RECEIVING DATA * -----------------------------**/ progressTracker.currentStep = RECEIVING_AND_SENDING_DATA // We need to respond to the messages sent by the initiator: // 1. They sent us an ``Any`` instance // 2. They waited to receive an ``Integer`` instance back // 3. They sent a ``String`` instance and waited to receive a // ``Boolean`` instance back // Our side of the flow must mirror these calls. // DOCSTART 08 val any: Any = counterpartySession.receive&lt;Any&gt;().unwrap { data -&gt; data } val string: String = counterpartySession.sendAndReceive&lt;String&gt;(99).unwrap { data -&gt; data } counterpartySession.send(true) // DOCEND 08 /**---------------------------------------- * RESPONDING TO COLLECT_SIGNATURES_FLOW * ----------------------------------------**/ progressTracker.currentStep = SIGNING // The responder will often need to respond to a call to // ``CollectSignaturesFlow``. It does so my invoking its own // ``SignTransactionFlow`` subclass. // DOCSTART 16 val signTransactionFlow: SignTransactionFlow = object : SignTransactionFlow(counterpartySession) { override fun checkTransaction(stx: SignedTransaction) = requireThat { // Any additional checking we see fit... val outputState = stx.tx.outputsOfType&lt;DummyState&gt;().single() require(outputState.magicNumber == 777) } } val idOfTxWeSigned = subFlow(signTransactionFlow).id // DOCEND 16 /**----------------------------- * FINALISING THE TRANSACTION * -----------------------------**/ progressTracker.currentStep = FINALISATION // As the final step the responder waits to receive the notarised transaction from the sending party // Since it knows the ID of the transaction it just signed, the transaction ID is specified to ensure the correct // transaction is received and recorded. // DOCSTART ReceiveFinalityFlow subFlow(ReceiveFinalityFlow(counterpartySession, expectedTxId = idOfTxWeSigned)) // DOCEND ReceiveFinalityFlow }</ID>
    <ID>MaxLineLength:FlowException.kt$FlowException : CordaExceptionIdentifiableException</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$aliceNode = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, flowManager = aliceFlowManager))</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(0, charlieNode.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(0, node2b.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload + 1, secondFlow.getOrThrow().receivedPayload2, "Received payload does not match the expected second value on Node 2")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload, secondFlow.getOrThrow().receivedPayload, "Received payload does not match the (restarted) first value on Node 2")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload2 + 1, firstAgain.receivedPayload2, "Received payload does not match the expected second value on Node 3")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$mockNet.messagingNetwork.sentMessages.toSessionTransfers().filter { it.isPayloadTransfer }.forEach { sentCount++ }</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests${ val payload = random63BitValue() val payload2 = random63BitValue() var sentCount = 0 mockNet.messagingNetwork.sentMessages.toSessionTransfers().filter { it.isPayloadTransfer }.forEach { sentCount++ } val charlieNode = mockNet.createNode(InternalMockNodeParameters(legalName = CHARLIE_NAME)) val secondFlow = charlieNode.registerCordappFlowFactory(PingPongFlow::class) { PingPongFlow(it, payload2) } mockNet.runNetwork() val charlie = charlieNode.info.singleIdentity() // Kick off first send and receive bobNode.services.startFlow(PingPongFlow(charlie, payload)) bobNode.database.transaction { assertEquals(1, bobNode.internals.checkpointStorage.checkpoints().size) } // Make sure the add() has finished initial processing. bobNode.internals.disableDBCloseOnStop() // Restart node and thus reload the checkpoint and resend the message with same UUID bobNode.dispose() bobNode.database.transaction { assertEquals(1, bobNode.internals.checkpointStorage.checkpoints().size) // confirm checkpoint bobNode.services.networkMapCache.clearNetworkMapCache() } val node2b = mockNet.createNode(InternalMockNodeParameters(bobNode.internals.id)) bobNode.internals.manuallyCloseDB() val (firstAgain, fut1) = node2b.getSingleFlow&lt;PingPongFlow&gt;() // Run the network which will also fire up the second flow. First message should get deduped. So message data stays in sync. mockNet.runNetwork() fut1.getOrThrow() val receivedCount = receivedSessionMessages.count { it.isPayloadTransfer } // Check flows completed cleanly and didn't get out of phase assertEquals(4, receivedCount, "Flow should have exchanged 4 unique messages")// Two messages each way // can't give a precise value as every addMessageHandler re-runs the undelivered messages assertTrue(sentCount &gt; receivedCount, "Node restart should have retransmitted messages") node2b.database.transaction { assertEquals(0, node2b.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended") } charlieNode.database.transaction { assertEquals(0, charlieNode.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended") } assertEquals(payload2, firstAgain.receivedPayload, "Received payload does not match the first value on Node 3") assertEquals(payload2 + 1, firstAgain.receivedPayload2, "Received payload does not match the expected second value on Node 3") assertEquals(payload, secondFlow.getOrThrow().receivedPayload, "Received payload does not match the (restarted) first value on Node 2") assertEquals(payload + 1, secondFlow.getOrThrow().receivedPayload2, "Received payload does not match the expected second value on Node 2") }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$CommitReceiverFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$CommitterFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$SuspendThrowingActionExecutor : ActionExecutor</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$WaitForLedgerCommitFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$aliceNode.registerCordappFlowFactory(WaitForLedgerCommitFlow::class) { ExceptionFlow { throw Exception("Error") } }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$aliceNode.sendSessionMessage(InitialSessionMessage(SessionId(random63BitValue()), 0, "not.a.real.Class", 1, "", null), bob)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$aliceNode.sendSessionMessage(InitialSessionMessage(SessionId(random63BitValue()), 0, String::class.java.name, 1, "", null), bob)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat((lastMessage.payload as RejectSessionMessage).message).isEqualTo("${String::class.java.name} is not a flow")</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat(committerStx.getOrThrow()).isEqualTo(waiterStx.getOrThrow()).isEqualTo(commitReceiverStx.getOrThrow())</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat(receivedSessionMessages).hasSize(1)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat(receivedSessionMessages.filter { it.message is ExistingSessionMessage &amp;&amp; it.message.payload is ErrorSessionMessage }).hasSize(1)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThatExceptionOfType(MyFlowException::class.java) .isThrownBy { receivingFiber.resultFuture.getOrThrow() } .withMessage("Nothing useful") .withStackTraceContaining(ReceiveFlow::class.java.name)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThatExceptionOfType(MyPeerFlowException::class.java) .isThrownBy { receivingFiber.resultFuture.getOrThrow() } .has(Condition(Predicate&lt;MyPeerFlowException&gt; { it.peer == alice }, "subclassed peer field has original value"))</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$bobNode.registerCordappFlowFactory(UpgradedFlow::class, initiatedFlowVersion = 1) { InitiatedSendFlow("Old initiated", it) }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$bobNode.smm.flowHospital.dropSessionInit(sessionInitRecord.id)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$fiber.transientValues = TransientReference(fiber.transientValues!!.value.copy(actionExecutor = throwingActionExecutor))</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val anonymousBob = bobNode.services.keyManagementService.freshKeyAndCert(bobNode.info.legalIdentitiesAndCerts.single(), false)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val anonymousBob = bobNode.services.keyManagementService.freshKeyAndCert(bobNode.info.legalIdentitiesAndCerts.single(), false) .party.anonymise()</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val bobResponderFlow = bobNode.registerCordappFlowFactory(SendAndReceiveFlow::class) { SingleInlinedSubFlow(it) }</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val result = aliceNode.services.startFlow(SendAndReceiveFlow(anonymousBob.party.anonymise(), "Hello")).resultFuture</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$val throwingActionExecutor = SuspendThrowingActionExecutor(exceptionDuringSuspend, fiber.transientValues!!.value.actionExecutor)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.ConditionalExceptionFlow$private</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.IncorrectCustomSendFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.UpgradedFlow$@InitiatingFlow(version = 2) private</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests.WaitForOtherSideEndBeforeSendAndReceive$@Transient val receivedOtherFlowEnd: Semaphore</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$InitiatedSendFlow$internal open</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$PingPongFlow$@InitiatingFlow internal</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$PingPongFlow$constructor(otherPartySession: FlowSession, payload: Long) : this(otherPartySession.counterparty, payload, otherPartySession)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$SendAndReceiveFlow$@InitiatingFlow internal</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$SendAndReceiveFlow$constructor(otherPartySession: FlowSession, payload: Any) : this(otherPartySession.counterparty, payload, otherPartySession)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal fun errorMessage(errorResponse: FlowException? = null)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal fun sessionConfirm(flowVersion: Int = 1)</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal infix fun Pair&lt;Int, SessionMessage&gt;.to(node: TestStartedNode): SessionTransfer</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$internal infix fun TestStartedNode.sent(message: SessionMessage): Pair&lt;Int, SessionMessage&gt;</ID>
    <ID>MaxLineLength:FlowFrameworkTestsUsingMultithreadedSMM.kt$FlowFrameworkTestsUsingMultithreadedSMM$aliceNode.sendSessionMessage(InitialSessionMessage(SessionId(random63BitValue()), 0, "not.a.real.Class", 1, "", null), bob)</ID>
    <ID>MaxLineLength:FlowFrameworkTestsUsingMultithreadedSMM.kt$FlowFrameworkTestsUsingMultithreadedSMM$assertThat(receivedSessionMessages).hasSize(1)</ID>
    <ID>MaxLineLength:FlowFrameworkTestsUsingMultithreadedSMM.kt$FlowFrameworkTestsUsingMultithreadedSMM$bobNode.smm.flowHospital.dropSessionInit(sessionInitRecord.id)</ID>
    <ID>MaxLineLength:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$charlieNode.registerCordappFlowFactory(ReceiveFlow::class) { ExceptionFlow { MyFlowException("Nothing useful") } }</ID>
    <ID>MaxLineLength:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$val actualForNode = receivedSessionMessages.filter { it.from == node.internals.id || it.to == node.network.myAddress }</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandle&lt;A&gt; : FlowHandle</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$// For API compatibility fun copy(id: StateMachineRunId, returnValue: CordaFuture&lt;A&gt;, progress: Observable&lt;String&gt;): FlowProgressHandleImpl&lt;A&gt;</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$override val stepsTreeFeed: DataFeed&lt;List&lt;Pair&lt;Int, String&gt;&gt;, List&lt;Pair&lt;Int, String&gt;&gt;&gt;? = null</ID>
    <ID>MaxLineLength:FlowHandle.kt$FlowProgressHandleImpl$return copy(id = id, returnValue = returnValue, progress = progress, stepsTreeFeed = null, stepsTreeIndexFeed = null)</ID>
    <ID>MaxLineLength:FlowHookContainer.kt$FlowHookContainer$FiberMonitor.newEvent(MonitorEvent(MonitorEventType.ConnectionAcquired, keys = listOf(transactionOrThread, connection)))</ID>
    <ID>MaxLineLength:FlowHookContainer.kt$FlowHookContainer$FiberMonitor.newEvent(MonitorEvent(MonitorEventType.ConnectionReleased, keys = listOf(transactionOrThread, connection)))</ID>
    <ID>MaxLineLength:FlowHookContainer.kt$FlowHookContainer$FiberMonitor.newEvent(MonitorEvent(MonitorEventType.FiberException, keys = listOf(Fiber.currentFiber()), extra = exception))</ID>
    <ID>MaxLineLength:FlowHookContainer.kt$FlowHookContainer$FiberMonitor.newEvent(MonitorEvent(MonitorEventType.SendSessionMessage, keys = listOf(currentFiberOrThread(), sessionId)))</ID>
    <ID>MaxLineLength:FlowHookContainer.kt$FlowHookContainer$FiberMonitor.newEvent(MonitorEvent(MonitorEventType.SmScheduleEvent, keys = listOf(fiber), extra = listOf(event, currentFiberOrThread())))</ID>
    <ID>MaxLineLength:FlowHospitalTest.kt$FlowHospitalTest$SpendFlowWithCustomException : FlowLogic</ID>
    <ID>MaxLineLength:FlowHospitalTest.kt$FlowHospitalTest$val aliceClient = CordaRPCClient(alice.rpcAddress).start(FlowHospitalTest.rpcUser.username, FlowHospitalTest.rpcUser.password).proxy</ID>
    <ID>MaxLineLength:FlowHospitalTest.kt$FlowHospitalTest$val charlieClient = CordaRPCClient(charlie.rpcAddress).start(FlowHospitalTest.rpcUser.username, FlowHospitalTest.rpcUser.password).proxy</ID>
    <ID>MaxLineLength:FlowInitiator.kt$FlowInitiator : Principal</ID>
    <ID>MaxLineLength:FlowInitiator.kt$FlowInitiator$/** * Returns an [InvocationContext], which is equivalent to this object but expressed using the successor to this * class hierarchy (which is now deprecated). The returned object has less information than it could have, so * prefer to use fetch an invocation context directly if you can (e.g. in [net.corda.core.messaging.StateMachineInfo]) */ val invocationContext: InvocationContext get() { val unknownName = CordaX500Name("UNKNOWN", "UNKNOWN", "GB") var actor: Actor? = null val origin: InvocationOrigin when (this) { is FlowInitiator.RPC -&gt; { actor = Actor(Actor.Id(this.username), AuthServiceId("UNKNOWN"), unknownName) origin = InvocationOrigin.RPC(actor) } is FlowInitiator.Peer -&gt; origin = InvocationOrigin.Peer(this.party.name) is FlowInitiator.Service -&gt; origin = InvocationOrigin.Service(this.serviceClassName, unknownName) FlowInitiator.Shell -&gt; origin = InvocationOrigin.Shell is FlowInitiator.Scheduled -&gt; origin = InvocationOrigin.Scheduled(this.scheduledState) } return InvocationContext.newInstance(origin = origin, actor = actor) }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Deprecated("Use FlowSession.getCounterpartyFlowInfo()", level = DeprecationLevel.WARNING) @Suspendable fun getFlowInfo(otherParty: Party): FlowInfo</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Deprecated("Use FlowSession.sendAndReceive()", level = DeprecationLevel.WARNING) @Suspendable open fun &lt;R : Any&gt; sendAndReceive(receiveType: Class&lt;R&gt;, otherParty: Party, payload: Any): UntrustworthyData&lt;R&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun &lt;R : Any&gt; receiveAll(receiveType: Class&lt;R&gt;, sessions: List&lt;FlowSession&gt;, maySkipCheckpoint: Boolean = false): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun receiveAllMap(sessions: Map&lt;FlowSession, Class&lt;out Any&gt;&gt;, maySkipCheckpoint: Boolean = false): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable fun initiateFlow(destination: Destination): FlowSession</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable fun waitForStateConsumption(stateRefs: Set&lt;StateRef&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Throws(FlowException::class) fun checkFlowPermission(permissionName: String, extraAuditData: Map&lt;String, String&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun recordAuditEvent(eventType: String, comment: String, extraAuditData: Map&lt;String, String&gt;)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun trackStepsTree(): DataFeed&lt;List&lt;Pair&lt;Int, String&gt;&gt;, List&lt;Pair&lt;Int, String&gt;&gt;&gt;?</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ fun trackStepsTreeIndex(): DataFeed&lt;Int, Int&gt;?</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * @suppress * Internal only. Reference to the [co.paralleluniverse.fibers.Fiber] instance that is the top level controller for * the entire flow. When inside a flow this is equivalent to [co.paralleluniverse.strands.Strand.currentStrand]. This * is public only because it must be accessed across module boundaries. */ var stateMachine: FlowStateMachine&lt;*&gt; @CordaInternal get() = _stateMachine ?: throw IllegalStateException( "You cannot access the flow's state machine until the flow has been started.") @CordaInternal set(value) { _stateMachine = value }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Override this to provide a [ProgressTracker]. If one is provided and stepped, the framework will do something * helpful with the progress reports e.g record to the audit service. If this flow is invoked as a subflow of another, * then the tracker will be made a child of the current step in the parent. If it's null, this flow doesn't track * progress. * * Note that this has to return a tracker before the flow is invoked. You can't change your mind half way * through. */ open val progressTracker: ProgressTracker? = DEFAULT_TRACKER()</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Specifies the identity to use for this flow. This will be one of the multiple identities that belong to this node. * This is the same as calling `ourIdentityAndCert.party`. * @see NodeInfo.legalIdentities * * Note: The current implementation returns the single identity of the node. This will change once multiple identities * is implemented. */ val ourIdentity: Party get() = stateMachine.ourIdentity</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$/** * Specifies the identity, with certificate, to use for this flow. This will be one of the multiple identities that * belong to this node. * @see NodeInfo.legalIdentitiesAndCerts * * Note: The current implementation returns the single identity of the node. This will change once multiple identities * is implemented. */ val ourIdentityAndCert: PartyAndCertificate get() { return serviceHub.myInfo.legalIdentitiesAndCerts.find { it.party == stateMachine.ourIdentity } ?: throw IllegalStateException("Identity specified by ${stateMachine.id} (${stateMachine.ourIdentity}) is not one of ours!") }</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$?:</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable @JvmOverloads open</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable internal</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$private</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic.Companion$throw FlowException("Attempt to sleep for longer than 5 minutes is not supported. Consider using SchedulableState.")</ID>
    <ID>MaxLineLength:FlowLogicRef.kt$FlowLogicRef</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl : SingletonSerializeAsTokenFlowLogicRefFactory</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$if (ref !is FlowLogicRefImpl) throw IllegalFlowLogicException(ref.javaClass, "FlowLogicRef was not created via correct FlowLogicRefFactory interface")</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$open</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$private</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$protected open</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$return (value is Any &amp;&amp; parameterAssignableFrom(parameter.type.javaType, value)) || parameter.type.isMarkedNullable</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefImpl$@CordaSerializable data</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager$fun registerInitiatedCoreFlowFactory(initiatingFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;, flowFactory: (FlowSession) -&gt; FlowLogic&lt;*&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager$fun registerInitiatedCoreFlowFactory(initiatingFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;?, flowFactory: (FlowSession) -&gt; FlowLogic&lt;*&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager$fun registerInitiatedCoreFlowFactory(initiatingFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;?, flowFactory: InitiatedFlowFactory.Core&lt;FlowLogic&lt;*&gt;&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$"${InitiatingFlow::class.java.name}.version not applicable for core flows; their version is the node's platform version"</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$// To verify the integrity of the current state, it is important that the tip of the responders is a unique weight // if there are multiple flows with the same weight as the tip, it means that it is impossible to reliably pick one as the responder private fun validateInvariants(toValidate: List&lt;RegisteredFlowContainer&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$@Synchronized override</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$FlowWeightComparator : Comparator</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$log</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$log.warn("Multiple flows are registered for InitiatingFlow: $initiatingFlowClass, currently using: ${listOfFlowsForInitiator.first().initiatedFlowClass}")</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$registerInitiatedCoreFlowFactory(initiatingFlowClass, initiatedFlowClass, InitiatedFlowFactory.Core(flowFactory))</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$throw IllegalArgumentException("$responder must have a constructor accepting a ${FlowSession::class.java.name}")</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val equalWeightAsCurrentTip = toValidate.map { flowWeightComparator.compare(currentTip, it) to it }.filter { it.first == 0 }.map { it.second }</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val flowToAdd = RegisteredFlowContainer(initiatingFlowClass, initiatedFlowClass, flowFactory, FlowType.CORDAPP)</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val message = "Unable to determine which flow to use when responding to: ${currentTip.initiatingFlowClass.canonicalName}. ${equalWeightAsCurrentTip.map { it.initiatedFlowClass!!.canonicalName }} are all registered with equal weight."</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager.FlowWeightComparator$override</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager.FlowWeightComparator$private open</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$@Suspendable override</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val mightDeadlockDrainingTarget = FlowStateMachineImpl.currentStateMachine()?.context?.origin.let { it is InvocationOrigin.Peer &amp;&amp; it.party == target.name }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val networkMessage = serviceHub.networkService.createMessage(sessionTopic, serializeSessionMessage(message).bytes, deduplicationId, message.additionalHeaders(party))</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val wellKnown = requireNotNull(serviceHub.identityService.wellKnownPartyFromAnonymous(destination as AnonymousParty)) { "We do not know who $destination belongs to" }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl${ // Handling Kryo and AMQP serialization problems. Unfortunately the two exception types do not share much of a common exception interface. if ((exception is KryoException || exception is NotSerializableException) &amp;&amp; message is ExistingSessionMessage &amp;&amp; message.payload is ErrorSessionMessage) { val error = message.payload.flowException val rewrappedError = FlowException(error?.message) message.copy(payload = message.payload.copy(flowException = rewrappedError)).serialize() } else { throw exception } }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl${ // This prevents a "deadlock" in case an initiated flow tries to start a session against a draining node that is also the initiator. // It does not help in case more than 2 nodes are involved in a circle, so the kill switch via RPC should be used in that case. val mightDeadlockDrainingTarget = FlowStateMachineImpl.currentStateMachine()?.context?.origin.let { it is InvocationOrigin.Peer &amp;&amp; it.party == target.name } return when { this !is InitialSessionMessage || mightDeadlockDrainingTarget -&gt; emptyMap() else -&gt; mapOf(P2PMessagingHeaders.Type.KEY to P2PMessagingHeaders.Type.SESSION_INIT_VALUE) } }</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$flow.ioRequest()?.let { request -&gt; warningMessageForFlowWaitingOnIo(request, flow, now) }?.let(logger::info)</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.ExecuteAsyncOperation -&gt; "for asynchronous operation of type ${request.operation::javaClass} to complete"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.GetFlowInfo -&gt; "to get flow information from parties ${request.sessions.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.Send -&gt; "to send a message to parties ${request.sessionToMessage.keys.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.SendAndReceive -&gt; "to send and receive messages from parties ${request.sessionToMessage.keys.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.Sleep -&gt; "to wake up from sleep ending at ${LocalDateTime.ofInstant(request.wakeUpAfter, ZoneId.systemDefault())}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.WaitForLedgerCommit -&gt; "for the ledger to commit transaction with hash ${request.hash}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$private</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$private fun FlowStateMachineImpl&lt;*&gt;.ioRequest()</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$scheduler!!.scheduleAtFixedRate({ logFlowsWaitingForParty(suspensionLoggingThreshold) }, 0, monitoringPeriod.toMillis(), TimeUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$val message = StringBuilder("Flow with id ${flow.id.uuid} has been waiting for ${flow.ongoingDuration(now).toMillis() / 1000} seconds ")</ID>
    <ID>MaxLineLength:FlowNameFormatter.kt$FlowNameFormatter.&lt;no name provided&gt;$val split = splitByCharacterTypeCamelCase(flowName).filter { it.compareTo("Flow", true) != 0 } .joinToString(" ")</ID>
    <ID>MaxLineLength:FlowOverrideTests.kt$FlowOverrideTests$assertThat(nodeB.rpc.startFlow(::Ping, nodeA.nodeInfo.singleIdentity()).returnValue.getOrThrow(), `is`(Pong.PONG))</ID>
    <ID>MaxLineLength:FlowOverrideTests.kt$FlowOverrideTests$assertThat(nodeB.rpc.startFlow(::Ping, nodeA.nodeInfo.singleIdentity()).returnValue.getOrThrow(), `is`(Pongiest.GORGONZOLA))</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$@Test fun `SQLTransientConnectionExceptions thrown by hikari are retried 3 times and then kept in the checkpoints table`()</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$it.proxy.startFlow(::GeneralExternalFailureFlow, nodeBHandle.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$it.proxy.startFlow(::InitiatorFlow, numSessions, numIterations, nodeBHandle.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$InitiatorFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$Step</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$WrappedTransientConnectionFailureFlow$throw IllegalStateException("wrapped error message", IllegalStateException("another layer deep", SQLTransientConnectionException("Connection is not available")/*.fillInStackTrace()*/))</ID>
    <ID>MaxLineLength:FlowRunner.kt$FlowRunner</ID>
    <ID>MaxLineLength:FlowRunner.kt$FlowRunner$val flowHandle = rpcClient.startFlowDynamic(CashIssueAndPaymentFlow::class.java, amount, issuerRef, target, false, notary)</ID>
    <ID>MaxLineLength:FlowRunner.kt$FlowRunner$vaultObserver</ID>
    <ID>MaxLineLength:FlowSession.kt$Destination</ID>
    <ID>MaxLineLength:FlowSession.kt$FlowSession$/** * If the destination on the other side of this session is a [Party] then returns that, otherwise throws [IllegalStateException]. * * Only use this method if it's known the other side is a [Party], otherwise use [destination]. * * @throws IllegalStateException if the other side is not a [Party]. * @see destination */ abstract val counterparty: Party</ID>
    <ID>MaxLineLength:FlowSession.kt$FlowSession$/** * The [Destination] on the other side of this session. In the case of a session created by [FlowLogic.initiateFlow] this is the same * destination as the one passed to that function. */ abstract val destination: Destination</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$@Suspendable override</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$val responseValues: Map&lt;FlowSession, SerializedBytes&lt;Any&gt;&gt; = flowStateMachine.suspend(request, maySkipCheckpoint)</ID>
    <ID>MaxLineLength:FlowSnapshotTreeDataManager.kt$FlowSnapshotTreeDataManager$fileNode.add(DefaultMutableTreeNode(Descriptor(snapshot.flowClass, AllIcons.Debugger.Db_primitive, "flowClass")))</ID>
    <ID>MaxLineLength:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$if (it != null &amp;&amp; (it is FlowLogic&lt;*&gt; || it is FlowStateMachine&lt;*&gt; || it is Fiber&lt;*&gt; || it is SerializeAsToken)) { StackFrameDataToken(it::class.java.name) } else { it }</ID>
    <ID>MaxLineLength:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$private</ID>
    <ID>MaxLineLength:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$val stackObjects = if (frameObjectsIterator.hasNext() &amp;&amp; (annotation == null || !annotation.methodOptimized)) { frameObjectsIterator.next() } else { emptyList() }</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$"criteria (specifically: extra objects are introduced to the quasar stack by th Jacoco agent). You can however "</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$@Ignore("When running via gradle the Jacoco agent interferes with the quasar instrumentation process and violates tested" + "criteria (specifically: extra objects are introduced to the quasar stack by th Jacoco agent). You can however " + "run these tests via an IDE.")</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;MultiplePersistingSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;NoSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;PersistingNoSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;PersistingSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;SideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$StackSnapshotFrame$@CordaSerializable data</ID>
    <ID>MaxLineLength:FlowStateMachine.kt$FlowStateMachine$@Suspendable fun &lt;SUSPENDRETURN : Any&gt; suspend(ioRequest: FlowIORequest&lt;SUSPENDRETURN&gt;, maySkipCheckpoint: Boolean): SUSPENDRETURN</ID>
    <ID>MaxLineLength:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest$val sm2 = sm1.checkpointSerialize(context = CheckpointSerializationDefaults.CHECKPOINT_CONTEXT).checkpointDeserialize(context = CheckpointSerializationDefaults.CHECKPOINT_CONTEXT)</ID>
    <ID>MaxLineLength:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest.TestFlowStateMachine$override</ID>
    <ID>MaxLineLength:FlowStateMachineComparatorTest.kt$FlowStateMachineComparatorTest.TestFlowStateMachine$private</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$"${InitiatingFlow::class.java.name}. See https://docs.corda.net/api-flows.html#flowlogic-annotations."</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$?:</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$"Transaction context is missing. This might happen if a suspendable method is not annotated with @Suspendable annotation."</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$/** * Return the logger for this state machine. The logger name incorporates [id] and so including it in the log message * is not necessary. */ override val logger = log</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$// Utilise the behaviour of `ourSenderUUID` to indicate whether we have restarted ever. Can be used to make certain code paths optimistic. internal val isNotRestarted: Boolean get() = (ourSenderUUID != null)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$@Suspendable private</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$Thread.currentThread().contextClassLoader = (serviceHub.cordappProvider as CordappProviderImpl).cordappLoader.appClassLoader</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$errorAndTerminate("Caught unrecoverable error from flow. Forcibly terminating the JVM, this might leave resources open, and most likely will.", t)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$require(continuation == FlowContinuation.ProcessEvents) { "Expected a continuation of type ${FlowContinuation.ProcessEvents}, found $continuation " }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$require(destination is Party || destination is AnonymousParty) { "Unsupported destination type ${destination.javaClass.name}" }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$throw FlowPermissionException("User ${context.principal()} not permissioned for $permissionName on flow $id")</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$val (continuation, newState) = transitionExecutor.executeTransition(this, oldState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$val permissionGranted = true // TODO define permission control service on ServiceHubInternal and actually check authorization.</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$val serializationContext = TransientReference(getTransientField(TransientValues::checkpointSerializationContext))</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl${ // This sets the Cordapp classloader on the contextClassLoader of the current thread. // Needed because in previous versions of the finance app we used Thread.contextClassLoader to resolve services defined in cordapps. Thread.currentThread().contextClassLoader = (serviceHub.cordappProvider as CordappProviderImpl).cordappLoader.appClassLoader val result = logic.call() suspend(FlowIORequest.WaitForSessionConfirmations, maySkipCheckpoint = true) Try.Success(result) }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl.Companion$private val SERIALIZER_BLOCKER = Fiber::class.java.getDeclaredField("SERIALIZER_BLOCKER").apply { isAccessible = true }.get(null)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$if (found != null) throw IllegalArgumentException("${InitiatingFlow::class.java.name} can only be annotated once")</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable fun &lt;R : Any&gt; FlowLogic&lt;*&gt;.receiveAll(receiveType: Class&lt;R&gt;, session: FlowSession, vararg sessions: FlowSession): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable fun FlowLogic&lt;*&gt;.receiveAll(session: Pair&lt;FlowSession, Class&lt;out Any&gt;&gt;, vararg sessions: Pair&lt;FlowSession, Class&lt;out Any&gt;&gt;): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable inline fun &lt;reified R : Any&gt; FlowLogic&lt;*&gt;.receiveAll(session: FlowSession, vararg sessions: FlowSession): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$@Suppress("UNCHECKED_CAST") infix</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$@Suspendable inline</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$flowFactory: (FlowSession) -&gt; T</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$return this.internals.registerInitiatedFlowFactory(initiatingFlowClass, initiatedFlowClass, InitiatedFlowFactory.Core(flowFactory), track)</ID>
    <ID>MaxLineLength:FlowTreeDataManager.kt$FlowTreeDataManager$flowModel.insertNodeInto(DefaultMutableTreeNode(dir), parentNode, findInsertionIndex(parentNode.childNodes, dir.name))</ID>
    <ID>MaxLineLength:FlowTreeDataManager.kt$FlowTreeDataManager.DirObserver$if (isSelected(parent) &amp;&amp; file.name.startsWith(FlowSnapshotTreeDataManager.SNAPSHOT_FILE_PREFIX)) { snapshotModel.addNodeToSnapshotModel(file) }</ID>
    <ID>MaxLineLength:FlowWatchPrintingSubscriber.kt$FlowWatchPrintingSubscriber$val header = RowElement(true).add("Id", "Flow name", "Initiator", "Status").style(Decoration.bold.fg(Color.black).bg(Color.white))</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowReplyResult : FlowWorkerMessage</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowReplyStateMachineRunId : FlowWorkerMessage</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowWorker$private val queueAddress = "$FLOW_WORKER_QUEUE_ADDRESS_PREFIX${flowWorkerServiceHub.myInfo.legalIdentities[0].owningKey.toStringShort()}"</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowWorker$resultMessage.writeBodyBufferBytes(FlowReplyResult(flowWorkerServiceHub.myInfo.legalIdentities.first().name, startFlowMessage.replyId, it.get()).serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowWorker$stateMachineRunIdMessage.writeBodyBufferBytes(FlowReplyStateMachineRunId(flowWorkerServiceHub.myInfo.legalIdentities.first().name, startFlowMessage.replyId, result.id).serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowWorker$val flowWorkerMessagingClient = ArtemisMessagingClient(flowWorkerServiceHub.configuration.p2pSslOptions, flowWorkerServiceHub.configuration.messagingServerAddress!!, flowWorkerServiceHub.networkParameters.maxMessageSize)</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowWorker$val logicRef = flowWorkerServiceHub.flowLogicRefFactory.createForRPC(startFlowMessage.logicType, *startFlowMessage.args)</ID>
    <ID>MaxLineLength:FlowWorker.kt$FlowWorker${ // Log a warning to indicate node info is not added to the network map cache. // NetworkMapCacheImpl.logger.warn("Node info for :'${it.name}' is not added to the network map due to verification error.") }</ID>
    <ID>MaxLineLength:FlowWorker.kt$NetworkMapUpdate : FlowWorkerMessage</ID>
    <ID>MaxLineLength:FlowWorker.kt$StartFlow : FlowWorkerMessage</ID>
    <ID>MaxLineLength:FlowWorkerPartitioner.kt$FlowWorkerPartitioner$// TODO: Determine which is the latest, could happen if partition from last leader didn't get deleted. if (event.children.isNotEmpty()) { watchedClient.data.inBackground { _, e -&gt; val partitions = e.data.deserialize&lt;Map&lt;String, Pair&lt;Long, Long&gt;&gt;&gt;() partition.onNext(partitions[leaderLatch.registration.value.myPath?.split("/")?.last()]) logger.info("My partition is ${partition.value}") }.forPath(ZKPaths.makePath(partitionPath, event.children.last())) } else { // No partition data i.e leader is down, set partition to null reset(watchedClient) }</ID>
    <ID>MaxLineLength:FlowWorkerPartitioner.kt$FlowWorkerPartitioner$partition.onNext(partitions[leaderLatch.registration.value.myPath?.split("/")?.last()])</ID>
    <ID>MaxLineLength:FlowWorkerPartitioner.kt$FlowWorkerPartitioner$val lowerBound = listOf(0L) + upperBound.dropLast(1).map { it + 1 } // Make sure lower bound start from 0</ID>
    <ID>MaxLineLength:FlowWorkerRegister.kt$FlowWorkerRegister$logger.error("Can't find our zNode[$nodeId]. Resetting. Index: $ownIndex. My path is ${registration.value.myPath}")</ID>
    <ID>MaxLineLength:FlowWorkerRegister.kt$FlowWorkerRegister.Companion$private val workerSorter = LockInternalsSorter { str, lockName -&gt; StandardLockInternalsDriver.standardFixForSorting(str, lockName) }</ID>
    <ID>MaxLineLength:FlowWorkerRegister.kt$FlowWorkerRegistration</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$"${InitiatingFlow::class.java.name}.version not applicable for core flows; their version is the node's platform version"</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$@Suppress("LeakingThis") override</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$database.startHikariPool(configuration.dataSourceProperties, configuration.database, schemaService.schemaOptions.keys, ourName = myInfo.legalIdentities.first().name)</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$override val cacheFactory = EnterpriseNamedCacheFactory(configuration.enterpriseConfiguration.getTracingConfig()).bindWithConfig(configuration).bindWithMetrics(metricRegistry).tokenize()</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$override val cordappProvider = CordappProviderImpl(cordappLoader, CordappConfigFileProvider(emptyList()), attachments).tokenize()</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$override val networkParametersService = DBNetworkParametersStorage(cacheFactory, database, networkMapClient).tokenize()</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$override val nodeProperties = NodePropertiesPersistentStore(StubbedNodeUniqueIdProvider::value, database, cacheFactory)</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$parseSecureHashConfiguration(configuration.blacklistedAttachmentSigningKeys) { "Error while adding signing key $it to blacklistedAttachmentSigningKeys" }</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$private</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$private val networkMapClient: NetworkMapClient? = configuration.networkServices?.let { NetworkMapClient(it, versionInfo) }</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$private val serverThread = AffinityExecutor.ServiceAffinityExecutor("FlowWorker thread-${sameVmNodeCounter.incrementAndGet()}", 1)</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$private val signedNetworkParameters: NetworkParametersReader.NetworkParametersAndSigned</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$return "Installing flow factory for $flowClass accepting a ${Party::class.java.simpleName}, which is deprecated. " + "It should accept a ${FlowSession::class.java.simpleName} instead"</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$throw IllegalArgumentException("$initiatedFlow must have a constructor accepting a ${FlowSession::class.java.name}")</ID>
    <ID>MaxLineLength:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$val executor = MultiThreadedStateMachineExecutor(metricRegistry, configuration.enterpriseConfiguration.tuning.flowThreadPoolSize)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$keyStorePassword = "pass"</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$message.writeBodyBufferBytes(startFlowMessage.serialize(context = SerializationDefaults.RPC_CLIENT_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$p2pAddress = NetworkHostAndPort("localhost", 1)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$private</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$relay = null</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$return FlowWorkerInfra(trustRoot, nodeCa, bankInfo, bankKeyPair, session, consumer, producer, flowWorkerRequestQueueAddress, flowWorkerReplyQueueAddress, broker, bridgeControlListener, config)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$rpcUsers = listOf()</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$val (nodeBFlowWorker, nodeBFlowWorkerHub) = createFlowWorkerAndPerformTest(infraB, signedNetworkParameters, 1)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$val artemisClient = ArtemisMessagingClient(config.p2pSslOptions, config.messagingServerAddress!!, MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$val bridgeControlListener = BridgeControlListener(config.p2pSslOptions, config.messagingServerAddress!!, maxMessageSize, config.crlCheckSoftFail.toRevocationConfig(), enableSNI = true)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$val flowWorkerRequestQueueAddress = "${FlowWorker.FLOW_WORKER_QUEUE_ADDRESS_PREFIX}${bankKeyPair.public.toStringShort()}"</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$val flowWorkerServiceHub = FlowWorkerServiceHub(config, myInfo, ourKeyPair, trustRoot, nodeCa, signedNetworkParameters)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest$val startFlowMessage = StartFlow(legalName, CashIssueFlow::class.java, arrayOf(10.DOLLARS, OpaqueBytes.of(0x01), notary), InvocationContext.service("bla", legalName), infra.flowWorkerReplyQueueAddress, traceId)</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest.FlowWorkerInfra$private data</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest.FlowWorkerInfra$val flowWorkerRequestQueueAddress: String</ID>
    <ID>MaxLineLength:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest.FlowWorkerInfra$val session: ClientSession</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$bankAFlowWorkerServiceHub.networkMapCache.addNode(NodeInfo(listOf(NetworkHostAndPort("localhost", bankBConfig.messagingServerAddress!!.port)), listOf(bankBPartyAndCertificate), 1, 1))</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$bankBFlowWorkerServiceHub.networkMapCache.addNode(NodeInfo(listOf(NetworkHostAndPort("localhost", bankAConfig.messagingServerAddress!!.port)), listOf(bankAPartyAndCertificate), 1, 1))</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$keyStorePassword = "pass"</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$message.writeBodyBufferBytes(startFlowMessage.serialize(context = SerializationDefaults.RPC_CLIENT_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$p2pAddress = NetworkHostAndPort("localhost", 1)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$private</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$private val bankAInfo = NodeInfo(listOf(NetworkHostAndPort("localhost", 1111)), listOf(bankAPartyAndCertificate), 1, 1)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$private val bankBInfo = NodeInfo(listOf(NetworkHostAndPort("localhost", 1112)), listOf(bankBPartyAndCertificate), 1, 1)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$private val confidentialIdentitiesCordapp = cordappWithPackages("net.corda.confidential").copy(name = "confidential-cordapp")</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$relay = null</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$rpcUsers = listOf()</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$swapIdentitiesMessage.writeBodyBufferBytes(swapIdentitiesStartFlowMessage.serialize(context = SerializationDefaults.RPC_CLIENT_CONTEXT).bytes)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val (bankAFlowWorker, bankAFlowWorkerServiceHub) = createFlowWorker(bankAConfig, bankAInfo, signedNetworkParameters, bankAKeyPair, bankATrustRoot, bankANodeCa)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val (bankBFlowWorker, bankBFlowWorkerServiceHub) = createFlowWorker(bankBConfig, bankBInfo, signedNetworkParameters, bankBKeyPair, bankBTrustRoot, bankBNodeCa)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val (flowWorker, flowWorkerServiceHub) = createFlowWorker(config, bankAInfo, signedNetworkParameters, bankAKeyPair, trustRoot, nodeCa)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val artemisClient = ArtemisMessagingClient(config.p2pSslOptions, config.messagingServerAddress!!, MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val bankANodeCa = bankAConfig.signingCertificateStore.get().query { getCertificate(X509Utilities.CORDA_CLIENT_CA) }</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val bankARequestQueueAddress = "${FlowWorker.FLOW_WORKER_QUEUE_ADDRESS_PREFIX}${bankAKeyPair.public.toStringShort()}"</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val bankATrustRoot = bankAConfig.p2pSslOptions.trustStore.get().query { getCertificate(X509Utilities.CORDA_ROOT_CA) }</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val bankBNodeCa = bankBConfig.signingCertificateStore.get().query { getCertificate(X509Utilities.CORDA_CLIENT_CA) }</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val bankBTrustRoot = bankBConfig.p2pSslOptions.trustStore.get().query { getCertificate(X509Utilities.CORDA_ROOT_CA) }</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val bridgeControlListener = BridgeControlListener(config.p2pSslOptions, config.messagingServerAddress!!, maxMessageSize, config.crlCheckSoftFail.toRevocationConfig(), enableSNI = true)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val flowWorkerRequestQueueAddress = "${FlowWorker.FLOW_WORKER_QUEUE_ADDRESS_PREFIX}${bankAKeyPair.public.toStringShort()}"</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val flowWorkerServiceHub = FlowWorkerServiceHub(config, myInfo, ourKeyPair, trustRoot, nodeCa, signedNetworkParameters)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val startFlowMessage = StartFlow(DUMMY_BANK_A_NAME, CashIssueFlow::class.java, arrayOf(10.DOLLARS, OpaqueBytes.of(0x01), notary), InvocationContext.service("bla", DUMMY_BANK_A_NAME), flowWorkerReplyQueueAddress, traceId)</ID>
    <ID>MaxLineLength:FlowWorkerTest.kt$FlowWorkerTest$val swapIdentitiesStartFlowMessage = StartFlow(DUMMY_BANK_A_NAME, SwapIdentitiesFlow::class.java, arrayOf(bankB), InvocationContext.service("bla", DUMMY_BANK_A_NAME), bankAReplyQueueAddress, swapIdentitiesTraceId)</ID>
    <ID>MaxLineLength:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$bob -&gt; client.registration.subscribe { if (it.isLeader) bobLeaderGain.countDown() else bobLeaderLoss.countDown() }</ID>
    <ID>MaxLineLength:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$chip -&gt; client.registration.subscribe { if (it.isLeader) chipLeaderGain.countDown() else chipLeaderLoss.countDown() }</ID>
    <ID>MaxLineLength:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$val alice = FlowWorkerZkClient(zkServer.connectString, ZKPaths.makePath(ELECTION_PATH, "test5"), ZKPaths.makePath(FLOW_BUCKETS_PATH, "test5"), "ALICE", 0)</ID>
    <ID>MaxLineLength:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$val bob = FlowWorkerZkClient(zkServer.connectString, ZKPaths.makePath(ELECTION_PATH, "test5"), ZKPaths.makePath(FLOW_BUCKETS_PATH, "test5"), "BOB", 1)</ID>
    <ID>MaxLineLength:FlowWorkerZkClientTest.kt$FlowWorkerZkClientTest$val chip = FlowWorkerZkClient(zkServer.connectString, ZKPaths.makePath(ELECTION_PATH, "test5"), ZKPaths.makePath(FLOW_BUCKETS_PATH, "test5"), "CHIP", 2)</ID>
    <ID>MaxLineLength:FlowsDrainingModeContentionTest.kt$FlowsDrainingModeContentionTest$val flow = nodeA.rpc.startFlow(::ProposeTransactionAndWaitForCommit, message, nodeARpcInfo, nodeB.nodeInfo.singleIdentity(), defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:FlowsExecutionModeRpcTest.kt$FlowsExecutionModeRpcTest$val user = User("mark", "dadada", setOf(Permissions.invokeRpc("setFlowsDrainingModeEnabled"), Permissions.invokeRpc("isFlowsDrainingModeEnabled")))</ID>
    <ID>MaxLineLength:FlowsExecutionModeRpcTest.kt$FlowsExecutionModeRpcTest$val user = User("mark", "dadada", setOf(invokeRpc("setFlowsDrainingModeEnabled"), invokeRpc("isFlowsDrainingModeEnabled")))</ID>
    <ID>MaxLineLength:FlowsExecutionModeRpcTest.kt$FlowsExecutionModeTests$private</ID>
    <ID>MaxLineLength:ForwardingArtemisMessageClient.kt$ForwardingArtemisMessageClient : ArtemisSessionProvider</ID>
    <ID>MaxLineLength:ForwardingArtemisMessageClient.kt$ForwardingArtemisMessageClient${ // We don't want to start and stop artemis from clients as the lifecycle management is provided by the BridgeArtemisConnectionService return artemisConnectionService.started!! }</ID>
    <ID>MaxLineLength:ForwardingArtemisMessageClient.kt$ForwardingArtemisMessageClient${ // We don't want to start and stop artemis from clients as the lifecycle management is provided by the BridgeArtemisConnectionService }</ID>
    <ID>MaxLineLength:FoundNode.kt$FoundNode$val name: String = configFile.parentFile.name.toLowerCase().replace(Constants.ALPHA_NUMERIC_ONLY_REGEX, "")</ID>
    <ID>MaxLineLength:FungibleAsset.kt$InsufficientBalanceException : FlowException</ID>
    <ID>MaxLineLength:FutureXCryptoService.kt$FutureXCryptoService$ override fun isLoggedIn(): Boolean</ID>
    <ID>MaxLineLength:FutureXCryptoService.kt$FutureXCryptoService$(provider as SunPKCS11).login(null) { callbacks -&gt; (callbacks[0] as PasswordCallback).password = config.credentials.toCharArray() }</ID>
    <ID>MaxLineLength:FutureXCryptoService.kt$FutureXCryptoService$override</ID>
    <ID>MaxLineLength:FutureXCryptoService.kt$FutureXCryptoService$val key = keyStore.getKey(alias, null) as PrivateKey? ?: throw CryptoServiceException("No key found for alias $alias", isRecoverable = false)</ID>
    <ID>MaxLineLength:FutureXCryptoService.kt$FutureXCryptoService.Companion$is ConfigException, is UnknownConfigurationKeysException -&gt; throw Exception("Error in ${cryptoServiceConf.toFile().absolutePath} : ${e.message}")</ID>
    <ID>MaxLineLength:FutureXNodeRegistrationTest.kt$FutureXNodeRegistrationTest$provider.login(null) { callbacks -&gt; (callbacks[0] as PasswordCallback).password = config.credentials.toCharArray() }</ID>
    <ID>MaxLineLength:FutureXNodeRegistrationTest.kt$FutureXNodeRegistrationTest$val config = ConfigFactory.parseFile(configPath().toFile()).resolve().parseAs(FutureXCryptoService.FutureXConfiguration::class)</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$val sum = it.filter { it.owner.let { it is Party &amp;&amp; serviceHub.myInfo.isLegalIdentity(it) } }.map { it.amount.quantity }.sum()</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$ForeignExchangeRemoteFlow$val ourKey = serviceHub.keyManagementService.filterMyKeys(ourInputState.flatMap { it.state.data.participants }.map { it.owningKey }).single()</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$private</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val eligibleStates = serviceHub.vaultService.tryLockFungibleStatesForSpending(lockId, fullCriteria, amountRequired.withoutIssuer(), Cash.State::class.java)</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val logicalExpression = builder { CashSchemaV1.PersistentCashState::currency.equal(amountRequired.token.product.currencyCode) }</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val ourParties = ourKeys.map { serviceHub.identityService.partyFromKey(it) ?: throw IllegalStateException("Unable to resolve party from key") }</ID>
    <ID>MaxLineLength:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService$detailedLogger.trace { "CryptoService(action=generate_key_pair_start;alias=$alias;scheme=$scheme)" } val keyPairGenerator = keyPairGeneratorFromScheme(scheme) val keyPair = keyPairGenerator.generateKeyPair() keyStore.setKeyEntry(alias, keyPair.private, null, selfSign(scheme, keyPair)) keyStore.store(null, null) // Gemalto-specific detailedLogger.trace { "CryptoService(action=generate_key_pair_end;alias=$alias;scheme=$scheme)" } // We call toSupportedKey because it's possible that the PublicKey object returned by the provider is not initialized. Crypto.toSupportedPublicKey(keyPair.public)</ID>
    <ID>MaxLineLength:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService$override</ID>
    <ID>MaxLineLength:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService.Companion$is ConfigException, is UnknownConfigurationKeysException -&gt; throw Exception("Error in ${cryptoServiceConf.toFile().absolutePath} : ${e.message}")</ID>
    <ID>MaxLineLength:GemaltoLunaCryptoService.kt$net.corda.nodeapi.internal.cryptoservice.gemalto.GemaltoLunaCryptoService.kt</ID>
    <ID>MaxLineLength:GemaltoLunaCryptoServiceTest.kt$GemaltoLunaCryptoServiceTest$override fun getSupportedSchemes(): List&lt;SignatureScheme&gt;</ID>
    <ID>MaxLineLength:GenerateHelpers.kt$return generateAmount(1, max, Generator.pure(Issued(PartyAndReference(issuer, OpaqueBytes.of(0)), currency))).combine( Generator.pickOne(possibleRecipients) ) { amount, recipient -&gt; PaymentRequest(amount.withoutIssuer(), recipient, true, setOf(issuer)) }</ID>
    <ID>MaxLineLength:GenerateNodeInfoCli.kt$GenerateNodeInfoCli : NodeCliCommand</ID>
    <ID>MaxLineLength:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$println("You need to distribute this file along with the password in a secure way to all RPC clients.")</ID>
    <ID>MaxLineLength:GenerateRpcSslCertsCli.kt$GenerateRpcSslCertsCli : NodeCliCommand</ID>
    <ID>MaxLineLength:Generator.kt$Generator$fun &lt;B, C, D, E, R&gt; combine(other1: Generator&lt;B&gt;, other2: Generator&lt;C&gt;, other3: Generator&lt;D&gt;, other4: Generator&lt;E&gt;, function: (A, B, C, D, E) -&gt; R)</ID>
    <ID>MaxLineLength:Generator.kt$Generator$fun &lt;B, C, D, R&gt; combine(other1: Generator&lt;B&gt;, other2: Generator&lt;C&gt;, other3: Generator&lt;D&gt;, function: (A, B, C, D) -&gt; R)</ID>
    <ID>MaxLineLength:Generator.kt$Generator$product&lt;R&gt;(other1.product(other2.product(other3.product(other4.product(pure({ e -&gt; { d -&gt; { c -&gt; { b -&gt; { a -&gt; function(a, b, c, d, e) } } } } }))))))</ID>
    <ID>MaxLineLength:Generator.kt$Generator$product&lt;R&gt;(other1.product(other2.product(other3.product(pure({ d -&gt; { c -&gt; { b -&gt; { a -&gt; function(a, b, c, d) } } } })))))</ID>
    <ID>MaxLineLength:Generator.kt$Generator.Companion$fun &lt;A&gt; replicatePoisson(meanSize: Double, generator: Generator&lt;A&gt;, atLeastOne: Boolean = false)</ID>
    <ID>MaxLineLength:Generator.kt$Generator&lt;out A&gt;</ID>
    <ID>MaxLineLength:GenericsTests.kt$GenericsTests$LTransactionState&lt;T1, T2, T3 : BaseState&lt;T1, T2&gt;, out T4: BaseState&lt;T1, T2&gt;&gt;</ID>
    <ID>MaxLineLength:GenericsTests.kt$GenericsTests$StateWrapper&lt;T1, T2, T3 : BaseState&lt;T1, T2&gt;, out T4: BaseState&lt;T1, T2&gt;&gt;</ID>
    <ID>MaxLineLength:GenericsTests.kt$GenericsTests$val bytes = SerializationOutput(factory).serializeAndReturnSchema(Wrapper(1, G1("hi"), G2("poop"))).apply { printSchema() }</ID>
    <ID>MaxLineLength:GenericsTests.kt$GenericsTests.Companion$private val MINI_CORP_PARTY = Party(MINI_CORP_NAME, Crypto.deriveKeyPairFromEntropy(Crypto.DEFAULT_SIGNATURE_SCHEME, BigInteger.valueOf(20)).public)</ID>
    <ID>MaxLineLength:GetBalances.kt$CashSchemaV1.PersistentCashState::pennies</ID>
    <ID>MaxLineLength:GetBalances.kt$require(rows.otherResults[1] == currency.currencyCode){"Currency on rows returned by query does not match expected"}</ID>
    <ID>MaxLineLength:GetBalances.kt$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:GetBalances.kt${ val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) } val sumCriteria = QueryCriteria.VaultCustomQueryCriteria(sum) val ccyIndex = builder { CashSchemaV1.PersistentCashState::currency.equal(currency.currencyCode) } // This query should only return cash states the calling node is a participant of (meaning they can be modified/spent). val ccyCriteria = QueryCriteria.VaultCustomQueryCriteria(ccyIndex, relevancyStatus = Vault.RelevancyStatus.RELEVANT) return sumCriteria.and(ccyCriteria) }</ID>
    <ID>MaxLineLength:GetBalances.kt${ val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) } // This query should only return cash states the calling node is a participant of (meaning they can be modified/spent). return QueryCriteria.VaultCustomQueryCriteria(sum, relevancyStatus = Vault.RelevancyStatus.RELEVANT) }</ID>
    <ID>MaxLineLength:GroupATests.kt$GroupATests$"forClassGroupATests-setup"</ID>
    <ID>MaxLineLength:GroupBTests.kt$GroupBTests$"forClassGroupBTests-setup"</ID>
    <ID>MaxLineLength:GuiUtilities.kt$ fun &lt;T&gt; stringConverter(fromStringFunction: ((String?) -&gt; T)? = null, toStringFunction: (T) -&gt; String): StringConverter&lt;T&gt;</ID>
    <ID>MaxLineLength:GuiUtilities.kt$// TODO: This is a temporary fix for the UI to show the correct issuer identity, this will break when we start randomizing keys. More work is needed here when the identity work is done. fun StateAndRef&lt;Cash.State&gt;.resolveIssuer(): ObservableValue&lt;Party?&gt;</ID>
    <ID>MaxLineLength:GuiUtilities.kt$fun PublicKey.toKnownParty()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$assumeTrue(!IntegrationTest.isRemoteDatabaseMode())</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$driver</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode(customOverrides = mapOf(h2AddressKey to "${InetAddress.getLocalHost().hostAddress}:${getFreePort()}")).getOrThrow()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode(customOverrides = mapOf(h2AddressKey to "${InetAddress.getLocalHost().hostName}:${getFreePort()}")).getOrThrow()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$val nodeHandle = startNode(rpcUsers = listOf(user), customOverrides = mapOf(h2AddressKey to "localhost:$port", dbPasswordKey to "x")).getOrThrow()</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$ClassLoader.getSystemResourceAsStream("artemis/artemis-roles.properties").copyTo(masterConfigPath.parent / "artemis-roles.properties")</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$ClassLoader.getSystemResourceAsStream("artemis/artemis-roles.properties").copyTo(slaveConfigPath.parent / "artemis-roles.properties")</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$ClassLoader.getSystemResourceAsStream("artemis/artemis-users.properties").copyTo(masterConfigPath.parent / "artemis-users.properties")</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$ClassLoader.getSystemResourceAsStream("artemis/artemis-users.properties").copyTo(slaveConfigPath.parent / "artemis-users.properties")</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$aliceNode.rpc.startFlow(::CashIssueFlow, 1000.POUNDS, OpaqueBytes.of(0), defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000), externalBridge = false)).whenever(it)</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$internalDriver</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$private fun CordaRPCOps.vaultTotal()</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$return ProcessUtilities.startJavaProcess&lt;OutOfProcessArtemisBroker&gt;(workingDirectory = baseDir, arguments = listOf())</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$val aliceNode = startNode(NodeParameters(providedName = ALICE_NAME, rpcUsers = listOf(aliceUser), customOverrides = nodeConfiguration, additionalCordapps = FINANCE_CORDAPPS)).getOrThrow()</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$val bobNode = startNode(NodeParameters(providedName = BOB_NAME, rpcUsers = listOf(aliceUser), additionalCordapps = FINANCE_CORDAPPS)).getOrThrow()</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$val flow = aliceNode.rpc.startFlow(::CashPaymentFlow, 50.POUNDS, bobNode.nodeInfo.singleIdentity()).returnValue</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$HABrokerFailoverTest$val flow2 = aliceNode.rpc.startFlow(::CashPaymentFlow, 50.POUNDS, bobNode.nodeInfo.singleIdentity()).returnValue</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$OutOfProcessArtemisBroker$val server = ActiveMQServers.newActiveMQServer(config, ManagementFactory.getPlatformMBeanServer(), createArtemisSecurityManager())</ID>
    <ID>MaxLineLength:HABrokerFailoverTest.kt$OutOfProcessArtemisBroker.&lt;no name provided&gt;$return arrayOf(AppConfigurationEntry(name, AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, options))</ID>
    <ID>MaxLineLength:HSMStartupTest.kt$HSMStartupTest$assertThatExceptionOfType(IllegalStateException::class.java) .isThrownBy { createNode(InternalMockNodeParameters(legalName = ALICE_NAME, configOverrides = { doReturn(SupportedCryptoServices.BC_SIMPLE).whenever(it).cryptoServiceName })) }</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$HTTP_UNAUTHORIZED -&gt; throw CertificateRequestException("Certificate signing request has been rejected: ${conn.errorMessage}")</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$else -&gt; throw IOException("Error while connecting to the Doorman. Http response status code was ${conn.responseCode}.")</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$in TRANSIENT_ERROR_STATUS_CODES -&gt; throw ServiceUnavailableException("Could not connect with Doorman. Http response status code was ${conn.responseCode}.")</ID>
    <ID>MaxLineLength:HardRestartTest.kt$HardRestartTest$val rpc = tlRpc.get() ?: CordaRPCClient(a.rpcAddress).start(demoUser.username, demoUser.password).proxy.also { tlRpc.set(it) }</ID>
    <ID>MaxLineLength:HardRestartTest.kt$HardRestartTest$val string = rpc.startFlow(::RecursiveA, b.nodeInfo.singleIdentity(), 10).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:HashLookupCommandTest.kt$HashLookupCommandTest$testCommand(session, command = "hashLookup ${SecureHash.randomSHA256()}", expected = "No matching transaction found")</ID>
    <ID>MaxLineLength:HashLookupCommandTest.kt$HashLookupCommandTest$testCommand(session, command = "hashLookup ${txId.sha256()}", expected = "Found a matching transaction with Id: $txId")</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow$NotaryClientFlow : Client</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow$addOutputState(NullContract.State(listOf(ourIdentity)), NullContract::class.java.name, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow.NotaryClientFlow$@Suspendable private</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow.NotaryClientFlow$NotarySendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow.NotaryClientFlow$it is StateRef || it is ReferenceStateRef || it is TimeWindow || it == notaryParty || it is NetworkParametersHash</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow.NotaryClientFlow$val gauge = (serviceHub as ServiceHubInternal).monitoringService.metrics.gauge(name, { WaitTimeLatchedGauge(AtomicLong(value)) })</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow.NotaryClientFlow.NotarySendTransactionFlow$@Suspendable override</ID>
    <ID>MaxLineLength:HealthCheckFlow.kt$HealthCheckFlow.NotaryClientFlow.NotarySendTransactionFlow$private</ID>
    <ID>MaxLineLength:HibernateColumnConverterTests.kt$HibernateColumnConverterTests$// AbstractPartyToX500NameAsStringConverter could cause circular flush of Hibernate session because it is invoked during flush, and a // cache miss was doing a flush. This also checks that loading during flush does actually work. @Test fun `issue some cash on a notary that exists only in the database to check cache loading works in our identity column converters during flush of vault update`()</ID>
    <ID>MaxLineLength:HibernateColumnConverterTests.kt$HibernateColumnConverterTests${ val expected = 500.DOLLARS val ref = OpaqueBytes.of(0x01) // Create parallel set of key and identity services so that the values are not cached, forcing the node caches to do a lookup. val identityService = PersistentIdentityService(TestingNamedCacheFactory()) val originalIdentityService: PersistentIdentityService = services.identityService as PersistentIdentityService identityService.database = originalIdentityService.database identityService.start(originalIdentityService.trustRoot) val keyService = E2ETestKeyManagementService(identityService) keyService.start(setOf(myself.keyPair)) // New identity for a notary (doesn't matter that it's for Bank Of Corda... since not going to use it as an actual notary etc). val newKeyAndCert = keyService.freshKeyAndCert(services.myInfo.legalIdentitiesAndCerts[0], false) val randomNotary = Party(myself.name, newKeyAndCert.owningKey) val ourIdentity = services.myInfo.legalIdentities.first() val builder = TransactionBuilder(notary.party) val issuer = services.myInfo.legalIdentities.first().ref(ref) val signers = Cash().generateIssue(builder, expected.issuedBy(issuer), ourIdentity, randomNotary) val tx: SignedTransaction = services.signInitialTransaction(builder, signers) services.recordTransactions(tx) val output = tx.tx.outputsOfType&lt;Cash.State&gt;().single() assertEquals(expected.`issued by`(ourIdentity.ref(ref)), output.amount) }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$ fun sessionFactoryForSchemas(key: Set&lt;MappedSchema&gt;): SessionFactory</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$// Enterprise only - preserving case-sensitive schema name for PostgreSQL by wrapping in double quotes, schema without double quotes would be treated as case-insensitive (lower cases) val schemaName = if (jdbcUrl.contains(":postgresql:", ignoreCase = true) &amp;&amp; !databaseConfig.schema.startsWith("\"")) { "\"" + databaseConfig.schema + "\"" } else { databaseConfig.schema } config.setProperty("hibernate.default_schema", schemaName)</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$// Enterprise only: allow batching the vault update query for consumed states to avoid overloading SQLServer val vaultUpdateBatchSize: Int? = databaseConfig.vaultUpdateBatchSize ?: if (jdbcUrl.contains(":sqlserver:")) 40 else null</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$// TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session schema.mappedTypes.forEach { config.addAnnotatedClass(it) }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString())</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaMaterializedBlobType : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaPrimitiveByteArrayTypeDescriptor : PrimitiveByteArrayTypeDescriptor</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaWrapperBinaryType : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$MapBlobToPostgresByteA : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$if (databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) { "update" } else if ((!databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) || databaseConfig.initialiseAppSchema == SchemaInitializationType.VALIDATE) { "validate" } else { "none" }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$if (isH2Database(jdbcUrl)) { val hbm2dll: String = if (databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) { "update" } else if ((!databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) || databaseConfig.initialiseAppSchema == SchemaInitializationType.VALIDATE) { "validate" } else { "none" } config.setProperty("hibernate.hbm2ddl.auto", hbm2dll) } else if (!isNonStopSqlMxDatabase(jdbcUrl)) //Enterprise only NonStop database - NonStop Hibernate dialect doesn't support validation config.setProperty("hibernate.hbm2ddl.auto","validate")</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$private</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$private val sessionFactories = cacheFactory.buildNamed&lt;Set&lt;MappedSchema&gt;, SessionFactory&gt;(Caffeine.newBuilder(), "HibernateConfiguration_sessionFactories")</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$val config = Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString()) .setProperty("javax.persistence.validation.mode", "none")</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$val schemaName = if (jdbcUrl.contains(":postgresql:", ignoreCase = true) &amp;&amp; !databaseConfig.schema.startsWith("\"")) { "\"" + databaseConfig.schema + "\"" } else { databaseConfig.schema }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration${ "update" }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration${ logger.info("Creating session factory for schemas: $schemas") val serviceRegistry = BootstrapServiceRegistryBuilder().build() val metadataSources = MetadataSources(serviceRegistry) // We set a connection provider as the auto schema generation requires it. The auto schema generation will not // necessarily remain and would likely be replaced by something like Liquibase. For now it is very convenient though. val config = Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString()) .setProperty("javax.persistence.validation.mode", "none") if (isH2Database(jdbcUrl)) { val hbm2dll: String = if (databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) { "update" } else if ((!databaseConfig.initialiseSchema &amp;&amp; databaseConfig.initialiseAppSchema == SchemaInitializationType.UPDATE) || databaseConfig.initialiseAppSchema == SchemaInitializationType.VALIDATE) { "validate" } else { "none" } config.setProperty("hibernate.hbm2ddl.auto", hbm2dll) } else if (!isNonStopSqlMxDatabase(jdbcUrl)) //Enterprise only NonStop database - NonStop Hibernate dialect doesn't support validation config.setProperty("hibernate.hbm2ddl.auto","validate") databaseConfig.schema?.apply { // Enterprise only - preserving case-sensitive schema name for PostgreSQL by wrapping in double quotes, schema without double quotes would be treated as case-insensitive (lower cases) val schemaName = if (jdbcUrl.contains(":postgresql:", ignoreCase = true) &amp;&amp; !databaseConfig.schema.startsWith("\"")) { "\"" + databaseConfig.schema + "\"" } else { databaseConfig.schema } config.setProperty("hibernate.default_schema", schemaName) } databaseConfig.hibernateDialect?.apply { config.setProperty("hibernate.dialect", this) } schemas.forEach { schema -&gt; // TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session schema.mappedTypes.forEach { config.addAnnotatedClass(it) } } val sessionFactory = buildSessionFactory(config, metadataSources, customClassLoader) logger.info("Created session factory for schemas: $schemas") // export Hibernate JMX statistics if (databaseConfig.exportHibernateJMXStatistics) initStatistics(sessionFactory) return sessionFactory }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.Companion$// register custom converters fun buildHibernateMetadata(metadataBuilder: MetadataBuilder, jdbcUrl:String, attributeConverters: Collection&lt;AttributeConverter&lt;*, *&gt;&gt;): Metadata</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.Companion$attributeConverters.forEach { applyAttributeConverter(it) } // Register a tweaked version of `org.hibernate.type.MaterializedBlobType` that truncates logged messages. // to avoid OOM when large blobs might get logged. applyBasicType(CordaMaterializedBlobType, CordaMaterializedBlobType.name) applyBasicType(CordaWrapperBinaryType, CordaWrapperBinaryType.name) // Create a custom type that will map a blob to byteA in postgres and as a normal blob for all other dbms. // This is required for the Checkpoints as a workaround for the issue that postgres has on azure. if (jdbcUrl.contains(":postgresql:", ignoreCase = true)) { applyBasicType(MapBlobToPostgresByteA, MapBlobToPostgresByteA.name) } else { applyBasicType(MapBlobToNormalBlob, MapBlobToNormalBlob.name) } // When connecting to SqlServer or Oracle, do we need to tell hibernate to use // nationalised (i.e. Unicode) strings by default val forceUnicodeForSqlServer = listOf(":oracle:", ":sqlserver:").any { jdbcUrl.contains(it, ignoreCase = true) } enableGlobalNationalizedCharacterDataSupport(forceUnicodeForSqlServer) return build()</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.Companion$val forceUnicodeForSqlServer = listOf(":oracle:", ":sqlserver:").any { jdbcUrl.contains(it, ignoreCase = true) }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.NodeDatabaseConnectionProvider$override fun isUnwrappableAs(unwrapType: Class&lt;*&gt;?): Boolean</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$cashStates = vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, numStates, issuer.ref(1), rng = Random(0L)).states.toList()</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$criteriaQuery.where(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultCashStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$criteriaQuery.where(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$database = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$database = configureDatabase(dataSourceProps, DatabaseConfig(initialiseSchema = initialiseSchema), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$println("${it.stateRef} with owner ${cashState.owner.owningKey.toBase58String()} and participants ${cashState.participants.map { it.owningKey.toBase58String() }}")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$println("${vaultState.stateRef} : [${_dummyLinearStates.externalId} ${_dummyLinearStates.uuid}] : [${_vaultLinearStates.externalId} ${_vaultLinearStates.uuid}]")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$private fun sessionFactoryForSchemas(vararg schemas: MappedSchema)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate = criteriaBuilder.and(andDummyLinearStatesPredicate1, criteriaBuilder.and(andDummyLinearStatesPredicate2, andDummyLinearStatesPredicate3))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate1 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;String&gt;("linearString"), "123"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;Long&gt;("linearNumber"), 123L))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate3 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;Boolean&gt;("linearBoolean"), true))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andLinearStatesPredicate1 = criteriaBuilder.and(criteriaBuilder.equal(vaultLinearStates.get&lt;String&gt;("externalId"), uniqueID456.externalId))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andLinearStatesPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(vaultLinearStates.get&lt;UUID&gt;("uuid"), uniqueID456.id))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val cashStates = vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 2, issuer.ref(1), ALICE, Random(0L)).states</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val cordappPackages = listOf("net.corda.testing.internal.vault", "net.corda.finance.contracts.asset", "net.corda.finance.schemas")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinCashStateToParty = cashStatesSchema.joinSet&lt;SampleCashSchemaV3.PersistentCashState, String&gt;("participants")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate1 = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), dummyLinearStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinVaultStatesToCash = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), cashStatesSchema.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val moreCash = vaultFiller.fillWithSomeTestCash(100.DOLLARS, services, 2, identity.ref(0), identity, Random(0L)).states</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val schemaService = NodeSchemaService(extraSchemas = setOf(CashSchemaV1, SampleCashSchemaV1, SampleCashSchemaV2, SampleCashSchemaV3, DummyLinearStateSchemaV1, DummyLinearStateSchemaV2, DummyDealStateSchemaV1))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$vaultFiller.fillWithSomeTestLinearStates(1, externalId = "123", linearString = "123", linearNumber = 123, linearBoolean = true)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest${ fun createNewDB(schemas: Set&lt;MappedSchema&gt;, initialiseSchema: Boolean = true): CordaPersistence { val schemaService = NodeSchemaService(extraSchemas = schemas) val dataSourceProps = makeTestDataSourceProperties("aa") val identityService = mock&lt;IdentityService&gt;().also { mock -&gt; doReturn(null).whenever(mock).wellKnownPartyFromAnonymous(any&lt;AbstractParty&gt;()) listOf(dummyCashIssuer, dummyNotary).forEach { doReturn(it.party).whenever(mock).wellKnownPartyFromAnonymous(it.party) doReturn(it.party).whenever(mock).wellKnownPartyFromX500Name(it.name) } } database = configureDatabase(dataSourceProps, DatabaseConfig(initialiseSchema = initialiseSchema), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService) return database } createNewDB(setOf(CashSchemaV1, SampleCashSchemaV1)).apply { database.transaction { vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 4, issuer.ref(1), rng = Random(0L)) } } // OS - Enterprise diff, Liquibase does verification earlier than Hibernate validation for CorDapps in OS and throws the different error assertThatThrownBy { createNewDB(setOf(CashSchemaV1, SampleCashSchemaV1, SampleCashSchemaV2), initialiseSchema = false) }.isInstanceOf(DatabaseIncompatibleException::class.java) }</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest.&lt;no name provided&gt;$override val vaultService = NodeVaultService(Clock.systemUTC(), keyManagementService, servicesForResolution, database, schemaService, TestingNamedCacheFactory(), cordappClassloader).apply { start() }</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest.&lt;no name provided&gt;${ for (stx in txs) { (validatedTransactions as WritableTransactionStorage).addTransaction(stx) } // Refactored to use notifyAll() as we have no other unit test for that method with multiple transactions. vaultService.notifyAll(statesToRecord, txs.map { it.tx }) }</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider$ fun createEntityManagerFactory(dataSource: DataSource, dataSourceProperties: Properties, databaseConfig: StandaloneJPANotaryDatabaseConfig, maxBatchSize: Int): EntityManagerFactory</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider$// Enterprise only - preserving case-sensitive schema name for PostgreSQL by wrapping in double quotes, schema without double quotes would be treated as case-insensitive (lower cases) val schemaName = if (jdbcUrl.contains(":postgresql:", ignoreCase = true) &amp;&amp; databaseConfig.schema?.startsWith("\"") == false) { "\"" + databaseConfig.schema + "\"" } else { databaseConfig.schema } dataSourceProperties.setProperty("hibernate.default_schema", schemaName)</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider$val schemaName = if (jdbcUrl.contains(":postgresql:", ignoreCase = true) &amp;&amp; databaseConfig.schema?.startsWith("\"") == false) { "\"" + databaseConfig.schema + "\"" } else { databaseConfig.schema }</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider${ dataSourceProperties.setProperty("hibernate.hbm2ddl.auto", "none") }</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$HibernateEntityManagerFactoryProvider${ dataSourceProperties.setProperty("hibernate.hbm2ddl.auto", "validate") }</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$PersistenceOptions : PersistenceUnitInfo</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$PersistenceOptions$return mutableListOf(CommittedState::class.java.canonicalName, CommittedTransaction::class.java.canonicalName, Request::class.java.canonicalName)</ID>
    <ID>MaxLineLength:HibernateEntityManagerFactoryProvider.kt$PersistenceOptions${ //This should be true so that Hibernate only maps specified classes listed in getManagedClassNames above //Setting this to false will result in Hibernate searching through the JAR and mapping all tables, which results in the tables above being mapped twice return true }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$LIKE_IGNORE_CASE -&gt; criteriaBuilder.like(criteriaBuilder.upper(column), columnPredicate.rightLiteral.toUpperCase())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$NOT_IN_IGNORE_CASE -&gt; criteriaBuilder.not(criteriaBuilder.upper(column).`in`(literal.map { it.toUpperCase() }))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$NOT_LIKE_IGNORE_CASE -&gt; criteriaBuilder.notLike(criteriaBuilder.upper(column), columnPredicate.rightLiteral.toUpperCase())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$abstract</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$private</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$AbstractQueryCriteriaParser&lt;AttachmentQueryCriteria, AttachmentsQueryCriteriaParser, AttachmentSort&gt;(), AttachmentsQueryCriteriaParser</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$Sort.Direction.DESC -&gt; orderCriteria.add(criteriaBuilder.desc(root.get&lt;String&gt;(sortAttribute.columnName)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$private val criteriaQuery: CriteriaQuery&lt;NodeAttachmentService.DBAttachment&gt;</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$val joinDBAttachmentToContractClassNames = root.joinList&lt;NodeAttachmentService.DBAttachment, ContractClassName&gt;("contractClassNames")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$Sort.Direction.ASC -&gt; criteriaBuilder.asc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$Sort.Direction.DESC -&gt; criteriaBuilder.desc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$Triple(VaultSchemaV1.VaultStates::class.java, sortAttribute.attributeParent, sortAttribute.attributeChild)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.and(vaultStates.get&lt;String&gt;(VaultSchemaV1.VaultStates::contractStateClassName.name).`in`(contractStateTypes.plus(existingTypes))))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.and(vaultStates.get&lt;Vault.ConstraintInfo.Type&gt;(VaultSchemaV1.VaultStates::constraintType.name).`in`(criteria.constraintTypes.plus(existingTypes))))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.equal(vaultStates.get&lt;Vault.RelevancyStatus&gt;(VaultSchemaV1.VaultStates::relevancyStatus.name), criteria.relevancyStatus))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), criteria.status))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.and(vaultStates.get&lt;String&gt;(VaultSchemaV1.VaultStates::contractStateClassName.name).`in`(contractStateTypes))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.and(vaultStates.get&lt;Vault.ConstraintInfo.Type&gt;(VaultSchemaV1.VaultStates::constraintType.name).`in`(criteria.constraintTypes))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.equal(vaultStates.get&lt;Vault.RelevancyStatus&gt;(VaultSchemaV1.VaultStates::relevancyStatus.name), criteria.relevancyStatus)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), criteria.status)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;IndirectStatePersistable&lt;*&gt;&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$elem</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$if (path is SingularAttributePath) //remove the same columns from different joins to match the single column in 'group by' only (from the last join) aggregateExpressions.removeAll { elem -&gt; if (elem is SingularAttributePath) elem.attribute.javaMember == path.attribute.javaMember else false }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$is SortAttribute.Custom -&gt; Triple(sortAttribute.entityStateClass, sortAttribute.entityStateColumnName, null)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Enriching previous attribute [${VaultSchemaV1.VaultStates::constraintType.name}] values [$existingTypes] with [${criteria.constraintTypes}]")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Enriching previous attribute [${VaultSchemaV1.VaultStates::contractStateClassName.name}] values [$existingTypes] with [$contractStateTypes]")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Overriding previous attribute [${VaultSchemaV1.VaultStates::relevancyStatus.name}] value $existingStatus with ${criteria.status}")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Overriding previous attribute [${VaultSchemaV1.VaultStates::stateStatus.name}] value $existingStatus with ${criteria.status}")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$orderCriteria.add(criteriaBuilder.asc(sortEntityRoot.get&lt;String&gt;(entityStateAttributeParent).get&lt;String&gt;(entityStateAttributeChild)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$orderCriteria.add(criteriaBuilder.desc(sortEntityRoot.get&lt;String&gt;(entityStateAttributeParent).get&lt;String&gt;(entityStateAttributeChild)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$predicateSet.add(criteriaBuilder.and(vaultStates.get&lt;String&gt;("lockId").`in`(softLocking.lockIds.map { it.toString() })))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private val commonPredicates = mutableMapOf&lt;Pair&lt;String, Operator&gt;, Predicate&gt;() // schema attribute Name, operator -&gt; predicate</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$shiftLeft += columnNumberBeforeRemoval - aggregateExpressions.size</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$sorting.copy(columns = sorting.columns + Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF), Sort.Direction.ASC))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val actualSorting = if (sorting.columns.none { it.sortAttribute == SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF) }) { sorting.copy(columns = sorting.columns + Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF), Sort.Direction.ASC)) } else { sorting }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val combinedPredicates = commonPredicates.values.plus(predicateSet).plus(constraintPredicates).plus(joinPredicates)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val existingStatus = ((commonPredicates[predicateID] as ComparisonPredicate).rightHandOperand as LiteralExpression).literal</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val existingTypes = (commonPredicates[predicateID]!!.expressions[0] as InPredicate&lt;*&gt;).values.map { (it as LiteralExpression).literal }.toSet()</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val externalIdJoin = criteriaBuilder.equal(vaultStates.get&lt;VaultSchemaV1.VaultStates&gt;("stateRef"), entityRoot.get&lt;VaultSchemaV1.StateToExternalId&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val externalIdPredicate = criteriaBuilder.and(entityRoot.get&lt;VaultSchemaV1.StateToExternalId&gt;("externalId").`in`(ids))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultFungibleStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val participantsPredicate = criteriaBuilder.and(entityRoot.get&lt;VaultSchemaV1.PersistentParty&gt;("x500Name").`in`(participants))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val predicateConstraintData = criteriaBuilder.equal(vaultStates.get&lt;Vault.ConstraintInfo&gt;(VaultSchemaV1.VaultStates::constraintData.name), constraint.data())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val predicateConstraintType = criteriaBuilder.equal(vaultStates.get&lt;Vault.ConstraintInfo&gt;(VaultSchemaV1.VaultStates::constraintType.name), constraint.type())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val statePartyJoin = criteriaBuilder.equal(vaultStates.get&lt;VaultSchemaV1.VaultStates&gt;("stateRef"), entityRoot.get&lt;VaultSchemaV1.PersistentParty&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val vaultStates: Root&lt;VaultSchemaV1.VaultStates&gt;</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser${ @Suppress("UNCHECKED_CAST") column as Path&lt;Long?&gt;? val aggregateExpression = when (columnPredicate.type) { AggregateFunctionType.SUM -&gt; criteriaBuilder.sum(column) AggregateFunctionType.AVG -&gt; criteriaBuilder.avg(column) AggregateFunctionType.COUNT -&gt; criteriaBuilder.count(column) AggregateFunctionType.MAX -&gt; criteriaBuilder.max(column) AggregateFunctionType.MIN -&gt; criteriaBuilder.min(column) } //TODO investigate possibility to avoid producing redundant joins in SQL for multiple aggregate functions against the same table aggregateExpressions.add(aggregateExpression) // Some databases may not support aggregate expression in 'group by' clause e.g. 'group by sum(col)', // Hibernate Criteria Builder can't produce alias 'group by col_alias', and the only solution is to use a positional parameter 'group by 1' val orderByColumnPosition = aggregateExpressions.size var shiftLeft = 0 // add optional group by clauses expression.groupByColumns?.let { columns -&gt; val groupByExpressions = columns.map { _column -&gt; val path = root.get&lt;Any?&gt;(getColumnName(_column)) val columnNumberBeforeRemoval = aggregateExpressions.size if (path is SingularAttributePath) //remove the same columns from different joins to match the single column in 'group by' only (from the last join) aggregateExpressions.removeAll { elem -&gt; if (elem is SingularAttributePath) elem.attribute.javaMember == path.attribute.javaMember else false } shiftLeft += columnNumberBeforeRemoval - aggregateExpressions.size //record how many times a duplicated column was removed (from the previous 'parseAggregateFunction' run) aggregateExpressions.add(path) path } criteriaQuery.groupBy(groupByExpressions) } // optionally order by this aggregate function expression.orderBy?.let { val orderCriteria = when (expression.orderBy!!) { // when adding column position of 'group by' shift in case columns were removed Sort.Direction.ASC -&gt; criteriaBuilder.asc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft)) Sort.Direction.DESC -&gt; criteriaBuilder.desc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft)) } criteriaQuery.orderBy(orderCriteria) } return aggregateExpression }</ID>
    <ID>MaxLineLength:Hooker.kt$Hooker$if (className.startsWith("java") || className.startsWith("sun") || className.startsWith("javassist") || className.startsWith("kotlin")) { return null }</ID>
    <ID>MaxLineLength:Hooker.kt$Hooker$if (signature.parameterTypes[i] != objectName &amp;&amp; signature.parameterTypes[i] != method.parameterTypes[i].name) { return@mapNotNull null }</ID>
    <ID>MaxLineLength:Hooker.kt$Hooker$val overriddenPosition = if (method.methodInfo.isConstructor &amp;&amp; annotation.passThis &amp;&amp; annotation.position == HookPosition.Before) { println("passThis=true and position=${HookPosition.Before} for a constructor. " + "You can only inspect 'this' at the end of the constructor! Hooking *after*.. $method") HookPosition.After } else { annotation.position }</ID>
    <ID>MaxLineLength:Hooker.kt$Hooker.Companion$return "try { $statement } catch (Throwable throwable) { ${Hooker::class.java.canonicalName}.${Hooker.Companion::exceptionInHook.name}(throwable); }"</ID>
    <ID>MaxLineLength:HospitalisingInterceptor.kt$HospitalisingInterceptor : TransitionExecutor</ID>
    <ID>MaxLineLength:HospitalisingInterceptor.kt$HospitalisingInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:HsmSimulator.kt$HsmSimulator : ExternalResource</ID>
    <ID>MaxLineLength:HsmSimulator.kt$HsmSimulator$ private fun cleanUpExisting()</ID>
    <ID>MaxLineLength:HsmSimulator.kt$HsmSimulator$val portBindings = mapOf(HSM_SIMULATOR_PORT to listOf(PortBinding.create(address.host, address.port.toString())))</ID>
    <ID>MaxLineLength:HsmSimulator.kt$net.corda.nodeapi.internal.hsm.HsmSimulator.kt</ID>
    <ID>MaxLineLength:HttpApi.kt$HttpApi.Companion$fun fromHostAndPort(hostAndPort: NetworkHostAndPort, base: String, protocol: String = "http", mapper: ObjectMapper = defaultMapper): HttpApi</ID>
    <ID>MaxLineLength:HttpTests.kt$HttpTests.&lt;no name provided&gt;$override val proxyConfig: ProxyConfig? = ProxyConfig(ProxyVersion.HTTP, NetworkHostAndPort("127.0.0.1", httpProxyPort), null, null)</ID>
    <ID>MaxLineLength:HttpUtils.kt$HttpUtils$inline</ID>
    <ID>MaxLineLength:HttpUtils.kt$HttpUtils$throw IOException("${request.method()} to ${request.url()} returned a ${response.code()}: ${response.body()?.string()}")</ID>
    <ID>MaxLineLength:IOUFlow.kt$IOUFlow$val fullySignedTx = subFlow(CollectSignaturesFlow(signedTx, listOf(otherPartySession), CollectSignaturesFlow.tracker()))</ID>
    <ID>MaxLineLength:IRS.kt$FixedRatePaymentEvent$"FixedRatePaymentEvent $accrualStartDate -&gt; $accrualEndDate : $dayCountFactor : $days : $date : $notional : $rate : $flow"</ID>
    <ID>MaxLineLength:IRS.kt$FixedRatePaymentEvent$override val flow: Amount&lt;Currency&gt; get() = Amount(dayCountFactor.times(BigDecimal(notional.quantity)).times(rate.ratioUnit!!.value).toLong(), notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$override fun asCSV(): String</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$override fun toString(): String</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$rate: Rate</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$rate: Rate = this.rate</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$val nextFloating = interest(notional, "act/365", fix("LIBOR", start, Tenor("3M")), start, end)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$ private fun getFloatingLegPaymentsDifferences(payments1: Map&lt;LocalDate, Event&gt;, payments2: Map&lt;LocalDate, Event&gt;): List&lt;Pair&lt;LocalDate, Pair&lt;FloatingRatePaymentEvent, FloatingRatePaymentEvent&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"All notionals must be non zero" using (irs.fixedLeg.notional.quantity &gt; 0 &amp;&amp; irs.floatingLeg.notional.quantity &gt; 0)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The changed payments dates are aligned" using (oldFloatingRatePaymentEvent.date == newFixedRatePaymentEvent.date)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The currency of the notionals must be the same" using (irs.fixedLeg.notional.token == irs.floatingLeg.notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The effective date is before the termination date for the fixed leg" using (irs.fixedLeg.effectiveDate &lt; irs.fixedLeg.terminationDate)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The effective date is before the termination date for the floating leg" using (irs.floatingLeg.effectiveDate &lt; irs.floatingLeg.terminationDate)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fix payment has the same currency as the notional" using (newFixedRatePaymentEvent.flow.token == irs.floatingLeg.notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixed leg parties are constant" using (irs.fixedLeg.fixedRatePayer == prevIrs.fixedLeg.fixedRatePayer)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixed leg payment schedule is constant" using (irs.calculation.fixedLegPaymentSchedule == prevIrs.calculation.fixedLegPaymentSchedule)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixing is for the next required date" using (prevIrs.calculation.nextFixingDate() == fixValue.of.forDay)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The new payment has the correct rate" using (newFixedRatePaymentEvent.rate.ratioUnit!!.value == fixValue.value)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"There is at least one difference in the IRS floating leg payment schedules" using !paymentDifferences.isEmpty()</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$Calculation</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$TransactionBuilder(notary) .addCommand(Command(Commands.Agree(), listOf(state.floatingLeg.floatingRatePayer.owningKey, state.fixedLeg.fixedRatePayer.owningKey)))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$private</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$tx.addCommand(Commands.Refix(fixing), listOf(irs.state.data.floatingLeg.floatingRatePayer.owningKey, irs.state.data.fixedLeg.fixedRatePayer.owningKey))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val (oldFloatingRatePaymentEvent, newFixedRatePaymentEvent) = paymentDifferences.single().second // Ignore the date of the changed rate (we checked that earlier).</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val groups: List&lt;LedgerTransaction.InOutGroup&lt;State, UniqueIdentifier&gt;&gt; = tx.groupStates { state -&gt; state.linearId }</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val paymentDifferences = getFloatingLegPaymentsDifferences(prevIrs.calculation.floatingLegPaymentSchedule, irs.calculation.floatingLegPaymentSchedule)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Calculation$return floatingLegPaymentSchedule.filter { it.value.rate is ReferenceRate }.// TODO - a better way to determine what fixings remain to be fixed minBy { it.value.fixingDate.toEpochDay() }?.value?.fixingDate</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Commands$Mature : TypeOnlyCommandDataCommands</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Common$val valuationDateDescription: String</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$"PaymentRule=$paymentRule,PaymentDelay=$paymentDelay,PaymentCalendar=$paymentCalendar,InterestPeriodAdjustment=$interestPeriodAdjustment"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$"TerminationDateAdjustment=$terminationDateAdjustment,DayCountBasis=$dayCountBasisDay/$dayCountBasisYear,DayInMonth=$dayInMonth,"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$dayCountBasisDay</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$effectiveDateAdjustment</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$return "Notional=$notional,PaymentFrequency=$paymentFrequency,EffectiveDate=$effectiveDate,EffectiveDateAdjustment:$effectiveDateAdjustment,TerminatationDate=$terminationDate," + "TerminationDateAdjustment=$terminationDateAdjustment,DayCountBasis=$dayCountBasisDay/$dayCountBasisYear,DayInMonth=$dayInMonth," + "PaymentRule=$paymentRule,PaymentDelay=$paymentDelay,PaymentCalendar=$paymentCalendar,InterestPeriodAdjustment=$interestPeriodAdjustment"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FixedLeg$dayCountBasisDay</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FixedLeg$override</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$"FixingPeriondOffset=$fixingPeriodOffset,ResetRule=$resetRule,FixingsPerPayment=$fixingsPerPayment,FixingCalendar=$fixingCalendar,"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$"rollConvention=$rollConvention,FixingRollConvention=$fixingRollConvention,ResetDayInMonth=$resetDayInMonth"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$( var floatingRatePayer: AbstractParty, notional: Amount&lt;Currency&gt;, paymentFrequency: Frequency, effectiveDate: LocalDate, effectiveDateAdjustment: DateRollConvention?, terminationDate: LocalDate, terminationDateAdjustment: DateRollConvention?, dayCountBasisDay: DayCountBasisDay, dayCountBasisYear: DayCountBasisYear, dayInMonth: Int, paymentRule: PaymentRule, paymentDelay: Int, paymentCalendar: BusinessCalendar, interestPeriodAdjustment: AccrualAdjustment, var rollConvention: DateRollConvention, var fixingRollConvention: DateRollConvention, var resetDayInMonth: Int, var fixingPeriodOffset: Int, var resetRule: PaymentRule, var fixingsPerPayment: Frequency, var fixingCalendar: BusinessCalendar, var index: String, var indexSource: String, var indexTenor: Tenor )</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$dayCountBasisDay</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$InterestRateSwap().generateFix(ptx, StateAndRef(TransactionState(this, IRS_PROGRAM_ID, oldState.state.notary, constraint = AlwaysAcceptAttachmentConstraint), oldState.ref), fix)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$override</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$return ScheduledActivity(flowLogicRefFactory.create("net.corda.irs.flows.FixingFlow\$FixingRoleDecider", thisStateRef), instant)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$val instant = suggestInterestRateAnnouncementTimeWindow(index = nextFixingOf.name, source = floatingLeg.indexSource, date = nextFixingOf.forDay).fromTime!!</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State${ val nextFixingOf = nextFixingOf() ?: return null // This is perhaps not how we should determine the time point in the business day, but instead expect the schedule to detail some of these aspects val instant = suggestInterestRateAnnouncementTimeWindow(index = nextFixingOf.name, source = floatingLeg.indexSource, date = nextFixingOf.forDay).fromTime!! return ScheduledActivity(flowLogicRefFactory.create("net.corda.irs.flows.FixingFlow\$FixingRoleDecider", thisStateRef), instant) }</ID>
    <ID>MaxLineLength:IRS.kt$PaymentEvent : Event</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$// TODO : Fix below (use daycount convention for division, not hardcoded 360 etc) val dayCountFactor: BigDecimal get() = (BigDecimal(days).divide(BigDecimal(360.0), 8, RoundingMode.HALF_UP)).setScale(4, RoundingMode.HALF_UP)</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$open fun asCSV()</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$val days: Int get() = BusinessCalendar.calculateDaysBetween(accrualStartDate, accrualEndDate, dayCountBasisYear, dayCountBasisDay)</ID>
    <ID>MaxLineLength:IRS.kt$UnknownType</ID>
    <ID>MaxLineLength:IRSDemo.kt$Role.Trade -&gt; IRSDemoClientApi(NetworkHostAndPort("localhost", 10007)).runTrade(value, CordaX500Name.parse("O=Notary Service,L=Zurich,C=CH"))</ID>
    <ID>MaxLineLength:IRSDemoDockerTest.kt$IRSDemoDockerTest.Companion$DockerComposeRule.builder() .files(DockerComposeFiles.from( System.getProperty("CORDAPP_DOCKER_COMPOSE"), System.getProperty("WEB_DOCKER_COMPOSE"))) .waitingForService("web-a", HealthChecks.toRespondOverHttp(8080, { port -&gt; port.inFormat("http://\$HOST:\$EXTERNAL_PORT") }))</ID>
    <ID>MaxLineLength:IRSDemoDockerTest.kt$IRSDemoDockerTest.Companion$throw IllegalStateException("System property $property not set. Please refer to README file for proper setup instructions.")</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$InterestRateSwapStateDeserializer : JsonDeserializer</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$return IOUtils.toString(Thread.currentThread().contextClassLoader.getResourceAsStream(filename), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$val (controllerApi, nodeAApi, nodeBApi) = listOf(controller, nodeA, nodeB).zip(listOf(controllerAddr, nodeAAddr, nodeBAddr)).map { val mapper = JacksonSupport.createDefaultMapper(it.first.rpc) registerFinanceJSONMappers(mapper) registerIRSModule(mapper) HttpApi.fromHostAndPort(it.second, "api/irs", mapper = mapper) }</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest.InterestRateSwapStateDeserializer$InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, linearId = linearId, oracle = oracle)</ID>
    <ID>MaxLineLength:IRSExport.kt$this.calculation.floatingLegPaymentSchedule.toSortedMap().values.joinToString("\n") { it.asCSV() }</ID>
    <ID>MaxLineLength:IRSState.kt$IRSState$override val linearId: UniqueIdentifier = UniqueIdentifier(swap.id.first + swap.id.second)</ID>
    <ID>MaxLineLength:IRSState.kt$IRSState$return TransactionBuilder(notary).withItems(StateAndContract(state, IRS_PROGRAM_ID), Command(OGTrade.Commands.Agree(), participants.map { it.owningKey }))</ID>
    <ID>MaxLineLength:IRSTests.kt$"(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"</ID>
    <ID>MaxLineLength:IRSTests.kt$( // TODO: this seems to fail quite dramatically //expression = "fixedLeg.notional * fixedLeg.fixedRate", // TODO: How I want it to look //expression = "( fixedLeg.notional * (fixedLeg.fixedRate)) - (floatingLeg.notional * (rateSchedule.get(context.getDate('currentDate'))))", // How it's ended up looking, which I think is now broken but it's a WIP. expression = Expression("( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) -" + "(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"), floatingLegPaymentSchedule = mutableMapOf(), fixedLegPaymentSchedule = mutableMapOf() )</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$ fun tradegroups(): LedgerDSL&lt;TestTransactionDSLInterpreter, TestLedgerDSLInterpreter&gt;</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$( "fixedLeg.notional.quantity", "fixedLeg.fixedRate.ratioUnit", "fixedLeg.fixedRate.ratioUnit.value", "floatingLeg.notional.quantity", "fixedLeg.fixedRate", "currentBusinessDate", "calculation.floatingLegPaymentSchedule.get(currentBusinessDate)", "fixedLeg.notional.token.currencyCode", "fixedLeg.notional.quantity * 10", "fixedLeg.notional.quantity * fixedLeg.fixedRate.ratioUnit.value", "(fixedLeg.notional.token.currencyCode.equals('GBP')) ? 365 : 360 ", "(fixedLeg.notional.quantity * (fixedLeg.fixedRate.ratioUnit.value))" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value", //"( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) - (floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))", // "( fixedLeg.notional * fixedLeg.fixedRate )" )</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$attachments(IRS_PROGRAM_ID) input(IRS_PROGRAM_ID, oldIRS) // Templated tweak for reference. A corrent fixing applied should be ok tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) output(IRS_PROGRAM_ID, newIRS) this.verifies() } // This test makes sure that verify confirms the fixing was applied and there is a difference in the old and new tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) output(IRS_PROGRAM_ID, oldIRS) this `fails with` "There is at least one difference in the IRS floating leg payment schedules" } // This tests tries to sneak in a change to another fixing (which may or may not be the latest one) tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) val firstResetKey = newIRS.calculation.floatingLegPaymentSchedule.keys.toList()[1] val firstResetValue = newIRS.calculation.floatingLegPaymentSchedule[firstResetKey] val modifiedFirstResetValue = firstResetValue!!.copy(notional = Amount(firstResetValue.notional.quantity, Currency.getInstance("JPY"))) output(IRS_PROGRAM_ID, newIRS.copy( newIRS.fixedLeg, newIRS.floatingLeg, newIRS.calculation.copy(floatingLegPaymentSchedule = newIRS.calculation.floatingLegPaymentSchedule.plus( Pair(firstResetKey, modifiedFirstResetValue))), newIRS.common)) this `fails with` "There is only one change in the IRS floating leg payment schedule" } // This tests modifies the payment currency for the fixing tweak { command(ORACLE_PUBKEY, InterestRateSwap.Commands.Refix(Fix(FixOf("ICE LIBOR", ld, Tenor("3M")), bd))) timeWindow(TEST_TX_TIME) val latestReset = newIRS.calculation.floatingLegPaymentSchedule.filter { it.value.rate is FixedRate }.maxBy { it.key } val modifiedLatestResetValue = latestReset!!.value.copy(notional = Amount(latestReset.value.notional.quantity, Currency.getInstance("JPY"))) output(IRS_PROGRAM_ID, newIRS.copy( newIRS.fixedLeg, newIRS.floatingLeg, newIRS.calculation.copy(floatingLegPaymentSchedule = newIRS.calculation.floatingLegPaymentSchedule.plus( Pair(latestReset.key, modifiedLatestResetValue))), newIRS.common)) this `fails with` "The fix payment has the same currency as the notional" }</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$newIRS.calculation</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$output(IRS_PROGRAM_ID, irs.copy(calculation = irs.calculation.copy(fixedLegPaymentSchedule = emptySchedule)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$output(IRS_PROGRAM_ID, irs.copy(calculation = irs.calculation.copy(floatingLegPaymentSchedule = emptySchedule)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$private val notaryServices = MockServices(cordappPackages, dummyNotary, mock(), networkParameters, dummyNotary.keyPair)</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val latestReset = newIRS.calculation.floatingLegPaymentSchedule.filter { it.value.rate is FixedRate }.maxBy { it.key }</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedFirstResetValue = firstResetValue!!.copy(notional = Amount(firstResetValue.notional.quantity, Currency.getInstance("JPY")))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS = irs.copy(fixedLeg = irs.fixedLeg.copy(notional = Amount(irs.fixedLeg.notional.quantity, Currency.getInstance("JPY"))))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS = irs.copy(fixedLeg = irs.fixedLeg.copy(notional = Amount(irs.floatingLeg.notional.quantity + 1, irs.floatingLeg.notional.token)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS1 = irs.copy(fixedLeg = irs.fixedLeg.copy(terminationDate = irs.fixedLeg.effectiveDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS2 = irs.copy(floatingLeg = irs.floatingLeg.copy(terminationDate = irs.floatingLeg.effectiveDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS3 = irs.copy(floatingLeg = irs.floatingLeg.copy(terminationDate = irs.fixedLeg.terminationDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS4 = irs.copy(floatingLeg = irs.floatingLeg.copy(effectiveDate = irs.fixedLeg.effectiveDate.minusDays(1)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedLatestResetValue = latestReset!!.value.copy(notional = Amount(latestReset.value.notional.quantity, Currency.getInstance("JPY")))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests${ val dummyIRS = singleIRS() val stuffToPrint: ArrayList&lt;String&gt; = arrayListOf( "fixedLeg.notional.quantity", "fixedLeg.fixedRate.ratioUnit", "fixedLeg.fixedRate.ratioUnit.value", "floatingLeg.notional.quantity", "fixedLeg.fixedRate", "currentBusinessDate", "calculation.floatingLegPaymentSchedule.get(currentBusinessDate)", "fixedLeg.notional.token.currencyCode", "fixedLeg.notional.quantity * 10", "fixedLeg.notional.quantity * fixedLeg.fixedRate.ratioUnit.value", "(fixedLeg.notional.token.currencyCode.equals('GBP')) ? 365 : 360 ", "(fixedLeg.notional.quantity * (fixedLeg.fixedRate.ratioUnit.value))" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value", //"( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) - (floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))", // "( fixedLeg.notional * fixedLeg.fixedRate )" ) for (i in stuffToPrint) { println(i) val z = dummyIRS.evaluateCalculation(LocalDate.of(2016, 9, 15), Expression(i)) println(z.javaClass) println(z) println("-----------") } // This does not throw an exception in the test itself; it evaluates the above and they will throw if they do not pass. }</ID>
    <ID>MaxLineLength:IRSTests.kt$InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY)</ID>
    <ID>MaxLineLength:IRSTests.kt$dailyInterestAmount = Expression("(CashAmount * InterestRate ) / (fixedLeg.notional.currency.currencyCode.equals('GBP')) ? 365 : 360")</ID>
    <ID>MaxLineLength:IRSTests.kt$resolutionTime = "2:00pm London time on the first LocalBusiness Day following the date on which the notice is given "</ID>
    <ID>MaxLineLength:IRSTests.kt$return InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY)</ID>
    <ID>MaxLineLength:IRSTests.kt${ // 10y swap, we pay 1.3% fixed 30/360 semi, rec 3m usd libor act/360 Q on 25m notional (mod foll/adj on both sides) // I did a mock up start date 10/03/2015  10/03/2025 so you have 5 cashflows on float side that have been preset the rest are unknown val fixedLeg = InterestRateSwap.FixedLeg( fixedRatePayer = MEGA_CORP, notional = 25000000.DOLLARS, paymentFrequency = Frequency.SemiAnnual, effectiveDate = LocalDate.of(2015, 3, 10), effectiveDateAdjustment = null, terminationDate = LocalDate.of(2025, 3, 10), terminationDateAdjustment = null, fixedRate = FixedRate(PercentageRatioUnit("1.3")), dayCountBasisDay = DayCountBasisDay.D30, dayCountBasisYear = DayCountBasisYear.Y360, rollConvention = DateRollConvention.ModifiedFollowing, dayInMonth = 10, paymentRule = PaymentRule.InArrears, paymentDelay = 0, paymentCalendar = BusinessCalendar.EMPTY, interestPeriodAdjustment = AccrualAdjustment.Adjusted ) val floatingLeg = InterestRateSwap.FloatingLeg( floatingRatePayer = MINI_CORP, notional = 25000000.DOLLARS, paymentFrequency = Frequency.Quarterly, effectiveDate = LocalDate.of(2015, 3, 10), effectiveDateAdjustment = null, terminationDate = LocalDate.of(2025, 3, 10), terminationDateAdjustment = null, dayCountBasisDay = DayCountBasisDay.DActual, dayCountBasisYear = DayCountBasisYear.Y360, rollConvention = DateRollConvention.ModifiedFollowing, fixingRollConvention = DateRollConvention.ModifiedFollowing, dayInMonth = 10, resetDayInMonth = 10, paymentRule = PaymentRule.InArrears, paymentDelay = 0, paymentCalendar = BusinessCalendar.EMPTY, interestPeriodAdjustment = AccrualAdjustment.Adjusted, fixingPeriodOffset = 2, resetRule = PaymentRule.InAdvance, fixingsPerPayment = Frequency.Quarterly, fixingCalendar = BusinessCalendar.EMPTY, index = "USD LIBOR", indexSource = "TEL3750", indexTenor = Tenor("3M") ) val calculation = InterestRateSwap.Calculation( // TODO: this seems to fail quite dramatically //expression = "fixedLeg.notional * fixedLeg.fixedRate", // TODO: How I want it to look //expression = "( fixedLeg.notional * (fixedLeg.fixedRate)) - (floatingLeg.notional * (rateSchedule.get(context.getDate('currentDate'))))", // How it's ended up looking, which I think is now broken but it's a WIP. expression = Expression("( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) -" + "(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"), floatingLegPaymentSchedule = mutableMapOf(), fixedLegPaymentSchedule = mutableMapOf() ) val common = InterestRateSwap.Common( baseCurrency = EUR, eligibleCurrency = EUR, eligibleCreditSupport = "Cash in an Eligible Currency", independentAmounts = Amount(0, EUR), threshold = Amount(0, EUR), minimumTransferAmount = Amount(250000 * 100, EUR), rounding = Amount(10000 * 100, EUR), valuationDateDescription = "Every Local Business Day", notificationTime = "2:00pm London", resolutionTime = "2:00pm London time on the first LocalBusiness Day following the date on which the notice is given ", interestRate = ReferenceRate("T3270", Tenor("6M"), "EONIA"), addressForTransfers = "", exposure = UnknownType(), localBusinessDay = loadTestCalendar("London"), tradeID = "trade2", hashLegalDocs = "put hash here", dailyInterestAmount = Expression("(CashAmount * InterestRate ) / (fixedLeg.notional.currency.currencyCode.equals('GBP')) ? 365 : 360") ) return InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY) }</ID>
    <ID>MaxLineLength:IRSTradeFlow.kt$IRSTradeFlow.Requester$val notary = serviceHub.networkMapCache.notaryIdentities.first() // TODO We should pass the notary as a parameter to the flow, not leave it to random choice.</ID>
    <ID>MaxLineLength:IRSUtils.kt$PercentageRatioUnit$open</ID>
    <ID>MaxLineLength:IRSUtils.kt$net.corda.irs.contract.IRSUtils.kt</ID>
    <ID>MaxLineLength:IRSUtils.kt$operator</ID>
    <ID>MaxLineLength:IRSUtils.kt$operator fun kotlin.Int.times(other: FixedRate): Int</ID>
    <ID>MaxLineLength:Id.kt$Id.Companion$ @DeleteForDJVM @JvmStatic fun &lt;V : Any&gt; newInstance(value: V, entityType: String? = null, timestamp: Instant = now())</ID>
    <ID>MaxLineLength:IdempotentFlowTests.kt$IdempotentFlowTests.TimedSubflow$subFlowExecutionCounter.incrementAndGet()</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer$private</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer$private val patchFlags = byteArrayOf(PATCH_SYMMETRIC, 0, 0, 0, PATCH_SYMMETRIC, 0, 0, 0, PATCH_SYMMETRIC, 0, 0, 0, 0, 0, 0, (PATCH_SYMMETRIC + PATCH_INVERTED).toByte())</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer.Patch$return byteArray.map(Byte::toInt).map { it % PATCH_GRIDS * (patchSize / PATCH_CELLS) - patchSize / 2 }.toDoubleArray()</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer.Patch$return byteArray.map(Byte::toInt).map { it / PATCH_GRIDS * (patchSize / PATCH_CELLS) - patchSize / 2 }.toDoubleArray()</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer.PatchColor$private</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ @Throws(IllegalArgumentException::class) fun registerKeyToParty(key: PublicKey, party: Party)</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ fun wellKnownPartyFromX500Name(name: CordaX500Name): Party?</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$@Deprecated("This method has been deprecated in favour of using a new way to generate and use confidential identities. See the new " + "confidential identities repository.")</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService${ // The original version of this would return the party as-is if it was a Party (rather than AnonymousParty), // however that means that we don't verify that we know who owns the key. As such as now enforce turning the key // into a party, and from there figure out the well known party. log.debug("Attempting to find wellKnownParty for: ${party.owningKey.hash}") val candidate = partyFromKey(party.owningKey) // TODO: This should be done via the network map cache, which is the authoritative source of well known identities return if (candidate != null) { require(party.nameOrNull() == null || party.nameOrNull() == candidate.name) { "Candidate party $candidate does not match expected $party" } wellKnownPartyFromX500Name(candidate.name) } else { null } }</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean): PartyAndCertificate?</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false): PartyAndCertificate?</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$ fun justVerifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false)</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal$val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country)</ID>
    <ID>MaxLineLength:IdentityServiceInternal.kt$IdentityServiceInternal${ private companion object { val log = contextLogger() } /** This method exists so it can be mocked with doNothing, rather than having to make up a possibly invalid return value. */ fun justVerifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false) { verifyAndRegisterIdentity(identity, isNewRandomIdentity) } /** * Verify and then store an identity. * * @param identity a party and the certificate path linking them to the network trust root. * @param isNewRandomIdentity true if the identity will not have been registered before (e.g. because it is randomly generated by ourselves). * @return the issuing entity, if known. * @throws IllegalArgumentException if the certificate path is invalid. */ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean): PartyAndCertificate? // We can imagine this being a query over a lucene index in future. // // Kostas says: When exactMatch = false, we can easily use the Jaro-Winkler distance metric as it is best suited for short // strings such as entity/company names, and to detect small typos. We can also apply it for city // or any keyword related search in lists of records (not raw text - for raw text we need indexing) // and we can return results in hierarchical order (based on normalised String similarity 0.0-1.0). /** Check if [x500name] matches the [query]. */ fun x500Matches(query: String, exactMatch: Boolean, x500name: CordaX500Name): Boolean { val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country) return components.any { (exactMatch &amp;&amp; it == query) || (!exactMatch &amp;&amp; it.contains(query, ignoreCase = true)) } } /** * Verifies that an identity is valid. * * @param trustAnchor The trust anchor that will verify the identity's validity * @param identity The identity to verify * @param isNewRandomIdentity true if the identity will not have been registered before (e.g. because it is randomly generated by ourselves). */ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false): PartyAndCertificate? { // Validate the chain first, before we do anything clever with it val identityCertChain = identity.certPath.x509Certificates try { identity.verify(trustAnchor) } catch (e: CertPathValidatorException) { log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.") log.warn("Certificate path :") identityCertChain.reversed().forEachIndexed { index, certificate -&gt; val space = (0 until index).joinToString("") { " " } log.warn("$space${certificate.subjectX500Principal}") } throw e } // Ensure we record the first identity of the same name, first val wellKnownCert = identityCertChain.single { CertRole.extract(it)?.isWellKnown ?: false } if (wellKnownCert != identity.certificate &amp;&amp; !isNewRandomIdentity) { val idx = identityCertChain.lastIndexOf(wellKnownCert) val firstPath = X509Utilities.buildCertPath(identityCertChain.slice(idx until identityCertChain.size)) verifyAndRegisterIdentity(trustAnchor, PartyAndCertificate(firstPath)) } return registerIdentity(identity, isNewRandomIdentity) } fun registerIdentity(identity: PartyAndCertificate, isNewRandomIdentity: Boolean = false): PartyAndCertificate? }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$//the only time an identity name does not have a PK_HASH is if there are multiple identities associated with that name Assert.assertThat(groupedByNameIdentities[it]?.size, `is`(greaterThan(1)))</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$Assert.assertThat(nameToHashResultSet.getString(1), `is`(anyOf(groupedByNameIdentities.getValue(it.name).map&lt;PartyAndCertificate, Matcher&lt;String&gt;?&gt; { identity -&gt; CoreMatchers.equalTo(identity.name.toString()) })))</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val hashToIdentityStatement = database.dataSource.connection.prepareStatement("SELECT ${PersistentIdentityService.PK_HASH_COLUMN_NAME} FROM ${PersistentIdentityService.HASH_TO_IDENTITY_TABLE_NAME} WHERE pk_hash=?")</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val hashToIdentityStatement = database.dataSource.connection.prepareStatement("SELECT ${PersistentIdentityService.PK_HASH_COLUMN_NAME} FROM ${PersistentIdentityService.HASH_TO_IDENTITY_TABLE_NAME} WHERE pk_hash=?") hashToIdentityStatement.setString(1, it.owningKey.toStringShort()) val hashToIdentityResultSet = hashToIdentityStatement.executeQuery() //check that there is a row for every "new" hash Assert.assertThat(hashToIdentityResultSet.next(), `is`(true)) //check that the pk_hash actually matches what we expect (kinda redundant, but deserializing the whole PartyAndCertificate feels like overkill) Assert.assertThat(hashToIdentityResultSet.getString(1), `is`(it.owningKey.toStringShort())) val nameToHashStatement = connection.prepareStatement("SELECT ${PersistentIdentityService.NAME_COLUMN_NAME} FROM ${PersistentIdentityService.NAME_TO_HASH_TABLE_NAME} WHERE pk_hash=?") nameToHashStatement.setString(1, it.owningKey.toStringShort()) val nameToHashResultSet = nameToHashStatement.executeQuery() //if there is no result for this key, this means its an identity that is not stored in the DB (IE, it's been seen after another identity has already been mapped to it) if (nameToHashResultSet.next()) { Assert.assertThat(nameToHashResultSet.getString(1), `is`(anyOf(groupedByNameIdentities.getValue(it.name).map&lt;PartyAndCertificate, Matcher&lt;String&gt;?&gt; { identity -&gt; CoreMatchers.equalTo(identity.name.toString()) }))) } else { logger.warn("did not find a PK_HASH for ${it.name}") listOfNamesWithoutPkHash.add(it.name) }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val nameToHashStatement = connection.prepareStatement("SELECT ${PersistentIdentityService.NAME_COLUMN_NAME} FROM ${PersistentIdentityService.NAME_TO_HASH_TABLE_NAME} WHERE pk_hash=?")</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val persistentIDs = certs.map { PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.hash.toString(), it.certPath.encoded) }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val persistentName = PersistentIdentityService.PersistentPartyToPublicKeyHash(name.toString(), certs.first().owningKey.hash.toString())</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive$// Store the received confidential identities in the identity service so we have a record of which well known identity they map to. serviceHub.identityService.verifyAndRegisterIdentity(identity)</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive$val unknownIdentities = allIdentities.filter { serviceHub.identityService.wellKnownPartyFromAnonymous(it) == null }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive${ progressTracker.currentStep = RECEIVING_IDENTITIES val allIdentities = otherSideSession.receive&lt;List&lt;AbstractParty&gt;&gt;().unwrap { it } val unknownIdentities = allIdentities.filter { serviceHub.identityService.wellKnownPartyFromAnonymous(it) == null } progressTracker.currentStep = RECEIVING_CERTIFICATES val missingIdentities = otherSideSession.sendAndReceive&lt;List&lt;PartyAndCertificate&gt;&gt;(unknownIdentities) // Batch verify the identities we've received, so we know they're all correct before we start storing them in // the identity service missingIdentities.unwrap { identities -&gt; identities.forEach { it.verify(serviceHub.identityService.trustAnchor) } identities }.forEach { identity -&gt; // Store the received confidential identities in the identity service so we have a record of which well known identity they map to. serviceHub.identityService.verifyAndRegisterIdentity(identity) } }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$confidentialIdentities .map { @Suppress("DEPRECATION") Pair(it, serviceHub.identityService.certificateFromKey(it.owningKey)) } // Filter down to confidential identities of our well known identity // TODO: Consider if this too restrictive - we perhaps should be checking the name on the signing certificate in the certificate path instead .filter { it.second?.name == ourIdentity.name }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$require(req.all { it in identityCertificates.keys }) { "${otherSideSession.counterparty} requested a confidential identity not part of transaction: ${tx.id}" }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$throw IllegalStateException("Counterparty requested a confidential identity for which we do not have the certificate path: ${tx.id}")</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$val requestedIdentities: List&lt;AbstractParty&gt; = otherSideSession.sendAndReceive&lt;List&lt;AbstractParty&gt;&gt;(identityCertificates.keys.toList()).unwrap { req -&gt; require(req.all { it in identityCertificates.keys }) { "${otherSideSession.counterparty} requested a confidential identity not part of transaction: ${tx.id}" } req }</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$aliceNode.database.transaction { aliceNode.services.identityService.verifyAndRegisterIdentity(confidentialIdentCert) }</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$assertNotNull(aliceNode.database.transaction { aliceNode.services.identityService.wellKnownPartyFromAnonymous(confidentialIdentity) })</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$assertNull(bobNode.database.transaction { bobNode.services.identityService.wellKnownPartyFromAnonymous(confidentialIdentity) })</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val confidentialIdentCert = @Suppress("DEPRECATION") charlieNode.services.identityService.certificateFromKey(confidentialIdentity.owningKey)!!</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val issueFlow = aliceNode.services.startFlow(CashIssueAndPaymentFlow(1000.DOLLARS, ref, alice, anonymous, notary)).resultFuture</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val issueFlow = charlieNode.services.startFlow(CashIssueAndPaymentFlow(1000.DOLLARS, ref, charlie, anonymous, notary))</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val payTx = charlieNode.services.startFlow(CashPaymentFlow(1000.DOLLARS, alice, anonymous)).resultFuture.getOrThrow().stx</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty(serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty(serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;, ignoreUnrecognisedParties: Boolean): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;, ignoreUnrecognisedParties: Boolean): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ fun &lt;T&gt; excludeHostNode(serviceHub: ServiceHub, map: Map&lt;Party, T&gt;): Map&lt;Party, T&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$(serviceHub.identityService.wellKnownPartyFromAnonymous(it) ?: if (ignoreUnrecognisedParties) return@mapNotNull null else throw IllegalArgumentException("Could not find Party for $it")) to it</ID>
    <ID>MaxLineLength:IdentityUtils.kt$groupAbstractPartyByWellKnownParty(serviceHub, publicKeys.map { AnonymousParty(it) }, ignoreUnrecognisedParties).mapValues { it.value.map { it.owningKey } }</ID>
    <ID>MaxLineLength:IdentityUtils.kt$val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country)</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$override</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$results += keyToPartyAndCerts[key]?.party ?: throw IllegalArgumentException("Could not find an entry in the database for the public key $key.")</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$ @Test fun `get anonymous identity by key`()</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$listOf("Org A", "Org B", "Org C") .map { getTestPartyAndCertificate(CordaX500Name(organisation = it, locality = "London", country = "GB"), generateKeyPair().public) }</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$val alicente = getTestPartyAndCertificate(CordaX500Name(organisation = "Alicente Worldwide", locality = "London", country = "GB"), generateKeyPair().public)</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests.Companion$fun createService(vararg identities: PartyAndCertificate)</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$@Synchronized private</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$DistributedServiceHandle : MessageRecipientGroup</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$MessageTransfer</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$ServicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$peersMapping[messagingService.myAddress.name] = messagingService.myAddress</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$private val servicePeerAllocationStrategy: ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork.Companion$servicePeerAllocationStrategy: ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork.MessageTransfer.Companion$internal</ID>
    <ID>MaxLineLength:InMemoryTransactionVerifierService.kt$InMemoryTransactionVerifierService : SingletonSerializeAsTokenTransactionVerifierServiceTransactionVerifierServiceInternalAutoCloseable</ID>
    <ID>MaxLineLength:InProcessBridgeReceiverService.kt$InProcessBridgeReceiverService$amqpListenerService.provisionKeysAndActivate(signingService.keyStore(), signingService.truststore(), maxMessageSize)</ID>
    <ID>MaxLineLength:InProcessBridgeReceiverService.kt$InProcessBridgeReceiverService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:InProcessBridgeReceiverService.kt$InProcessBridgeReceiverService$private val statusFollower = ServiceStateCombiner(listOf(auditService, haService, amqpListenerService, filterService, signingService))</ID>
    <ID>MaxLineLength:IncomingMessageFilterService.kt$IncomingMessageFilterService : ServiceLifecycleSupport</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCache.kt$InfrequentlyMutatedCache$ fun get(key: K, valueGetter: (K) -&gt; V): V</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCache.kt$InfrequentlyMutatedCache$// This protects against the cache purging something that is marked as invalid and thus we "forget" it shouldn't be cached. private val currentlyInvalid = ConcurrentHashMap&lt;K, Wrapper.Invalidated&lt;V&gt;&gt;()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCache.kt$InfrequentlyMutatedCache&lt;K : Any, V : Any&gt;</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$// This should not get cached, as the transaction that invalidated it in the other thread has completed but we might // not see the new value in our transaction since it started first. val result1 = cache.get("foo") { 1 } assertEquals(1, result1) val result2 = cache.get("foo") { 3 } assertEquals(3, result2) // Now allow other thread to commit transaction phaser.arriveAndAwaitAdvance() // and wait for commit to be complete phaser.arriveAndAwaitAdvance() // This should get cached, as the transaction that invalidated it in the other thread has completed but we might // not see the new value in our transaction since it started first. val result3 = cache.get("foo") { 3 } assertEquals(3, result3) val result4 = cache.get("foo") { 4 } assertEquals(4, result4)</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$// This will cache "2" cache.get("foo") { 2 } invalidateInOtherThread("foo") // This should not get cached, as the transaction that invalidated it in the other thread has completed but we might // not see the new value in our transaction since it started first. val result = cache.get("foo") { 1 } assertEquals(1, result)</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in other thread in the middle returns result of second loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with nested invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `getIfPresent outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `third get outside first transaction from empty cache with invalidate in the middle returns result of third loader`()</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration : RunAfterNodeInitialisationNodeStartupLogging</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$e.logAsUnexpected( "Could not delete the marker file that was created for `initial-registration`.", print = logger::warn)</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$println("Node was started before with `--initial-registration`, but the registration was not completed.\nResuming registration.")</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$println("Successfully registered Corda node with compatibility zone, node identity keys and certificates are stored in '${conf.certificatesDirectory}', it is advised to backup the private keys and certificates.")</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$require(networkRootTrustStorePath.exists()) { "Network root trust store path: '$networkRootTrustStorePath' doesn't exist" }</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration${ // Null checks for [compatibilityZoneURL], [rootTruststorePath] and [rootTruststorePassword] has been done in [CmdLineOptions.loadConfig] attempt { registerWithNetwork(config) }.doOnFailure(Consumer(this::handleRegistrationError)) as Try.Success // At this point the node registration was successful. We can delete the marker file. deleteNodeRegistrationMarker(baseDirectory) }</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli : CliWrapperBase</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$@Option(names = ["-p", "--network-root-truststore-password"], description = ["Network root trust store password obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$@Option(names = ["-t", "--network-root-truststore"], description = ["Network root trust store obtained from network operator."])</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$return startup.initialiseAndRun(cmdLineOptions, InitialRegistration(cmdLineOptions.baseDirectory, networkRootTrustStorePath, networkRootTrustStorePassword, startup))</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$val networkRootTrustStorePath: Path = networkRootTrustStorePathParameter ?: cmdLineOptions.baseDirectory / "certificates" / "network-root-truststore.jks"</ID>
    <ID>MaxLineLength:InitiatedBy.kt$InitiatedBy</ID>
    <ID>MaxLineLength:InitiatingFlow.kt$InitiatingFlow</ID>
    <ID>MaxLineLength:InstallCheckScheduleStateFlow.kt$InstallCheckScheduleStateFlow$val state = SchedulingContract.ScheduledCheckState(participants, newId, idsToCheck, target, startTime, lastSuccessTime, waitTimeSeconds, waitForOutstandingFlowsSeconds)</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$InstallShellExtensionsParser : CliWrapperBase</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$// If on Windows, Path.toString() returns a path with \ instead of /, but for bash Windows users we want to convert those back to /'s private fun Path.toStringWithDeWindowsfication(): String</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$loggerFor&lt;InstallShellExtensionsParser&gt;().warn("Failed to run command: ${commandAndArgs.joinToString(" ")}; $exception")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$printWarning("Cannot install shell extension for bash major version earlier than $minSupportedBashVersion. Please upgrade your bash version. Aliases should still work.")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$println("Installation complete, ${parent.alias} is available in bash, but autocompletion was not installed because of an old version of bash.")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$println("Restart bash for this to take effect, or run `. ~/.bashrc` in bash or `. ~/.zshrc` in zsh to re-initialise your shell now")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$private fun jarVersion(alias: String)</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator.SettingsFile$println("Updating settings in ${filePath.fileName} - existing settings file has been backed up to $backupFilePath")</ID>
    <ID>MaxLineLength:Instances.kt$Instances</ID>
    <ID>MaxLineLength:Instances.kt$Instances$SignatureKey</ID>
    <ID>MaxLineLength:InstantSerializer.kt$InstantSerializer : Proxy</ID>
    <ID>MaxLineLength:InstantSerializer.kt$InstantSerializer$override fun fromProxy(proxy: InstantProxy): Instant</ID>
    <ID>MaxLineLength:InstrumentationTest.kt$InstrumentationTest$Assertions.assertThat(snapshot.map { it.transactionId }.toSet()).containsAll(successfulPayments.map { it.stx.id })</ID>
    <ID>MaxLineLength:InstrumentationTest.kt$InstrumentationTest$alice = startNode(NodeParameters(providedName = ALICE_NAME, rpcUsers = listOf(testUser)), bytemanPort = bytemanPort).getOrThrow()</ID>
    <ID>MaxLineLength:InstrumentationTest.kt$InstrumentationTest$assertThatThrownBy { aliceProxy.nodeInfo() }.isInstanceOf(RPCException::class.java).hasMessageContaining("RPC server is not available")</ID>
    <ID>MaxLineLength:InstrumentationTest.kt$InstrumentationTest$assertThatThrownBy { paySelf(5.POUNDS) }.isInstanceOf(RPCException::class.java).hasMessageContaining("Connection failure detected")</ID>
    <ID>MaxLineLength:InstrumentationTest.kt$InstrumentationTest$private fun paySelf(amount: Amount&lt;Currency&gt;)</ID>
    <ID>MaxLineLength:InstrumentationTest.kt$InstrumentationTest.Companion$@ClassRule @JvmField val databaseSchemas = IntegrationTestSchemas(DUMMY_NOTARY_NAME.toDatabaseSchemaNames("_0", "_1", "_2") + ALICE_NAME.toDatabaseSchemaName())</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: CordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("attachments", "Commands to extract information about attachments stored within the node", AttachmentShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("checkpoints", "Commands to extract information about checkpoints stored within the node", CheckpointShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("flow", "Commands to work with flows. Flows are how you can change the ledger.", FlowShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("hashLookup", "Checks if a transaction with matching Id hash exists.", HashLookupShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("output-format", "Commands to inspect and update the output format.", OutputFormatCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ExternalResolver.INSTANCE.addCommand("run", "Runs a method from the CordaRPCOps interface on the node.", RunShellCommand::class.java)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$ReconnectingCordaRPCOps(configuration.hostAndPort, username, password, configuration.ssl, classLoader)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$out.println("Please use the 'flow' command to interact with flows rather than the 'run' command.", Color.yellow)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$private</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$rpcConn.close() // This will only show up in the standalone Shell, because the embedded one is killed as part of a node's shutdown. display { println("...done, quitting the shell now.") } onExit.invoke()</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$shell = ShellLifecycle(configuration.commandsDirectory).start(config, configuration.user, configuration.password)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$val mapElement: (Any?) -&gt; String = { element -&gt; outputMapper.writerWithDefaultPrettyPrinter().writeValueAsString(element) }</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell$val stateObservable = runFlowFromString({ clazz, args -&gt; rpcOps.startTrackedFlowDynamic(clazz, *args) }, inputData, flowClazz, inputObjectMapper)</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell${ private val log = LoggerFactory.getLogger(javaClass) private lateinit var rpcOps: (username: String, password: String) -&gt; InternalCordaRPCOps private lateinit var ops: InternalCordaRPCOps private lateinit var rpcConn: AutoCloseable private var shell: Shell? = null private var classLoader: ClassLoader? = null private lateinit var shellConfiguration: ShellConfiguration private var onExit: () -&gt; Unit = {} @JvmStatic fun getCordappsClassloader() = classLoader enum class OutputFormat { JSON, YAML } fun startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null, standalone: Boolean = false) { rpcOps = { username: String, password: String -&gt; if (standalone) { ReconnectingCordaRPCOps(configuration.hostAndPort, username, password, configuration.ssl, classLoader).also { rpcConn = it } } else { val client = CordaRPCClient(hostAndPort = configuration.hostAndPort, configuration = CordaRPCClientConfiguration.DEFAULT.copy( maxReconnectAttempts = 1 ), sslConfiguration = configuration.ssl, classLoader = classLoader) val connection = client.start(username, password) rpcConn = connection connection.proxy as InternalCordaRPCOps } } _startShell(configuration, classLoader) } private fun _startShell(configuration: ShellConfiguration, classLoader: ClassLoader? = null) { shellConfiguration = configuration InteractiveShell.classLoader = classLoader val runSshDaemon = configuration.sshdPort != null val config = Properties() if (runSshDaemon) { // Enable SSH access. Note: these have to be strings, even though raw object assignments also work. config["crash.ssh.port"] = configuration.sshdPort?.toString() config["crash.auth"] = "corda" configuration.sshHostKeyDirectory?.apply { val sshKeysDir = configuration.sshHostKeyDirectory.createDirectories() config["crash.ssh.keypath"] = (sshKeysDir / "hostkey.pem").toString() config["crash.ssh.keygen"] = "true" } } ExternalResolver.INSTANCE.addCommand("output-format", "Commands to inspect and update the output format.", OutputFormatCommand::class.java) ExternalResolver.INSTANCE.addCommand("run", "Runs a method from the CordaRPCOps interface on the node.", RunShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("flow", "Commands to work with flows. Flows are how you can change the ledger.", FlowShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("start", "An alias for 'flow start'", StartShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("hashLookup", "Checks if a transaction with matching Id hash exists.", HashLookupShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("attachments", "Commands to extract information about attachments stored within the node", AttachmentShellCommand::class.java) ExternalResolver.INSTANCE.addCommand("checkpoints", "Commands to extract information about checkpoints stored within the node", CheckpointShellCommand::class.java) shell = ShellLifecycle(configuration.commandsDirectory).start(config, configuration.user, configuration.password) } fun runLocalShell(onExit: () -&gt; Unit = {}) { this.onExit = onExit val terminal = TerminalFactory.create() val consoleReader = ConsoleReader("Corda", FileInputStream(FileDescriptor.`in`), System.out, terminal) val jlineProcessor = JLineProcessor(terminal.isAnsiSupported, shell, consoleReader, System.out) InterruptHandler { jlineProcessor.interrupt() }.install() thread(name = "Command line shell processor", isDaemon = true) { Emoji.renderIfSupported { try { jlineProcessor.run() } catch (e: IndexOutOfBoundsException) { log.warn("Cannot parse malformed command.") } } } thread(name = "Command line shell terminator", isDaemon = true) { // Wait for the shell to finish. jlineProcessor.closed() log.info("Command shell has exited") terminal.restore() onExit.invoke() } } class ShellLifecycle(private val shellCommands: Path) : PluginLifeCycle() { fun start(config: Properties, localUserName: String = "", localUserPassword: String = ""): Shell { val classLoader = this.javaClass.classLoader val classpathDriver = ClassPathMountFactory(classLoader) val fileDriver = FileMountFactory(Utils.getCurrentDirectory()) val extraCommandsPath = shellCommands.toAbsolutePath().createDirectories() val commandsFS = FS.Builder() .register("file", fileDriver) .mount("file:$extraCommandsPath") .register("classpath", classpathDriver) .mount("classpath:/net/corda/tools/shell/") .mount("classpath:/crash/commands/") .build() val confFS = FS.Builder() .register("classpath", classpathDriver) .mount("classpath:/crash") .build() val discovery = object : ServiceLoaderDiscovery(classLoader) { override fun getPlugins(): Iterable&lt;CRaSHPlugin&lt;*&gt;&gt; { // Don't use the Java language plugin (we may not have tools.jar available at runtime), this // will cause any commands using JIT Java compilation to be suppressed. In CRaSH upstream that // is only the 'jmx' command. return super.getPlugins().filterNot { it is JavaLanguage } + CordaAuthenticationPlugin(rpcOps) } } val attributes = emptyMap&lt;String, Any&gt;() val context = PluginContext(discovery, attributes, commandsFS, confFS, classLoader) context.refresh() this.config = config start(context) ops = makeRPCOps(rpcOps, localUserName, localUserPassword) return context.getPlugin(ShellFactory::class.java).create(null, CordaSSHAuthInfo(false, ops, StdoutANSIProgressRenderer)) } } fun nodeInfo() = try { ops.nodeInfo() } catch (e: UndeclaredThrowableException) { throw e.cause ?: e } @JvmStatic fun setOutputFormat(outputFormat: OutputFormat) { this.outputFormat = outputFormat } @JvmStatic fun getOutputFormat(): OutputFormat { return outputFormat } fun createYamlInputMapper(rpcOps: CordaRPCOps): ObjectMapper { // Return a standard Corda Jackson object mapper, configured to use YAML by default and with extra // serializers. return JacksonSupport.createDefaultMapper(rpcOps, YAMLFactory(), true).apply { val rpcModule = SimpleModule().apply { addDeserializer(InputStream::class.java, InputStreamDeserializer) addDeserializer(UniqueIdentifier::class.java, UniqueIdentifierDeserializer) } registerModule(rpcModule) } } private fun createOutputMapper(outputFormat: OutputFormat): ObjectMapper { val factory = when(outputFormat) { OutputFormat.JSON -&gt; JsonFactory() OutputFormat.YAML -&gt; YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER) } return JacksonSupport.createNonRpcMapper(factory).apply { // Register serializers for stateful objects from libraries that are special to the RPC system and don't // make sense to print out to the screen. For classes we own, annotations can be used instead. val rpcModule = SimpleModule().apply { addSerializer(Observable::class.java, ObservableSerializer) addSerializer(InputStream::class.java, InputStreamSerializer) } registerModule(rpcModule) disable(SerializationFeature.FAIL_ON_EMPTY_BEANS) enable(SerializationFeature.INDENT_OUTPUT) } } // TODO: A default renderer could be used, instead of an object mapper. See: http://www.crashub.org/1.3/reference.html#_renderers private var outputFormat = OutputFormat.YAML @VisibleForTesting lateinit var latch: CountDownLatch private set /** * Called from the 'flow' shell command. Takes a name fragment and finds a matching flow, or prints out * the list of options if the request is ambiguous. Then parses [inputData] as constructor arguments using * the [runFlowFromString] method and starts the requested flow. Ctrl-C can be used to cancel. */ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps)) { val matches = try { rpcOps.registeredFlows().filter { nameFragment in it } } catch (e: PermissionException) { output.println(e.message ?: "Access denied", Color.red) return } if (matches.isEmpty()) { output.println("No matching flow found, run 'flow list' to see your options.", Color.red) return } else if (matches.size &gt; 1 &amp;&amp; matches.find { it.endsWith(nameFragment)} == null) { output.println("Ambiguous name provided, please be more specific. Your options are:") matches.forEachIndexed { i, s -&gt; output.println("${i + 1}. $s", Color.yellow) } return } val flowName = matches.find { it.endsWith(nameFragment)} ?: matches.single() val flowClazz: Class&lt;FlowLogic&lt;*&gt;&gt; = if (classLoader != null) { uncheckedCast(Class.forName(flowName, true, classLoader)) } else { uncheckedCast(Class.forName(flowName)) } try { // Show the progress tracker on the console until the flow completes or is interrupted with a // Ctrl-C keypress. val stateObservable = runFlowFromString({ clazz, args -&gt; rpcOps.startTrackedFlowDynamic(clazz, *args) }, inputData, flowClazz, inputObjectMapper) latch = CountDownLatch(1) ansiProgressRenderer.render(stateObservable, latch::countDown) // Wait for the flow to end and the progress tracker to notice. By the time the latch is released // the tracker is done with the screen. while (!Thread.currentThread().isInterrupted) { try { latch.await() break } catch (e: InterruptedException) { try { rpcOps.killFlow(stateObservable.id) } finally { Thread.currentThread().interrupt() break } } } output.println("Flow completed with result: ${stateObservable.returnValue.get()}") } catch (e: NoApplicableConstructor) { output.println("No matching constructor found:", Color.red) e.errors.forEach { output.println("- $it", Color.red) } } catch (e: PermissionException) { output.println(e.message ?: "Access denied", Color.red) } catch (e: ExecutionException) { // ignoring it as already logged by the progress handler subscriber } finally { InputStreamDeserializer.closeAll() } } class NoApplicableConstructor(val errors: List&lt;String&gt;) : CordaException(this.toString()) { override fun toString() = (listOf("No applicable constructor for flow. Problems were:") + errors).joinToString(System.lineSeparator()) } /** * Tidies up a possibly generic type name by chopping off the package names of classes in a hard-coded set of * hierarchies that are known to be widely used and recognised, and also not have (m)any ambiguous names in them. * * This is used for printing error messages when something doesn't match. */ private fun maybeAbbreviateGenericType(type: Type, extraRecognisedPackage: String): String { val packagesToAbbreviate = listOf("java.", "net.corda.core.", "kotlin.", extraRecognisedPackage) fun shouldAbbreviate(typeName: String) = packagesToAbbreviate.any { typeName.startsWith(it) } fun abbreviated(typeName: String) = if (shouldAbbreviate(typeName)) typeName.split('.').last() else typeName fun innerLoop(type: Type): String = when (type) { is ParameterizedType -&gt; { val args: List&lt;String&gt; = type.actualTypeArguments.map(::innerLoop) abbreviated(type.rawType.typeName) + '&lt;' + args.joinToString(", ") + '&gt;' } is GenericArrayType -&gt; { innerLoop(type.genericComponentType) + "[]" } is Class&lt;*&gt; -&gt; { if (type.isArray) abbreviated(type.simpleName) else abbreviated(type.name).replace('$', '.') } else -&gt; type.toString() } return innerLoop(type) } @JvmStatic fun killFlowById(id: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps)) { try { val runId = try { inputObjectMapper.readValue(id, StateMachineRunId::class.java) } catch (e: JsonMappingException) { output.println("Cannot parse flow ID of '$id' - expecting a UUID.", Color.red) log.error("Failed to parse flow ID", e) return } if (rpcOps.killFlow(runId)) { output.println("Killed flow $runId", Color.yellow) } else { output.println("Failed to kill flow $runId", Color.red) } } finally { output.flush() } } // TODO: This utility is generally useful and might be better moved to the node class, or an RPC, if we can commit to making it stable API. /** * Given a [FlowLogic] class and a string in one-line Yaml form, finds an applicable constructor and starts * the flow, returning the created flow logic. Useful for lightweight invocation where text is preferable * to statically typed, compiled code. * * See the [StringToMethodCallParser] class to learn more about limitations and acceptable syntax. * * @throws NoApplicableConstructor if no constructor could be found for the given set of types. */ @Throws(NoApplicableConstructor::class) fun &lt;T&gt; runFlowFromString(invoke: (Class&lt;out FlowLogic&lt;T&gt;&gt;, Array&lt;out Any?&gt;) -&gt; FlowProgressHandle&lt;T&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;, om: ObjectMapper): FlowProgressHandle&lt;T&gt; { val errors = ArrayList&lt;String&gt;() val parser = StringToMethodCallParser(clazz, om) val nameTypeList = getMatchingConstructorParamsAndTypes(parser, inputData, clazz) try { val args = parser.parseArguments(clazz.name, nameTypeList, inputData) return invoke(clazz, args) } catch (e: StringToMethodCallParser.UnparseableCallException.ReflectionDataMissing) { val argTypes = nameTypeList.map { (_, type) -&gt; type } errors.add("$argTypes: &lt;constructor missing parameter reflection data&gt;") } catch (e: StringToMethodCallParser.UnparseableCallException) { val argTypes = nameTypeList.map { (_, type) -&gt; type } errors.add("$argTypes: ${e.message}") } throw NoApplicableConstructor(errors) } private fun &lt;T&gt; getMatchingConstructorParamsAndTypes(parser: StringToMethodCallParser&lt;FlowLogic&lt;T&gt;&gt;, inputData: String, clazz: Class&lt;out FlowLogic&lt;T&gt;&gt;) : List&lt;Pair&lt;String, Type&gt;&gt; { val errors = ArrayList&lt;String&gt;() val classPackage = clazz.packageName lateinit var paramNamesFromConstructor: List&lt;String&gt; for (ctor in clazz.constructors) { // Attempt construction with the given arguments. fun getPrototype(): List&lt;String&gt; { val argTypes = ctor.genericParameterTypes.map { // If the type name is in the net.corda.core or java namespaces, chop off the package name // because these hierarchies don't have (m)any ambiguous names and the extra detail is just noise. maybeAbbreviateGenericType(it, classPackage) } return paramNamesFromConstructor.zip(argTypes).map { (name, type) -&gt; "$name: $type" } } try { paramNamesFromConstructor = parser.paramNamesFromConstructor(ctor) val nameTypeList = paramNamesFromConstructor.zip(ctor.genericParameterTypes) parser.validateIsMatchingCtor(clazz.name, nameTypeList, inputData) return nameTypeList } catch (e: StringToMethodCallParser.UnparseableCallException.MissingParameter) { errors.add("${getPrototype()}: missing parameter ${e.paramName}") } catch (e: StringToMethodCallParser.UnparseableCallException.TooManyParameters) { errors.add("${getPrototype()}: too many parameters") } catch (e: StringToMethodCallParser.UnparseableCallException.ReflectionDataMissing) { val argTypes = ctor.genericParameterTypes.map { it.typeName } errors.add("$argTypes: &lt;constructor missing parameter reflection data&gt;") } catch (e: StringToMethodCallParser.UnparseableCallException) { val argTypes = ctor.genericParameterTypes.map { it.typeName } errors.add("$argTypes: ${e.message}") } } throw NoApplicableConstructor(errors) } // TODO Filtering on error/success when we will have some sort of flow auditing, for now it doesn't make much sense. @JvmStatic fun runStateMachinesView(out: RenderPrintWriter, rpcOps: CordaRPCOps): Any? { val proxy = rpcOps val (stateMachines, stateMachineUpdates) = proxy.stateMachinesFeed() val currentStateMachines = stateMachines.map { StateMachineUpdate.Added(it) } val subscriber = FlowWatchPrintingSubscriber(out) stateMachineUpdates.startWith(currentStateMachines).subscribe(subscriber) var result: Any? = subscriber.future if (result is Future&lt;*&gt;) { if (!result.isDone) { out.cls() out.println("Waiting for completion or Ctrl-C ... ") out.flush() } try { result = result.get() } catch (e: InterruptedException) { subscriber.unsubscribe() Thread.currentThread().interrupt() } catch (e: ExecutionException) { throw e.rootCause } catch (e: InvocationTargetException) { throw e.rootCause } } return result } @JvmStatic fun runAttachmentTrustInfoView( out: RenderPrintWriter, rpcOps: InternalCordaRPCOps ): Any { return AttachmentTrustTable(out, rpcOps.attachmentTrustInfos) } @JvmStatic fun runDumpCheckpoints(rpcOps: InternalCordaRPCOps) { rpcOps.dumpCheckpoints() } @JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: CordaRPCOps, inputObjectMapper: ObjectMapper): Any? { val cmd = input.joinToString(" ").trim { it &lt;= ' ' } if (cmd.startsWith("startflow", ignoreCase = true)) { // The flow command provides better support and startFlow requires special handling anyway due to // the generic startFlow RPC interface which offers no type information with which to parse the // string form of the command. out.println("Please use the 'flow' command to interact with flows rather than the 'run' command.", Color.yellow) return null } else if (cmd.substringAfter(" ").trim().equals("gracefulShutdown", ignoreCase = true)) { return InteractiveShell.gracefulShutdown(out, cordaRPCOps) } var result: Any? = null try { InputStreamSerializer.invokeContext = context val parser = StringToMethodCallParser(CordaRPCOps::class.java, inputObjectMapper) val call = parser.parse(cordaRPCOps, cmd) result = call.call() if (result != null &amp;&amp; result !== kotlin.Unit &amp;&amp; result !is Void) { result = printAndFollowRPCResponse(result, out, outputFormat) } if (result is Future&lt;*&gt;) { if (!result.isDone) { out.println("Waiting for completion or Ctrl-C ... ") out.flush() } try { result = result.get() } catch (e: InterruptedException) { Thread.currentThread().interrupt() } catch (e: ExecutionException) { throw e.rootCause } catch (e: InvocationTargetException) { throw e.rootCause } } } catch (e: StringToMethodCallParser.UnparseableCallException) { out.println(e.message, Color.red) if (e !is StringToMethodCallParser.UnparseableCallException.NoSuchFile) { out.println("Please try 'man run' to learn what syntax is acceptable") } } catch (e: Exception) { out.println("RPC failed: ${e.rootCause}", Color.red) } finally { InputStreamSerializer.invokeContext = null InputStreamDeserializer.closeAll() } return result } @JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps) { fun display(statements: RenderPrintWriter.() -&gt; Unit) { statements.invoke(userSessionOut) userSessionOut.flush() } var isShuttingDown = false try { display { println("Orchestrating a clean shutdown, press CTRL+C to cancel...") } isShuttingDown = true display { println("...enabling draining mode") println("...waiting for in-flight flows to be completed") } cordaRPCOps.terminate(true) val latch = CountDownLatch(1) @Suppress("DEPRECATION") cordaRPCOps.pendingFlowsCount().updates.doOnError { error -&gt; log.error(error.message) throw error }.doAfterTerminate(latch::countDown).subscribe( // For each update. { (first, second) -&gt; display { println("...remaining: $first / $second") } }, // On error. { error -&gt; if (!isShuttingDown) { display { println("RPC failed: ${error.rootCause}", Color.red) } } }, // When completed. { rpcConn.close() // This will only show up in the standalone Shell, because the embedded one is killed as part of a node's shutdown. display { println("...done, quitting the shell now.") } onExit.invoke() }) while (!Thread.currentThread().isInterrupted) { try { latch.await() break } catch (e: InterruptedException) { try { cordaRPCOps.setFlowsDrainingModeEnabled(false) display { println("...cancelled clean shutdown.") } } finally { Thread.currentThread().interrupt() break } } } } catch (e: StringToMethodCallParser.UnparseableCallException) { display { println(e.message, Color.red) println("Please try 'man run' to learn what syntax is acceptable") } } catch (e: Exception) { if (!isShuttingDown) { display { println("RPC failed: ${e.rootCause}", Color.red) } } } finally { InputStreamSerializer.invokeContext = null InputStreamDeserializer.closeAll() } } private fun printAndFollowRPCResponse(response: Any?, out: PrintWriter, outputFormat: OutputFormat): CordaFuture&lt;Unit&gt; { val outputMapper = createOutputMapper(outputFormat) val mapElement: (Any?) -&gt; String = { element -&gt; outputMapper.writerWithDefaultPrettyPrinter().writeValueAsString(element) } return maybeFollow(response, mapElement, out) } private class PrintingSubscriber(private val printerFun: (Any?) -&gt; String, private val toStream: PrintWriter) : Subscriber&lt;Any&gt;() { private var count = 0 val future = openFuture&lt;Unit&gt;() init { // The future is public and can be completed by something else to indicate we don't wish to follow // anymore (e.g. the user pressing Ctrl-C). future.then { unsubscribe() } } @Synchronized override fun onCompleted() { toStream.println("Observable has completed") future.set(Unit) } @Synchronized override fun onNext(t: Any?) { count++ toStream.println("Observation $count: " + printerFun(t)) toStream.flush() } @Synchronized override fun onError(e: Throwable) { toStream.println("Observable completed with an error") e.printStackTrace(toStream) future.setException(e) } } private fun maybeFollow(response: Any?, printerFun: (Any?) -&gt; String, out: PrintWriter): CordaFuture&lt;Unit&gt; { // Match on a couple of common patterns for "important" observables. It's tough to do this in a generic // way because observables can be embedded anywhere in the object graph, and can emit other arbitrary // object graphs that contain yet more observables. So we just look for top level responses that follow // the standard "track" pattern, and print them until the user presses Ctrl-C if (response == null) return doneFuture(Unit) if (response is DataFeed&lt;*, *&gt;) { out.println("Snapshot:") out.println(printerFun(response.snapshot)) out.flush() out.println("Updates:") return printNextElements(response.updates, printerFun, out) } if (response is Observable&lt;*&gt;) { return printNextElements(response, printerFun, out) } out.println(printerFun(response)) return doneFuture(Unit) } private fun printNextElements(elements: Observable&lt;*&gt;, printerFun: (Any?) -&gt; String, out: PrintWriter): CordaFuture&lt;Unit&gt; { val subscriber = PrintingSubscriber(printerFun, out) uncheckedCast(elements).subscribe(subscriber) return subscriber.future } }</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell.NoApplicableConstructor$override fun toString()</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell.PrintingSubscriber$private</ID>
    <ID>MaxLineLength:InteractiveShell.kt$InteractiveShell.ShellLifecycle$return context.getPlugin(ShellFactory::class.java).create(null, CordaSSHAuthInfo(false, ops, StdoutANSIProgressRenderer))</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$InteractiveShell.runFlowByNameFragment(NoOpFlow::class.java.name, "", output, node.rpc, mockAnsiProgressRenderer())</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$private</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$startNode(rpcUsers = listOf(user), customOverrides = brokerSslOptions.useSslRpcOverrides()).getOrThrow()</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$val node = startNode(rpcUsers = listOf(user), customOverrides = brokerSslOptions.useSslRpcOverrides()).getOrThrow()</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$val zipFile = (aliceNode.baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME).list().first { "checkpoints_dump-" in it.toString() }</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$FlowA$constructor(amounts: Array&lt;Amount&lt;UserValue&gt;&gt;) : this(amounts.joinToString("++", transform = Amount&lt;UserValue&gt;::toString))</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$InteractiveShellTest$input = """amounts: [ { "quantity": 10, "token": { "label": "(1)" } }, { "quantity": 200, "token": { "label": "(2)" } } ]"""</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$InteractiveShellTest$input = "pair: { first: $100.12, second: df489807f81c8c8829e509e1bcb92e6692b9dd9d624b7456435cb2f51dc82587 }"</ID>
    <ID>MaxLineLength:InteractiveShellTest.kt$InteractiveShellTest$val instance = clazz.getConstructor(*args.map { it!!::class.java }.toTypedArray()).newInstance(*args) as FlowA</ID>
    <ID>MaxLineLength:InterestSwapRestAPI.kt$InterestRateSwapAPI</ID>
    <ID>MaxLineLength:InterestSwapRestAPI.kt$InterestRateSwapAPI$val states = vault.filterStatesOfType&lt;InterestRateSwap.State&gt;().filter { it.state.data.linearId.externalId == ref }</ID>
    <ID>MaxLineLength:InternalAccessTestHelpers.kt$/** * A set of functions in serialization:test that allows testing of serialization internal classes in the serialization-tests project. */ const val MAX_TYPE_PARAM_DEPTH = AMQPTypeIdentifierParser.MAX_TYPE_PARAM_DEPTH</ID>
    <ID>MaxLineLength:InternalAccessTestHelpers.kt$fun &lt;T&gt; ifThrowsAppend(strToAppendFn: () -&gt; String, block: () -&gt; T): T</ID>
    <ID>MaxLineLength:InternalAccessTestHelpers.kt$fun Class&lt;out Any?&gt;.accessPropertyDescriptors(validateProperties: Boolean = true): Map&lt;String, PropertyDescriptor&gt;</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$@Option(names = ["-o", "--organization"], description = ["X500Name's organization attribute."], defaultValue = "Corda")</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$@Option(names = ["-p", "--keyStorePassword"], description = ["Password for all generated keystores."], defaultValue = DEFAULT_PASSWORD)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$@Option(names = ["-t", "--trustStorePassword"], description = ["Password for the trust store."], defaultValue = DEFAULT_PASSWORD)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$@Option(names = ["-u", "--organization-unit"], description = ["X500Name's organization unit attribute."], required = false)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$SupportedCryptoServices.BC_SIMPLE -&gt; FileBasedCertificateStoreSupplier(keystorePath, storePassword, entryPassword)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$X509KeyStore.fromFile(trustStorePath, trustStorePassword, createNew = true).setCertificate(X509Utilities.CORDA_ROOT_CA, rootCert)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$keystorePath: Path</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$logger.warn("Password for '$paramName' is defaulted to '$DEFAULT_PASSWORD'. Please consider changing the password using java keytool.")</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$protected</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$requireNotNull(certificateStoreSupplier) { "Fallback keystore must not be null when Crypto service config is not provided." }</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$return CryptoServiceFactory.makeCryptoService(supportedCryptoServiceName, x500Name, certificateStoreSupplier, cryptoServiceConfigPath)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$val cert = X509Utilities.createCertificate(CertificateType.TLS, root.certificate, root.keyPair, getX500Principal(serviceName), publicKey)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator : AbstractInternalKeystoreGenerator</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$@Option(names = ["--bridge-hsm-config-file", "-f"], paramLabel = "FILE", description = ["The path to the HSM config file. Only required if the HSM name has been specified"])</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$@Option(names = ["--node-hsm-config-file", "-i"], paramLabel = "FILE", description = ["The path to the HSM config file. Only required if the HSM name has been specified"])</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$createArtemisKeystore( "BridgeArtemis", "artemisbridge.jks", root, cryptoServiceNameBridge, cryptoServiceConfigFileBridge)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$createArtemisKeystore( "NodeArtemis","artemisnode.jks", root, cryptoServiceNameNode, cryptoServiceConfigFileNode)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$description = ["The Bridge HSM name. One of ${HSM_LIST}. The first x characters to uniquely identify the name is adequate (case insensitive)"]</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$description = ["The Node HSM name. One of ${HSM_LIST}. The first x characters to uniquely identify the name is adequate (case insensitive)"]</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$if (errorInHSMOptions(cryptoServiceNameBridge, cryptoServiceConfigFileBridge, "Error in Bridge HSM options for Artemis key")) { throw IllegalArgumentException("Error in HSM options for Artemis key") }</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$if (errorInHSMOptions(cryptoServiceNameNode, cryptoServiceConfigFileNode, "Error in Node HSM options for Artemis key")) { throw IllegalArgumentException("Error in HSM options for Artemis key") }</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$keyStorePassword</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalArtemisKeystoreGenerator$val root = createRootKeystore("Internal Artemis Root", artemisCertDir / "artemis-root.jks", artemisCertDir / "artemis-truststore.jks", keyStorePassword, keyStorePassword, trustStorePassword).getCertificateAndKeyPair(X509Utilities.CORDA_ROOT_CA, keyStorePassword)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator : AbstractInternalKeystoreGenerator</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$@Option(names = ["-e", "--entryPassword"], description = ["Password for all the keystores private keys."], defaultValue = DEFAULT_PASSWORD)</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$description = ["The HSM name for the Bridge. One of ${HSM_LIST}. The first x characters to uniquely identify the name is adequate (case insensitive)"]</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$description = ["The HSM name for the Float. One of ${HSM_LIST}. The first x characters to uniquely identify the name is adequate (case insensitive)"]</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$if (errorInHSMOptions(cryptoServiceNameBridge, cryptoServiceConfigFileBridge, "Error in HSM options for Bridge")) { throw IllegalArgumentException("Error in HSM options for Bridge") }</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$keyStorePassword</ID>
    <ID>MaxLineLength:InternalKeystoreGenerator.kt$InternalTunnelKeystoreGenerator$val tunnelRoot = createRootKeystore("Internal Tunnel Root", tunnelCertDir / "tunnel-root.jks", tunnelCertDir / "tunnel-truststore.jks", keyStorePassword, entryPassword, trustStorePassword).getCertificateAndKeyPair(X509Utilities.CORDA_ROOT_CA, entryPassword)</ID>
    <ID>MaxLineLength:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$assertNotNull(X509KeyStore.fromFile(keyStoreFile, keyStorePassword).internal.getCertificateAndKeyPair(alias, entryPassword))</ID>
    <ID>MaxLineLength:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$checkKeystore(workingDirectory / "tunnel/bridge.jks", "${CORDA_CLIENT_TLS}bridge", keyStorePassword, entryPassword)</ID>
    <ID>MaxLineLength:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$checkKeystore(workingDirectory / "tunnel/float.jks", "${CORDA_CLIENT_TLS}float", keyStorePassword, entryPassword)</ID>
    <ID>MaxLineLength:InternalKeystoreGeneratorTest.kt$InternalKeystoreGeneratorTest$val certificateAndKeyPair = X509KeyStore.fromFile(keyStoreFile, keyStorePassword).internal.getCertificateAndKeyPair(alias, entryPassword)</ID>
    <ID>MaxLineLength:InternalKeystoreGeneratorTest.kt$MockedCryptoService$override</ID>
    <ID>MaxLineLength:InternalKeystoreGeneratorTest.kt$MockedCryptoService$val certificateStoreSupplier = FileBasedCertificateStoreSupplier(keystorePath / "keys.jks", "password", "password")</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$ fun createNode(parameters: InternalMockNodeParameters = InternalMockNodeParameters(), nodeFactory: (MockNodeArgs) -&gt; MockNode): TestStartedNode</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$"You can use MockNetwork.waitQuiescent() to wait for all the nodes to process all the messages on their queues instead."</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$/** * Returns the list of nodes started by the network. Each notary specified when the network is constructed ([notarySpecs] * parameter) maps 1:1 to the notaries returned by this list. */ val notaryNodes: List&lt;TestStartedNode&gt;</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$?:</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$TestCordappInternal.installCordapps(baseDirectory, parameters.additionalCordapps.toSet(), combinedCordappsForAllNodes)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$configOverrides = { doReturn(NotaryConfig(spec.validating, className = spec.className)).whenever(it).notary }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$doReturn(makeInternalTestDataSourceProperties("node_$id", "net_$networkId")).whenever(it).dataSourceProperties</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$fun createUnstartedNode(parameters: InternalMockNodeParameters = InternalMockNodeParameters(), nodeFactory: (MockNodeArgs) -&gt; MockNode): MockNode</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$private</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$private val serializationEnv = checkNotNull(setDriverSerialization()) { "Using more than one mock network simultaneously is not supported." }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = defaultParameters.servicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$val messagingNetwork = InMemoryMessagingNetwork.create(networkSendManuallyPumped, servicePeerAllocationStrategy, busyLatch)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$val node = nodeFactory(MockNodeArgs(config, this, id, parameters.entropyRoot, parameters.version, flowManager = parameters.flowManager))</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$val testDirectory: Path = Paths.get("build") / "mock-network" / getTimestampAsDirectoryName()</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$(network as MockNodeMessagingService).start(mockNet.messagingNetwork, !mockNet.threadPerNode, id, myNotaryIdentity)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlowFactory(initiatingFlowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: Class&lt;T&gt;, factory: InitiatedFlowFactory&lt;T&gt;, track: Boolean): Observable&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$open</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$require(cryptoService.underlyingService is BCCryptoService) { "MockNode supports BCCryptoService only, but it is ${cryptoService.underlyingService.javaClass.name}" }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode${ require(cryptoService.underlyingService is BCCryptoService) { "MockNode supports BCCryptoService only, but it is ${cryptoService.underlyingService.javaClass.name}" } counter = counter.add(BigInteger.ONE) // The StartedMockNode specifically uses EdDSA keys as they are fixed and stored in json files for some tests (e.g IRSSimulation). val keyPair = Crypto.deriveKeyPairFromEntropy(Crypto.EDDSA_ED25519_SHA512, counter) (cryptoService.underlyingService as BCCryptoService).importKey(alias, keyPair) return keyPair.public }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode.TestStartedNodeImpl$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode.TestStartedNodeImpl$return smm.changes.filter { it is StateMachineManager.Change.Add }.map { it.logic }.ofType(initiatedFlowClass)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$MessagingServiceSpy$val messagingService: MessagingService get() = checkNotNull(_messagingService) { "Spy has not been attached to a node" }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$MockNodeFlowManager$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$TestStartedNode$ fun setMessagingServiceSpy(spy: MessagingServiceSpy)</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$TestStartedNode$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatingFlowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: Class&lt;T&gt;, track: Boolean = false): Observable&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalMockNetworkConfigOverrides.kt$return NotaryConfig(validating = this.validating, extraConfig = this.extraConfig, serviceLegalName = this.serviceLegalName, className = this.className)</ID>
    <ID>MaxLineLength:InternalMockNetworkConfigOverrides.kt$this.flowTimeout?.also { fto -&gt; doReturn(FlowTimeoutConfiguration(fto.timeout, fto.maxRestartCount, fto.backoffBase)).whenever(config).flowTimeout }</ID>
    <ID>MaxLineLength:InternalMockNetworkIntegrationTests.kt$InternalMockNetworkIntegrationTests$assertEquals(0, startJavaProcess&lt;InternalMockNetworkIntegrationTests&gt;(emptyList(), extraJvmArguments = listOf("-javaagent:$quasar")).waitFor())</ID>
    <ID>MaxLineLength:InternalMockNetworkTests.kt$InternalMockNetworkTests$node1.network.send(node2.network.createMessage("test.topic", data = bits), rigorousMock&lt;AllPossibleRecipients&gt;())</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$fun init(rpcOpsRouting: RPCOpsRouting&lt;OPS&gt;, securityManager: RPCSecurityManager, cacheFactory: NamedCacheFactory)</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$rpcServer = RPCServer(rpcOpsRouting, NODE_RPC_USER, NODE_RPC_USER, locator!!, securityManager, nodeName, rpcServerConfiguration, cacheFactory)</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$val keyStoreProvider: String? = null</ID>
    <ID>MaxLineLength:InternalSerializationTestHelpers.kt$fun &lt;T&gt; SerializationEnvironment.asTestContextEnv(inheritable: Boolean = false, callable: (SerializationEnvironment) -&gt; T): T</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ // TODO Rename to cordappWithClasses fun cordappForClasses(vararg classes: Class&lt;*&gt;): CustomCordapp</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun JarOutputStream.addEntry(entry: ZipEntry, input: InputStream)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun NodeInfo.chooseIdentity(): Party</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun addressMustBeBound(executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort, listenProcess: Process? = null)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun cordappWithPackages(vararg packageNames: String): CustomCordapp</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun createDevNodeCaCertPath( legalName: CordaX500Name, nodeKeyPair: KeyPair = generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME), rootCaName: X500Principal = defaultRootCaName, intermediateCaName: X500Principal = defaultIntermediateCaName ): Triple&lt;CertificateAndKeyPair, CertificateAndKeyPair, CertificateAndKeyPair&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun databaseProviderDataSourceConfig(nodeName: String? = null): Config</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun findCordapp(scanPackage: String): TestCordappImpl</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun makeInternalTestDataSourceProperties(nodeName: String? = SecureHash.randomSHA256().toString(), nodeNameExtension: String? = null, configSupplier: (String?) -&gt; Config = ::databaseProviderDataSourceConfig, fallBackConfigSupplier: (String?, String?) -&gt; Config = ::inMemoryH2DataSourceConfig): Properties</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/* * The default timeout value of 40 seconds have been chosen based on previous node shutdown time estimate. * It's been observed that nodes can take up to 30 seconds to shut down, so just to stay on the safe side the 60 seconds * timeout has been chosen. */ fun addressMustNotBeBound(executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort, timeout: Duration = 40.seconds)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * *Custom* CorDapp containing the contents of the `net.corda.testing.contracts` package, i.e. the dummy contracts. This is not a real CorDapp * in the way that [FINANCE_CONTRACTS_CORDAPP] and [FINANCE_WORKFLOWS_CORDAPP] are. */ @JvmField val DUMMY_CONTRACTS_CORDAPP: CustomCordapp = cordappWithPackages("net.corda.testing.contracts")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * Reference to the finance-contracts CorDapp in this repo. The metadata is taken directly from finance/contracts/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.contracts")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the flows as well. */ @JvmField val FINANCE_CONTRACTS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.contracts")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * Reference to the finance-workflows CorDapp in this repo. The metadata is taken directly from finance/workflows/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.flows")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the contract classes as well. */ @JvmField val FINANCE_WORKFLOWS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.workflows")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$DatabaseConstants.DATA_SOURCE_URL to "jdbc:h2:mem:${h2InstanceName}_persistence;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE"</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ListenProcessDeathException$CordaException("The process that was expected to listen on $hostAndPort has died with status: ${listenProcess.exitValue()}")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(users).copy(id = id), TestingNamedCacheFactory())</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$configSupplier: (String?) -&gt; Config = ::databaseProviderDataSourceConfig</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fallBackConfigSupplier: (String?, String?) -&gt; Config = ::inMemoryH2DataSourceConfig</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun &lt;T&gt; StartedNodeServices.startFlow(logic: FlowLogic&lt;T&gt;): FlowStateMachine&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun addressMustBeBoundFuture(executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort, listenProcess: Process? = null): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun addressMustNotBeBoundFuture(executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun fakeAttachment(filePath1: String, content1: String, filePath2: String, content2: String, manifestAttributes: Map&lt;String, String&gt; = emptyMap()): ByteArray</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$manifestAttributes.forEach { manifest[it.key] = it.value }</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$require(classes.isNotEmpty()) { "${receiverClass.name} does not contain any enclosed classes to build a CorDapp out of" }</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val componentGroups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val databaseConfig = ConfigFactory.parseResources(System.getProperty("custom.databaseProvider") + ".conf", parseOptions.setAllowMissing(true))</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val nodeOrganizationNameConfig = if (nodeName != null) configOf("custom.nodeOrganizationName" to parseToDbSchemaFriendlyName(nodeName)) else ConfigFactory.empty()</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val persistence = createCordaPersistence(databaseConfig, wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous, schemaService, cacheFactory, null)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt${ val persistence = createCordaPersistence(databaseConfig, wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous, schemaService, cacheFactory, null) //Enterprise differs to Open Source as it doesn't distinguish internal schemas and Cordapp's schemas as all tables are created by Liquibase persistence.startHikariPool(hikariProperties, databaseConfig, schemaService.schemaOptions.keys, ourName = ourName) return persistence }</ID>
    <ID>MaxLineLength:InternalTestUtilsTest.kt$InternalTestUtilsTest$assertThat(simplifyScanPackages(listOf("com.foobar", "com.foo"))).containsExactlyInAnyOrder("com.foobar", "com.foo")</ID>
    <ID>MaxLineLength:InternalTestUtilsTest.kt$InternalTestUtilsTest$assertThat(simplifyScanPackages(listOf("com.foobar", "com.foo.bar"))).containsExactlyInAnyOrder("com.foobar", "com.foo.bar")</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(clazz: Class&lt;*&gt;, name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(clazz: KClass&lt;*&gt;, name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; Any.declaredField(name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ @DeleteForDJVM fun &lt;T&gt; KClass&lt;*&gt;.staticField(name: String): DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$ fun &lt;T, U&gt; List&lt;T&gt;.lazyMapped(transform: (T, Int) -&gt; U): List&lt;U&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future. fun CertPath.validate(trustAnchor: TrustAnchor, checkRevocation: Boolean = false): PKIXCertPathValidatorResult</ID>
    <ID>MaxLineLength:InternalUtils.kt$?:</ID>
    <ID>MaxLineLength:InternalUtils.kt$@DeleteForDJVM fun InputStream.copyTo(target: Path, vararg options: CopyOption): Long</ID>
    <ID>MaxLineLength:InternalUtils.kt$@DeleteForDJVM fun URL.openHttpConnection(proxy: Proxy? = null): HttpURLConnection</ID>
    <ID>MaxLineLength:InternalUtils.kt$DeclaredField&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$LazyMappedList&lt;T, U&gt; : AbstractList</ID>
    <ID>MaxLineLength:InternalUtils.kt$if (predicate(iterator.next())) throw IllegalArgumentException("Collection contains more than one matching element.")</ID>
    <ID>MaxLineLength:InternalUtils.kt$val Class&lt;*&gt;.packageNameOrNull: String? // This intentionally does not go via `package` as that code path is slow and contended and just ends up doing this. get() { val name = this.getName() val i = name.lastIndexOf('.') if (i != -1) { return name.substring(0, i) } else { return null } }</ID>
    <ID>MaxLineLength:Interpolators.kt$CubicSplineInterpolator : Interpolator</ID>
    <ID>MaxLineLength:Interpolators.kt$Polynomial</ID>
    <ID>MaxLineLength:InvocationContext.kt$Actor.Companion$@JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name): Actor</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext$@CordaSerializable data</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(origin: InvocationOrigin, trace: Trace = Trace.newInstance(), actor: Actor? = null, externalTrace: Trace? = null, impersonatedActor: Actor? = null)</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun peer(party: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null, impersonatedActor: Actor? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun rpc(actor: Actor, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null, impersonatedActor: Actor? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun scheduled(scheduledState: ScheduledStateRef, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun shell(trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:IrsDemoClientApi.kt$IRSDemoClientApi$val fileContents = IOUtils.toString(Thread.currentThread().contextClassLoader.getResourceAsStream("net/corda/irs/simulation/example.rates.txt"), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IrsDemoClientApi.kt$IRSDemoClientApi$val fileContents = IOUtils.toString(javaClass.classLoader.getResourceAsStream("net/corda/irs/web/simulation/example-irs-trade.json"), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IrsDemoWebApplicationTests.kt$IrsDemoWebApplicationTests$@SpringBootTest(properties = ["corda.host=localhost:12345", "corda.user=user", "corda.password=password", "liquibase.enabled=false"])</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$BankOfCordaClientApi.requestWebIssue(NetworkHostAndPort("localhost", BOC_WEB_PORT), createParams(amount, NOTARY_NAME))</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$private</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$return BankOfCordaClientApi.requestRPCIssue(NetworkHostAndPort("localhost", BOC_RPC_PORT), createParams(amount, NOTARY_NAME))</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$val currency = parser.accepts("currency").withOptionalArg().ofType(String::class.java).describedAs("[GBP|USD|CHF|EUR]")</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$val roleArg = parser.accepts("role").withRequiredArg().ofType(Role::class.java).describedAs("[ISSUER|ISSUE_CASH_RPC|ISSUE_CASH_WEB]")</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$Assume.assumeTrue(!IntegrationTest.isRemoteDatabaseMode())</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$nodeA.rpc.startFlow(::CashIssueAndPaymentFlow, amount, ref, recipient, false, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$val linesWithDuplicateInsertionWarningsInA = nodeA.logFile().useLines { lines -&gt; lines.filter(String::containsDuplicateInsertWarning).toList() }</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$val linesWithDuplicateInsertionWarningsInB = nodeB.logFile().useLines { lines -&gt; lines.filter(String::containsDuplicateInsertWarning).toList() }</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$fun NodeHandle.logFile(): File</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$private fun String.containsDuplicateInsertWarning(): Boolean</ID>
    <ID>MaxLineLength:IssuerModel.kt$IssuerModel$val currencyTypes = ChosenList(cashAppConfiguration.map { it?.issuableCurrencies?.observable() ?: FXCollections.emptyObservableList() }, "currencyTypes")</ID>
    <ID>MaxLineLength:IssuerModel.kt$IssuerModel$val supportedCurrencies = ChosenList(cashAppConfiguration.map { it?.supportedCurrencies?.observable() ?: FXCollections.singletonObservableList(defaultCurrency) }, "supportedCurrencies")</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService$ internal open fun selfSign(scheme: SignatureScheme, keyPair: KeyPair): Array&lt;out Certificate&gt;</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService$ override fun sign(alias: String, data: ByteArray, signAlgorithm: String?): ByteArray</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService$detailedLogger.trace { "CryptoService(action=generate_key_pair_start;alias=$alias;scheme=$scheme)" } val keyPairGenerator = keyPairGeneratorFromScheme(scheme) val keyPair = keyPairGenerator.generateKeyPair() keyStore.setKeyEntry(alias, keyPair.private, null, selfSign(scheme, keyPair)) detailedLogger.trace { "CryptoService(action=generate_key_pair_end;alias=$alias;scheme=$scheme)" } // We call toSupportedKey because it's possible that the PublicKey object returned by the provider is not initialized. Crypto.toSupportedPublicKey(keyPair.public)</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService$val builder = JcaX509v3CertificateBuilder(x500PrincipalForCerts, BigInteger.valueOf(random63BitValue()), window.first, window.second, x500PrincipalForCerts, keyPair.public)</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService$val window = X509Utilities.getCertificateValidityWindow(X509Utilities.DEFAULT_VALIDITY_WINDOW.first, X509Utilities.DEFAULT_VALIDITY_WINDOW.second)</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService.&lt;no name provided&gt;$private val publicKey: PublicKey = getPublicKey(alias) ?: throw CryptoServiceException("No key found for alias $alias", isRecoverable = false)</ID>
    <ID>MaxLineLength:JCACryptoService.kt$JCACryptoService.Companion$throw FileNotFoundException("Configured crypto configuration file [${cryptoServiceConf.toFile().absolutePath}] does not exist")</ID>
    <ID>MaxLineLength:JCACryptoService.kt$net.corda.nodeapi.internal.cryptoservice.JCACryptoService.kt</ID>
    <ID>MaxLineLength:JPALoadTestFlow.kt$JPALoadTestFlow$return StandaloneJPAUniquenessProvider(serviceHubInternal.monitoringService.metrics, serviceHubInternal.clock, notaryConfig.jpa!!)</ID>
    <ID>MaxLineLength:JPALoadTestFlow.kt$JPALoadTestFlow$val cordappConfig = CordappConfigFileProvider(serviceHubInternal.configuration.cordappDirectories).getConfigByName(serviceHubInternal.getAppContext().cordapp.name)</ID>
    <ID>MaxLineLength:JPANotaryService.kt$JPANotaryService$?:</ID>
    <ID>MaxLineLength:JPANotaryService.kt$JPANotaryService$JPAUniquenessProvider(services.monitoringService.metrics, services.clock, services.database, jpaNotaryConfig, unspentStatesCache)</ID>
    <ID>MaxLineLength:JPANotaryService.kt$JPANotaryService$private val unspentStatesCache: UnspentStatesCache? = if (notaryConfig.useUnspentStatesCache) UnspentStatesCache(services.monitoringService.metrics) else null</ID>
    <ID>MaxLineLength:JPANotaryService.kt$JPANotaryService$throw IllegalArgumentException("Failed to register ${JPANotaryService::class.java}: extra notary configuration parameters invalid")</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$ override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;UniquenessProvider.Result&gt;</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$/** Tracks the distribution of the number of unique transactions that contributed states to the current transaction. */ private val uniqueTxHashCount = metrics.histogram("$metricPrefix.NumberOfUniqueTxHashes")</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$log.info("Processing notarization requests with ${requests.sumBy { it.states.size }} input states and ${requests.sumBy { it.references.size }} references")</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$private</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$request.future.setException(NotaryInternalException(NotaryError.General(Exception("Internal service error."))))</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$requestSignature = requestSignature.serialize(context = SerializationDefaults.STORAGE_CONTEXT.withEncoding(CordaSerializationEncoding.SNAPPY)).bytes</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$stateRef to StateConsumptionDetails(consumingTxId.sha256(), type = StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$val drainedSize = Queues.drain(requestQueue, buffer, config.batchSize, config.batchTimeoutMs, TimeUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider$val request = CommitRequest(states, txId, callerIdentity, requestSignature, timeWindow, references, future, requestEntities, stateEntities)</ID>
    <ID>MaxLineLength:JPAUniquenessProvider.kt$JPAUniquenessProvider.CommittedState$@NamedQuery(name = "CommittedState.select", query = "SELECT c from JPAUniquenessProvider\$CommittedState c WHERE c.id in :ids")</ID>
    <ID>MaxLineLength:JPAUniquenessProviderTests.kt$JPAUniquenessProviderTests$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null }, NodeSchemaService(extraSchemas = setOf(JPANotarySchemaV1)))</ID>
    <ID>MaxLineLength:JPAUniquenessProviderTests.kt$JPAUniquenessProviderTests$private val requestSignature = NotarisationRequestSignature(DigitalSignature.WithKey(NullKeys.NullPublicKey, ByteArray(32)), 0)</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$ @JvmStatic @JvmOverloads fun createDefaultMapper(rpc: CordaRPCOps, factory: JsonFactory = JsonFactory(), fuzzyIdentityMatch: Boolean = false, fullParties: Boolean = false): ObjectMapper</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$ @JvmStatic @JvmOverloads fun createInMemoryMapper(identityService: IdentityService, factory: JsonFactory = JsonFactory(), fuzzyIdentityMatch: Boolean = false, fullParties: Boolean = false): ObjectMapper</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$ @JvmStatic @JvmOverloads fun createNonRpcMapper(factory: JsonFactory = JsonFactory(), fullParties: Boolean = false): ObjectMapper</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$@CordaInternal @VisibleForTesting internal</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport$@Deprecated("Do not use this as it's not thread safe. Instead get a ObjectMapper instance with one of the create*Mapper methods.")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.IdentityObjectMapper$override fun wellKnownPartyFromX500Name(name: CordaX500Name): Party?</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$?:</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$mapper.wellKnownPartyFromX500Name(principal) ?: throw JsonParseException(parser, "Could not find a Party with name $principal")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$throw JsonParseException(parser, "No matching Party found, then tried to directly deserialise ${parser.text} as a PublicKey with no success", e)</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.RpcObjectMapper$@Deprecated("This is an internal class, do not use", replaceWith = ReplaceWith("JacksonSupport.createDefaultMapper"))</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.X509CertificateSerializer$writeObjectField("keyUsage", value.keyUsage?.asList()?.mapIndexedNotNull { i, flag -&gt; if (flag) keyUsages[i] else null })</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.X509CertificateSerializer$writeObjectField("pathLength", value.basicConstraints.let { if (it != Int.MAX_VALUE) it else null })</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$TransactionSignature(ByteArray(1), ALICE_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID), partialMerkleTree)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$TransactionSignature(ByteArray(1), BOB_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(BOB_PUBKEY).schemeNumberID))</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(json["class"].textValue()).isEqualTo("net.corda.client.jackson.JacksonSupportTest\$ClassNotOnClasspath")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.convertValue&lt;OpaqueBytes&gt;(BinaryNode(byteArrayOf(1, 2, 3, 4)))).isEqualTo(OpaqueBytes.of(1, 2, 3, 4))</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.convertValue&lt;SerializedBytes&lt;*&gt;&gt;(BinaryNode(serializedBytes.bytes))).isEqualTo(serializedBytes)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.convertValue&lt;SignatureScheme&gt;(TextNode("EDDSA_ED25519_SHA512"))).isSameAs(Crypto.EDDSA_ED25519_SHA512)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$assertThat(mapper.valueToTree&lt;TextNode&gt;(Amount.parseCurrency("25000000")).textValue()).isEqualTo("25000000.00 GBP")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$fun convertToNodeInfo()</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$val transactionSignature = TransactionSignature(secureRandomBytes(128), BOB_PUBKEY, signatureMetadata, partialMerkleTree)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$val wtxFields = wtxJson.assertHasOnlyFields("id", "notary", "inputs", "attachments", "outputs", "commands", "timeWindow", "references", "privacySalt", "networkParametersHash")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest${ val cert: X509Certificate = MINI_CORP.identity.certificate val json = mapper.valueToTree&lt;ObjectNode&gt;(cert) println(mapper.writeValueAsString(json)) assertThat(json["serialNumber"].bigIntegerValue()).isEqualTo(cert.serialNumber) assertThat(json["issuer"].valueAs&lt;X500Principal&gt;(mapper)).isEqualTo(cert.issuerX500Principal) assertThat(json["subject"].valueAs&lt;X500Principal&gt;(mapper)).isEqualTo(cert.subjectX500Principal) // cert.publicKey should be converted to a supported format (this is required because [Certificate] returns keys as SUN EC keys, not BC). assertThat(json["publicKey"].valueAs&lt;PublicKey&gt;(mapper)).isEqualTo(Crypto.toSupportedPublicKey(cert.publicKey)) assertThat(json["notAfter"].valueAs&lt;Date&gt;(mapper)).isEqualTo(cert.notAfter) assertThat(json["notBefore"].valueAs&lt;Date&gt;(mapper)).isEqualTo(cert.notBefore) assertThat(json["encoded"].binaryValue()).isEqualTo(cert.encoded) }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$CordappLoaderTemplate$"${entry.value.first().first.name}: [ ${entry.value.joinToString { it.second.jarPath.toString() }} ]."</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$CordappLoaderTemplate$throw MultipleCordappsForFlowException("There are multiple CorDapp JARs on the classpath for flow " + "${entry.value.first().first.name}: [ ${entry.value.joinToString { it.second.jarPath.toString() }} ].")</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$"platform version ${it.minimumPlatformVersion} (This node is running version ${versionInfo.platformVersion})."</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$?:</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$RestrictedURL</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$contractInfo != null &amp;&amp; workflowInfo != null -&gt; return Cordapp.Info.ContractAndWorkflow(contractInfo, workflowInfo)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$it.javaClass.location == cordappJarPath.url &amp;&amp; it.javaClass.name.startsWith(cordappJarPath.qualifiedNamePrefix)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$logger</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$override val appClassLoader: URLClassLoader = URLClassLoader(cordappJarPaths.stream().map { it.url }.toTypedArray(), javaClass.classLoader)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$private val signerKeyFingerprintBlacklist: List&lt;SecureHash.SHA256&gt; = emptyList()</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$return Modifier.isPublic(modifiers) &amp;&amp; !isLocalClass &amp;&amp; !isAnonymousClass &amp;&amp; (!isMemberClass || Modifier.isStatic(modifiers))</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$return scanResult.getClassesWithAnnotation(FlowLogic::class, StartableByRPC::class).filter { it.isUserInvokable() }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$throw CordappInvalidVersionException("Target versionId ($versionStr) for attribute $attributeName must not be smaller than 1.")</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$throw CordappInvalidVersionException("Target versionId attribute $attributeName not specified. Please specify a whole number starting from 1.")</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val blockedCertificates = certificates.filter { it.publicKey.hash.sha256() in signerKeyFingerprintBlacklist }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val certificates = it.jarPath.openStream().let(::JarInputStream).use(JarSignatureCollector::collectCertificates)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val scanResult = ClassGraph().addClassLoader(appClassLoader).overrideClasspath(cordappJarPath.url).enableAllInfo().pooledScan()</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$val targetPlatformVersion = manifest?.get(CordappImpl.TARGET_PLATFORM_VERSION)?.toIntOrNull() ?: minPlatformVersion</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$versionId = parseVersion(manifest[CordappImpl.CORDAPP_CONTRACT_VERSION], CordappImpl.CORDAPP_CONTRACT_VERSION)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$versionId = parseVersion(manifest[CordappImpl.CORDAPP_WORKFLOW_VERSION], CordappImpl.CORDAPP_WORKFLOW_VERSION)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader.Companion$ fun fromJarUrls(scanJars: List&lt;URL&gt;, versionInfo: VersionInfo = VersionInfo.UNKNOWN, extraCordapps: List&lt;CordappImpl&gt; = emptyList(), cordappsSignerKeyFingerprintBlacklist: List&lt;SecureHash.SHA256&gt; = emptyList()): JarScanningCordappLoader</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader.Companion$cordappsSignerKeyFingerprintBlacklist: List&lt;SecureHash.SHA256&gt; = emptyList()</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader.Companion$signerKeyFingerprintBlacklist: List&lt;SecureHash.SHA256&gt; = emptyList()</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader.RestrictedScanResult$fun &lt;T : Any&gt; getClassesWithAnnotation(type: KClass&lt;T&gt;, annotation: KClass&lt;out Annotation&gt;): List&lt;Class&lt;out T&gt;&gt;</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader.RestrictedScanResult$private inner</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$@Test fun `cordapp classloader does not load apps when their min platform version is greater than the node platform version`()</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$assertThat(actualCordapp.serializationWhitelists.first().javaClass.name).isEqualTo("net.corda.serialization.internal.DefaultWhitelist")</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$val loader = JarScanningCordappLoader.fromJarUrls(listOf(jar), cordappsSignerKeyFingerprintBlacklist = DEV_PUB_KEY_HASHES)</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$val loader = JarScanningCordappLoader.fromJarUrls(listOf(jar), cordappsSignerKeyFingerprintBlacklist = emptyList())</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$val serializationWhitelistedClasses = actualCordapp.serializationWhitelists.flatMap { it.whitelist }.map { it.name }</ID>
    <ID>MaxLineLength:JarSignatureCollector.kt$JarSignatureCollector$ fun collectCertificates(jar: JarInputStream): List&lt;X509Certificate&gt;</ID>
    <ID>MaxLineLength:JarSignatureCollector.kt$JarSignatureCollector$/** * @see &lt;https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Signed_JAR_File&gt; * Additionally accepting *.EC as its valid for [java.util.jar.JarVerifier] and jarsigner @see https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jarsigner.html, * temporally treating META-INF/INDEX.LIST as unsignable entry because [java.util.jar.JarVerifier] doesn't load its signers. */ private val unsignableEntryName = "META-INF/(?:(?:.*[.](?:SF|DSA|RSA|EC)|SIG-.*)|INDEX\\.LIST)".toRegex()</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$// Signing with EC algorithm produces META-INF/*.EC file name not compatible with JAR File Spec however it's compatible with java.util.JarVerifier // and our JarSignatureCollector @Test fun `one signer with EC algorithm`()</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$assertEquals(listOf(key), dir.getJarSigners(FILENAME))</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest${ (dir / "volatile").writeLines(listOf("volatile")) dir.createJar(FILENAME, "volatile") val key1 = signAsAlice() assertEquals(listOf(key1), dir.getJarSigners(FILENAME)) (dir / "volatile").writeLines(listOf("garbage")) dir.updateJar(FILENAME, "volatile", "_signable1") // ALICE's signature on volatile is now bad. signAsBob() // The JDK doesn't care that BOB has correctly signed the whole thing, it won't let us process the entry with ALICE's bad signature: assertFailsWith&lt;SecurityException&gt; { dir.getJarSigners(FILENAME) } }</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$executeProcess("jarsigner", "-keystore", "_teststore", "-storepass", storePassword, "-keypass", keyPassword, fileName, alias)</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$executeProcess("keytool", "-genkeypair", "-keystore", storeName, "-storepass", storePassword, "-keyalg", keyalg, "-alias", alias, "-keypass", keyPassword, "-dname", name)</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.generateKey(alias: String = "Test", storePassword: String = "secret!", name: String = CODE_SIGNER.toString(), keyalg: String = "RSA", keyPassword: String = storePassword, storeName: String = "_teststore") : PublicKey</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.signJar(fileName: String, alias: String, storePassword: String, keyPassword: String = storePassword): PublicKey</ID>
    <ID>MaxLineLength:JvmStatsHelper.kt$JvmStatsHelper$message.tryAppend("GC") { "${it.name}\n collectionCount: ${it.collectionCount} collectionTime: ${it.collectionTime}\n" }</ID>
    <ID>MaxLineLength:JvmStatsHelper.kt$JvmStatsHelper$message.tryAppend("OS stats") { "System load average: $systemLoadAverage Available processors: $availableProcessors" }</ID>
    <ID>MaxLineLength:JvmStatsHelper.kt$JvmStatsHelper.Companion$"init: ${memoryUsage.init} committed: ${memoryUsage.committed} max: ${memoryUsage.max} used: ${memoryUsage.used}"</ID>
    <ID>MaxLineLength:KMSUtils.kt$require(issuerRole == CertRole.LEGAL_IDENTITY) { "Confidential identities can only be issued from well known identities, provided issuer ${issuer.name} has role $issuerRole" }</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun externalIdForPublicKey(publicKey: PublicKey): UUID?</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKey(externalId: UUID): PublicKey</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean, externalId: UUID): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun sign(bytes: ByteArray, publicKey: PublicKey): DigitalSignature.WithKey</ID>
    <ID>MaxLineLength:KeyManagementService.kt$KeyManagementService$ @Suspendable fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature</ID>
    <ID>MaxLineLength:KeyManagementServiceInternal.kt$KeyManagementServiceInternal$override</ID>
    <ID>MaxLineLength:KeyOwningIdentity.kt$KeyOwningIdentity</ID>
    <ID>MaxLineLength:KeyOwningIdentity.kt$KeyOwningIdentity$MappedIdentity : KeyOwningIdentity</ID>
    <ID>MaxLineLength:KeyOwningIdentity.kt$KeyOwningIdentity$UnmappedIdentity : KeyOwningIdentity</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$"certificates/$DEV_CA_TRUST_STORE_FILE"</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$// A code signing policy is currently under design. // The following interim key represents a self-signed certificate produced using the Java keytool and located in the gradle cordapp plugins resources key store: // https://github.com/corda/corda-gradle-plugins/blob/master/cordapp/src/main/resources/certificates/cordadevcodesign.jks const val DEV_CORDAPP_CODE_SIGNING_STR = "AA59D829F2CA8FDDF5ABEA40D815F937E3E54E572B65B93B5C216AE6594E7D6B"</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$devNodeCa: CertificateAndKeyPair = createDevNodeCa(intermediateCa, legalName)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$fun CertificateStore.storeLegalIdentity(alias: String, keyPair: KeyPair = Crypto.generateKeyPair()): PartyAndCertificate</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$fun loadDevCaKeyStore(classLoader: ClassLoader = DevCaHelper::class.java.classLoader): CertificateStore</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$fun loadDevCaTrustStore(classLoader: ClassLoader = DevCaHelper::class.java.classLoader): CertificateStore</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$nodeKeyPair: KeyPair = generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$setPrivateKey</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val DEV_PUB_KEY_HASHES: List&lt;SecureHash.SHA256&gt; get() = listOf(DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate).map { it.publicKey.hash.sha256() } + SecureHash.parse(DEV_CORDAPP_CODE_SIGNING_STR).sha256()</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val identityCert = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCaCertAndKeyPair.certificate, nodeCaCertAndKeyPair.keyPair, nodeCaCertAndKeyPair.certificate.subjectX500Principal, keyPair.public)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val nodeCaCertAndKeyPair = getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, this@storeLegalIdentity.entryPassword)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, devNodeCa.certificate, devNodeCa.keyPair, legalName.x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun KeyStore.addOrReplaceKey(alias: String, key: Key, password: CharArray, chain: Array&lt;out Certificate&gt;)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun KeyStore.getSupportedKey(alias: String, keyPassword: String): PrivateKey</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun KeyStore.save(keyStoreFilePath: Path, storePassword: String)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$ fun loadOrCreateKeyStore(keyStoreFilePath: Path, storePassword: String, keystoreType: String = KEYSTORE_TYPE): KeyStore</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$return certificate as? X509Certificate ?: throw IllegalStateException("Certificate under alias \"$alias\" is not an X.509 certificate: $certificate")</ID>
    <ID>MaxLineLength:KotlinIntegrationTestingTutorial.kt$KotlinIntegrationTestingTutorial$bobProxy.startFlow(::CashPaymentFlow, 1000.DOLLARS, alice.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:KotlinUtilsTest.kt$KotlinUtilsTest$original.checkpointSerialize(context = KRYO_CHECKPOINT_CONTEXT.withEncoding(null)).checkpointDeserialize(context = KRYO_CHECKPOINT_NOWHITELIST_CONTEXT)</ID>
    <ID>MaxLineLength:KotlinUtilsTest.kt$KotlinUtilsTest$val copy = original.checkpointSerialize(context = KRYO_CHECKPOINT_CONTEXT).checkpointDeserialize(context = KRYO_CHECKPOINT_CONTEXT)</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeFilteredTransactionSerializer$override</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeFilteredTransactionSerializer$val visibleComponents: Map&lt;Int, ContractUpgradeFilteredTransaction.FilteredComponent&gt; = uncheckedCast(kryo.readClassAndObject(input))</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeWireTransactionSerializer$override</ID>
    <ID>MaxLineLength:Kryo.kt$ImmutableClassSerializer$throw KryoException("Hashcode mismatch for parameter types for ${klass.qualifiedName}: unsupported type evolution has happened.")</ID>
    <ID>MaxLineLength:Kryo.kt$PublicKeySerializer${ // TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser. output.writeBytesWithLength(obj.encoded) }</ID>
    <ID>MaxLineLength:Kryo.kt$ThrowableSerializer$private val delegate: Serializer&lt;Throwable&gt; = uncheckedCast(ReflectionSerializerFactory.makeSerializer(kryo, FieldSerializer::class.java, type))</ID>
    <ID>MaxLineLength:Kryo.kt$X509CertificateSerializer$return CertificateFactory.getInstance("X.509").generateCertificate(input.readBytesWithLength().inputStream()) as X509Certificate</ID>
    <ID>MaxLineLength:Kryo.kt$fun Kryo.serializationContext(): SerializeAsTokenContext?</ID>
    <ID>MaxLineLength:Kryo.kt$if (elemCount &lt; minLen) throw KryoException("Cannot deserialize list, too little elements. Minimum required: $minLen, got: $elemCount")</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$AutoCloseableSerialisationDetector$override fun read(kryo: Kryo, input: Input, type: Class&lt;AutoCloseable&gt;)</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$AutoCloseableSerialisationDetector$val message = "${closeable.javaClass.name}, which is a closeable resource, has been detected during flow checkpointing. " + "Restoring such resources across node restarts is not supported. Make sure code accessing it is " + "confined to a private method or the reference is nulled out."</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$context.encodingWhitelist.acceptEncoding(encoding) || throw KryoException(encodingNotPermittedFormat.format(encoding))</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$override</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$val serializer = Fiber.getFiberSerializer(false) as KryoSerializer val classResolver = CordaClassResolver(context).apply { setKryo(serializer.kryo) } // TODO The ClassResolver can only be set in the Kryo constructor and Quasar doesn't provide us with a way of doing that val field = Kryo::class.java.getDeclaredField("classResolver").apply { isAccessible = true } serializer.kryo.apply { field.set(this, classResolver) // don't allow overriding the public key serializer for checkpointing DefaultKryoCustomizer.customize(this) addDefaultSerializer(AutoCloseable::class.java, AutoCloseableSerialisationDetector) register(ClosureSerializer.Closure::class.java, CordaClosureSerializer) classLoader = it.second }</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$@Test fun `serialised form is stable when the same object instance occurs more than once, and using java serialisation`()</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$assertThat(deserialisedList.checkpointSerialize(noReferencesContext)).isEqualTo(originalList.checkpointSerialize(noReferencesContext))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$assertThat(listWithSameInstances.checkpointSerialize(noReferencesContext)).isEqualTo(listWithCopies.checkpointSerialize(noReferencesContext))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val deserialisedList = originalList.checkpointSerialize(noReferencesContext).checkpointDeserialize(noReferencesContext)</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val deserialisedMap: Map&lt;Int, Int&gt; = emptyMap&lt;Int, Int&gt;().checkpointSerialize(context).checkpointDeserialize(context)</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val meta = SignableData(testBytes.sha256(), SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val readRubbishStream: InputStream = rubbish.inputStream().checkpointSerialize(context).checkpointDeserialize(context)</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$val streams = byteArrays.map { it.inputStream() }.checkpointSerialize(context).checkpointDeserialize(context).iterator()</ID>
    <ID>MaxLineLength:LargeTransactionsTest.kt$LargeTransactionsTest$networkParameters = testNetworkParameters(maxMessageSize = 16.MB.toInt(), maxTransactionSize = 14.MB.toInt())</ID>
    <ID>MaxLineLength:LargeTransactionsTest.kt$LargeTransactionsTest$val (alice, _) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow()</ID>
    <ID>MaxLineLength:Launcher.kt$// initialise loggers lazily as some configuration is changed on startup and if loggers are already initialised it will be ignored val migrationLogger: Logger by lazy { LoggerFactory.getLogger("migration.tool") }</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$override fun additionalSubCommands()</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$printWarning("The --$CREATE_MIGRATION_CORDAPP option has been deprecated and will be removed in a future version. Use the $CREATE_MIGRATION_CORDAPP command instead.")</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$printWarning("The --$DRY_RUN option has been deprecated and will be removed in a future version. Use the $DRY_RUN command instead.")</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$printWarning("The --$EXECUTE_MIGRATION option has been deprecated and will be removed in a future version. Use the $EXECUTE_MIGRATION command instead.")</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$printWarning("The --$RELEASE_LOCK flag has been deprecated and will be removed in a future version. Use the $RELEASE_LOCK command instead.")</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$require(selectedOptions.count() != 0) { "You must call database-manager with a command option. See --help for further info." }</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool$require(selectedOptions.count() == 1) { "You cannot call more than one of: ${selectedOptions.joinToString(", ")}. See --help for further info." }</ID>
    <ID>MaxLineLength:Launcher.kt$DbManagementTool${ // The database manager should be invoked using one of the vaild subcommands. If the old --flag based options are used, // this is the entry point that will be used. It does some additional validation and then delegates to the relevant // subcommand. It should be removed in a future version. return runLegacyCommands() }</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$JMeterArgsPlus</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$Ssh.createSshTunnels(cmdLine.sshHosts.toTypedArray(), jMeterPropertiesFile.toString(), serverRmiMappings, cmdLine.sshUser)</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$logger.info("No rmi server mapping found, using default server.rmi.localport - assuming no ssh tunnelling in effect")</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$throw LauncherException("Enabling ssh tunneling requires providing rmi mappings via -XserverRmiMappings")</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$throw LauncherException("To choose jmeter.properties, use the -XjmeterProperties flag, not -p for JMeter arguments")</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$val searchPath = Files.readAllLines(Paths.get(searchPathsFilename)).first() + if (cmdLine.additionalSearchPaths.isBlank()) "" else ";${cmdLine.additionalSearchPaths}"</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion$val searchPath = if (capsuleDir != null) prepareJMeterPropsCapsule(cmdLine, capsuleDir) else prepareJMeterPropsGradle(cmdLine)</ID>
    <ID>MaxLineLength:Launcher.kt$Launcher.Companion${ // check that a search_paths_file has been provided as a system property and throw meaningful error otherwise val searchPathsFilename = System.getProperty("search_paths_file") if (searchPathsFilename.isNullOrBlank()) { throw LauncherException("System property search_paths_file must be set when running without capsule") } if (System.getProperty("jmeter.home").isNullOrBlank()) { throw LauncherException("System property jmeter.home must be set when running without capsule") } val searchPath = Files.readAllLines(Paths.get(searchPathsFilename)).first() + if (cmdLine.additionalSearchPaths.isBlank()) "" else ";${cmdLine.additionalSearchPaths}" logger.info("search_paths read from $searchPathsFilename: $searchPath") return searchPath }</ID>
    <ID>MaxLineLength:Launcher.kt${ if (args.isEmpty()) { println("Usage: launcher &lt;main-class-name&gt; [args]") exitProcess(0) } // TODO: --base-directory is specific of the Node app, it should be controllable by a config property // we must use this directory for loading classpath components //but it must be resolved relative to the CWD the user has launched the script from as they may use a relative path val nodeBaseDirFromArgs = Paths.get(Settings.WORKING_DIR) .resolve(getBaseDirectoryFromArgs(args) ?: ".") .toAbsolutePath() val appClassLoader = setupClassLoader(nodeBaseDirFromArgs) val appMain = try { appClassLoader .loadClass(args[0]) .getMethod("main", Array&lt;String&gt;::class.java) } catch (e: Exception) { System.err.println("Error looking for method 'main' in class ${args[0]}:") e.printStackTrace() exitProcess(1) } // Propagate current working directory via system property, to patch it after javapackager System.setProperty("corda-launcher.cwd", Settings.WORKING_DIR) System.setProperty("user.dir", Settings.WORKING_DIR) // To distinguish how Corda was started in order to create more detailed message for any discrepancies between Capsule and javapackager (tarball) // e.g. if JDBC driver was not found, remove once Corda started by Capsule is no longer in use System.setProperty("corda-distribution.tarball", "true") val argsWithBaseDir = fixBaseDirArg(args, nodeBaseDirFromArgs) try { appMain.invoke(null, argsWithBaseDir.sliceArray(1..argsWithBaseDir.lastIndex)) } catch (e: Exception) { e.printStackTrace() exitProcess(1) } }</ID>
    <ID>MaxLineLength:LauncherCommandLine.kt$LauncherCommandLine$"A semicolon separated list of directories/jar files to search for plug-ins/samplers. This will be added to any search paths already in the properties"</ID>
    <ID>MaxLineLength:LauncherCommandLine.kt$LauncherCommandLine$"Path to a jmeter.properties file to replace the one in the jar. Use this instead of the -p flag of jMeter as the wrapping code needs access to the file as well."</ID>
    <ID>MaxLineLength:LauncherCommandLine.kt$LauncherCommandLine$"This file should have a line for each server that needs an ssh tunnel created to. Each line should have the unqualified server name, followed by a colon and the port number. Each host needs a different port number. Lines starting with # are comments and are ignored."</ID>
    <ID>MaxLineLength:LauncherCommandLine.kt$LauncherCommandLine$@CommandLine.Command(synopsisHeading = "", customSynopsis = arrayOf("Usage: jmeter-corda [OPTIONS] -- [&lt;jMeter args&gt;...]"), sortOptions = false)</ID>
    <ID>MaxLineLength:LauncherCommandLine.kt$LauncherCommandLine$@CommandLine.Option(names = arrayOf("-Xssh"), description = arrayOf("List of hosts to create SSH tunnels to, separated by space", "Example: -Xssh &lt;hostname1&gt; [&lt;hostname2&gt; ...]"), arity = "1..*")</ID>
    <ID>MaxLineLength:LauncherCommandLine.kt$LauncherCommandLine$@CommandLine.Parameters(paramLabel = "&lt;jMeter args&gt;", description = arrayOf("All arguments after -- are passed to JMeter"))</ID>
    <ID>MaxLineLength:LazyPool.kt$LazyPool&lt;A&gt;</ID>
    <ID>MaxLineLength:LazyStickyPool.kt$LazyStickyPool&lt;A : Any&gt;</ID>
    <ID>MaxLineLength:LedgerDSLInterpreter.kt$LedgerDSL$ @JvmOverloads fun unverifiedTransaction(label: String? = null, transactionBuilder: TransactionBuilder = TransactionBuilder(notary = notary), dsl: TransactionDSL&lt;TransactionDSLInterpreter&gt;.() -&gt; Unit)</ID>
    <ID>MaxLineLength:LedgerDSLInterpreter.kt$LedgerDSL&lt;out T : TransactionDSLInterpreter, out L : LedgerDSLInterpreter&lt;T&gt;&gt; : LedgerDSLInterpreter</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ @Throws(TransactionVerificationException::class) fun verify()</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; commandsOfType(clazz: Class&lt;T&gt;): List&lt;Command&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; filterCommands(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;Command&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; findCommand(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): Command&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : CommandData&gt; getCommand(index: Int): Command&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterInRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterInputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterReferenceInputRefs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; filterReferenceInputs(clazz: Class&lt;T&gt;, predicate: Predicate&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; inputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$ fun &lt;T : ContractState&gt; referenceInputsOfType(clazz: Class&lt;T&gt;): List&lt;T&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$"Use WireTransaction.toLedgerTransaction instead. The result of the verify method would not be accurate."</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** * Network parameters that were in force when the transaction was constructed. This is nullable only for backwards * compatibility for serialized transactions. In reality this field will always be set when on the normal codepaths. */ override val networkParameters: NetworkParameters?</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** A list of [Attachment] objects identified by the transaction that are needed for this transaction to verify. */ val attachments: List&lt;Attachment&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** Random data used to make the transaction hash unpredictable even if the contents can be predicted; needed to avoid some obscure attacks. */ val privacySalt: PrivacySalt</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** The notary that the tx uses, this must be the same as the notary of all the inputs, or null if there are no inputs. */ override val notary: Party?</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$// Create a copy of the outer LedgerTransaction which deserializes all fields inside the [transactionClassLoader]. // Only the copy will be used for verification, and the outer shell will be discarded. // This artifice is required to preserve backwards compatibility. Verifier(createLtxForVerification(), transactionClassLoader)</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$inline</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$inline fun &lt;reified T : ContractState&gt; referenceInputRefsOfType(): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$logger</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return inputs.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return references.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.")</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$val deserializedOutputs = deserialiseComponentGroup(componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction${ // Switch thread local deserialization context to using a cached attachments classloader. This classloader enforces various rules // like no-overlap, package namespace ownership and (in future) deterministic Java. return AttachmentsClassLoaderBuilder.withAttachmentsClassloaderContext( this.attachments + extraAttachments, getParamsWithGoo(), id, isAttachmentTrusted = isAttachmentTrusted) { transactionClassLoader -&gt; // Create a copy of the outer LedgerTransaction which deserializes all fields inside the [transactionClassLoader]. // Only the copy will be used for verification, and the outer shell will be discarded. // This artifice is required to preserve backwards compatibility. Verifier(createLtxForVerification(), transactionClassLoader) } }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction${ // This path is triggered if someone used old constructors that were accidentally exposed; darn Kotlin's lack of package-private // visibility! We did originally try to maintain verification codepaths that supported lack of network parameters, but, it // got too convoluted and people kept just !! asserting the nullity away because on normal codepaths this is always set. logger.warn("Network parameters on the LedgerTransaction with id: $id are null. Please don't use deprecated constructors of the LedgerTransaction. " + "Use WireTransaction.toLedgerTransaction instead. The result of the verify method would not be accurate.") // Roll the dice - we're probably in flow context if we got here at all, which means we can fish the current params out. try { params = getParamsFromFlowLogic() } catch (e: UnsupportedOperationException) { // Inside DJVM, ignore. } if (params == null) throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.") }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction.Companion$return LedgerTransaction(inputs, outputs, commands, attachments, id, notary, timeWindow, privacySalt, networkParameters, references).apply { this.componentGroups = componentGroups this.serializedInputs = serializedInputs this.serializedReferences = serializedReferences this.isAttachmentTrusted = isAttachmentTrusted }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction.InOutGroup$@KeepForDJVM data</ID>
    <ID>MaxLineLength:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$return StateAndRef(TransactionState(dummyState, DummyContract.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), dummyStateRef)</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeConfigurationImpl$val whitelistedHeaders: List&lt;String&gt; = ArtemisMessagingComponent.Companion.P2PMessagingHeaders.whitelistedHeaders.toList()</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeInboundConfigurationImpl$private val customSSLConfiguration: Version3BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeInnerConfigurationImpl$return BridgeInnerConfigurationImpl(floatAddresses, expectedCertificateSubject, customSSLConfiguration?.toConfig(), enableSNI)</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeInnerConfigurationImpl$val customSSLConfiguration: Version3BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeInnerConfigurationImpl$val enableSNI: Boolean = true</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeOutboundConfigurationImpl$val alternateArtemisBrokerAddresses: List&lt;NetworkHostAndPort&gt;</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeOutboundConfigurationImpl$val customSSLConfiguration: Version3BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeOutboundConfigurationImpl$val socksProxyConfig: ProxyConfig? = null</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeSSLConfigurationImpl$return BridgeSSLConfigurationImpl(sslKeystore, keyStorePassword, keyStorePrivateKeyPassword, trustStoreFile, trustStorePassword, useOpenSsl)</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3BridgeSSLConfigurationImpl$val useOpenSsl: Boolean = false</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version3FloatOuterConfigurationImpl$val customSSLConfiguration: Version3BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4BridgeInnerConfigurationImpl$private val enableSNI: Boolean = true</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4BridgeInnerConfigurationImpl$return BridgeInnerConfigurationImpl(floatAddresses, expectedCertificateSubject, tunnelSSLConfiguration?.toConfig(), enableSNI)</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4BridgeOutboundConfigurationImpl$private val alternateArtemisBrokerAddresses: List&lt;NetworkHostAndPort&gt;</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4BridgeOutboundConfigurationImpl$private val artemisSSLConfiguration: Version3BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4BridgeOutboundConfigurationImpl$private val proxyConfig: ProxyConfig? = null</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4BridgeOutboundConfigurationImpl$return BridgeOutboundConfigurationImpl(artemisBrokerAddress, alternateArtemisBrokerAddresses, artemisSSLConfiguration?.toConfig(), proxyConfig)</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4FirewallConfiguration$val whitelistedHeaders: List&lt;String&gt; = ArtemisMessagingComponent.Companion.P2PMessagingHeaders.whitelistedHeaders.toList()</ID>
    <ID>MaxLineLength:LegacyConfigurations.kt$Version4FloatOuterConfigurationImpl$private val tunnelSSLConfiguration: Version3BridgeSSLConfigurationImpl?</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$ fun validateNameAttribute(normalizedNameAttribute: String, validation: Validation)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$ fun validateOrganization(normalizedOrganization: String, validation: Validation)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator$@Deprecated("Use validateOrganization instead", replaceWith = ReplaceWith("validateOrganization(normalizedLegalName)"))</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.CapitalLetterRule$require(legalName == capitalizedLegalName) { "Legal name should be capitalized. i.e. '$capitalizedLegalName'" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.MustHaveAtLeastTwoLettersRule$require(legalName.count { it.isLetter() } &gt;= 2) { "Illegal input legal name '$legalName'. Legal name must have at least two letters" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeNormalizationRule$require(legalName == normalize(legalName)) { "Legal name must be normalized. Please use 'normalize' to normalize the legal name before validation." }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeRangeRule$val illegalChars = legalName.toCharArray().filter { Character.UnicodeBlock.of(it) !in supportScriptsSet }.size</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateNameAttribute("The quick brown fox jumped over the lazy dog.1234567890", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("Legal Name With\n\rLine\nBreaks", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("Legal Name\u2004With\u0009Unicode\u0020Whitespaces", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("The quick brown fox jumped over the lazy dog.1234567890", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization(LegalNameValidator.normalize("Test Legal Name"), LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization(longLegalName.append("A").toString(), LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$assertEquals("Legal Name With Unicode Whitespaces", LegalNameValidator.normalize("Legal Name\u2004With\u0009Unicode\u0020Whitespaces"))</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseContract.kt$LinearStateBatchNotariseContract.Companion$const val CP_PROGRAM_ID: ContractClassName = "com.r3.corda.enterprise.perftestcordapp.contracts.LinearStateBatchNotariseContract"</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow : FlowLogic</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$@Suspendable private</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$builder.addOutputState(TransactionState(LinearStateBatchNotariseContract.State(UniqueIdentifier(), us, serviceHub.clock.instant()), LinearStateBatchNotariseContract.CP_PROGRAM_ID, notary))</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$builder.addOutputState(TransactionState(LinearStateBatchNotariseContract.State(input.state.data.linearId, us, serviceHub.clock.instant()), LinearStateBatchNotariseContract.CP_PROGRAM_ID, notary))</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$logger.info("Notarised $x transactions ($n states/tx) in ${totalTime}ms (avg ${totalTime / x.toDouble()}ms/tx, slowest ${txDurations[0]}ms; 95% &lt; ${txDurations[p95Index]}ms)")</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$val durationOfEachIteration = Duration.ofHours(1).dividedBy((transactionsPerSecond * TimeUnit.SECONDS.convert(1, TimeUnit.HOURS)).toLong())</ID>
    <ID>MaxLineLength:LinearStateBatchNotariseFlow.kt$LinearStateBatchNotariseFlow$val expectedTimeOfNextIteration = iterationStartTime.plus(durationOfEachIteration.times(iterationNumber.toLong()))</ID>
    <ID>MaxLineLength:LinearStateScenarioRunner.kt$LinearStateScenarioRunner : AbstractScenarioRunnerCallable</ID>
    <ID>MaxLineLength:LinearStateScenarioRunner.kt$LinearStateScenarioRunner$@Suppress("UNUSED_PARAMETER") private</ID>
    <ID>MaxLineLength:LinearStateScenarioRunner.kt$LinearStateScenarioRunner$require(results.size == iterCount) { "Expected number of results is $iterCount, actual number of payments: ${results.size}" }</ID>
    <ID>MaxLineLength:LinearStateScenarioRunner.kt$LinearStateScenarioRunner$val haStates: Vault.Page&lt;LinearStateBatchNotariseContract.State&gt; = haNodeRpcOps.vaultQueryByWithRetry(criteria, pageSpecification)</ID>
    <ID>MaxLineLength:LinearStateScenarioRunner.kt$LinearStateScenarioRunner$val result = haNodeRpcOps.startFlowWithRetryAndGet(::LinearStateBatchNotariseFlow, notary, 1, 1, true, 1000.0)</ID>
    <ID>MaxLineLength:LinearStateScenarioRunner.kt$LinearStateScenarioRunner${ // Unfortunately, there is absolutely nothing in `LinearStateBatchNotariseFlow.Result` which can link it to the original transaction return true }</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$ListsSerializationTest$Assertions.assertThatThrownBy { wrongPayloadType.serialize() } .isInstanceOf(NotSerializableException::class.java)</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$ListsSerializationTest.Companion$val envelope = DeserializationInput(SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader)).getEnvelope(serBytes, context)</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$internal inline</ID>
    <ID>MaxLineLength:Literal.kt$ContractBuilder$@Suppress("UNUSED_PARAMETER") p3: kotlin.Pair&lt;Parameter&lt;T3&gt;, Perceivable&lt;T3&gt;&gt;</ID>
    <ID>MaxLineLength:Literal.kt$ContractBuilder$fun &lt;T&gt; rollOut(startDate: LocalDate, endDate: LocalDate, frequency: Frequency, vars: T, init: RollOutBuilder&lt;T&gt;.() -&gt; Unit): RollOut</ID>
    <ID>MaxLineLength:Literal.kt$ContractBuilder$fun rollOut(startDate: LocalDate, endDate: LocalDate, frequency: Frequency, init: RollOutBuilder&lt;Dummy&gt;.() -&gt; Unit): RollOut</ID>
    <ID>MaxLineLength:Literal.kt$RollOutBuilder&lt;T&gt; : ContractBuilder</ID>
    <ID>MaxLineLength:LoadTest.kt$LoadTest&lt;T, S&gt;</ID>
    <ID>MaxLineLength:LoadTest.kt$RemoteNode(hostname, it.remoteSystemdServiceName, it.sshUser, it.rpcUser, it.rpcPort, it.remoteNodeDirectory)</ID>
    <ID>MaxLineLength:LoadTest.kt$it.legalIdentitiesAndCerts.fold("") { acc, elem -&gt; acc + "\n" + elem.name + ": " + elem.owningKey.toBase58String() }</ID>
    <ID>MaxLineLength:LoadTest.kt$simpleNodes = hostNodeMap.values.filter { it.info.legalIdentitiesAndCerts.size == 1 }</ID>
    <ID>MaxLineLength:LoadTestConfiguration.kt$RemoteNode</ID>
    <ID>MaxLineLength:LocalDateSerializer.kt$LocalDateSerializer : Proxy</ID>
    <ID>MaxLineLength:LocalDateSerializer.kt$LocalDateSerializer$override fun fromProxy(proxy: LocalDateProxy): LocalDate</ID>
    <ID>MaxLineLength:LocalDateSerializer.kt$LocalDateSerializer$override fun toProxy(obj: LocalDate): LocalDateProxy</ID>
    <ID>MaxLineLength:LocalDateTimeSerializer.kt$LocalDateTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:LocalDateTimeSerializer.kt$LocalDateTimeSerializer$override fun toProxy(obj: LocalDateTime): LocalDateTimeProxy</ID>
    <ID>MaxLineLength:LocalDateTimeSerializer.kt$LocalDateTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalDateSerializer(factory), LocalTimeSerializer(factory))</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$ConstructorPairedProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$GetterSetterProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$PrivateConstructorPairedProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation$ReadOnlyProperty : LocalPropertyInformation</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.CalculatedProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.ConstructorPairedProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.GetterSetterProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.PrivateConstructorPairedProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.ReadOnlyProperty$data</ID>
    <ID>MaxLineLength:LocalSerializationRule.kt$LocalSerializationRule.AMQPSerializationScheme$( cordappCustomSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;, cordappSerializationWhitelists: Set&lt;SerializationWhitelist&gt;, serializerFactoriesForContexts: AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; )</ID>
    <ID>MaxLineLength:LocalSerializationRule.kt$LocalSerializationRule.AMQPSerializationScheme$override</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory : LocalSerializerFactory</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$clazz.isSynthetic</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$is LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$is LocalTypeInformation.AMap</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private val serializersByActualAndDeclaredType: MutableMap&lt;ActualAndDeclaredType, AMQPSerializer&lt;Any&gt;&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private val serializersByTypeId: MutableMap&lt;TypeIdentifier, AMQPSerializer&lt;Any&gt;&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$LocalSerializerFactory</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$LocalSerializerFactory$ fun getTypeInformation(typeName: String): LocalTypeInformation?</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$LocalSerializerFactory$/** * The [ClassWhitelist] used by this factory. Classes must be whitelisted for serialization, because they are expected * to be written in a secure manner. */ val whitelist: ClassWhitelist</ID>
    <ID>MaxLineLength:LocalTimeSerializer.kt$LocalTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:LocalTimeSerializer.kt$LocalTimeSerializer$override fun fromProxy(proxy: LocalTimeProxy): LocalTime</ID>
    <ID>MaxLineLength:LocalTimeSerializer.kt$LocalTimeSerializer$override fun toProxy(obj: LocalTime): LocalTimeProxy</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$ fun prettyPrint(simplifyClassNames: Boolean = true): String</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$Abstract : LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$AnArray : LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation$AnInterface : LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.ACollection$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AMap$fun withParameters(keyType: LocalTypeInformation, valueType: LocalTypeInformation): AMap</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AMap$val reparameterizedType = typeIdentifier.copy(parameters = listOf(keyType.typeIdentifier, valueType.typeIdentifier))</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AMap$val unerasedType = typeIdentifier.toParameterized(listOf(keyType.typeIdentifier, valueType.typeIdentifier))</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AnArray$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Atomic$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Companion$ fun forType(type: Type, typeIdentifier: TypeIdentifier, lookup: LocalTypeLookup): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Companion$throw IllegalStateException("Should not be attempting to build new type information when populating a cycle")</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Singleton$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformationPrettyPrinter$private</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformationPrettyPrinter$private data</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private fun buildNonAtomic(rawType: Class&lt;*&gt;, type: Type, typeIdentifier: TypeIdentifier, typeParameterInformation: List&lt;LocalTypeInformation&gt;): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private inline fun &lt;T&gt; suppressValidation(block: LocalTypeInformationBuilder.() -&gt; T): T</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$!EnumSet::class.java.isAssignableFrom(type)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$Map::class.java.isAssignableFrom(type) -&gt; LocalTypeInformation.AMap(type, typeIdentifier, LocalTypeInformation.Unknown, LocalTypeInformation.Unknown)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$constructorInformation.parameters[index].isMandatory &amp;&amp; index !in indicesAddressedByProperties -&gt; parameter</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$constructorInformation: LocalConstructorInformation</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$is TypeIdentifier.Parameterised -&gt; buildForParameterised(rawType, type as ParameterizedType, typeIdentifier, isOpaque)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$it.name ?: throw IllegalStateException("Unnamed parameter in constructor $observedConstructor")</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$name to LocalPropertyInformation.ReadOnlyProperty(descriptor.getter, paramTypeInformation, isMandatory)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$reason = "Mandatory constructor parameters $missingParameters are missing from the readable properties ${properties.keys}"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either annotate a constructor for this type with @ConstructorForDeserialization, or provide a custom serializer for it"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either ensure that the properties ${nonComposableProperties.keys} are serializable, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either provide getters or readable fields for $missingParameters, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$return LocalTypeInformation.Composable(type, typeIdentifier, constructorInformation, evolutionConstructors, properties, superclassInformation, interfaceInformation, typeParameterInformation)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$suppressValidation { buildNonAtomic(rawType, type, typeIdentifier, buildTypeParameterInformation(type)) }</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$throw NotSerializableException("Type '${type.typeName} has synthetic fields and is likely a nested inner class.")</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$val constants = type.enumConstants.asSequence().mapIndexed { index, constant -&gt; constant.toString() to index }.toMap()</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$val constructorParameterIndices = constructorInformation.parameters.asSequence().mapIndexed { index, parameter -&gt; parameter.name to index }.toMap()</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$val missingParameters = missingMandatoryConstructorProperties(constructorInformation, properties).map { it.name }</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$ConfigurableLocalTypeModel : LocalTypeModel</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$ConfigurableLocalTypeModel.BuilderLookup$override</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$LocalTypeLookup</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$LocalTypeLookup$ fun findOrBuild(type: Type, typeIdentifier: TypeIdentifier, builder: (Boolean) -&gt; LocalTypeInformation): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$LocalTypeModel$ fun inspect(type: Type): LocalTypeInformation</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ Concrete(a: Integer[], b: double, c: List&lt;Integer[]&gt;, d: int): Abstract&lt;Integer&gt;, Super&lt;Integer[]&gt;, SuperSuper&lt;Integer[], Double&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ StringCollectionHolder(list: List&lt;String&gt;, map: Map&lt;String, String&gt;, array: List&lt;String&gt;[]): StringKeyedCollectionHolder&lt;String&gt;, CollectionHolder&lt;String, String&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ StringKeyedCollectionHolder&lt;Integer&gt;(list: List&lt;Integer&gt;, map: Map&lt;String, Integer&gt;, array: List&lt;Integer&gt;[]): CollectionHolder&lt;String, Integer&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ c [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ collectionHolder (optional): StringKeyedCollectionHolder&lt;Integer&gt;(list: List&lt;Integer&gt;, map: Map&lt;String, Integer&gt;, array: List&lt;Integer&gt;[]): CollectionHolder&lt;String, Integer&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ d [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ g [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$"Either annotate a constructor for this type with @ConstructorForDeserialization, or provide a custom serializer for it"</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$"Either ensure that the properties [b, c, d] are serializable, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$AliasingOldStylePojoImpl : OldStylePojo</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$NonComposableNested</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$StringCollectionHolder : StringKeyedCollectionHolder</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$StringKeyedCollectionHolder&lt;T&gt; : CollectionHolder</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val customSerializerRegistry: CustomSerializerRegistry = CachingCustomSerializerRegistry(descriptorBasedSerializerRegistry)</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val model = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, customSerializerRegistry))</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val modelWithoutOpacity = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, emptyCustomSerializerRegistry))</ID>
    <ID>MaxLineLength:LocalVolume.kt$LocalVolume$networkParamsFile.outputStream() .use { networkParameters.signWithCert(Volume.keyPair.private, Volume.networkMapCert).serialize().writeTo(it) }</ID>
    <ID>MaxLineLength:LogProcessor.kt$LogProcessor$private</ID>
    <ID>MaxLineLength:LogProcessor.kt$LogProcessor$val sessionSpan = sessions[sessionId] ?: if (sessionId == "Unknown") { parentLogSpan } else { span(sessionStart, "Session $sessionId", emptyMap(), parentSpan, sessionEnd) }</ID>
    <ID>MaxLineLength:LogProcessor.kt$LogProcessor.LogSpan$private</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$"${nf.format(dirStatsOut.accepted.mapValues { it.value.second }.sumValues())}(outbound)\n"</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$"\tActive connection count: ${nf.format(dirStatsIn.activeConnectionCount.sumValues())}(inbound), ${nf.format(dirStatsOut.activeConnectionCount.sumValues())}(outbound)\n"</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$"\tBytes transmitted: ${nf.format(dirStatsIn.accepted.mapValues { it.value.second }.sumValues())}(inbound), "</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$"\tFailed connection count: ${nf.format(dirStatsIn.failedConnectionCount.sumValues())}(inbound), ${nf.format(dirStatsOut.failedConnectionCount.sumValues())}(outbound)\n"</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$"\tPackets dropped count: ${nf.format(dirStatsIn.droppedPacketsCount.sumValues())}(inbound), ${nf.format(dirStatsOut.droppedPacketsCount.sumValues())}(outbound)"</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$"\tSuccessful connection count: ${nf.format(dirStatsIn.successfulConnectionCount.sumValues())}(inbound), ${nf.format(dirStatsOut.successfulConnectionCount.sumValues())}(outbound)\n"</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$dirStatsIn.activeConnectionCount.keys.union(dirStatsOut.activeConnectionCount.keys).whenNonEmptyPrint { "\tLive connections:\n" + "${prettyPrint(dirStatsIn.activeConnectionCount, dirStatsOut.activeConnectionCount, nf)}\n" }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$dirStatsIn.droppedPacketsCount.keys.union(dirStatsOut.droppedPacketsCount.keys).whenNonEmptyPrint { "\tDropped packets:\n" + "${prettyPrint(dirStatsIn.droppedPacketsCount, dirStatsOut.droppedPacketsCount, nf)}\n" }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$dirStatsIn.failedConnectionCount.keys.union(dirStatsOut.failedConnectionCount.keys).whenNonEmptyPrint { "\tFailed connections:\n" + "${prettyPrint(dirStatsIn.failedConnectionCount, dirStatsOut.failedConnectionCount, nf)}\n" }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$dirStatsIn.successfulConnectionCount.keys.union(dirStatsOut.successfulConnectionCount.keys).whenNonEmptyPrint { "\tSuccessful connections:\n" + "${prettyPrint(dirStatsIn.successfulConnectionCount, dirStatsOut.successfulConnectionCount, nf)}\n" }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$inAcceptedPackets.keys.union(outAcceptedPackets.keys).whenNonEmptyPrint { "\tAccepted packets:\n" + "${prettyPrint(inAcceptedPackets, outAcceptedPackets, nf)}\n" }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$override</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$private</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.Companion$leftPad + "$key -&gt; in: ${nf.format(inbound.getOrDefault(key, AtomicLong(0)).get())} out: ${nf.format(outbound.getOrDefault(key, AtomicLong(0)).get())}"</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.Companion$private</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.DirectionalStats$private data</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.DirectionalStats$val accepted : ConcurrentMap&lt;String, Pair&lt;AtomicLong, AtomicLong&gt;&gt; = ConcurrentHashMap&lt;String, Pair&lt;AtomicLong, AtomicLong&gt;&gt;()</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.DirectionalStats$val activeConnectionCount : ConcurrentMap&lt;InetSocketAddress, AtomicLong&gt; = ConcurrentHashMap&lt;InetSocketAddress, AtomicLong&gt;()</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.DirectionalStats$val droppedPacketsCount : ConcurrentMap&lt;String, AtomicLong&gt; = ConcurrentHashMap&lt;String, AtomicLong&gt;()</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.DirectionalStats$val failedConnectionCount : ConcurrentMap&lt;InetSocketAddress, AtomicLong&gt; = ConcurrentHashMap&lt;InetSocketAddress, AtomicLong&gt;()</ID>
    <ID>MaxLineLength:LoggingFirewallAuditService.kt$LoggingFirewallAuditService.State$private data</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$(1..10).forEach { instance.successfulConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionSuccess", it.toDirection()) }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$(1..10).forEach { instance.terminatedConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionClose", it.toDirection()) }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$(1..20).forEach { instance.successfulConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionSuccess", it.toDirection()) }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$(1..5).forEach { instance.terminatedConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionClose", it.toDirection()) }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$(1..failedConnCount).forEach { instance.terminatedConnectionEvent(it.toAddress(), null, "test", it.toDirection()) }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest$(1..succConnCount).forEach { instance.successfulConnectionEvent(it.toAddress(), "test2", "test", it.toDirection()) }</ID>
    <ID>MaxLineLength:LoggingFirewallAuditServiceTest.kt$LoggingFirewallAuditServiceTest${ fun triggerActivity() { val t1 = thread { (1..20).forEach { instance.successfulConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionSuccess", it.toDirection()) } (1..10).forEach { instance.terminatedConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionClose", it.toDirection()) } } val t2 = thread { (1..10).forEach { instance.successfulConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionSuccess", it.toDirection()) } (1..5).forEach { instance.terminatedConnectionEvent(it.toAddress(), "connectionTrackingTest", "connectionClose", it.toDirection()) } } t1.join() t2.join() } triggerActivity() with(instance.prepareStatsAndReset()) { assertThat(this, containsSubstring("Successful connection count: 9(inbound), 21(outbound)")) assertThat(this, containsSubstring("Failed connection count: 4(inbound), 11(outbound)")) assertThat(this, containsSubstring("Active connection count: 5(inbound), 10(outbound)")) assertThat(this, containsSubstring("Packets accepted count: 0(inbound), 0(outbound)")) assertThat(this, containsSubstring("Bytes transmitted: 0(inbound), 0(outbound)")) assertThat(this, containsSubstring("Packets dropped count: 0(inbound), 0(outbound)")) } triggerActivity() // Verify that after another round of connection shuffling, the temporary stats are properly reset while active connections are only updated correctly with(instance.prepareStatsAndReset()) { assertThat(this, containsSubstring("Successful connection count: 9(inbound), 21(outbound)")) assertThat(this, containsSubstring("Failed connection count: 4(inbound), 11(outbound)")) assertThat(this, containsSubstring("Active connection count: 10(inbound), 20(outbound)")) assertThat(this, containsSubstring("Packets accepted count: 0(inbound), 0(outbound)")) assertThat(this, containsSubstring("Bytes transmitted: 0(inbound), 0(outbound)")) assertThat(this, containsSubstring("Packets dropped count: 0(inbound), 0(outbound)")) } }</ID>
    <ID>MaxLineLength:LoginView.kt$LoginView$nodeModel = login(hostTextField.text, portProperty.value, usernameTextField.text, passwordTextField.text)</ID>
    <ID>MaxLineLength:LoginView.kt$LoginView$val button = Alert(Alert.AlertType.CONFIRMATION, "Are you sure you want to exit Corda Explorer?").apply { initOwner(root.scene.window) }.showAndWait().get()</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager : AMQPBridgeManager</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager$override</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager$sslHandshakeTimeout: Long? = null</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager$val newBridge = LoopbackBridge(sourceX500Name, queueName, targets, legalNames, artemis!!, bridgeMetricsService)</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$logDebugWithMDC { "Loopback Send to ${legalNames.first()} uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}" }</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$logInfoWithMDC("Bridge Connected") bridgeMetricsService?.bridgeConnected(targets, legalNames) val sessionFactory = started!!.sessionFactory this@LoopbackBridge.consumerSession = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) this@LoopbackBridge.producerSession = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) // Several producers (in the case of shared bridge) can put messages in the same outbound p2p queue. The consumers are created using the source x500 name as a filter val consumer = consumerSession!!.createConsumer(queueName, "hyphenated_props:sender-subject-name = '$sourceX500Name'") consumer.setMessageHandler(this@LoopbackBridge::clientArtemisMessageHandler) this@LoopbackBridge.consumer = consumer this@LoopbackBridge.producer = producerSession!!.createProducer() consumerSession?.start() producerSession?.start()</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$metricsService.packetAcceptedEvent(SendableMessageImpl(artemisMessage.payload(), peerInbox, legalNames.first().toString(), targets.first(), properties))</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$this@LoopbackBridge.consumerSession = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$this@LoopbackBridge.producerSession = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$val consumer = consumerSession!!.createConsumer(queueName, "hyphenated_props:sender-subject-name = '$sourceX500Name'")</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$LoopbackBridgeManager.LoopbackBridge$val properties = ArtemisMessagingComponent.Companion.P2PMessagingHeaders.whitelistedHeaders.mapNotNull { key -&gt; if (artemisMessage.containsProperty(key)) { key to artemisMessage.getObjectProperty(key).let { (it as? SimpleString)?.toString() ?: it } } else { null } }.toMap()</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.RemoteInboxAddress.Companion.translateInboxAddressToLocalQueue</ID>
    <ID>MaxLineLength:LoopbackBridgeManager.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.RemoteInboxAddress.Companion.translateLocalQueueToInboxAddress</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$// This test will hang if AMQP bridge is being use instead of Loopback bridge. @Test(timeout = 600000) fun `Nodes behind one bridge can communicate with each other using loopback bridge - with bridge starts after nodes`()</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$Assume.assumeTrue(!isRemoteDatabaseMode())</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000))).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$internalDriver</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$private</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$startBridge(driverDirectory, artemisPort, advertisedP2PPort, bankAPath / "certificates" / "sslkeystore.jks", bankBPath / "certificates" / "sslkeystore.jks").getOrThrow()</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$startBridge(driverDirectory, artemisPort, advertisedP2PPort, bankAPath / "certificates" / "sslkeystore.jks", bankBPath / "certificates" / "sslkeystore.jks", floatPort = floatPort).getOrThrow()</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$val artemisClient = ArtemisMessagingClient(artemisConfig.p2pSslOptions, artemisAddress, MAX_MESSAGE_SIZE, confirmationWindowSize = artemisConfig.enterpriseConfiguration.tuning.p2pConfirmationWindowSize)</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$val artemisPort = portAllocation.nextPort() val advertisedP2PPort = portAllocation.nextPort() val floatPort = portAllocation.nextPort() val bankAPath = driverDirectory / DUMMY_BANK_A_NAME.organisation / "node" val bankBPath = driverDirectory / DUMMY_BANK_B_NAME.organisation / "node" artemis = createArtemis(driverDirectory, artemisPort) artemis!!.start() val artemisCertDir = driverDirectory / "artemis" val artemisSSLConfig = mapOf( "sslKeystore" to (artemisCertDir / ARTEMIS_KEYSTORE).toString(), "keyStorePassword" to DEV_CA_KEY_STORE_PASS, "trustStoreFile" to (artemisCertDir / ARTEMIS_TRUSTSTORE).toString(), "trustStorePassword" to DEV_CA_TRUST_STORE_PASS ) // The nodes are configured with a wrong P2P address, to ensure AMQP bridge won't work. val aFuture = startNode( providedName = DUMMY_BANK_A_NAME, rpcUsers = listOf(demoUser), customOverrides = mapOf( "baseDirectory" to "$bankAPath", "p2pAddress" to "localhost:0", "messagingServerAddress" to "0.0.0.0:$artemisPort", "messagingServerExternal" to true, "enterpriseConfiguration" to mapOf( "externalBridge" to true, "messagingServerSslConfiguration" to artemisSSLConfig ) ) ) val a = aFuture.getOrThrow() val bFuture = startNode( providedName = DUMMY_BANK_B_NAME, rpcUsers = listOf(demoUser), customOverrides = mapOf( "baseDirectory" to "$bankBPath", "p2pAddress" to "localhost:0", "messagingServerAddress" to "0.0.0.0:$artemisPort", "messagingServerExternal" to true, "enterpriseConfiguration" to mapOf( "externalBridge" to true, "messagingServerSslConfiguration" to artemisSSLConfig ) ) ) val b = bFuture.getOrThrow() val testThread = thread { CordaRPCClient(a.rpcAddress).use(demoUser.username, demoUser.password) { // Loopback flow test. it.proxy.startFlow(::Ping, b.nodeInfo.singleIdentity(), 5).returnValue.getOrThrow() } CordaRPCClient(b.rpcAddress).use(demoUser.username, demoUser.password) { // Loopback flow test. it.proxy.startFlow(::Ping, a.nodeInfo.singleIdentity(), 5).returnValue.getOrThrow() } } // Starting the bridge at the end, to test the NodeToBridgeSnapshot message's AMQP bridge convert to Loopback bridge code path. startBridge(driverDirectory, artemisPort, advertisedP2PPort, bankAPath / "certificates" / "sslkeystore.jks", bankBPath / "certificates" / "sslkeystore.jks", floatPort = floatPort).getOrThrow() testThread.join()</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$val artemisServer = ArtemisMessagingServer(artemisConfig, artemisAddress.copy(host = "0.0.0.0"), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest$val p2pSslConfiguration = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, useOpenSsl = useOpenSsl)</ID>
    <ID>MaxLineLength:LoopbackBridgeTest.kt$LoopbackBridgeTest${ ArtemisMessagingClient(artemisConfig.p2pSslOptions, artemisAddress, MAX_MESSAGE_SIZE, confirmationWindowSize = artemisConfig.enterpriseConfiguration.tuning.p2pConfirmationWindowSize) }</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$attacker.start(ActiveMQDefaultConfiguration.getDefaultClusterUser(), ActiveMQDefaultConfiguration.getDefaultClusterPassword())</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, clientKeyPair.private, listOf(clientCACert, DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate), signingCertStore.entryPassword)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(clientTLSCert, clientCACert, DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate), p2pSslConfig.keyStore.entryPassword)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val clientCACert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, DEV_INTERMEDIATE_CA.certificate, DEV_INTERMEDIATE_CA.keyPair, legalName.x500Principal, clientKeyPair.public, nameConstraints = nameConstraints)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val clientTLSCert = X509Utilities.createCertificate(CertificateType.TLS, clientCACert, clientKeyPair, CordaX500Name("MiniCorp", "London", "GB").x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:MQSecurityTest.kt$MQSecurityTest$fun clientTo(target: NetworkHostAndPort, sslConfiguration: MutualSslConfiguration? = configureTestSSL(CordaX500Name("MegaCorp", "London", "GB"))): SimpleMQClient</ID>
    <ID>MaxLineLength:Main.kt$ fun main(args: Array&lt;String&gt;)</ID>
    <ID>MaxLineLength:Main.kt$Files.write(filename, signature, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)</ID>
    <ID>MaxLineLength:Main.kt$HAToolBase : CliWrapperBase</ID>
    <ID>MaxLineLength:Main.kt$HAToolBase$/** * Base directory where to lookup `drivers` sub-folder in addition to current dir. Return `null` to skip loading jars from `drivers` folder. */ abstract val driversParentDir: Path?</ID>
    <ID>MaxLineLength:Main.kt$HAToolBase$if (driversParentDir != null &amp;&amp; !HAUtilities.addJarsInDriversDirectoryToSystemClasspath(driversParentDir!!)) { HAUtilities.addJarsInDriversDirectoryToSystemClasspath(Paths.get(".")) }</ID>
    <ID>MaxLineLength:Main.kt$HAToolBase$logger.error("Crypto service driver not found: please check that the 'drivers' directory contains the client side jar for the HSM", e)</ID>
    <ID>MaxLineLength:Main.kt$HAUtilities : CordaCliWrapper</ID>
    <ID>MaxLineLength:Main.kt$HAUtilities$override fun additionalSubCommands()</ID>
    <ID>MaxLineLength:Main.kt$Main$// TODO : This could block the UI thread when number of views increase, maybe we can make this async and display a loading screen. // Stock Views. registerView&lt;Dashboard&gt;() registerView&lt;TransactionViewer&gt;() registerView&lt;StateMachineViewer&gt;() // CordApps Views. registerView&lt;CashViewer&gt;() // Tools. registerView&lt;Network&gt;() registerView&lt;Settings&gt;() // Default view to Dashboard. selectedView.set(find&lt;Dashboard&gt;())</ID>
    <ID>MaxLineLength:Main.kt$MandatoryCommandLineArguments$enum</ID>
    <ID>MaxLineLength:Main.kt$MandatoryCommandLineArguments.values().forEach { argSpec -&gt; parser.accepts(argSpec.name).withRequiredArg().withValuesConvertedBy(argSpec.valueConverter).describedAs(argSpec.description) }</ID>
    <ID>MaxLineLength:Main.kt$MandatoryCommandLineArguments.values().forEach { require(options.has(it.name)) { "$it is a mandatory option. Please provide it." } }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner : CordaCliWrapper</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--copy-cordapps"], description = ["Whether or not to copy the CorDapp JARs into the nodes' 'cordapps' directory. \${COMPLETION-CANDIDATES}"])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--event-horizon"], description = ["The event horizon to use in the network-parameters. Default is 30 days."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--max-message-size"], description = ["The maximum message size to use in the network-parameters, in bytes. Current default is $DEFAULT_MAX_MESSAGE_SIZE."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--max-transaction-size"], description = ["The maximum transaction size to use in the network-parameters, in bytes. Current default is $DEFAULT_MAX_TRANSACTION_SIZE."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--minimum-platform-version"], description = ["The minimum platform version to use in the network-parameters. Current default is $PLATFORM_VERSION."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--network-parameter-overrides", "-n"], description = ["Overrides the default network parameters with those in the given file."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--no-copy"], hidden = true, description = ["""DEPRECATED. Don't copy the CorDapp JARs into the nodes' "cordapps" directories."""])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$description</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$if (networkParametersFile?.exists() != true) throw FileNotFoundException("Unable to find specified network parameters config file at $networkParametersFile")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$overrides += minimumPlatformVersion?.let { mapOf("minimumPlatformVersion" to minimumPlatformVersion!!) } ?: mutableMapOf()</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$printError("Error${errors.pluralise()} found parsing the network parameter overrides file at $networkParametersFile:")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$printWarning("The --no-copy parameter has been deprecated and been replaced with the --copy-cordapps parameter.")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(eventHorizon == null || eventHorizon?.isNegative == false) { "The --event-horizon parameter must be a positive value" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(maxMessageSize == null || maxMessageSize ?: 0 &gt; 0) { "The --max-message-size parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(maxTransactionSize == null || maxTransactionSize ?: 0 &gt; 0) { "The --max-transaction-size parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(minimumPlatformVersion == null || minimumPlatformVersion ?: 0 &gt; 0) { "The --minimum-platform-version parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$val networkParameterOverrides = getNetworkParametersOverrides().doOnErrors(::reportErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:Main.kt$Node$if (transactions.size == 1) listOf(genesisTx) else transactions.values.reversed().take(10).filter { !isAccepted(it) &amp;&amp; conflicts[it.data]!!.size == 1 }.shuffled(network.rng).take(3)</ID>
    <ID>MaxLineLength:Main.kt$OptionalCommandLineArguments$enum</ID>
    <ID>MaxLineLength:Main.kt$OptionalCommandLineArguments.values().forEach { argSpec -&gt; parser.accepts(argSpec.name).withOptionalArg().withValuesConvertedBy(argSpec.valueConverter).describedAs(argSpec.description) }</ID>
    <ID>MaxLineLength:Main.kt$Transaction$return "T(id=${id.toString().take(5)}, data=$data, parents=[${parents.map {it.toString().take(5) }}, chit=$chit, confidence=$confidence)"</ID>
    <ID>MaxLineLength:Main.kt$fun Logger.logConfigPath(configPath: Path?)</ID>
    <ID>MaxLineLength:Main.kt$nodeFilter = isNotary</ID>
    <ID>MaxLineLength:Main.kt$proxy.startFlow(::StartCheckScheduleFlow, target, parsed.waitPeriodSeconds, parsed.waitForOutstandingFlows)</ID>
    <ID>MaxLineLength:Main.kt$require(acceptance.filter { it }.size &lt; 2) { "More than one transaction of the conflict set of $v got accepted." }</ID>
    <ID>MaxLineLength:Main.kt$val commitDuration = rpc.startFlow(::JPALoadTestFlow, TRANSACTION_COUNT, BATCH_SIZE, inputStateCount).returnValue.get()</ID>
    <ID>MaxLineLength:Main.kt$val defaultConfig = ConfigFactory.parseResources("loadtest-reference.conf", ConfigParseOptions.defaults().setAllowMissing(false))</ID>
    <ID>MaxLineLength:MainView.kt$MainView$contentDisplayProperty().bind(smallIconProperty.map { if (it) ContentDisplay.TOP else ContentDisplay.LEFT })</ID>
    <ID>MaxLineLength:MainView.kt$MainView$if (selected == it) listOf(menuItemCSS, menuItemSelectedCSS).observable() else listOf(menuItemCSS).observable()</ID>
    <ID>MaxLineLength:MainView.kt$MainView$textAlignmentProperty().bind(smallIconProperty.map { if (it) TextAlignment.CENTER else TextAlignment.LEFT })</ID>
    <ID>MaxLineLength:ManagedCryptoService.kt$ManagedCryptoService : CryptoServiceAutoCloseable</ID>
    <ID>MaxLineLength:ManagedCryptoService.kt$ManagedCryptoService$ private fun &lt;A&gt; managedCall(func: () -&gt; A) : A</ID>
    <ID>MaxLineLength:ManagedCryptoService.kt$ManagedCryptoService$override</ID>
    <ID>MaxLineLength:ManagedCryptoServiceTest.kt$ManagedCryptoServiceTest$doAnswer { sleep((timeout * 2).toMillis()); return@doAnswer testKeyPair.public }.whenever(it).generateKeyPair(any(), any())</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer$private val typeNotation: TypeNotation = RestrictedType(AMQPTypeIdentifiers.nameForType(declaredType), null, emptyList(), "map", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer.Companion$fun resolveActual(actualClass: Class&lt;*&gt;, declaredTypeInformation: LocalTypeInformation.AMap): LocalTypeInformation.AMap</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer.Companion$private</ID>
    <ID>MaxLineLength:MapValuesList.kt$MapValuesList.Companion$val backingList = FXCollections.observableArrayList&lt;Map.Entry&lt;K, A&gt;&gt;(sourceMap.entries.sortedBy { it.key!!.hashCode() })</ID>
    <ID>MaxLineLength:MappedList.kt$MappedList&lt;A, B&gt; : TransformationList</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$BadSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$GoodSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$PoliteSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$TrickySchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests.TrickySchema.State$( @Column var id: String, //the field is a cross-reference to other MappedSchema however the field is not persistent (no JPA annotation) var other: GoodSchema.State )</ID>
    <ID>MaxLineLength:MapsSerializationTest.kt$MapsSerializationTest$"Map type class java.util.HashMap is unstable under iteration. Suggested fix: use java.util.LinkedHashMap instead."</ID>
    <ID>MaxLineLength:MapsSerializationTest.kt$MapsSerializationTest$@Test fun `check EmptyMap serialization`()</ID>
    <ID>MaxLineLength:MaxTransactionSizeTests.kt$MaxTransactionSizeTests$assertThatThrownBy { future.getOrThrow() }.hasMessageContaining("Transaction exceeded network's maximum transaction size limit")</ID>
    <ID>MaxLineLength:MaxTransactionSizeTests.kt$MaxTransactionSizeTests${ // These 4 attachments yield a transaction that's got ~ 4mb, which will exceed the 3mb max transaction size limit val bigFile1 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 0, "a") val bigFile2 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 1, "b") val bigFile3 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 2, "c") val bigFile4 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 3, "c") val flow = aliceNode.transaction { val hash1 = aliceNode.importAttachment(bigFile1.inputStream) val hash2 = aliceNode.importAttachment(bigFile2.inputStream) val hash3 = aliceNode.importAttachment(bigFile3.inputStream) val hash4 = aliceNode.importAttachment(bigFile4.inputStream) assertEquals(hash1, bigFile1.sha256) SendLargeTransactionFlow(notary, bob, hash1, hash2, hash3, hash4, verify = false) } val future = aliceNode.startFlow(flow) mockNet.runNetwork() assertThatThrownBy { future.getOrThrow() }.hasMessageContaining("Transaction exceeded network's maximum transaction size limit") }</ID>
    <ID>MaxLineLength:MaxTransactionSizeTests.kt$MaxTransactionSizeTests${ // These 4 attachments yield a transaction that's got ~ 4mb, which will exceed the 3mb max transaction size limit val bigFile1 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 0, "a") val bigFile2 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 1, "b") val bigFile3 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 2, "c") val bigFile4 = InputStreamAndHash.createInMemoryTestZip(1024 * 1024, 3, "d") val flow = aliceNode.transaction { val hash1 = aliceNode.importAttachment(bigFile1.inputStream) val hash2 = aliceNode.importAttachment(bigFile2.inputStream) val hash3 = aliceNode.importAttachment(bigFile3.inputStream) val hash4 = aliceNode.importAttachment(bigFile4.inputStream) assertEquals(hash1, bigFile1.sha256) SendLargeTransactionFlow(notary, bob, hash1, hash2, hash3, hash4) } val exception = assertFailsWith&lt;IllegalArgumentException&gt; { val future = aliceNode.startFlow(flow) mockNet.runNetwork() future.getOrThrow() } assertThat(exception).hasMessageContaining("Transaction exceeded network's maximum transaction size limit") }</ID>
    <ID>MaxLineLength:Measure.kt$fun &lt;A : Any, B : Any, C : Any, D : Any, R&gt; measure(a: Iterable&lt;A&gt;, b: Iterable&lt;B&gt;, c: Iterable&lt;C&gt;, d: Iterable&lt;D&gt;, f: (A, B, C, D) -&gt; R)</ID>
    <ID>MaxLineLength:Measure.kt$measure(listOf(a, b, c, d), f.reflect()!!) { f(uncheckedCast(it[0]), uncheckedCast(it[1]), uncheckedCast(it[2]), uncheckedCast(it[3])) }</ID>
    <ID>MaxLineLength:Measure.kt$private</ID>
    <ID>MaxLineLength:MemUtils.kt$info("Memory stats @$stage - Used memory: ${nf.format(totalMemory - freeMemory)} KB, Total memory: ${nf.format(totalMemory)} KB, Max memory: ${nf.format(maxMemory)} KB")</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$ComponentVisibilityException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredComponentGroup : ComponentGroup</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkAllComponentsVisible(componentGroupEnum: ComponentGroupEnum)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkCommandVisibility(publicKey: PublicKey)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ fun checkWithFun(checkingFun: (Any) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Did not receive components for group ${componentGroupEnum.ordinal} and cannot verify they didn't exist in the original wire transaction"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Partial Merkle tree root and advertised full Merkle tree root for component group $groupIndex do not match"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$val groupFullRoot = MerkleTree.getMerkleTree(group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }).hash</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck(groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group $groupIndex" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(group.groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group ${group.groupIndex}" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(groupPartialRoot == groupFullRoot) { "Some components for group ${group.groupIndex} are not visible" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentGroups.add(FilteredComponentGroup(groupIndex, value, filteredComponentNonces[groupIndex]!!, createPartialMerkleTree(groupIndex)))</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[signersGroupIndex] = wtx.availableComponentHashes[signersGroupIndex]!!.toMutableList()</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[signersGroupIndex] = wtx.availableComponentNonces[signersGroupIndex]!!.toMutableList()</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val filteredComponentHashes: MutableMap&lt;Int, MutableList&lt;SecureHash&gt;&gt; = hashMapOf() // Required for partial Merkle tree generation.</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val serialisedComponent = wtx.componentGroups.first { it.groupIndex == componentGroupIndex }.components[internalIndex]</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ group.add(serialisedComponent) // If the group[componentGroupIndex] existed, then we guarantee that // filteredComponentNonces[componentGroupIndex] and filteredComponentHashes[componentGroupIndex] are not null. filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ if (!filtering.test(t)) return val group = filteredSerialisedComponents[componentGroupIndex] // Because the filter passed, we know there is a match. We also use first Vs single as the init function // of WireTransaction ensures there are no duplicated groups. val serialisedComponent = wtx.componentGroups.first { it.groupIndex == componentGroupIndex }.components[internalIndex] if (group == null) { // As all of the helper Map structures, like availableComponentNonces, availableComponentHashes // and groupsMerkleRoots, are computed lazily via componentGroups.forEach, there should always be // a match on Map.get ensuring it will never return null. filteredSerialisedComponents[componentGroupIndex] = mutableListOf(serialisedComponent) filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) } else { group.add(serialisedComponent) // If the group[componentGroupIndex] existed, then we guarantee that // filteredComponentNonces[componentGroupIndex] and filteredComponentHashes[componentGroupIndex] are not null. filteredComponentNonces[componentGroupIndex]!!.add(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex]) filteredComponentHashes[componentGroupIndex]!!.add(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex]) } // If at least one command is visible, then all command-signers should be visible as well. // This is required for visibility purposes, see FilteredTransaction.checkAllCommandsVisible() for more details. if (componentGroupIndex == COMMANDS_GROUP.ordinal &amp;&amp; !signersIncluded) { signersIncluded = true val signersGroupIndex = SIGNERS_GROUP.ordinal // There exist commands, thus the signers group is not empty. val signersGroupComponents = wtx.componentGroups.first { it.groupIndex == signersGroupIndex } filteredSerialisedComponents[signersGroupIndex] = signersGroupComponents.components.toMutableList() filteredComponentNonces[signersGroupIndex] = wtx.availableComponentNonces[signersGroupIndex]!!.toMutableList() filteredComponentHashes[signersGroupIndex] = wtx.availableComponentHashes[signersGroupIndex]!!.toMutableList() } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ wtx.inputs.forEachIndexed { internalIndex, it -&gt; filter(it, INPUTS_GROUP.ordinal, internalIndex) } wtx.outputs.forEachIndexed { internalIndex, it -&gt; filter(it, OUTPUTS_GROUP.ordinal, internalIndex) } wtx.commands.forEachIndexed { internalIndex, it -&gt; filter(it, COMMANDS_GROUP.ordinal, internalIndex) } wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) } if (wtx.notary != null) filter(wtx.notary, NOTARY_GROUP.ordinal, 0) if (wtx.timeWindow != null) filter(wtx.timeWindow, TIMEWINDOW_GROUP.ordinal, 0) // Note that because [inputs] and [references] share the same type [StateRef], we use a wrapper for references [ReferenceStateRef], // when filtering. Thus, to filter-in all [references] based on type, one should use the wrapper type [ReferenceStateRef] and not [StateRef]. // Similar situation is for network parameters hash and attachments, one should use wrapper [NetworkParametersHash] and not [SecureHash]. wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) } wtx.networkParametersHash?.let { filter(NetworkParametersHash(it), PARAMETERS_GROUP.ordinal, 0) } // It is highlighted that because there is no a signers property in TraversableTransaction, // one cannot specifically filter them in or out. // The above is very important to ensure someone won't filter out the signers component group if at least one // command is included in a FilteredTransaction. // It's sometimes possible that when we receive a WireTransaction for which there is a new or more unknown component groups, // we decide to filter and attach this field to a FilteredTransaction. // An example would be to redact certain contract state types, but otherwise leave a transaction alone, // including the unknown new components. wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransactionVerificationException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override val outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = deserialiseComponentGroup(componentGroups, TransactionState::class, OUTPUTS_GROUP)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$val timeWindows: List&lt;TimeWindow&gt; = deserialiseComponentGroup(componentGroups, TimeWindow::class, TIMEWINDOW_GROUP)</ID>
    <ID>MaxLineLength:MerkleTree.kt$MerkleTree$Node : MerkleTree</ID>
    <ID>MaxLineLength:MessageChainState.kt$MessageChainState$@BelongsToContract(MessageChainContract::class) data</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$AmqpMessageSizeChecksInterceptor : MessageSizeChecksInterceptorAmqpInterceptor</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor : MessageSizeChecksInterceptorInterceptor</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor$is MessagePacket -&gt; (packet.message.persistentSize - packet.message.headersAndPropertiesEncodeSize - 4).toInt()</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$MessageSizeChecksInterceptor$logger</ID>
    <ID>MaxLineLength:MessageState.kt$MessageState$@BelongsToContract(MessageContract::class) data</ID>
    <ID>MaxLineLength:Messaging.kt$DeduplicationHandler</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$ fun addMessageHandler(topic: String, callback: MessageHandler): MessageHandlerRegistration</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$ fun createMessage(topic: String, data: ByteArray, deduplicationId: SenderDeduplicationId = SenderDeduplicationId(DeduplicationId.createRandom(newSecureRandom()), ourSenderUUID), additionalHeaders: Map&lt;String, String&gt; = emptyMap()): Message</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$/** * A unique identifier for this sender that changes whenever a node restarts. This is used in conjunction with a sequence * number for message de-duplication at the recipient. */ val ourSenderUUID: String</ID>
    <ID>MaxLineLength:Messaging.kt$ReceivedMessage : Message</ID>
    <ID>MaxLineLength:Messaging.kt$fun MessagingService.send(topicSession: String, payload: Any, to: MessageRecipients, deduplicationId: SenderDeduplicationId = SenderDeduplicationId(DeduplicationId.createRandom(newSecureRandom()), ourSenderUUID), additionalHeaders: Map&lt;String, String&gt; = emptyMap())</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$"sessionID: ${job.message.topic} id: ${job.message.uniqueMessageId} size: ${artemisMessage?.bodySize}"</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$putStringProperty(P2PMessagingHeaders.cordaVendorProperty, cordaVendor) putStringProperty(P2PMessagingHeaders.releaseVersionProperty, releaseVersion) putIntProperty(P2PMessagingHeaders.platformVersionProperty, versionInfo.platformVersion) putStringProperty(P2PMessagingHeaders.topicProperty, SimpleString(message.topic)) putStringProperty(P2PMessagingHeaders.bridgedCertificateSubject, SimpleString(myLegalName)) // Add a group ID to messages to be able to have multiple filtered consumers while preventing reordering. // This header will be dropped off during transit through the bridge, which is fine as it's needed locally only. if (enableSNI) { if (target is ArtemisMessagingComponent.ServiceAddress) { putStringProperty(HDR_GROUP_ID, SimpleString(message.uniqueMessageId.toString)) } else { putStringProperty(HDR_GROUP_ID, SimpleString(myLegalName)) } } sendMessageSizeMetric.update(message.data.bytes.size) writeBodyBufferBytes(message.data.bytes) // Use the magic deduplication property built into Artemis as our message identity too putStringProperty(HDR_DUPLICATE_DETECTION_ID, SimpleString(message.uniqueMessageId.toString)) // If we are the sender (ie. we are not going through recovery of some sort), use sequence number short cut. if (ourSenderUUID == message.senderUUID) { putStringProperty(P2PMessagingHeaders.senderUUID, SimpleString(ourSenderUUID)) putLongProperty(P2PMessagingHeaders.senderSeqNo, ourSenderSeqNo.getAndIncrement()) } // For demo purposes - if set then add a delay to messages in order to demonstrate that the flows are doing as intended if (amqDelayMillis &gt; 0 &amp;&amp; message.topic == FlowMessagingImpl.sessionTopic) { putLongProperty(HDR_SCHEDULED_DELIVERY_TIME, System.currentTimeMillis() + amqDelayMillis) } message.additionalHeaders.forEach { key, value -&gt; putStringProperty(key, value) }</ID>
    <ID>MaxLineLength:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration</ID>
    <ID>MaxLineLength:MessagingServerConnectionConfiguration.kt$MessagingServerConnectionConfiguration.FAIL_FAST$// Client die too fast during failover/failback, need a few reconnect attempts to allow new master to become active override fun reconnectAttempts(isHa: Boolean)</ID>
    <ID>MaxLineLength:MetricInterceptor.kt$MetricInterceptor$@Suspendable override</ID>
    <ID>MaxLineLength:MigrationExporter.kt$MigrationExporter</ID>
    <ID>MaxLineLength:MigrationExporter.kt$MigrationExporter$config.standardServiceRegistryBuilder .addService(org.hibernate.boot.registry.classloading.spi.ClassLoaderService::class.java, ClassLoaderServiceImpl(cordappClassLoader))</ID>
    <ID>MaxLineLength:MigrationExporter.kt$MigrationExporter$return buildHibernateMetadata(metadataBuilder, datasourceProperties.getProperty(CordaPersistence.DataSourceConfigTag.DATA_SOURCE_URL), listOf(DummyAbstractPartyToX500NameAsStringConverter()))</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory : BindableNamedCacheFactorySingletonSerializeAsToken</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$override</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration)</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry)</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$private val nodeConfiguration: NodeConfiguration?</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$deserialiseComponentGroup(tx.componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$else -&gt; throw MigrationException("Unknown transaction type ${baseTx::class.qualifiedName} found when loading a state")</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$is ContractUpgradeLedgerTransaction -&gt; it.value.map { stateRef -&gt; StateAndRef(baseTx.outputs[stateRef.index], stateRef) }</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$is NotaryChangeLedgerTransaction -&gt; it.value.map { stateRef -&gt; StateAndRef(baseTx.outputs[stateRef.index], stateRef) }</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$logger.info("Couldn't find network parameters file: ${e.message}. This is expected if the node is starting for the first time.")</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$override</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$private</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution${ // If there is no attachment that allows the state class to be deserialised correctly, then carpent a state class anyway. It // might still be possible to access the participants depending on how the state class was serialised. logger.debug("Could not use attachments to deserialise transaction output states for transaction ${tx.id}") tx.outputs.filterIndexed { index, _ -&gt; stateIndices.contains(index)} }</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution.&lt;no name provided&gt;${ // Note that the parameters in any file shouldn't be put into the database - this will be done by the node on startup. return if (hash == filedParams?.raw?.hash) { filedParams.raw.deserialize() } else { cordaDB.transaction { storage[hash]?.verified() } } }</ID>
    <ID>MaxLineLength:MissingAttachmentsException.kt$MissingAttachmentsException : CordaException</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$"${contractsClassName ?: states.map { it.contract }.distinct()}${minimumRequiredContractClassVersion?.let { ", minimum required contract class version $minimumRequiredContractClassVersion"}}. "</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$@JvmOverloads constructor(val states: List&lt;TransactionState&lt;ContractState&gt;&gt;, contractsClassName: String? = null, minimumRequiredContractClassVersion: Version? = null)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$// This function only covers those possibilities currently used within tests. Each ColumnPredicate type can have multiple operators, // and not all predicate types are covered here. private fun &lt;C&gt; criteriaFilter(metadata: C, predicate: ColumnPredicate&lt;C&gt;?): Boolean</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$@JvmOverloads fun importContractAttachment(contractClassNames: List&lt;ContractClassName&gt;, uploader: String, jar: InputStream, attachmentId: AttachmentId? = null, signers: List&lt;PublicKey&gt; = emptyList()): AttachmentId</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$ContractAttachment.create(baseAttachment, contractClassNames.first(), contractClassNames.toSet(), uploader, signers, version)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$ContractAttachmentMetadata</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$MockAttachment : AbstractAttachment</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$fun getAttachmentIdAndBytes(jar: InputStream): Pair&lt;AttachmentId, ByteArray&gt;</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$private</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val attachmentQueryCriteria = AttachmentQueryCriteria.AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf(contractClassName)), versionCondition = Builder.greaterThanOrEqual(minContractVersion), uploaderCondition = Builder.`in`(TRUSTED_UPLOADERS))</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val attachmentSort = AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val contractClassMetadata = ContractAttachmentMetadata(contractClassName, version, signers.isNotEmpty(), signers, uploader)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val version = try { Integer.parseInt(baseAttachment.openAsJAR().manifest?.mainAttributes?.getValue(Attributes.Name.IMPLEMENTATION_VERSION)) } catch (e: Exception) { DEFAULT_CORDAPP_VERSION }</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$versionCondition = Builder.greaterThanOrEqual(minContractVersion)</ID>
    <ID>MaxLineLength:MockContractAttachment.kt$// A valid zip file with 1 entry. val simpleZip = byteArrayOf(80, 75, 3, 4, 20, 0, 8, 8, 8, 0, 15, 113, 79, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 47, 97, -2, -54, 0, 0, 75, 4, 0, 80, 75, 7, 8, 67, -66, -73, -24, 3, 0, 0, 0, 1, 0, 0, 0, 80, 75, 1, 2, 20, 0, 20, 0, 8, 8, 8, 0, 15, 113, 79, 78, 67, -66, -73, -24, 3, 0, 0, 0, 1, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 97, -2, -54, 0, 0, 80, 75, 5, 6, 0, 0, 0, 0, 1, 0, 1, 0, 52, 0, 0, 0, 55, 0, 0, 0, 0, 0)</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$attachments.importContractAttachment(contractClassNames, DEPLOYED_CORDAPP_UPLOADER, data.inputStream(), contractHash, signers)</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$fakeAttachment(contractClass.replace('.', '/') + ".class", "fake class file for $contractClass", manifestAttributes)</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$if (cordappRegistry.none { it.first.contractClassNames.contains(contractClassName) &amp;&amp; it.second == contractHash }) { cordappRegistry.add(Pair( cordapp, findOrImportAttachment( listOf(contractClassName), fakeAttachmentCached(contractClassName, jarManifestAttributesWithObligatoryElement), attachments, contractHash, signers ) )) }</ID>
    <ID>MaxLineLength:MockCordappProvider.kt$MockCordappProvider$private</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$override</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$return ContentSignerBuilder.build(signatureScheme, privateKey, Crypto.findProvider(signatureScheme.providerName), newSecureRandom())</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$throw CryptoServiceException("Cannot sign using the key with alias $alias. SHA256 of data to be signed: ${data.sha256()}", e)</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$val privateKey = cipher.unwrap(wrappedPrivateKey.keyMaterial, keyAlgorithmFromScheme(wrappedPrivateKey.signatureScheme), Cipher.PRIVATE_KEY) as PrivateKey</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$val signature = Instances.getSignatureInstance(wrappedPrivateKey.signatureScheme.signatureName, cordaBouncyCastleProvider)</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$val wrappingKey = wrappingKeys[masterKeyAlias] ?: throw IllegalStateException("There is no master key under the alias: $masterKeyAlias")</ID>
    <ID>MaxLineLength:MockKeyManagementService.kt$MockKeyManagementService$override fun filterMyKeys(candidateKeys: Iterable&lt;PublicKey&gt;): Iterable&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:MockKeyManagementService.kt$MockKeyManagementService$private val keyStore: MutableMap&lt;PublicKey, PrivateKey&gt; = initialKeys.associateByTo(HashMap(), { it.public }, { it.private })</ID>
    <ID>MaxLineLength:MockKeyManagementService.kt$MockKeyManagementService$private val pkToIdCache: WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$ fun createPartyNode(legalName: CordaX500Name? = null): StartedMockNode</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$/** In a mock network, nodes have an incrementing integer ID. Real networks do not have this. Returns the next ID that will be used. */ val nextNodeId get(): Int = internalMockNetwork.nextNodeId</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$@Deprecated("cordappPackages does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use MockNetworkParameters.cordappsForAllNodes instead.")</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$val servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = defaultParameters.servicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$(networkSendManuallyPumped: Boolean, threadPerNode: Boolean, servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy, notarySpecs: List&lt;MockNetworkNotarySpec&gt;, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$constructor(cordappsForAllNodes: Collection&lt;TestCordapp&gt;) : this(threadPerNode = false, cordappsForAllNodes = cordappsForAllNodes)</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withCordappsForAllNodes(cordappsForAllNodes: Collection&lt;TestCordapp&gt;): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNetworkParameters(networkParameters: NetworkParameters): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNetworkSendManuallyPumped(networkSendManuallyPumped: Boolean): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNotarySpecs(notarySpecs: List&lt;MockNetworkNotarySpec&gt;): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withServicePeerAllocationStrategy(servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$return MockNetworkParameters(networkSendManuallyPumped, threadPerNode, servicePeerAllocationStrategy, notarySpecs, networkParameters, emptyList())</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$val servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun copy(forcedID: Int?, legalName: CordaX500Name?, entropyRoot: BigInteger, configOverrides: MockNodeConfigOverrides): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun withAdditionalCordapps(additionalCordapps: Collection&lt;TestCordapp&gt;): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun withConfigOverrides(configOverrides: MockNodeConfigOverrides): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; findStateMachines(flowClass: Class&lt;F&gt;): List&lt;Pair&lt;F, CordaFuture&lt;*&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatedFlowClass: Class&lt;F&gt;): Observable&lt;F&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatingFlowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: Class&lt;F&gt;): Observable&lt;F&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;T&gt; startFlow(logic: FlowLogic&lt;T&gt;): CordaFuture&lt;T&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$UnstartedMockNode$ fun &lt;T : SerializeAsToken&gt; installCordaService(serviceClass: Class&lt;T&gt;): T</ID>
    <ID>MaxLineLength:MockNetworkIntegrationTests.kt$MockNetworkIntegrationTests$assertEquals(0, startJavaProcess&lt;MockNetworkIntegrationTests&gt;(emptyList(), extraJvmArguments = listOf("-javaagent:$quasar")).waitFor())</ID>
    <ID>MaxLineLength:MockNetworkParametersService.kt$MockNetworkParametersStorage : NetworkParametersStorage</ID>
    <ID>MaxLineLength:MockNetworkParametersService.kt$MockNetworkParametersStorage$override</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$ fun start(network: InMemoryMessagingNetwork, manuallyPumped: Boolean, id: Int, notaryService: PartyAndCertificate?)</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$ private fun unPopMessages(transfers: Collection&lt;InMemoryMessagingNetwork.MessageTransfer&gt;)</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$OpaqueBytes(message.data.bytes.copyOf())</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$handler.callback(receivedMessage, handler, InMemoryDeduplicationHandler(receivedMessage, transfer))</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$override</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$private</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$return InMemoryMessage(topic, OpaqueBytes(data), deduplicationId.deduplicationId, senderUUID = deduplicationId.senderUUID)</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$val matchingHandlers = handlers.filter { it.topicSession.isBlank() || transfer.message.topic == it.topicSession }</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService${ // Got no handlers for this message yet. Keep the message around and attempt redelivery after a new // handler has been registered. The purpose of this path is to make unit tests that have multi-threading // reliable, as a sender may attempt to send a message to a receiver that hasn't finished setting // up a handler for yet. Most unit tests don't run threaded, but we want to test true parallelism at // least sometimes. log.warn("Message to ${transfer.message.topic} could not be delivered") pendingRedelivery.add(transfer) null }</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService.InMemoryDeduplicationHandler$private inner</ID>
    <ID>MaxLineLength:MockPublicKeyToOwningIdentityCache.kt$MockPublicKeyToOwningIdentityCache : WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:MockPublicKeyToOwningIdentityCache.kt$MockPublicKeyToOwningIdentityCache$private val cache: MutableMap&lt;PublicKey, KeyOwningIdentity&gt; = mutableMapOf&lt;PublicKey, KeyOwningIdentity&gt;().toSynchronised()</ID>
    <ID>MaxLineLength:MockServices.kt$ fun &lt;T : SerializeAsToken&gt; createMockCordaService(serviceHub: MockServices, serviceConstructor: (AppServiceHub) -&gt; T): T</ID>
    <ID>MaxLineLength:MockServices.kt$MockAppServiceHubImpl&lt;out T : SerializeAsToken&gt; : AppServiceHubServiceHub</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$ fun addMockCordapp(contractClassName: ContractClassName)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$ override fun loadContractAttachment(stateRef: StateRef)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that can't load CorDapp code, and which uses a default service identity. */ constructor(cordappPackages: Iterable&lt;String&gt;) : this(cordappPackages, CordaX500Name("TestIdentity", "", "GB"), makeTestIdentityService())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that can't load CorDapp code, which uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. */ @JvmOverloads constructor(cordappPackages: Iterable&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService()) : this(cordappPackages, TestIdentity(initialIdentityName), identityService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that looks for app code in the given package names, uses the provided identity service * (you can get one from [makeTestIdentityService]) and represents the given identity. */ @JvmOverloads constructor(cordappPackages: Iterable&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService(), key: KeyPair, vararg moreKeys: KeyPair) : this(cordappPackages, TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses a default service * identity. */ constructor() : this(listOf(getCallerPackage(MockServices::class)!!), CordaX500Name("TestIdentity", "", "GB"), makeTestIdentityService())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. */ @JvmOverloads constructor(initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService(), key: KeyPair, vararg moreKeys: KeyPair) : this(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. It has no keys. */ @JvmOverloads constructor(initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService()) : this(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName), identityService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(cordappPackages: List&lt;String&gt;, firstIdentity: TestIdentity, networkParameters: NetworkParameters, vararg moreIdentities: TestIdentity) : this( cordappPackages, firstIdentity, makeTestIdentityService(*listOf(firstIdentity, *moreIdentities).map { it.identity }.toTypedArray()), networkParameters, firstIdentity.keyPair )</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(cordappPackages: List&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService, networkParameters: NetworkParameters) : this(cordappPackages, TestIdentity(initialIdentityName), identityService, networkParameters)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(cordappPackages: List&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService, networkParameters: NetworkParameters, key: KeyPair) : this(cordappPackages, TestIdentity(initialIdentityName, key), identityService, networkParameters)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(firstIdentity: TestIdentity, networkParameters: NetworkParameters, vararg moreIdentities: TestIdentity) : this( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, networkParameters, *moreIdentities )</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$get() = ServicesForResolutionImpl(identityService, attachments, cordappProvider, networkParametersService, validatedTransactions)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$initialIdentity: TestIdentity</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$internal</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(initialNetworkParameters)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$private</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$private constructor(cordappLoader: CordappLoader, identityService: IdentityService, networkParameters: NetworkParameters, initialIdentity: TestIdentity, moreKeys: Array&lt;out KeyPair&gt;, keyManagementService: KeyManagementService) : this(cordappLoader, MockTransactionStorage(), identityService, networkParameters, initialIdentity, moreKeys, keyManagementService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$return NodeInfo(listOf(NetworkHostAndPort("mock.node.services", 10000)), listOf(initialIdentity.identity), 1, serial = 1L)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$return NodeVaultService(clock, keyManagementService, servicesForResolution, database, schemaService, EnterpriseMockNamedCachedFactory(), cordappLoader.appClassLoader).apply { start() }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, networkParameters, initialIdentity, moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, networkParameters, initialIdentity, moreKeys, keyManagementService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, testNetworkParameters(modifiedTime = Instant.MIN), initialIdentity, moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndMockServices(cordappPackages: List&lt;String&gt;, identityService: IdentityService, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), vararg moreKeys: KeyPair): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndPersistentServices( cordappPackages: List&lt;String&gt;, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), moreKeys: Set&lt;KeyPair&gt;, moreIdentities: Set&lt;PartyAndCertificate&gt; ): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$ @JvmStatic fun makeTestDataSourceProperties(nodeName: String = SecureHash.randomSHA256().toString()): Properties</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys, keyManagementService, schemaService, persistence)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys.toSet(), keyManagementService, schemaService, database)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$private</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$return JarScanningCordappLoader.fromJarUrls(cordappsForPackages(packages).map { it.jarFile.toUri().toURL() }, versionInfo)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$return object : MockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys.toTypedArray(), keyManagementService) { override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(networkParameters) override val vaultService: VaultService = makeVaultService(schemaService, persistence, cordappLoader) override fun recordTransactions(statesToRecord: StatesToRecord, txs: Iterable&lt;SignedTransaction&gt;) { ServiceHubInternal.recordTransactions( statesToRecord, txs as? Collection ?: txs.toList(), validatedTransactions as WritableTransactionStorage, mockStateMachineRecordedTransactionMappingStorage, vaultService as VaultServiceInternal, persistence ) } override fun jdbcSession(): Connection = persistence.createSession() override fun &lt;T : Any?&gt; withEntityManager(block: EntityManager.() -&gt; T): T { return block(contextTransaction.restrictedEntityManager) } override fun withEntityManager(block: Consumer&lt;EntityManager&gt;) { return block.accept(contextTransaction.restrictedEntityManager) } }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$val dataSourceProps = makeInternalTestDataSourceProperties(initialIdentity.name.organisation, SecureHash.randomSHA256().toString())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$val database = configureDatabase(dataSourceProps, makeTestDatabaseProperties(initialIdentity.name.organisation), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$val persistence = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion${ val cordappLoader = cordappLoaderForPackages(cordappPackages) val dataSourceProps = makeTestDataSourceProperties() val schemaService = NodeSchemaService(cordappLoader.cordappSchemas) val identityService = PersistentIdentityService(TestingNamedCacheFactory()) val persistence = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService) // Create a persistent identity service and add all the supplied identities. identityService.apply { ourNames = setOf(initialIdentity.name) database = persistence start(DEV_ROOT_CA.certificate) persistence.transaction { identityService.loadIdentities(moreIdentities + initialIdentity.identity) } } // Create a persistent key management service and add the key pair which was created for the TestIdentity. // We only add the keypair for the initial identity and any other keys which this node may control. Note: We don't add the keys // for the other identities. val pkToIdCache = PublicKeyToOwningIdentityCacheImpl(persistence, TestingNamedCacheFactory()) val aliasKeyMap = mutableMapOf&lt;String, KeyPair&gt;() val aliasedMoreKeys = moreKeys.mapIndexed { index, keyPair -&gt; val alias = "Extra key $index" aliasKeyMap[alias] = keyPair KeyPair(keyPair.public, AliasPrivateKey(alias)) }.toSet() val identityAlias = "${initialIdentity.name} private key" aliasKeyMap[identityAlias] = initialIdentity.keyPair val aliasedIdentityKey = KeyPair(initialIdentity.publicKey, AliasPrivateKey(identityAlias)) val keyManagementService = BasicHSMKeyManagementService( TestingNamedCacheFactory(), identityService, persistence, MockCryptoService(aliasKeyMap), pkToIdCache ) persistence.transaction { keyManagementService.start(aliasedMoreKeys + aliasedIdentityKey) } val mockService = persistence.transaction { makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys, keyManagementService, schemaService, persistence) } return Pair(persistence, mockService) }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion.&lt;no name provided&gt;$override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(networkParameters)</ID>
    <ID>MaxLineLength:MockTransactionStorage.kt$MockTransactionStorage$override fun getTransaction(id: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:MockTransactionStorage.kt$MockTransactionStorage$override fun getTransactionInternal(id: SecureHash): Pair&lt;SignedTransaction, Boolean&gt;?</ID>
    <ID>MaxLineLength:ModeSelectingChannel.kt$ModeSelectingChannel${ // Matched the healthCheckPhrase currentMode = TriState.ECHO_MODE log.info("Echo mode activated for connection ${ctx.channel().id()}") // Cancel scheduled action to avoid SSL handshake timeout, which starts "ticking" upon connection is established, // namely upon call to `io.netty.handler.ssl.SslHandler#handlerAdded` is made ctx.pipeline().get(SslHandler::class.java)?.handshakeFuture()?.cancel(false) ctx.echoBack(inByteBuf) }</ID>
    <ID>MaxLineLength:Models.kt$Models</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$ #See https://docs.corda.net/troubleshooting.html - 'Fiber classes not instrumented' for more details.</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$ override fun stop(allowedUnsuspendedFiberCount: Int)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$"""Missing the '-javaagent' JVM argument. Make sure you run the tests with the Quasar java agent attached to your JVM. #See https://docs.corda.net/troubleshooting.html - 'Fiber classes not instrumented' for more details."""</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$changesPublisher.onNext(StateMachineManager.Change.Removed(lastState.flowLogic, Try.Failure&lt;Nothing&gt;(exception)))</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$changesPublisher.onNext(StateMachineManager.Change.Removed(lastState.flowLogic, Try.Success(removalReason.flowReturnValue)))</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$check(!foundUnrestorableFibers) { "Unrestorable checkpoints were created, please check the logs for details." }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$detailedLogger.trace { "Flow(action=$action;flowId=${id.uuid};flowState=${checkpoint.flowState};session=${checkpoint.sessions};subFlowStack=${checkpoint.subFlowStack};errorState=${checkpoint.errorState};numberOfSuspends=${checkpoint.numberOfSuspends})" }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$is ExistingSessionMessage -&gt; onExistingSessionMessage(sessionMessage, event.deduplicationHandler, sender)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$is InitiatedFlowFactory.CorDapp -&gt; FlowInfo(initiatedFlowFactory.flowVersion, initiatedFlowFactory.appName)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$lifeCycle</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$logger.debug { "Ignoring request to set time-out on timed flow $flowId to $timeoutSeconds seconds which is shorter than default of ${serviceHub.configuration.flowTimeout.timeout.seconds} seconds." }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$logger.debug { "Unhandled message ${event.sessionMessage} by ${flow.fiber} due to flow shutting down" }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$logger.error("Unable to deserialize checkpoint for flow $flowId. Something is very wrong and this flow will be ignored.", e)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$logger.error("Unable to find database checkpoint for flow $flowId. Something is very wrong. The flow will not retry.")</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$logger.warn("Unhandled message ${event.sessionMessage} by ${flow.fiber} due to flow shutting down")</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private inline</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private val fiberDeserializationChecker = if (serviceHub.configuration.shouldCheckCheckpoints()) FiberDeserializationChecker() else null</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$return lifeCycle.requireState(State.STARTED, StateMachineStoppedException("Flow cannot be started. State machine is stopped.")) { startFlowInternal( invocationContext = context, flowLogic = flowLogic, flowStart = FlowStart.Explicit, ourIdentity = ourIdentity ?: ourFirstIdentity, deduplicationHandler = deduplicationHandler, isStartIdempotent = false ) }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$return serviceHub.getFlowFactory(initiatorFlowClass) ?: throw SessionRejectException.NotRegistered(initiatorFlowClass)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$startInitiatedFlow(flowLogic, event.deduplicationHandler, senderSession, initiatedSessionId, sessionMessage, senderCoreFlowVersion, initiatedFlowInfo)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val externalEvents = currentState.pendingDeduplicationHandlers.map { it.externalCause } + unprocessedExternalEvents</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val flowCorDappVersion = FlowStateMachineImpl.createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val flowStart = FlowStart.Initiated(peerSession, initiatedSessionId, initiatingMessage, senderCoreFlowVersion, initiatedFlowInfo)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val frozenFlowLogic = (flowLogic as FlowLogic&lt;*&gt;).checkpointSerialize(context = checkpointSerializationContext!!)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val future = startFlow(event.flowLogic, event.context, ourIdentity = null, deduplicationHandler = event.deduplicationHandler)</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val initialCheckpoint = Checkpoint.create(invocationContext, flowStart, flowLogic.javaClass, frozenFlowLogic, ourIdentity, flowCorDappVersion, flowLogic.isEnabledTimedFlow()) .getOrThrow()</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$val timeoutDelaySeconds = timeout.seconds * Math.pow(backoffBase, min(retryCount, maxRestartCount).toDouble()).toLong()</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager${ // If the node is running as a notary service, we don't retain errored session initiation requests in case of missing Cordapps // to avoid memory leaks if the notary is under heavy load. val isNotary = serviceHub.configuration.notary != null return StaffedFlowHospital(flowMessaging, ourSenderUUID, !isNotary) }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager${ // It may be that the id refers to a checkpoint that couldn't be deserialised into a flow, so we delete it if it exists. database.transaction { checkpointStorage.removeCheckpoint(id) } }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager${ // We intentionally grab the checkpoint from storage rather than relying on the one referenced by currentState. This is so that // we mirror exactly what happens when restarting the node. val serializedCheckpoint = checkpointStorage.getCheckpoint(flowId) if (serializedCheckpoint == null) { logger.error("Unable to find database checkpoint for flow $flowId. Something is very wrong. The flow will not retry.") return } // Resurrect flow createFlowFromCheckpoint( id = flowId, serializedCheckpoint = serializedCheckpoint, initialDeduplicationHandler = null, isAnyCheckpointPersisted = true, isStartIdempotent = false ) ?: return }</ID>
    <ID>MaxLineLength:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager${ val flowId = StateMachineRunId.createRandom() detailedLogger.trace { "Flow(action=start;logic=$flowLogic;flowId=${flowId.uuid})" } // Before we construct the state machine state by freezing the FlowLogic we need to make sure that lazy properties // have access to the fiber (and thereby the service hub) val flowStateMachineImpl = FlowStateMachineImpl(flowId, flowLogic, scheduler) val resultFuture = openFuture&lt;Any?&gt;() flowStateMachineImpl.transientValues = TransientReference(createTransientValues(flowId, resultFuture)) flowLogic.stateMachine = flowStateMachineImpl val frozenFlowLogic = (flowLogic as FlowLogic&lt;*&gt;).checkpointSerialize(context = checkpointSerializationContext!!) val flowCorDappVersion = FlowStateMachineImpl.createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion) val initialCheckpoint = Checkpoint.create(invocationContext, flowStart, flowLogic.javaClass, frozenFlowLogic, ourIdentity, flowCorDappVersion, flowLogic.isEnabledTimedFlow()) .getOrThrow() val startedFuture = openFuture&lt;Unit&gt;() val initialState = StateMachineState( checkpoint = initialCheckpoint, pendingDeduplicationHandlers = deduplicationHandler?.let { listOf(it) } ?: emptyList(), isFlowResumed = false, isTransactionTracked = false, isAnyCheckpointPersisted = false, isStartIdempotent = isStartIdempotent, isRemoved = false, flowLogic = flowLogic, senderUUID = ourSenderUUID ) flowStateMachineImpl.transientState = TransientReference(initialState) concurrentBox.concurrent { startedFutures[flowId] = startedFuture } totalStartedFlows.inc() addAndStartFlow(flowId, Flow(flowStateMachineImpl, resultFuture)) return startedFuture.map { flowStateMachineImpl as FlowStateMachine&lt;A&gt; } }</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyCustomValidatingNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyCustomValidatingNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyCustomValidatingNotaryService$override val uniquenessProvider = JPAUniquenessProvider(services.monitoringService.metrics, services.clock, services.database)</ID>
    <ID>MaxLineLength:MyCustomNotaryService.kt$MyValidatingNotaryFlow : ValidatingNotaryFlow</ID>
    <ID>MaxLineLength:MySQLLoadTestFlow.kt$MySQLLoadTestFlow$return MySQLUniquenessProvider(serviceHubInternal.monitoringService.metrics, serviceHubInternal.clock, notaryConfig.mysql!!)</ID>
    <ID>MaxLineLength:MySQLLoadTestFlow.kt$MySQLLoadTestFlow$val cordappConfig = CordappConfigFileProvider(serviceHubInternal.configuration.cordappDirectories).getConfigByName(serviceHubInternal.getAppContext().cordapp.name)</ID>
    <ID>MaxLineLength:MySQLNotaryService.kt$MySQLNotaryService$?:</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$assertEquals(error.consumedStates[inputState1.ref]!!.type, StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$assertEquals(error.consumedStates[inputState2.ref]!!.type, StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()), threadPerNode = true)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$mysql = MySQLNotaryConfig(dataStoreProperties, maxBatchSize = 10, maxBatchInputStates = 100)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$notaryParty = DevIdentityGenerator.generateDistributedNotarySingularIdentity(listOf(mockNet.baseDirectory(mockNet.nextNodeId)), notaryName)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val dataStoreProperties = makeInternalTestDataSourceProperties(configSupplier = { ConfigFactory.empty() }).apply { setProperty("autoCommit", "false") }</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val firstSpendReferenceInvalidButIdempotent = node.services.startFlow(NotaryFlow.Client(firstSpendTx)).resultFuture</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val networkParameters = NetworkParametersCopier(testNetworkParameters(notaries = listOf(NotaryInfo(notaryParty, true)), minimumPlatformVersion = 4))</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val outputState = TransactionState(DummyContract.SingleOwnerState(Random().nextInt(), node.services.myInfo.singleIdentity()), DummyContract.PROGRAM_ID, notaryParty)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val results = notaryNode.services.startFlow(RequestGenerationFlow(notaryService, transactionCount)).resultFuture.get()</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val results = notaryNode.services.startFlow(RequestGenerationFlow(notaryService, transactionCount, 50)).resultFuture.get()</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests$val txBuilder = DummyContract.generateInitial(Random().nextInt(), notaryParty, node.info.singleIdentity().ref(0)) .setTimeWindow(node.services.clock.instant(), 30.seconds)</ID>
    <ID>MaxLineLength:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests.RequestGenerationFlow$private val stateRefGenerator = txIdGenerator.combine(Generator.intRange(0, 10)) { id, pos -&gt; StateRef(id, pos) }</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$/** Tracks the distribution of the number of unique transactions that contributed states to the current transaction */ private val uniqueTxHashCount = metrics.histogram("$metricPrefix.NumberOfUniqueTxHashes")</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$is BatchUpdateException</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$is SQLNonTransientConnectionException</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$is SQLRecoverableException</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$throw IllegalStateException("Database operation reached the maximum number of retries: $retryCount, something went wrong.")</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$val drainedSize = Queues.drain(requestQueue, buffer, config.maxBatchSize, config.batchTimeoutMs, TimeUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$while (buffer.isNotEmpty() &amp;&amp; inputStateCount + buffer.peek().states.size &lt;= config.maxBatchInputStates) { val request = buffer.poll() batch.add(request) inputStateCount += request.states.size }</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$StateConsumptionDetails(consumingTxId.sha256(), StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$private</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$val inputStateConflicts = allConflicts.keys.intersect(request.states.toSet()).map { it to allConflicts[it]!! }.toMap()</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.CommitStates$val referenceStateConflicts = allConflicts.keys.intersect(request.references.toSet()).map { it to allConflicts[it]!! } .toMap()</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.Companion$private const</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.Companion$private const val insertCommittedTransactionStatement = "INSERT INTO notary_committed_transactions (transaction_id) VALUES (?)"</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.Companion$private const val insertRequestStatement = "INSERT INTO notary_request_log (consuming_transaction_id, requesting_party_name, request_signature) VALUES (?, ?, ?)"</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.Companion$private const val insertStateStatement = "INSERT INTO notary_committed_states (issue_transaction_id, issue_transaction_output_id, consuming_transaction_id) VALUES (?, ?, ?)"</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.Companion$private const val selectCommittedTransactionStatement = "SELECT COUNT(transaction_id) FROM notary_committed_transactions WHERE transaction_id = ?"</ID>
    <ID>MaxLineLength:MySQLUniquenessProvider.kt$MySQLUniquenessProvider.LogRequests$setBytes(3, requestSignature.serialize(context = SerializationDefaults.STORAGE_CONTEXT.withEncoding(SNAPPY)).bytes)</ID>
    <ID>MaxLineLength:MySQLUniquenessProviderTest.kt$MySQLUniquenessProviderTest$private</ID>
    <ID>MaxLineLength:MySQLUniquenessProviderTest.kt$MySQLUniquenessProviderTest$val results = MySQLUniquenessProvider.CommitStates(listOf(request, conflictingRequest), clock).execute(uniquenessProvider.connection)</ID>
    <ID>MaxLineLength:NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.kt$NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS$val ECDSAR1_KEYPAIR by lazy { Crypto.deriveKeyPairFromEntropy(Crypto.ECDSA_SECP256R1_SHA256, BigInteger.valueOf(0)) }</ID>
    <ID>MaxLineLength:NamedCacheTest.kt$NamedCacheTest$override</ID>
    <ID>MaxLineLength:NetParams.kt$ fun main(args: Array&lt;String&gt;)</ID>
    <ID>MaxLineLength:NetParams.kt$NetParamsSigner$CertificatePathAndKeyPair</ID>
    <ID>MaxLineLength:NetParams.kt$NetParamsSigner.AMQPInspectorSerializationScheme$override</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$NettyTestClient(clientContext, InetAddress.getLocalHost().canonicalHostName, server.port, clientHandler)</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$cipherSuitesClient = arrayOf("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$cipherSuitesServer = arrayOf("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$private</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$testConnect(serverContext, clientContext, "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$testConnect(serverContext, clientContext, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests.Companion.SslSetup$override fun toString(): String</ID>
    <ID>MaxLineLength:NettyServerEventLogger.kt$NettyServerEventLogger : ChannelDuplexHandler</ID>
    <ID>MaxLineLength:NettyServerEventLogger.kt$NettyServerEventLogger$val level = if (msg is io.netty.channel.socket.SocketChannel) { // Should always be the case as this is a server socket, but be defensive if (msg.remoteAddress()?.hostString !in silencedIPs) internalLevel else InternalLogLevel.TRACE } else internalLevel</ID>
    <ID>MaxLineLength:NettyTestHandler.kt$NettyTestHandler : ChannelDuplexHandler</ID>
    <ID>MaxLineLength:Network.kt$Network$centralLabel = mapLabels.firstOrDefault(SimpleObjectProperty(myLabel), { centralPeer?.contains(it.text, true) == true })</ID>
    <ID>MaxLineLength:Network.kt$Network$if (it is WireTransaction) it.outputStates.observable().getParties() // For ContractUpgradeWireTransaction and NotaryChangeWireTransaction the output parties are the same as input parties else inputParties</ID>
    <ID>MaxLineLength:Network.kt$Network$label(PartyNameFormatter.short.format(identities[0].name)) { font = Font.font(font.family, FontWeight.BOLD, 15.0) }</ID>
    <ID>MaxLineLength:Network.kt$Network$mapScrollPane.hvalue = (valX + adjustment.x) / (mapImageView.layoutBounds.width - mapScrollPane.viewportBounds.width)</ID>
    <ID>MaxLineLength:Network.kt$Network$mapScrollPane.vvalue = (valY + adjustment.y) / (mapImageView.layoutBounds.height - mapScrollPane.viewportBounds.height)</ID>
    <ID>MaxLineLength:Network.kt$Network$node.getWorldMapLocation()?.coordinate?.project(mapPane.width, mapPane.height, 85.0511, -85.0511, -180.0, 180.0) ?: ScreenCoordinate(0.0, 0.0)</ID>
    <ID>MaxLineLength:Network.kt$Network$private</ID>
    <ID>MaxLineLength:Network.kt$Network$private val peerButtons = peerComponents.filtered { myIdentity.value !in it.nodeInfo.legalIdentitiesAndCerts.map { it.party } }.map { it.button }</ID>
    <ID>MaxLineLength:Network.kt$Network$val inputParties = it.inputs.sequence() .map { it as? PartiallyResolvedTransaction.InputResolution.Resolved } .filterNotNull() .map { it.stateAndRef.state.data }.getParties() val outputParties = it.transaction.coreTransaction.let { if (it is WireTransaction) it.outputStates.observable().getParties() // For ContractUpgradeWireTransaction and NotaryChangeWireTransaction the output parties are the same as input parties else inputParties } val signingParties = it.transaction.sigs.map { it.by.toKnownParty() } // Input parties fire a bullets to all output parties, then to the signing parties and then signing parties to output parties. // !! This is a rough guess of how the message moves in the network. // TODO : Expose artemis queue to get real message information. inputParties.cross(outputParties) + inputParties.cross(signingParties) + signingParties.cross(outputParties)</ID>
    <ID>MaxLineLength:Network.kt$Network$val mapLabel = label(PartyNameFormatter.short.format(identities.first().name)) // We choose the first one for the name of the node on the map.</ID>
    <ID>MaxLineLength:Network.kt$Network$val newHeight = Math.min(Math.max(mapImageView.prefHeight(-1.0) * zoomFactor, mapOriginalHeight), mapOriginalHeight * 10)</ID>
    <ID>MaxLineLength:Network.kt$Network$val receiver = destNode.label.boundsInParentProperty().map { Point2D(it.width / 2 + it.minX, it.height / 4 - 2.5 + it.minY) }</ID>
    <ID>MaxLineLength:Network.kt$Network$val sender = senderNode.label.boundsInParentProperty().map { Point2D(it.width / 2 + it.minX, it.height / 4 - 2.5 + it.minY) }</ID>
    <ID>MaxLineLength:Network.kt$Network${ // It has to be a copy if we want to have notary both in notaries list and in identity (if we are looking at that particular notary node). myIdentityPane.apply { center = node.renderButton(mapLabel) } myLabel = mapLabel }</ID>
    <ID>MaxLineLength:Network.kt$Network${ val node = this val identities = node.legalIdentitiesAndCerts.sortedBy { it.owningKey.toBase58String() } val mapLabel = label(PartyNameFormatter.short.format(identities.first().name)) // We choose the first one for the name of the node on the map. mapPane.add(mapLabel) // applyCss: This method does not normally need to be invoked directly but may be used in conjunction with Parent.layout() // to size a Node before the next pulse, or if the Scene is not in a Stage. // It's needed to properly add node label to the map (before that width and height are 0 which results in wrong placement of // nodes rendered after initial map rendering). mapPane.applyCss() mapPane.layout() mapLabel.apply { graphic = FontAwesomeIconView(FontAwesomeIcon.DOT_CIRCLE_ALT) contentDisplay = ContentDisplay.TOP val coordinate = Bindings.createObjectBinding({ // These coordinates are obtained when we generate the map using TileMill. node.getWorldMapLocation()?.coordinate?.project(mapPane.width, mapPane.height, 85.0511, -85.0511, -180.0, 180.0) ?: ScreenCoordinate(0.0, 0.0) }, arrayOf(mapPane.widthProperty(), mapPane.heightProperty())) // Center point of the label. layoutXProperty().bind(coordinate.map { it.screenX - width / 2 }) layoutYProperty().bind(coordinate.map { it.screenY - height / 4 }) } val button = node.renderButton(mapLabel) if (myIdentity.value in node.legalIdentitiesAndCerts.map { it.party }) { // It has to be a copy if we want to have notary both in notaries list and in identity (if we are looking at that particular notary node). myIdentityPane.apply { center = node.renderButton(mapLabel) } myLabel = mapLabel } return MapViewComponents(this, button, mapLabel) }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps$println("WARNING: ${it.fileName} already exists in $cordappsDir, ignoring and leaving existing CorDapp untouched")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps$protected abstract fun copyTo(cordappJars: List&lt;Path&gt;, nodeDirs: List&lt;Path&gt;, networkAlreadyExists: Boolean, fromCordform: Boolean)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.FirstRunOnly$override</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.FirstRunOnly$println("Not copying CorDapp JARs as --copy-cordapps is set to FirstRunOnly, and it looks like this network has already been bootstrapped.")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.No$override</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.Yes$override fun copyTo(cordappJars: List&lt;Path&gt;, nodeDirs: List&lt;Path&gt;, networkAlreadyExists: Boolean, fromCordform: Boolean)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$1 -&gt; return netParamsFilesGrouped.keys.first().deserialize().verifiedNetworkParametersCert(DEV_ROOT_CA.certificate)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$bootstrap(directory, cordappJars, CopyCordapps.No, fromCordform = true, networkParametersOverrides = networkParametersOverrides)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$bootstrap(directory, cordappJars, copyCordapps, fromCordform = false, networkParametersOverrides = networkParameterOverrides)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$is NotaryCluster.CFT -&gt; DevIdentityGenerator.generateDistributedNotarySingularIdentity(directories, cluster.name)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$listOf(CordaX500Name.parse(config.getString("notary.serviceLegalName")) to DirectoryAndConfig(path, config))</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$override</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$paths.filter { it.toString().endsWith(".jar") &amp;&amp; !it.isSameAs(bootstrapperJar) &amp;&amp; !jarsThatArentCordapps.contains(it.fileName.toString().toLowerCase()) }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$private val contractsJarConverter: (Path) -&gt; ContractsJar</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$require(networkParameterOverrides.minimumPlatformVersion == null || networkParameterOverrides.minimumPlatformVersion &lt;= PLATFORM_VERSION) { "Minimum platform version cannot be greater than $PLATFORM_VERSION" }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val configuration = ConfigFactory.parseString(extraConfigurations).resolve().getObject("networkParameterOverrides").toConfig().parseAsNetworkParametersConfiguration()</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val msg = StringBuilder("Differing sets of network parameters were found. Make sure all the nodes have the same " + "network parameters by copying the correct $NETWORK_PARAMS_FILE_NAME file across.\n\n")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val networkParametersOverrides = configuration.doOnErrors(::reportErrors).optional ?: throw IllegalStateException("Invalid configuration passed.")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val newNetParams = installNetworkParameters(notaryInfos, newWhitelist, existingNetParams, nodeDirs, networkParametersOverrides)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val newWhitelist = generateWhitelist(existingNetParams, readExcludeWhitelist(directory), unsignedJars.map(contractsJarConverter), readIncludeWhitelist(directory), signedJars.map(contractsJarConverter))</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val nodeDirs = directory.list { subDir -&gt; subDir.filter { (it / "node.conf").exists() &amp;&amp; !(it / "corda.jar").exists() }.toList() }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val signedJars = cordappJars.filter { isSigned(it) } // signed JARs are excluded by default, optionally include them in order to transition states from CZ whitelist to signature constraint</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$webServerConfFiles.firstOrNull { directory.relativize(it).toString().removeSuffix("_web-server.conf") == nodeName }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$when (legalIdentities.size) { // Single node notaries have just one identity like all other nodes. This identity is the notary identity 1 -&gt; legalIdentities[0] // Nodes which are part of a distributed notary have a second identity which is the composite identity of the // cluster and is shared by all the other members. This is the notary identity. 2 -&gt; legalIdentities[1] else -&gt; throw IllegalArgumentException("Not sure how to get the notary identity in this scenario: $this") }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper.AMQPParametersSerializationScheme$override</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$val timePerNode = 40.seconds // On the test machine, generating the node info takes 7 seconds for a single node.</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapperWithOverridableParameters$fun bootstrap(directory: Path, copyCordapps: CopyCordapps, networkParameterOverrides: NetworkParametersOverrides = NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$@Test fun `test when a package is specified in the network parameters file it is passed through to the bootstrapper DSA`()</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$@Test fun `test when a package is specified in the network parameters file it is passed through to the bootstrapper EC`()</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper)</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(eventHorizon = 7.days))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(maxMessageSize = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(maxTransactionSize = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(minimumPlatformVersion = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.No, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(tempDir.toPath().toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$assertContainsPackageOwner("bob", mapOf(Pair(alicePackageName, ALICE.publicKey), Pair(bobPackageName, BOB.publicKey)))</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$bootstrap(packageOwnership = mapOf(Pair(alicePackageName, ALICE.publicKey), Pair(bobPackageName, BOB.publicKey)))</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$private</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$return list { it.filter { it.fileName.toString().startsWith(NODE_INFO_FILE_NAME_PREFIX) }.toList() }.single()</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$val networkParameters = assertBootstrappedNetwork(fakeEmbeddedCorda, "alice" to aliceConfig, "notary" to notaryConfig)</ID>
    <ID>MaxLineLength:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$val networkParameters2 = assertBootstrappedNetwork(fakeEmbeddedCorda, "alice" to aliceConfig, "bob" to bobConfig)</ID>
    <ID>MaxLineLength:NetworkBuilder.kt$NetworkBuilderImpl$nodeInstantiator.createInstanceRequest(it).also { onNodeInstanceRequestedCallback(listOf(it)) }</ID>
    <ID>MaxLineLength:NetworkBuilder.kt$NetworkBuilderImpl$nodeInstantiator.instantiateNotaryInstance(request).thenApply { it.also(onNodeInstanceCallback) }</ID>
    <ID>MaxLineLength:NetworkHostAndPort.kt$NetworkHostAndPort.Companion$ @JvmStatic fun parse(str: String): NetworkHostAndPort</ID>
    <ID>MaxLineLength:NetworkHostAndPortTest.kt$NetworkHostAndPortTest${ NetworkHostAndPort("example.com", it) }</ID>
    <ID>MaxLineLength:NetworkHostAndPortTest.kt$NetworkHostAndPortTest${ NetworkHostAndPort.parse(it) }</ID>
    <ID>MaxLineLength:NetworkIdentityModel.kt$NetworkIdentityModel$val notaries = ChosenList(rpcProxy.map { FXCollections.observableList(it?.notaryIdentities() ?: emptyList()) }, "notaries")</ID>
    <ID>MaxLineLength:NetworkMap.kt$ParametersUpdate</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCache$ fun getNodeByLegalIdentity(party: AbstractParty): NodeInfo?</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun getNodeByLegalName(name: CordaX500Name): NodeInfo?</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun getNodesByLegalName(name: CordaX500Name): List&lt;NodeInfo&gt;</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$ fun track(): DataFeed&lt;List&lt;NodeInfo&gt;, NetworkMapCache.MapChange&gt;</ID>
    <ID>MaxLineLength:NetworkMapCache.kt$NetworkMapCacheBase$/** * A list of notary services available on the network. * * Note that the identities are sorted based on legal name, and the ordering might change once new notaries are introduced. */ val notaryIdentities: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:NetworkMapCacheTest.kt$NetworkMapCacheTest$assertEquals(aliceNode.info, bobCache.getNodesByLegalIdentityKey(aliceNode.info.singleIdentity().owningKey).single())</ID>
    <ID>MaxLineLength:NetworkMapCacheTest.kt$NetworkMapCacheTest$assertEquals(aliceNode.services.networkMapCache.getNodesByLegalIdentityKey(alice.owningKey).singleOrNull(), aliceNode.info)</ID>
    <ID>MaxLineLength:NetworkMapCacheTest.kt$NetworkMapCacheTest$assertEquals(aliceNode.services.networkMapCache.getNodesByLegalIdentityKey(alice.owningKey).singleOrNull(), bobNode.info)</ID>
    <ID>MaxLineLength:NetworkMapClient.kt$NetworkMapClient$logger.trace { "Fetched network parameters: '$networkParameterHash' successfully. Network Parameters: $networkParameter" }</ID>
    <ID>MaxLineLength:NetworkMapClient.kt$NetworkMapClient$logger.trace { "Sending network parameters with hash ${signedParametersHash.raw.deserialize()} approval to $ackURL." }</ID>
    <ID>MaxLineLength:NetworkMapClientTest.kt$NetworkMapClientTest$assertEquals(networkMapClient.getNetworkParameters(originalNetworkParameterHash).verified(), server.networkParameters)</ID>
    <ID>MaxLineLength:NetworkMapClientTest.kt$NetworkMapClientTest$networkMapClient</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$AuthenticatedConnectHandler$override</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, httpProxyPort), proxyType = Proxy.Type.HTTP), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, httpProxyPort), proxyType = Proxy.Type.HTTP, proxyPassword = "proxyPW", proxyUser = "proxyUser"), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, httpProxyPort), proxyType = Proxy.Type.HTTP, proxyUser = "proxyUser", proxyPassword = "ThisIsNotAPassword"), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyType = Proxy.Type.DIRECT), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("https://$serverAddress"), proxyType = Proxy.Type.DIRECT), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("https://no.such.address"), URL("https://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, httpProxyPort), proxyType = Proxy.Type.HTTP), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("https://no.such.address"), URL("https://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, httpProxyPort), proxyType = Proxy.Type.HTTP, proxyPassword = "proxyPW", proxyUser = "proxyUser"), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("https://no.such.address"), URL("https://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, httpProxyPort), proxyType = Proxy.Type.HTTP, proxyUser = "proxyUser", proxyPassword = "ThisIsNotAPassword"), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer$val jerseyServlet = ServletHolder(ServletContainer(resourceConfig)).apply { initOrder = 0 } // Initialise at server start</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$nodeInfoMap.filter { it.value.verified().legalIdentities.first().name == signedNodeInfo.verified().legalIdentities.first().name }</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$return Response.ok(signedNetworkMap.serialize().bytes).header("Cache-Control", "max-age=${pollInterval.seconds}").build()</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, socksProxyPort), proxyType = Proxy.Type.SOCKS), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, socksProxyPort), proxyType = Proxy.Type.SOCKS, proxyPassword = proxyPw, proxyUser = proxyUser), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, socksProxyPort), proxyType = Proxy.Type.SOCKS, proxyUser = proxyUser, proxyPassword = invalidPw), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$serverAddress"), proxyType = Proxy.Type.DIRECT), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("https://$serverAddress"), proxyType = Proxy.Type.DIRECT), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("https://no.such.address"), URL("https://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, socksProxyPort), proxyType = Proxy.Type.SOCKS), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("https://no.such.address"), URL("https://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, socksProxyPort), proxyType = Proxy.Type.SOCKS, proxyPassword = proxyPw, proxyUser = proxyUser), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest$val networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("https://no.such.address"), URL("https://$serverAddress"), proxyAddress = NetworkHostAndPort(myHostname, socksProxyPort), proxyType = Proxy.Type.SOCKS, proxyUser = proxyUser, proxyPassword = invalidPw), VersionInfo(1, "TEST", "TEST", "TEST")).apply { start(DEV_ROOT_CA.certificate) }</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$@Test fun `nodes process additions and removals from the network map correctly (and also download the network parameters)`()</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertEquals(laterHash, networkMapServer.latestParametersAccepted(alice.nodeInfo.legalIdentities.first().owningKey))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertThat(nodeInfosDir.list().single().readObject&lt;SignedNodeInfo&gt;().verified().legalIdentities.first(), `is`( this.nodeInfo.legalIdentities.first()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertThatThrownBy { alice.rpc.acceptNewNetworkParameters(nextHash) }.hasMessageContaining("Refused to accept parameters with hash")</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$networkMapServer.scheduleParametersUpdate(laterParams, "Another update", Instant.ofEpochMilli(random63BitValue()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$networkMapServer.scheduleParametersUpdate(nextParams, "Next parameters", Instant.ofEpochMilli(random63BitValue()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$val aliceNode = startNode(providedName = ALICE_NAME, devMode = false).getOrThrow() val aliceNodeInfo = aliceNode.nodeInfo.serialize().hash assertThat(networkMapServer.networkMapHashes()).contains(aliceNodeInfo) networkMapServer.removeNodeInfo(aliceNode.nodeInfo) var maxRemoveRetries = 5 // Try to remove multiple times in case the network map republishes just in between the removal and the check. while (aliceNodeInfo in networkMapServer.networkMapHashes()) { networkMapServer.removeNodeInfo(aliceNode.nodeInfo) if (maxRemoveRetries-- == 0) { throw AssertionError("Could not remove Node info.") } } // Wait until the node info is republished. Thread.sleep(2000) assertThat(networkMapServer.networkMapHashes()).contains(aliceNodeInfo)</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest.Companion$nms.networkParameters = testNetworkParameters(it, modifiedTime = Instant.ofEpochMilli(random63BitValue()), epoch = 2)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$"""Node is using network parameters with hash $currentParametersHash but the network map is advertising ${networkMap.networkParameterHash}. To resolve this mismatch, and move to the current parameters, delete the $NETWORK_PARAMS_FILE_NAME file from the node's directory and restart. The node will shutdown now."""</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$// Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$?:</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$ParametersUpdateInfo(it.first.newParametersHash, it.second.verified(), it.first.description, it.first.updateDeadline)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$To resolve this mismatch, and move to the current parameters, delete the </ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$hash.serialize().sign { keyManagementService.sign(it.bytes, ourNodeInfo.verified().legalIdentities[0].owningKey) }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$if (autoAcceptNetworkParameters &amp;&amp; networkParameters.canAutoAccept(newNetParams, excludedAutoAcceptNetworkParameters)) { logger.info("Auto-accepting network parameter update ${update.newParametersHash}") acceptNewNetworkParameters(update.newParametersHash) { hash -&gt; hash.serialize().sign { keyManagementService.sign(it.bytes, ourNodeInfo.verified().legalIdentities[0].owningKey) } } } else { parametersUpdatesTrack.onNext(updateInfo) }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.info("Auto-accept enabled for network parameter changes which modify only: $autoAcceptNetworkParametersNames")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.info("Fetched: ${hashesToFetch.size} using $threadsToUseForNetworkMapDownload Threads in ${System.currentTimeMillis() - networkMapDownloadStartTime}ms")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$private</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$this.excludedAutoAcceptNetworkParameters = networkParameterAcceptanceSettings.excludedAutoAcceptableParameters</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$throw CordaRuntimeException("Network map cache can be updated only if network map/compatibility zone URL is specified")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val (update, signedNewNetParams) = requireNotNull(newNetworkParameters) { "Couldn't find parameters update for the hash: $parametersHash" }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val acceptedHash = if (updatesFile.exists()) updatesFile.readObject&lt;SignedNetworkParameters&gt;().raw.hash else null</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val executorToUseForDownloadingNodeInfos = Executors.newFixedThreadPool(threadsToUseForNetworkMapDownload, NamedThreadFactory("NetworkMapUpdaterNodeInfoDownloadThread"))</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val executorToUseForInsertionIntoDB = Executors.newSingleThreadExecutor(NamedThreadFactory("NetworkMapUpdateDBInsertThread"))</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val networkMapDownloadFutures = hashesToFetch.chunked(max(hashesToFetch.size / threadsToUseForNetworkMapDownload, 1)) .map { nodeInfosToGet -&gt; //for a set of chunked hashes, get the nodeInfo for each hash CompletableFuture.supplyAsync(Supplier&lt;List&lt;NodeInfo&gt;&gt; { nodeInfosToGet.mapNotNull { nodeInfo -&gt; try { networkMapClient.getNodeInfo(nodeInfo) } catch (e: Exception) { // Failure to retrieve one node info shouldn't stop the whole update, log and return null instead. logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e) null } } }, executorToUseForDownloadingNodeInfos).thenAcceptAsync(Consumer { retrievedNodeInfos -&gt; // Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos) }, executorToUseForInsertionIntoDB) }.toTypedArray()</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater${ // Failure to retrieve one node info shouldn't stop the whole update, log and return null instead. logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e) null }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater${ if (networkMapClient == null) { throw CordaRuntimeException("Network map cache can be updated only if network map/compatibility zone URL is specified") } val (globalNetworkMap, cacheTimeout) = networkMapClient.getNetworkMap() globalNetworkMap.parametersUpdate?.let { handleUpdateNetworkParameters(networkMapClient, it) } val additionalHashes = extraNetworkMapKeys.flatMap { try { networkMapClient.getNetworkMap(it).payload.nodeInfoHashes } catch (e: Exception) { // Failure to retrieve one network map using UUID shouldn't stop the whole update. logger.warn("Error encountered when downloading network map with uuid '$it', skipping...", e) emptyList&lt;SecureHash&gt;() } } val allHashesFromNetworkMap = (globalNetworkMap.nodeInfoHashes + additionalHashes).toSet() if (currentParametersHash != globalNetworkMap.networkParameterHash) { exitOnParametersMismatch(globalNetworkMap) } val currentNodeHashes = networkMapCache.allNodeHashes // Remove node info from network map. (currentNodeHashes - allHashesFromNetworkMap - nodeInfoWatcher.processedNodeInfoHashes) .mapNotNull { if (it != ourNodeInfoHash) networkMapCache.getNodeByHash(it) else null } .forEach(networkMapCache::removeNode) //at the moment we use a blocking HTTP library - but under the covers, the OS will interleave threads waiting for IO //as HTTP GET is mostly IO bound, use more threads than CPU's //maximum threads to use = 24, as if we did not limit this on large machines it could result in 100's of concurrent requests val threadsToUseForNetworkMapDownload = min(Runtime.getRuntime().availableProcessors() * 4, 24) val executorToUseForDownloadingNodeInfos = Executors.newFixedThreadPool(threadsToUseForNetworkMapDownload, NamedThreadFactory("NetworkMapUpdaterNodeInfoDownloadThread")) //DB insert is single threaded - use a single threaded executor for it. val executorToUseForInsertionIntoDB = Executors.newSingleThreadExecutor(NamedThreadFactory("NetworkMapUpdateDBInsertThread")) val hashesToFetch = (allHashesFromNetworkMap - currentNodeHashes) val networkMapDownloadStartTime = System.currentTimeMillis() if (hashesToFetch.isNotEmpty()) { val networkMapDownloadFutures = hashesToFetch.chunked(max(hashesToFetch.size / threadsToUseForNetworkMapDownload, 1)) .map { nodeInfosToGet -&gt; //for a set of chunked hashes, get the nodeInfo for each hash CompletableFuture.supplyAsync(Supplier&lt;List&lt;NodeInfo&gt;&gt; { nodeInfosToGet.mapNotNull { nodeInfo -&gt; try { networkMapClient.getNodeInfo(nodeInfo) } catch (e: Exception) { // Failure to retrieve one node info shouldn't stop the whole update, log and return null instead. logger.warn("Error encountered when downloading node info '$nodeInfo', skipping...", e) null } } }, executorToUseForDownloadingNodeInfos).thenAcceptAsync(Consumer { retrievedNodeInfos -&gt; // Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos) }, executorToUseForInsertionIntoDB) }.toTypedArray() //wait for all the futures to complete val waitForAllHashes = CompletableFuture.allOf(*networkMapDownloadFutures) waitForAllHashes.thenRunAsync { logger.info("Fetched: ${hashesToFetch.size} using $threadsToUseForNetworkMapDownload Threads in ${System.currentTimeMillis() - networkMapDownloadStartTime}ms") executorToUseForDownloadingNodeInfos.shutdown() executorToUseForInsertionIntoDB.shutdown() }.getOrThrow() } // Mark the network map cache as ready on a successful poll of the HTTP network map, even on the odd chance that // it's empty networkMapCache.nodeReady.set(null) return cacheTimeout }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater${ networkMapClient ?: throw IllegalStateException("Network parameters updates are not supported without compatibility zone configured") // TODO This scenario will happen if node was restarted and didn't download parameters yet, but we accepted them. // Add persisting of newest parameters from update. val (update, signedNewNetParams) = requireNotNull(newNetworkParameters) { "Couldn't find parameters update for the hash: $parametersHash" } // We should check that we sign the right data structure hash. val newNetParams = signedNewNetParams.verifiedNetworkParametersCert(trustRoot) val newParametersHash = signedNewNetParams.raw.hash if (parametersHash == newParametersHash) { // The latest parameters have priority. signedNewNetParams.serialize() .open() .copyTo(baseDirectory / NETWORK_PARAMS_UPDATE_FILE_NAME, StandardCopyOption.REPLACE_EXISTING) networkMapClient.ackNetworkParametersUpdate(sign(parametersHash)) logger.info("Accepted network parameter update $update: $newNetParams") } else { throw OutdatedNetworkParameterHashException(parametersHash, newParametersHash) } }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$autoAcceptableNamesAndGetters.none { it.key in excludedParameterNames &amp;&amp; valueChanged(newNetworkParameters, it.value) }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$private fun KProperty1&lt;out NetworkParameters, Any?&gt;.isAutoAcceptable(): Boolean</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$private val memberPropertyPartition = NetworkParameters::class.declaredMemberProperties.partition { it.isAutoAcceptable() }</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$//Test fix for ENT-1882 //This scenario can happen when signing of network map server is performed much longer after the node joined the network. //Network map will advertise hashes without that node. @Test fun `not remove own node info when it is not in network map yet`()</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `network parameters not auto-accepted when update only changes whitelist but auto accept configured to be false`()</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$@Test fun `network parameters not auto-accepted when update only changes whitelist but parameter included in exclusion`()</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$Assert.assertThat(networkMapCache.allNodeHashes, IsIterableContainingInAnyOrder.containsInAnyOrder(signedNodeInfo1.raw.hash, signedNodeInfo2.raw.hash))</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$MockKeyManagementService(makeTestIdentityService(), ourKeyPair, pkToIdCache = MockPublicKeyToOwningIdentityCache())</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertFalse(netParams.canAutoAccept(netParamsAutoAcceptable, setOf("whitelistedContractImplementations")), "not auto-acceptable if only AutoAcceptable params have changed but one has been added to the exclusion set")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertFalse(netParams.canAutoAccept(netParamsNotAutoAcceptable, emptySet()), "not auto-acceptable if non-AutoAcceptable param has changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertThat(networkMapCache.allNodeHashes).containsExactlyInAnyOrder(fileNodeInfoAndSigned1.signed.raw.hash, fileNodeInfoAndSigned2.signed.raw.hash)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertThat(networkMapCache.allNodeHashes).containsExactlyInAnyOrder(signedMyInfo.raw.hash, signedOtherInfo.raw.hash)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParams, autoAcceptablePropertyNames), "auto acceptable if identical regardless of exclusions")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParamsAutoAcceptable, emptySet()), "auto-acceptable if only AutoAcceptable params have changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParamsAutoAcceptable, setOf("modifiedTime")), "auto-acceptable if only AutoAcceptable params have changed and excluded param has not changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$networkMapClient</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$on { getNodeByHash(any()) }.then { mock -&gt; data.values.singleOrNull { it.serialize().hash == mock.arguments[0] } }</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$private</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$updater = NetworkMapUpdater(networkMapCache, fileWatcher, netMapClient, baseDir, extraNetworkMapKeys, networkParametersStorage)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$val fileName = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${localNodeInfo.legalIdentities[0].name.serialize().hash}"</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$val fileName1 = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${fileNodeInfoAndSigned1.nodeInfo.legalIdentities[0].name.serialize().hash}"</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest${ setUpdater() val nodeInfoBuilder = TestNodeInfoBuilder() val (_, key) = nodeInfoBuilder.addLegalIdentity(CordaX500Name("Info", "London", "GB")) val (serverNodeInfo, serverSignedNodeInfo) = nodeInfoBuilder.buildWithSigned(1, 1) //Construct node for exactly same identity, but different serial. This one will go to additional-node-infos only. val localNodeInfo = serverNodeInfo.copy(serial = 17) val localSignedNodeInfo = NodeInfoAndSigned(localNodeInfo) { _, serialised -&gt; key.sign(serialised.bytes) } //The one with higher serial goes to additional-node-infos. NodeInfoWatcher.saveToFile(nodeInfoDir, localSignedNodeInfo) //Publish to network map the one with lower serial. networkMapClient.publish(serverSignedNodeInfo) startUpdater() advanceTime() verify(networkMapCache, times(1)).addNode(localNodeInfo) Thread.sleep(2L * cacheExpiryMs) //Node from file has higher serial than the one from NetworkMapServer assertThat(networkMapCache.allNodeHashes).containsOnly(localSignedNodeInfo.signed.raw.hash) val fileName = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${localNodeInfo.legalIdentities[0].name.serialize().hash}" (nodeInfoDir / fileName).delete() advanceTime() verify(networkMapCache, times(1)).removeNode(any()) verify(networkMapCache).removeNode(localNodeInfo) Thread.sleep(2L * cacheExpiryMs) //Instead of node from file we should have now the one from NetworkMapServer assertThat(networkMapCache.allNodeHashes).containsOnly(serverSignedNodeInfo.raw.hash) }</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec$internal</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$badValue("Error reading the key store from the file for keyStoreFilePath: $suppliedKeystorePath ${e.message}.")</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$badValue("Password is incorrect or the key store is damaged for keyStoreFilePath: $suppliedKeystorePath.")</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$override</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$internal fun &lt;T&gt; badValue(msg: String): Valid&lt;T&gt;</ID>
    <ID>MaxLineLength:NetworkParameters.kt$NetworkParameters</ID>
    <ID>MaxLineLength:NetworkParameters.kt$NetworkParameters$whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations</ID>
    <ID>MaxLineLength:NetworkParametersCollector.kt$NetworkParametersCollector : TrackedCollector</ID>
    <ID>MaxLineLength:NetworkParametersCopier.kt$NetworkParametersCopier$private val serialisedSignedNetParams: SerializedBytes&lt;SignedDataWithCert&lt;NetworkParameters&gt;&gt; = signingCertAndKeyPair.sign(networkParameters).serialize()</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader$logger.info("No network-parameters file found. Expecting network parameters to be available from the network map.")</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader$private</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ // Node joins for the first time. downloadParameters(advertisedParametersHash) }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ // TODO On one hand we have node starting without parameters and just accepting them by default, // on the other we have parameters update process - it needs to be unified. Say you start the node, you don't have matching parameters, // you get them from network map, but you have to run the approval step. if (signedParametersFromFile == null) { // Node joins for the first time. downloadParameters(advertisedParametersHash) } else if (signedParametersFromFile.raw.hash == advertisedParametersHash) { // Restarted with the same parameters. signedParametersFromFile } else { // Update case. readParametersUpdate(advertisedParametersHash, signedParametersFromFile.raw.hash) } }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ logger.info("Unable to download network map", e) // If NetworkMap is down while restarting the node, we should be still able to continue with parameters from file null }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error$NetworkMapNotConfigured : Error</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error$ParamsNotConfigured : Error</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error.OldParamsAndUpdate$"parameters advertised by network map. Please update node to use correct network parameters file."</ID>
    <ID>MaxLineLength:NetworkParametersReaderTest.kt$NetworkParametersReaderTest$NetworkParametersCopier(server.networkParameters, update = true).install(baseDirectory)</ID>
    <ID>MaxLineLength:NetworkParametersReaderTest.kt$NetworkParametersReaderTest$networkMapClient = NetworkMapClient(NetworkServicesConfig(URL("http://no.such.address"), URL("http://$address")), VersionInfo(1, "TEST", "TEST", "TEST"))</ID>
    <ID>MaxLineLength:NetworkParametersReaderTest.kt$NetworkParametersReaderTest$val parameters = NetworkParametersReader(DEV_ROOT_CA.certificate, networkMapClient, baseDirectory).read().networkParameters</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$(megaCorpNode.services.networkParametersService as NetworkParametersStorage).saveParameters(certKeyPair.sign(defaultParams))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$(megaCorpNode.services.networkParametersService as NetworkParametersStorage).saveParameters(certKeyPair.sign(params3))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$assertThatExceptionOfType(TransactionVerificationException.TransactionNetworkParameterOrderingException::class.java)</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, cordappForClasses(ResolveTransactionsFlowTest.TestFlow::class.java, ResolveTransactionsFlowTest.TestResponseFlow::class.java))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$params2 = testNetworkParameters(epoch = 2, minimumPlatformVersion = 3, notaries = listOf((NotaryInfo(notaryParty, true))))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$params3 = testNetworkParameters(epoch = 3, minimumPlatformVersion = 4, notaries = listOf((NotaryInfo(notaryParty, true))))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$private</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID)</ID>
    <ID>MaxLineLength:NetworkParametersService.kt$NetworkParametersService$/** * For backwards compatibility, this parameters hash will be used for resolving historical transactions in the chain. */ val defaultHash: SecureHash</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getEpochFromHash(hash: SecureHash): Int?</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getHistoricNotary(party: Party): NotaryInfo?</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun lookupSigned(hash: SecureHash): SignedDataWithCert&lt;NetworkParameters&gt;?</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$alice.services.startFlow(CashIssueFlow(500.DOLLARS, OpaqueBytes.of(0x01), fakeNotaryId)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$val alice = mockNet.createUnstartedNode(InternalMockNodeParameters(legalName = ALICE_NAME, forcedID = 100, version = MOCK_VERSION_INFO.copy(platformVersion = 1)))</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$val alice = mockNet.createUnstartedNode(InternalMockNodeParameters(legalName = ALICE_NAME, forcedID = 100, version = MOCK_VERSION_INFO.copy(platformVersion = 2)))</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val config = NetworkServicesConfig(URL("https://doorman"), URL("http://networkmap"), proxyType = Proxy.Type.HTTP, proxyAddress = NetworkHostAndPort("localhost", 1234), proxyPassword = "pw", proxyUser = "user")</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val config = NetworkServicesConfig(URL("https://doorman"), URL("http://networkmap"), proxyType = Proxy.Type.SOCKS, proxyAddress = NetworkHostAndPort("localhost", 1234), proxyPassword = "pw", proxyUser = "user")</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val config2 = NetworkServicesConfig(URL("https://doorman"), URL("http://networkmap"), proxyType = Proxy.Type.HTTP, proxyAddress = NetworkHostAndPort("localhost2", 5678), proxyPassword = "pw", proxyUser = "user")</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val pwAuth = Authenticator.requestPasswordAuthentication("localhost", InetAddress.getByName("localhost"), 1234, "https", "PROXY", "PROXY", URL("https://some.where.over.the/rainbow"), Authenticator.RequestorType.PROXY)</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val pwAuth = Authenticator.requestPasswordAuthentication("localhost", InetAddress.getByName("localhost"), 1234, "https", "PROXY", "PROXY", URL("https://some.where.over.the/rainbow"), Authenticator.RequestorType.SERVER)</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val pwAuthDifferentServer = Authenticator.requestPasswordAuthentication("foo.bar.com", InetAddress.getByName("localhost"), 1234, "https", "PROXY", "PROXY", URL("https://some.where.over.the/rainbow"), Authenticator.RequestorType.PROXY)</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val pwAuthDifferentServer = Authenticator.requestPasswordAuthentication("foo.bar.com", InetAddress.getByName("localhost"), 1234, "https", "PROXY", "PROXY", URL("https://some.where.over.the/rainbow"), Authenticator.RequestorType.SERVER)</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val pwAuthWrongType = Authenticator.requestPasswordAuthentication("localhost", InetAddress.getByName("localhost"), 1234, "https", "PROXY", "PROXY", URL("https://some.where.over.the/rainbow"), Authenticator.RequestorType.PROXY)</ID>
    <ID>MaxLineLength:NetworkProxyTests.kt$NetworkProxyTests$val pwAuthWrongType = Authenticator.requestPasswordAuthentication("localhost", InetAddress.getByName("localhost"), 1234, "https", "PROXY", "PROXY", URL("https://some.where.over.the/rainbow"), Authenticator.RequestorType.SERVER)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ fun generateKeysAndRegister(tslPublicKey: PublicKey? = null)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ | Please make sure the config is correct or that the correct certificate for the CRL issuer is added to the node's trust store.</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$"$networkRootTrustStorePath does not exist. This file must contain the root CA cert of your compatibility zone. "</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$certStore.query { setPrivateKey(SELF_SIGNED_PRIVATE_KEY, AliasPrivateKey(SELF_SIGNED_PRIVATE_KEY), listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), certificateStore.entryPassword) }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$if (Crypto.toSupportedPublicKey(certificates.first().publicKey) != Crypto.toSupportedPublicKey(registeringPublicKey)) { throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.") }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logError</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logProgress("Certificate signing request with the following information will be submitted to the Corda certificate signing server.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logProgress("Private key '$nodeCaKeyAlias' stored in the configured crypto service (${cryptoServiceType.userFriendlyName}). Certificate-chain stored in node's file-based keystore.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logProgress("Successfully submitted request to Corda certificate signing server, request ID: $requestId.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$onSuccess(nodeCaPublicKey, tslPublicKey, cryptoService.getSigner(nodeCaKeyAlias), nodeCaCertificates, tlsCrlIssuerCert?.subjectX500Principal?.toX500Name())</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private val nextIdleDuration: (Duration?) -&gt; Duration? = FixedPeriodLimitedRetrialStrategy(10, Duration.ofMinutes(1))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$protected open fun onSuccess(publicKey: PublicKey, tlsPublicKey: PublicKey?, contentSigner: ContentSigner, certificates: List&lt;X509Certificate&gt;, tlsCrlCertificateIssuer: X500Name?)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Received certificate contains invalid cert role, expected '$certRole', got '$nodeCaCertRole'.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Subject of received node CA cert doesn't match with node legal name: $nodeCaSubject")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw NodeRegistrationException("Compatibility Zone registration service is currently unavailable, " + "try again later!.", e)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val certStore: CertificateStore = if (cryptoService is BCCryptoService) cryptoService.certificateStore else certificateStore</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val nodeIdentityPublicKey = cryptoService.generateKeyPair(nodeIdentityAlias, cryptoService.defaultIdentitySignatureScheme())</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val request = X509Utilities.createCertificateSigningRequest(myLegalName.x500Principal, emailAddress, publicKey, contentSigner, certRole)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val requestId = submitOrResumeCertificateSigningRequest(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val validityWindow = X509Utilities.getCertificateValidityWindow(DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, nodeCaCertificate)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ // Create or load self signed keypair from the key store. // We use the self sign certificate to store the key temporarily in the keystore while waiting for the request approval. if (alias !in this) { // NODE_CA should be TLS compatible due to the cert hierarchy structure. val keyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME) val selfSignCert = X509Utilities.createSelfSignedCACertificate(myLegalName.x500Principal, keyPair) // Save to the key store. with(value) { setPrivateKey(alias, keyPair.private, listOf(selfSignCert), keyPassword = entryPassword) save() } } return query { getCertificateAndKeyPair(alias, entryPassword) }.keyPair }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ certificatesDirectory.createDirectories() // We need this in case cryptoService and certificateStore share the same KeyStore (for backwards compatibility purposes). // If we didn't, then an update to cryptoService wouldn't be reflected to certificateStore that is already loaded in memory. val certStore: CertificateStore = if (cryptoService is BCCryptoService) cryptoService.certificateStore else certificateStore // SELF_SIGNED_PRIVATE_KEY is used as progress indicator. if (certStore.contains(nodeCaKeyAlias) &amp;&amp; !certStore.contains(SELF_SIGNED_PRIVATE_KEY)) { logProgress("Certificate already exists, Corda node will now terminate...") return } val tlsCrlIssuerCert = getTlsCrlIssuerCert() // We use SELF_SIGNED_PRIVATE_KEY as progress indicator so we just store a dummy key and cert. // When registration succeeds, this entry should be deleted. certStore.query { setPrivateKey(SELF_SIGNED_PRIVATE_KEY, AliasPrivateKey(SELF_SIGNED_PRIVATE_KEY), listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), certificateStore.entryPassword) } val nodeCaPublicKey = loadOrGenerateKeyPair() val requestId = submitOrResumeCertificateSigningRequest(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias)) val nodeCaCertificates = pollServerForCertificates(requestId) validateCertificates(nodeCaPublicKey, nodeCaCertificates) certStore.setCertPathOnly(nodeCaKeyAlias, nodeCaCertificates) certStore.value.internal.deleteEntry(SELF_SIGNED_PRIVATE_KEY) certStore.value.save() val cryptoServiceType = cryptoService.getType() logProgress("Private key '$nodeCaKeyAlias' stored in the configured crypto service (${cryptoServiceType.userFriendlyName}). Certificate-chain stored in node's file-based keystore.") onSuccess(nodeCaPublicKey, tslPublicKey, cryptoService.getSigner(nodeCaKeyAlias), nodeCaCertificates, tlsCrlIssuerCert?.subjectX500Principal?.toX500Name()) // All done, clean up temp files. requestIdStore.deleteIfExists() }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ certificatesDirectory.createDirectories() // We need this in case cryptoService and certificateStore share the same KeyStore (for backwards compatibility purposes). // If we didn't, then an update to cryptoService wouldn't be reflected to certificateStore that is already loaded in memory. val certStore: CertificateStore = if (cryptoService is BCCryptoService) cryptoService.certificateStore else certificateStore if (!certStore.contains(nodeCaKeyAlias)) { logProgress("Node CA key doesn't exist, program will now terminate...") throw IllegalStateException("Node CA not found") } val nodeIdentityAlias = "${NODE_IDENTITY_ALIAS_PREFIX}-private-key" if (certStore.contains(nodeIdentityAlias)) { logProgress("Node identity already exists, Corda node will now terminate...") return } certStore.update { logProgress("Generating SSL certificate for node messaging service.") val nodeIdentityPublicKey = cryptoService.generateKeyPair(nodeIdentityAlias, cryptoService.defaultIdentitySignatureScheme()) val nodeCaCertChain = getCertificateChain(nodeCaKeyAlias) val nodeCaCertificate = nodeCaCertChain.first() val validityWindow = X509Utilities.getCertificateValidityWindow(DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, nodeCaCertificate) val nodeIdentityCert = X509Utilities.createCertificate( CertificateType.LEGAL_IDENTITY, nodeCaCertificate.subjectX500Principal, nodeCaCertificate.x509.publicKey, cryptoService.getSigner(nodeCaKeyAlias), nodeCaCertificate.subjectX500Principal, nodeIdentityPublicKey, validityWindow, crlDistPoint = null, crlIssuer = null) logger.info("Generated Node Identity certificate: $nodeIdentityCert") val nodeIdentityCertificateChain: List&lt;X509Certificate&gt; = listOf(nodeIdentityCert) + nodeCaCertChain X509Utilities.validateCertificateChain(rootCert, nodeIdentityCertificateChain) val privateKey = if (contains(nodeIdentityAlias)) { getPrivateKey(nodeIdentityAlias, certStore.entryPassword) } else { Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME).private // dummy value } setPrivateKey(nodeIdentityAlias, privateKey, nodeIdentityCertificateChain, certStore.entryPassword) } logProgress("Node identity private key and certificate chain stored in $nodeIdentityAlias.") }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ val nodeCACertificate = certificates.first() val nodeCaSubject = try { CordaX500Name.build(nodeCACertificate.subjectX500Principal) } catch (e: IllegalArgumentException) { throw CertificateRequestException("Received node CA cert has invalid subject name: ${e.message}") } if (nodeCaSubject != myLegalName) { throw CertificateRequestException("Subject of received node CA cert doesn't match with node legal name: $nodeCaSubject") } val nodeCaCertRole = try { CertRole.extract(nodeCACertificate) } catch (e: IllegalArgumentException) { throw CertificateRequestException("Unable to extract cert role from received node CA cert: ${e.message}") } if (certRole != nodeCaCertRole) { throw CertificateRequestException("Received certificate contains invalid cert role, expected '$certRole', got '$nodeCaCertRole'.") } // Validate returned certificate is for the correct public key. if (Crypto.toSupportedPublicKey(certificates.first().publicKey) != Crypto.toSupportedPublicKey(registeringPublicKey)) { throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.") } // Validate certificate chain returned from the doorman with the root cert obtained via out-of-band process, to prevent MITM attack on doorman server. X509Utilities.validateCertificateChain(rootCert, certificates) logProgress("Certificate signing request approved, storing private key with the certificate chain.") }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$Pair&lt;PrivateKey, PublicKey&gt;(Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME).private, tlsPublicKey)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$computeNextIdleDoormanConnectionPollInterval: (Duration?) -&gt; Duration? = FixedPeriodLimitedRetrialStrategy(10, Duration.ofMinutes(1))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$config.signingCertificateStore</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$logger.info("Copying trusted certificate to the node's trust store: Alias: $it, Certificate: $certificate")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$logger.warn("The node's trust store already exists. The following certificates will be overridden: ${this.aliases().asSequence()}")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$override</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$private</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$throw ConfigurationException("The crypto service configured for fresh identities ($cryptoServiceLabel) supports the ${cryptoService.getWrappingMode()} mode, but the node is configured to use $mode")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$val validityWindow = X509Utilities.getCertificateValidityWindow(DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, issuerCertificate)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$val wrappingCryptoService = CryptoServiceFactory.makeCryptoService(cryptoServiceConfigBlock.cryptoServiceName, config.myLegalName, config.signingCertificateStore, cryptoServiceConfigBlock.cryptoServiceConf, config.wrappingKeyStorePath)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$CertRole.NODE_CA -&gt; NodeRegistrationHelper(NodeRegistrationConfiguration(config), certService, NodeRegistrationOption(config.certificatesDirectory / networkRootTrustStoreFileName, networkRootTrustStorePassword))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$doReturn(CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory)).whenever(it).p2pSslOptions</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$doReturn(CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory)).whenever(it).signingCertificateStore</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$private</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$publicKey: PublicKey = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME).public</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$rootAndIntermediateCA: Pair&lt;CertificateAndKeyPair, CertificateAndKeyPair&gt; = createDevIntermediateCaCertPath()</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$val rootAndIntermediateCA = createDevIntermediateCaCertPath().also { saveNetworkTrustStore(CORDA_ROOT_CA to it.first.certificate) }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest${ createFixedResponseRegistrationHelper(nodeCaCertPath) }</ID>
    <ID>MaxLineLength:NetworkRegistrationService.kt$NetworkRegistrationService$ @Throws(CertificateRequestException::class) fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>MaxLineLength:NetworkStatusCollector.kt$NetworkStatusCollector : TrackedCollector</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Exit -&gt; ExitRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), issueRef)</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Issue -&gt; IssueAndPaymentRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), issueRef, partyBChoiceBox.value.party, selectNotary(), anonymous)</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Pay -&gt; PaymentRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), partyBChoiceBox.value.party, anonymous = anonymous, notary = selectNotary())</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$issueRefLabel.visibleProperty().bind(transactionTypeCB.valueProperty().map { it == CashTransaction.Issue || it == CashTransaction.Exit })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$issuer.isNotNull.and(currencyChoiceBox.valueProperty().isNotNull).and(transactionTypeCB.valueProperty().booleanBinding(transactionTypeCB.valueProperty()) { it != CashTransaction.Issue })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$partyATextField.textProperty().bind(myIdentity.map { it?.let { PartyNameFormatter.short.format(it.name) } ?: "" })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$val filteredCash = cash.filtered { it.token.issuer.party == issuer.value &amp;&amp; it.token.product == currencyChoiceBox.value } .map { it.withoutIssuer() }.sumOrNull()</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$val issuer = Bindings.createObjectBinding({ if (issuerChoiceBox.isVisible) issuerChoiceBox.value else myIdentity.value }, arrayOf(myIdentity, issuerChoiceBox.visibleProperty(), issuerChoiceBox.valueProperty()))</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$visibleProperty().bind(transactionTypeCB.valueProperty().map { it == CashTransaction.Issue || it == CashTransaction.Exit })</ID>
    <ID>MaxLineLength:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>MaxLineLength:Node.kt$Node$ private fun registerDefaultExceptionHandler()</ID>
    <ID>MaxLineLength:Node.kt$Node$"Invalid p2pAddress: $p2pAddress contains 0.0.0.0 which is not suitable as an advertised node address"</ID>
    <ID>MaxLineLength:Node.kt$Node$"To disable autodetect set detectPublicIp = false in the node.conf, or consider using messagingServerAddress and messagingServerExternal"</ID>
    <ID>MaxLineLength:Node.kt$Node$ArtemisRpcBroker.withSsl(sslOptions, this.address, adminAddress, sslConfig!!, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell())</ID>
    <ID>MaxLineLength:Node.kt$Node$ArtemisRpcBroker.withoutSsl(sslOptions, this.address, adminAddress, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell())</ID>
    <ID>MaxLineLength:Node.kt$Node$CordaX500Name(commonName, null, organisation = "CORDA", locality = "London", state = null, country = "GB")</ID>
    <ID>MaxLineLength:Node.kt$Node$ObjectName("$domain:type=$category,${if (component.isNotEmpty()) "component=$component," else ""}name=$subName")</ID>
    <ID>MaxLineLength:Node.kt$Node$System.setProperty("h2.allowedClasses", "org.h2.mvstore.db.MVTableEngine,org.locationtech.jts.geom.Geometry,org.h2.server.TcpServer")</ID>
    <ID>MaxLineLength:Node.kt$Node$System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString())</ID>
    <ID>MaxLineLength:Node.kt$Node$cacheFactoryPrototype: BindableNamedCacheFactory = EnterpriseNamedCacheFactory(configuration.enterpriseConfiguration.getTracingConfig())</ID>
    <ID>MaxLineLength:Node.kt$Node$configuration.enterpriseConfiguration.messagingServerConnectionConfiguration == MessagingServerConnectionConfiguration.CONTINUOUS_RETRY</ID>
    <ID>MaxLineLength:Node.kt$Node$failoverCallback = { errorAndTerminate("ArtemisMessagingClient failed. Shutting down.", null) }</ID>
    <ID>MaxLineLength:Node.kt$Node$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(@Suppress("UNUSED_PARAMETER") smm: StateMachineManager, initiatedFlowClass: Class&lt;T&gt;)</ID>
    <ID>MaxLineLength:Node.kt$Node$if (configuration.shouldStartLocalShell()) RPCSecurityManagerWithAdditionalUser(this, User(INTERNAL_SHELL_USER, INTERNAL_SHELL_USER, setOf(Permissions.all()))) else this</ID>
    <ID>MaxLineLength:Node.kt$Node$log</ID>
    <ID>MaxLineLength:Node.kt$Node$log.info("Detected public IP: ${foundPublicIP.hostAddress}. This will be used instead of the provided \"$host\" as the advertised address.")</ID>
    <ID>MaxLineLength:Node.kt$Node$log.info("Retrieved public IP from Network Map Service: $this. This will be used instead of the provided \"$host\" as the advertised address.")</ID>
    <ID>MaxLineLength:Node.kt$Node$override</ID>
    <ID>MaxLineLength:Node.kt$Node$override fun myAddresses(): List&lt;NetworkHostAndPort&gt;</ID>
    <ID>MaxLineLength:Node.kt$Node$private</ID>
    <ID>MaxLineLength:Node.kt$Node$registerScheme(AMQPClientSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()))</ID>
    <ID>MaxLineLength:Node.kt$Node$registerScheme(AMQPServerSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()))</ID>
    <ID>MaxLineLength:Node.kt$Node$require(nodeInfo.legalIdentities.size in 1..2) { "Currently nodes must have a primary address and optionally one serviced address" }</ID>
    <ID>MaxLineLength:Node.kt$Node$rpcClientContext = if (configuration.shouldInitCrashShell()) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classloader) else null</ID>
    <ID>MaxLineLength:Node.kt$Node$serviceIdentity = if (nodeInfo.legalIdentities.size == 1) null else nodeInfo.legalIdentities[1].owningKey</ID>
    <ID>MaxLineLength:Node.kt$Node$throw CouldNotCreateDataSourceException("Database password is required for H2 server listening on ${InetAddress.getByName(effectiveH2Settings.address.host)}.")</ID>
    <ID>MaxLineLength:Node.kt$Node$val artemisSigningService = createArtemisSigningService(configuration, nodeInfo.legalIdentities[0].name.commonName, sslOptions)</ID>
    <ID>MaxLineLength:Node.kt$Node$val sslOptions = configuration.enterpriseConfiguration.messagingServerSslConfiguration ?: configuration.p2pSslOptions</ID>
    <ID>MaxLineLength:Node.kt$Node${ // Netty arenas are approx 16MB each when max'd out. Set arenas based on memory, not core count, unless memory is abundant. val memBasedArenas = max(Runtime.getRuntime().maxMemory() / 256.MB, 1L) // We set the min of the above and the default. System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString()) }</ID>
    <ID>MaxLineLength:Node.kt$Node${ check(!serverThread.isOnThread) synchronized(this) { if (shutdown) return shutdown = true // Unregister shutdown hook to prevent any unnecessary second calls to stop shutdownHook?.cancel() shutdownHook = null } printBasicNodeInfo("Shutting down ...") // All the Node started subsystems were registered with the runOnStop list at creation. // So now simply call the parent to stop everything in reverse order. // In particular this prevents premature shutdown of the Database by AbstractNode whilst the serverThread is active super.stop() shutdown = false log.info("Shutdown complete") }</ID>
    <ID>MaxLineLength:Node.kt$Node${ override fun createStartedNode(nodeInfo: NodeInfo, rpcOps: CordaRPCOps, notaryService: NotaryService?): NodeInfo = nodeInfo companion object { private val staticLog = contextLogger() var renderBasicInfoToConsole = true /** Used for useful info that we always want to show, even when not logging to the console */ fun printBasicNodeInfo(description: String, info: String? = null) { val msg = if (info == null) description else "${description.padEnd(40)}: $info" val loggerName = if (renderBasicInfoToConsole) "BasicInfo" else "Main" LoggerFactory.getLogger(loggerName).info(msg) } fun printInRed(message: String) { println("${ShellConstants.RED}$message${ShellConstants.RESET}") } fun printWarning(message: String) { Emoji.renderIfSupported { printInRed("${Emoji.warningSign} ATTENTION: $message") } staticLog.warn(message) } internal fun failStartUp(message: String): Nothing { println(message) println("Corda will now exit...") exitProcess(1) } private fun createClock(configuration: NodeConfiguration): CordaClock { return (if (configuration.useTestClock) ::DemoClock else ::SimpleClock)(Clock.systemUTC()) } private val sameVmNodeCounter = AtomicInteger() // TODO: make this configurable. const val MAX_RPC_MESSAGE_SIZE = 10485760 fun isInvalidJavaVersion(): Boolean { if (!hasMinimumJavaVersion()) { println("You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.") println("Corda will now exit...") return true } return false } private fun hasMinimumJavaVersion(): Boolean { // when the ext.java8_minUpdateVersion gradle constant changes, so must this check return try { val update = getJavaUpdateVersion(SystemUtils.JAVA_VERSION) // To filter out cases like 1.8.0_202-ea SystemUtils.IS_JAVA_1_8 &amp;&amp; update &gt;= 171 } catch (e: NumberFormatException) { // custom JDKs may not have the update version (e.g. 1.8.0-adoptopenjdk) false } } } override val log: Logger get() = staticLog override val transactionVerifierWorkerCount: Int get() = 4 private var internalRpcMessagingClient: InternalRPCMessagingClient&lt;RPCOps&gt;? = null private var rpcBroker: ArtemisBroker? = null private var shutdownHook: ShutdownHook? = null // DISCUSSION // // We use a single server thread for now, which means all message handling is serialized. // // Writing thread safe code is hard. In this project we are writing most node services and code to be thread safe, but // the possibility of mistakes is always present. Thus we make a deliberate decision here to trade off some multi-core // scalability in order to gain developer productivity by setting the size of the serverThread pool to one, which will // reduce the number of threading bugs we will need to tackle. // // This leaves us with four possibilities in future: // // (1) We discover that processing messages is fast and that our eventual use cases do not need very high // processing rates. We have benefited from the higher productivity and not lost anything. // // (2) We discover that we need greater multi-core scalability, but that the bulk of our time goes into particular CPU // hotspots that are easily multi-threaded e.g. signature checking. We successfully multi-thread those hotspots // and find that our software now scales sufficiently well to satisfy our user's needs. // // (3) We discover that it wasn't enough, but that we only need to run some messages in parallel and that the bulk of // the work can stay single threaded. For example perhaps we find that latency sensitive UI requests must be handled // on a separate thread pool where long blocking operations are not allowed, but that the bulk of the heavy lifting // can stay single threaded. In this case we would need a separate thread pool, but we still minimise the amount of // thread safe code we need to write and test. // // (4) None of the above are sufficient and we need to run all messages in parallel to get maximum (single machine) // scalability and fully saturate all cores. In that case we can go fully free-threaded, e.g. change the number '1' // below to some multiple of the core count. Alternatively by using the ForkJoinPool and let it figure out the right // number of threads by itself. This will require some investment in stress testing to build confidence that we // haven't made any mistakes, but it will only be necessary if eventual deployment scenarios demand it. // // Note that the messaging subsystem schedules work onto this thread in a blocking manner. That means if the server // thread becomes too slow and a backlog of work starts to builds up it propagates back through into the messaging // layer, which can then react to the backpressure. Artemis MQ in particular knows how to do flow control by paging // messages to disk rather than letting us run out of RAM. // // The primary work done by the server thread is execution of flow logics, and related // serialisation/deserialisation work. override fun makeMessagingService(): MessagingService { return P2PMessagingClient( config = configuration, versionInfo = versionInfo, serverAddress = configuration.messagingServerAddress ?: NetworkHostAndPort("localhost", configuration.p2pAddress.port), nodeExecutor = serverThread, database = database, networkMap = networkMapCache, isDrainingModeOn = nodeProperties.flowsDrainingMode::isEnabled, drainingModeWasChangedEvents = nodeProperties.flowsDrainingMode.values, metricRegistry = metricRegistry, cacheFactory = cacheFactory, platformClock = platformClock ) } override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters) { require(nodeInfo.legalIdentities.size in 1..2) { "Currently nodes must have a primary address and optionally one serviced address" } network as P2PMessagingClient if (System.getProperty("io.netty.allocator.numHeapArenas").isNullOrBlank()) { // Netty arenas are approx 16MB each when max'd out. Set arenas based on memory, not core count, unless memory is abundant. val memBasedArenas = max(Runtime.getRuntime().maxMemory() / 256.MB, 1L) // We set the min of the above and the default. System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString()) } // When using external Artemis for P2P messaging, the node's p2pSslOptions are no longer used. val sslOptions = configuration.enterpriseConfiguration.messagingServerSslConfiguration ?: configuration.p2pSslOptions val artemisSigningService = createArtemisSigningService(configuration, nodeInfo.legalIdentities[0].name.commonName, sslOptions) // Start up the Artemis signing service artemisSigningService?.apply { closeOnStop() setupArtemisSigningServiceProvider(this, sslOptions) start() } // Construct security manager reading users data either from the 'security' config section // if present or from rpcUsers list if the former is missing from config. val securityManagerConfig = configuration.security?.authService ?: SecurityConfiguration.AuthService.fromUsers(configuration.rpcUsers) val securityManager = with(RPCSecurityManagerImpl(securityManagerConfig, cacheFactory)) { if (configuration.shouldStartLocalShell()) RPCSecurityManagerWithAdditionalUser(this, User(INTERNAL_SHELL_USER, INTERNAL_SHELL_USER, setOf(Permissions.all()))) else this } val messageBroker = if (!configuration.messagingServerExternal) { val brokerBindAddress = configuration.messagingServerAddress ?: NetworkHostAndPort("0.0.0.0", configuration.p2pAddress.port) ArtemisMessagingServer(configuration, brokerBindAddress, networkParameters.maxMessageSize) } else { null } val rpcServerAddresses = if (configuration.rpcOptions.standAloneBroker) { BrokerAddresses(configuration.rpcOptions.address, configuration.rpcOptions.adminAddress) } else { startLocalRpcBroker(securityManager, sslOptions) } val bridgeControlListener = makeBridgeControlListener(network.serverAddress, networkParameters) printBasicNodeInfo("Advertised P2P messaging addresses", nodeInfo.addresses.joinToString()) val rpcServerConfiguration = RPCServerConfiguration.DEFAULT.copy( rpcThreadPoolSize = configuration.enterpriseConfiguration.tuning.rpcThreadPoolSize ) rpcServerAddresses?.let { internalRpcMessagingClient = InternalRPCMessagingClient(sslOptions, it.admin, MAX_RPC_MESSAGE_SIZE, configuration.myLegalName, rpcServerConfiguration, artemisSigningServiceName(sslOptions)) printBasicNodeInfo("RPC connection address", it.primary.toString()) printBasicNodeInfo("RPC admin connection address", it.admin.toString()) } // Start up the embedded MQ server messageBroker?.apply { closeOnStop() start() } rpcBroker?.apply { closeOnStop() start() } // Start P2P bridge service bridgeControlListener?.apply { closeOnStop() start() } // Start up the MQ clients. internalRpcMessagingClient?.run { closeOnStop() init(rpcOps, securityManager, cacheFactory) } network.closeOnStop() // Due to how Artemis treats HA client connections, special behaviour is required if using an HA locator (i.e. at least one back-up address) var retry: Boolean var delay = 1000L do { retry = false try { network.start( myIdentity = nodeInfo.legalIdentities[0].owningKey, serviceIdentity = if (nodeInfo.legalIdentities.size == 1) null else nodeInfo.legalIdentities[1].owningKey, advertisedAddress = nodeInfo.addresses[0], maxMessageSize = networkParameters.maxMessageSize, legalName = nodeInfo.legalIdentities[0].name.toString() ) } catch (e: Exception) { when (e) { is ActiveMQNotConnectedException -&gt; { if (configuration.enterpriseConfiguration.messagingServerBackupAddresses.isNotEmpty() &amp;&amp; configuration.enterpriseConfiguration.messagingServerConnectionConfiguration == MessagingServerConnectionConfiguration.CONTINUOUS_RETRY) { log.warn("Failed to connect to any messaging servers. Retrying.") // Clean-up any created bits before retry-ing network.stop() Thread.sleep(delay) delay = Math.min(2L * delay, 60000L) retry = true } else { throw e } // Preserve old behaviour } else -&gt; { throw e } // All other exceptions are thrown to cause the node to exit } } } while (retry) } private fun makeBridgeControlListener(serverAddress: NetworkHostAndPort, networkParameters: NetworkParameters) : BridgeControlListener? { val externalBridge = configuration.enterpriseConfiguration.externalBridge return if (externalBridge == null || !externalBridge) { val artemisClient = { ArtemisMessagingClient(configuration.p2pSslOptions, serverAddress, networkParameters.maxMessageSize, true, true, -1, configuration.enterpriseConfiguration.messagingServerConnectionConfiguration, configuration.enterpriseConfiguration.messagingServerBackupAddresses, failoverCallback = { errorAndTerminate("ArtemisMessagingClient failed. Shutting down.", null) }) } BridgeControlListener(configuration.p2pSslOptions.keyStore.get(), configuration.p2pSslOptions.trustStore.get(), configuration.p2pSslOptions.useOpenSsl, null, networkParameters.maxMessageSize, configuration.crlCheckSoftFail.toRevocationConfig(), configuration.enableSNI, artemisClient).apply { this.failure.subscribe { errorAndTerminate("BridgeControlListener has failed. Node must restart.") } } } else { null } } private fun setupArtemisSigningServiceProvider(artemisSigningService: TLSSigningService, sslOptions: MutualSslConfiguration) { val provider = Security.getProvider(DelegatedKeystoreProvider.PROVIDER_NAME) val delegatedKeystoreProvider = if (provider != null) { provider as DelegatedKeystoreProvider } else { DelegatedKeystoreProvider().apply { Security.addProvider(this) } } delegatedKeystoreProvider.putService(artemisSigningServiceName(sslOptions), artemisSigningService) } private fun createArtemisSigningService(config: NodeConfiguration, commonName: String?, sslOptions: MutualSslConfiguration): TLSSigningService { return CryptoServiceSigningService(config.enterpriseConfiguration.artemisCryptoServiceConfig, CordaX500Name(commonName, null, organisation = "CORDA", locality = "London", state = null, country = "GB"), sslOptions, config.sslHandshakeTimeout, name = "Artemis") } private fun startLocalRpcBroker(securityManager: RPCSecurityManager, sslOptions: MutualSslConfiguration): BrokerAddresses? { return with(configuration) { rpcOptions.address.let { val rpcBrokerDirectory: Path = baseDirectory / "brokers" / "rpc" with(rpcOptions) { rpcBroker = if (useSsl) { ArtemisRpcBroker.withSsl(sslOptions, this.address, adminAddress, sslConfig!!, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell()) } else { ArtemisRpcBroker.withoutSsl(sslOptions, this.address, adminAddress, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell()) } } rpcBroker!!.addresses } } } override fun myAddresses(): List&lt;NetworkHostAndPort&gt; = listOf(getAdvertisedAddress()) + configuration.additionalP2PAddresses private fun getAdvertisedAddress(): NetworkHostAndPort { return with(configuration) { if (relay != null) { NetworkHostAndPort(relay!!.relayHost, relay!!.remoteInboundPort) } else { require(p2pAddress.host != "0.0.0.0") { "Invalid p2pAddress: $p2pAddress contains 0.0.0.0 which is not suitable as an advertised node address" } val host = if (detectPublicIp) { tryDetectIfNotPublicHost(p2pAddress.host) ?: p2pAddress.host } else { p2pAddress.host } NetworkHostAndPort(host, p2pAddress.port) } } } /** * Checks whether the specified [host] is a public IP address or hostname. If not, tries to discover the current * machine's public IP address to be used instead by looking through the network interfaces. */ private fun tryDetectIfNotPublicHost(host: String): String? { return if (host.toLowerCase() == "localhost") { log.warn("p2pAddress specified as localhost. Trying to autodetect a suitable public address to advertise in network map." + "To disable autodetect set detectPublicIp = false in the node.conf, or consider using messagingServerAddress and messagingServerExternal") val foundPublicIP = AddressUtils.tryDetectPublicIP() if (foundPublicIP == null) { try { val retrievedHostName = networkMapClient?.myPublicHostname() if (retrievedHostName != null) { log.info("Retrieved public IP from Network Map Service: $this. This will be used instead of the provided \"$host\" as the advertised address.") } retrievedHostName } catch (ignore: Exception) { // Cannot reach the network map service, ignore the exception and use provided P2P address instead. log.warn("Cannot connect to the network map service for public IP detection.") null } } else { log.info("Detected public IP: ${foundPublicIP.hostAddress}. This will be used instead of the provided \"$host\" as the advertised address.") foundPublicIP.hostAddress } } else { null } } /** * If the node is persisting to an embedded H2 database, then expose this via TCP with a DB URL of the form: * jdbc:h2:tcp://&lt;host&gt;:&lt;port&gt;/node * with username and password as per the DataSource connection details. The key element to enabling this support is to * ensure that you specify a DB connection URL of the form jdbc:h2:file: in the node config and that you include * the H2 option AUTO_SERVER_PORT set to the port you desire to use (0 will give a dynamically allocated port number) * but exclude the H2 option AUTO_SERVER=TRUE. * This is not using the H2 "automatic mixed mode" directly but leans on many of the underpinnings. For more details * on H2 URLs and configuration see: http://www.h2database.com/html/features.html#database_url */ override fun startDatabase() { val databaseUrl = configuration.dataSourceProperties.getProperty("dataSource.url") val h2Prefix = "jdbc:h2:file:" if (databaseUrl != null &amp;&amp; databaseUrl.startsWith(h2Prefix)) { val effectiveH2Settings = configuration.effectiveH2Settings //forbid execution of arbitrary code via SQL except those classes required by H2 itself System.setProperty("h2.allowedClasses", "org.h2.mvstore.db.MVTableEngine,org.locationtech.jts.geom.Geometry,org.h2.server.TcpServer") if (effectiveH2Settings?.address != null) { if (!InetAddress.getByName(effectiveH2Settings.address.host).isLoopbackAddress &amp;&amp; configuration.dataSourceProperties.getProperty("dataSource.password").isBlank()) { throw CouldNotCreateDataSourceException("Database password is required for H2 server listening on ${InetAddress.getByName(effectiveH2Settings.address.host)}.") } val databaseName = databaseUrl.removePrefix(h2Prefix).substringBefore(';') val baseDir = Paths.get(databaseName).parent.toString() val server = org.h2.tools.Server.createTcpServer( "-tcpPort", effectiveH2Settings.address.port.toString(), "-tcpAllowOthers", "-tcpDaemon", "-baseDir", baseDir, "-key", "node", databaseName) // override interface that createTcpServer listens on (which is always 0.0.0.0) System.setProperty("h2.bindAddress", effectiveH2Settings.address.host) runOnStop += server::stop val url = try { server.start().url } catch (e: JdbcSQLNonTransientConnectionException) { if (e.cause is BindException) { throw AddressBindingException(effectiveH2Settings.address) } else { throw e } } printBasicNodeInfo("Database connection url is", "jdbc:h2:$url/node") } } else if (databaseUrl != null) { printBasicNodeInfo("Database connection url is", databaseUrl) } super.startDatabase() database.closeOnStop() } private val _startupComplete = openFuture&lt;Unit&gt;() val startupComplete: CordaFuture&lt;Unit&gt; get() = _startupComplete override fun generateAndSaveNodeInfo(): NodeInfo { initialiseSerialization() return super.generateAndSaveNodeInfo() } override fun start(): NodeInfo { registerDefaultExceptionHandler() initialiseSerialization() val nodeInfo: NodeInfo = super.start() nodeReadyFuture.thenMatch({ serverThread.execute { registerJmxReporter(services.monitoringService.metrics) _startupComplete.set(Unit) } }, { th -&gt; staticLog.error("Unexpected exception", th) } // XXX: Why not use log? ) shutdownHook = addShutdownHook { stop() } return nodeInfo } /** * Register a default exception handler for all threads that terminates the process if the database connection goes away and * cannot be recovered. */ private fun registerDefaultExceptionHandler() { Thread.setDefaultUncaughtExceptionHandler(DbExceptionHandler(Thread.getDefaultUncaughtExceptionHandler())) } /** * A hook to allow configuration override of the JmxReporter being used. */ fun registerJmxReporter(metrics: MetricRegistry) { log.info("Registering JMX reporter:") when (configuration.jmxReporterType) { JmxReporterType.JOLOKIA -&gt; registerJolokiaReporter(metrics) JmxReporterType.NEW_RELIC -&gt; registerNewRelicReporter(metrics) } } private fun registerJolokiaReporter(registry: MetricRegistry) { log.info("Registering Jolokia JMX reporter:") // Begin exporting our own metrics via JMX. These can be monitored using any agent, e.g. Jolokia: // // https://jolokia.org/agent/jvm.html JmxReporter.forRegistry(registry).inDomain("net.corda").createsObjectNamesWith { _, domain, name -&gt; // Make the JMX hierarchy a bit better organised. val category = name.substringBefore('.').substringBeforeLast('/') val component = name.substringBefore('.').substringAfterLast('/', "") val subName = name.substringAfter('.', "") (if (subName == "") ObjectName("$domain:name=$category${if (component.isNotEmpty()) ",component=$component," else ""}") else ObjectName("$domain:type=$category,${if (component.isNotEmpty()) "component=$component," else ""}name=$subName")) }.build().start() } private fun registerNewRelicReporter(registry: MetricRegistry) { log.info("Registering New Relic JMX Reporter:") val reporter = NewRelicReporter.forRegistry(registry) .name("New Relic Reporter") .filter(MetricFilter.ALL) .attributeFilter(AllEnabledMetricAttributeFilter()) .rateUnit(TimeUnit.SECONDS) .durationUnit(TimeUnit.MILLISECONDS) .metricNamePrefix("corda/") .build() reporter.start(1, TimeUnit.MINUTES) } override val rxIoScheduler: Scheduler get() = Schedulers.io() private fun initialiseSerialization() { if (!initialiseSerialization) return val classloader = cordappLoader.appClassLoader nodeSerializationEnv = SerializationEnvironment.with( SerializationFactoryImpl().apply { registerScheme(AMQPServerSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap())) registerScheme(AMQPClientSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap())) }, p2pContext = AMQP_P2P_CONTEXT.withClassLoader(classloader), rpcServerContext = AMQP_RPC_SERVER_CONTEXT.withClassLoader(classloader), rpcClientContext = if (configuration.shouldInitCrashShell()) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classloader) else null, //even Shell embeded in the node connects via RPC to the node storageContext = AMQP_STORAGE_CONTEXT.withClassLoader(classloader), checkpointSerializer = KryoCheckpointSerializer, checkpointContext = KRYO_CHECKPOINT_CONTEXT.withClassLoader(classloader) ) } /** Starts a blocking event loop for message dispatch. */ fun run() { internalRpcMessagingClient?.start(rpcBroker!!.serverControl) (network as P2PMessagingClient).run() } private var shutdown = false override fun stop() { check(!serverThread.isOnThread) synchronized(this) { if (shutdown) return shutdown = true // Unregister shutdown hook to prevent any unnecessary second calls to stop shutdownHook?.cancel() shutdownHook = null } printBasicNodeInfo("Shutting down ...") // All the Node started subsystems were registered with the runOnStop list at creation. // So now simply call the parent to stop everything in reverse order. // In particular this prevents premature shutdown of the Database by AbstractNode whilst the serverThread is active super.stop() shutdown = false log.info("Shutdown complete") } fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(@Suppress("UNUSED_PARAMETER") smm: StateMachineManager, initiatedFlowClass: Class&lt;T&gt;) { this.flowManager.registerInitiatedFlow(initiatedFlowClass) } }</ID>
    <ID>MaxLineLength:Node.kt$Node${ require(nodeInfo.legalIdentities.size in 1..2) { "Currently nodes must have a primary address and optionally one serviced address" } network as P2PMessagingClient if (System.getProperty("io.netty.allocator.numHeapArenas").isNullOrBlank()) { // Netty arenas are approx 16MB each when max'd out. Set arenas based on memory, not core count, unless memory is abundant. val memBasedArenas = max(Runtime.getRuntime().maxMemory() / 256.MB, 1L) // We set the min of the above and the default. System.setProperty("io.netty.allocator.numHeapArenas", min(memBasedArenas, NettyRuntime.availableProcessors() * 2L).toString()) } // When using external Artemis for P2P messaging, the node's p2pSslOptions are no longer used. val sslOptions = configuration.enterpriseConfiguration.messagingServerSslConfiguration ?: configuration.p2pSslOptions val artemisSigningService = createArtemisSigningService(configuration, nodeInfo.legalIdentities[0].name.commonName, sslOptions) // Start up the Artemis signing service artemisSigningService?.apply { closeOnStop() setupArtemisSigningServiceProvider(this, sslOptions) start() } // Construct security manager reading users data either from the 'security' config section // if present or from rpcUsers list if the former is missing from config. val securityManagerConfig = configuration.security?.authService ?: SecurityConfiguration.AuthService.fromUsers(configuration.rpcUsers) val securityManager = with(RPCSecurityManagerImpl(securityManagerConfig, cacheFactory)) { if (configuration.shouldStartLocalShell()) RPCSecurityManagerWithAdditionalUser(this, User(INTERNAL_SHELL_USER, INTERNAL_SHELL_USER, setOf(Permissions.all()))) else this } val messageBroker = if (!configuration.messagingServerExternal) { val brokerBindAddress = configuration.messagingServerAddress ?: NetworkHostAndPort("0.0.0.0", configuration.p2pAddress.port) ArtemisMessagingServer(configuration, brokerBindAddress, networkParameters.maxMessageSize) } else { null } val rpcServerAddresses = if (configuration.rpcOptions.standAloneBroker) { BrokerAddresses(configuration.rpcOptions.address, configuration.rpcOptions.adminAddress) } else { startLocalRpcBroker(securityManager, sslOptions) } val bridgeControlListener = makeBridgeControlListener(network.serverAddress, networkParameters) printBasicNodeInfo("Advertised P2P messaging addresses", nodeInfo.addresses.joinToString()) val rpcServerConfiguration = RPCServerConfiguration.DEFAULT.copy( rpcThreadPoolSize = configuration.enterpriseConfiguration.tuning.rpcThreadPoolSize ) rpcServerAddresses?.let { internalRpcMessagingClient = InternalRPCMessagingClient(sslOptions, it.admin, MAX_RPC_MESSAGE_SIZE, configuration.myLegalName, rpcServerConfiguration, artemisSigningServiceName(sslOptions)) printBasicNodeInfo("RPC connection address", it.primary.toString()) printBasicNodeInfo("RPC admin connection address", it.admin.toString()) } // Start up the embedded MQ server messageBroker?.apply { closeOnStop() start() } rpcBroker?.apply { closeOnStop() start() } // Start P2P bridge service bridgeControlListener?.apply { closeOnStop() start() } // Start up the MQ clients. internalRpcMessagingClient?.run { closeOnStop() init(rpcOps, securityManager, cacheFactory) } network.closeOnStop() // Due to how Artemis treats HA client connections, special behaviour is required if using an HA locator (i.e. at least one back-up address) var retry: Boolean var delay = 1000L do { retry = false try { network.start( myIdentity = nodeInfo.legalIdentities[0].owningKey, serviceIdentity = if (nodeInfo.legalIdentities.size == 1) null else nodeInfo.legalIdentities[1].owningKey, advertisedAddress = nodeInfo.addresses[0], maxMessageSize = networkParameters.maxMessageSize, legalName = nodeInfo.legalIdentities[0].name.toString() ) } catch (e: Exception) { when (e) { is ActiveMQNotConnectedException -&gt; { if (configuration.enterpriseConfiguration.messagingServerBackupAddresses.isNotEmpty() &amp;&amp; configuration.enterpriseConfiguration.messagingServerConnectionConfiguration == MessagingServerConnectionConfiguration.CONTINUOUS_RETRY) { log.warn("Failed to connect to any messaging servers. Retrying.") // Clean-up any created bits before retry-ing network.stop() Thread.sleep(delay) delay = Math.min(2L * delay, 60000L) retry = true } else { throw e } // Preserve old behaviour } else -&gt; { throw e } // All other exceptions are thrown to cause the node to exit } } } while (retry) }</ID>
    <ID>MaxLineLength:Node.kt$Node.Companion$println("You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.")</ID>
    <ID>MaxLineLength:Node.kt$Node.Companion${ val update = getJavaUpdateVersion(SystemUtils.JAVA_VERSION) // To filter out cases like 1.8.0_202-ea SystemUtils.IS_JAVA_1_8 &amp;&amp; update &gt;= 171 }</ID>
    <ID>MaxLineLength:Node.kt$NodeWithInfo$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatedFlowClass: Class&lt;T&gt;)</ID>
    <ID>MaxLineLength:Node.kt$NodeWithInfo$val services: StartedNodeServices = object : StartedNodeServices, ServiceHubInternal by node.services, FlowStarter by node.flowStarter {}</ID>
    <ID>MaxLineLength:NodeAdder.kt$NodeAdder$?:</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$/** * This caches contract attachment versions by contract class name. For each version, we support one signed and one unsigned attachment, since that is allowed. * * It is correctly invalidated as new attachments are uploaded. */ private val contractsCache = InfrequentlyMutatedCache&lt;ContractClassName, NavigableMap&lt;Version, AttachmentIds&gt;&gt;("NodeAttachmentService_contractAttachmentVersions", cacheFactory)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$// TODO do not retrieve whole attachments only to return ids - https://r3-cev.atlassian.net/browse/CORDA-3191 raised to address this override fun queryAttachments(criteria: AttachmentQueryCriteria, sorting: AttachmentSort?): List&lt;AttachmentId&gt;</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$HashCheckingStream : FilterInputStream</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$HashMismatchException : CordaRuntimeException</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$detailedLogger.trace { "Attachment(action=query_version_end;type=contract;className=$contractClassName;criteria=$attachmentQueryCriteria)" }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$detailedLogger.trace { "Attachment(action=query_version_start;type=contract;className=$contractClassName;criteria=$attachmentQueryCriteria)" }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$detailedLogger.trace { "Attachment(action=store_created;id=$id;filename=$filename;uploader=$uploader)" }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$detailedLogger.trace { "Attachment(action=store_updated;id=$id;filename=$filename;uploader=$uploader)" }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("(Dev Mode) Multiple signed attachments ${signed.map { it.toString() }} for contract $contractClassName version '${it.key}'.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("Selecting attachment ${unsigned.first()} from duplicated, unsigned attachments ${unsigned.map { it.toString() }} for contract $contractClassName version '${it.key}'.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("Several versions based on whitelistedContractImplementations position are available: ${versions.toSet()}. $msg")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$private</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$require(inputStream !is JarInputStream) { "Input stream must not be a JarInputStream" } // Read the file into RAM and then calculate its hash. The attachment must fit into memory. // TODO: Switch to a two-phase insert so we can handle attachments larger than RAM. // To do this we must pipe stream into the database without knowing its hash, which we will learn only once // the insert/upload is complete. We can then query to see if it's a duplicate and if so, erase, and if not // set the hash field of the new attachment record. val bytes = inputStream.readFully() val id = bytes.sha256() detailedLogger.trace { "Attachment(action=store_start;id=$id;filename=$filename;uploader=$uploader)"} if (!hasAttachment(id)) { checkIsAValidJAR(bytes.inputStream()) val jarSigners = getSigners(bytes) val contractVersion = increaseDefaultVersionIfWhitelistedAttachment(contractClassNames, getVersion(bytes), id) val session = currentDBSession() val attachment = NodeAttachmentService.DBAttachment( attId = id.toString(), content = bytes, uploader = uploader, filename = filename, contractClassNames = contractClassNames, signers = jarSigners, version = contractVersion ) session.save(attachment) attachmentCount.inc() log.info("Stored new attachment: id=$id uploader=$uploader filename=$filename") detailedLogger.trace { "Attachment(action=store_created;id=$id;filename=$filename;uploader=$uploader)" } contractClassNames.forEach { contractsCache.invalidate(it) } return@withContractsInJar id } if (isUploaderTrusted(uploader)) { val session = currentDBSession() val attachment = session.get(NodeAttachmentService.DBAttachment::class.java, id.toString()) // update the `uploader` field (as the existing attachment may have been resolved from a peer) if (attachment.uploader != uploader) { attachment.uploader = uploader log.info("Updated attachment $id with uploader $uploader") detailedLogger.trace { "Attachment(action=store_updated;id=$id;filename=$filename;uploader=$uploader)" } contractClassNames.forEach { contractsCache.invalidate(it) } loadAttachmentContent(id)?.let { attachmentAndContent -&gt; // TODO: this is racey. ENT-2870 attachmentContentCache.put(id, Optional.of(attachmentAndContent)) attachmentCache.put(id, Optional.of(attachmentAndContent.first)) } return@withContractsInJar id } // If the uploader is the same, throw the exception because the attachment cannot be overridden by the same uploader. } throw DuplicateAttachmentException(id.toString())</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val contractVersion = increaseDefaultVersionIfWhitelistedAttachment(contractClassNames, getVersion(bytes), id)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val versions = contractClassNames.mapNotNull { servicesForResolution.networkParameters.whitelistedContractImplementations[it]?.indexOf(attachmentId) } .filter { it &gt;= 0 }.map { it + 1 } // +1 as versions starts from 1 not 0</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$weigher = Weigher&lt;SecureHash, Optional&lt;Pair&lt;Attachment, ByteArray&gt;&gt;&gt; { key, value -&gt; key.size + if (value.isPresent) value.get().second.size else 0 }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService${ val session = currentDBSession() val attachment = session.get(NodeAttachmentService.DBAttachment::class.java, id.toString()) // update the `uploader` field (as the existing attachment may have been resolved from a peer) if (attachment.uploader != uploader) { attachment.uploader = uploader log.info("Updated attachment $id with uploader $uploader") detailedLogger.trace { "Attachment(action=store_updated;id=$id;filename=$filename;uploader=$uploader)" } contractClassNames.forEach { contractsCache.invalidate(it) } loadAttachmentContent(id)?.let { attachmentAndContent -&gt; // TODO: this is racey. ENT-2870 attachmentContentCache.put(id, Optional.of(attachmentAndContent)) attachmentCache.put(id, Optional.of(attachmentAndContent.first)) } return@withContractsInJar id } // If the uploader is the same, throw the exception because the attachment cannot be overridden by the same uploader. }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.AttachmentImpl$return if (checkOnLoad &amp;&amp; id is SecureHash.SHA256) HashCheckingStream(id, attachmentData.size, stream) else stream</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$// Just iterate over the entries with verification enabled: should be good enough to catch mistakes. // Note that JarInputStream won't throw any kind of error at all if the file stream is in fact not // a ZIP! It'll just pretend it's an empty archive, which is kind of stupid but that's how it works. // So we have to check to ensure we found at least one item. // // For signed Jars add additional checks to close security holes left by the default jarSigner verifier: // - All entries listed in the Manifest are in the JAR file. // - No extra files in the JAR that were not listed in the Manifest. // Together with the check that all entries need to be signed by the same signers that is performed when the signers are read, // it should close any possibility of foul play. internal fun checkIsAValidJAR(stream: InputStream)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$if (manifestHasEntries &amp;&amp; !allManifestEntries!!.remove(cursor.name)) extraFilesNotFoundInEntries.add(cursor)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$private val PRIVILEGED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, P2P_UPLOADER, UNKNOWN_UPLOADER)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$require(!('\\' in cursor.name || cursor.name == "." || cursor.name == "..")) { "Bad character in $entryPath" }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$throw SecurityException("Signed jar has been tampered with. Files ${allManifestEntries} have been removed.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$throw SecurityException("Signed jar has been tampered with. Files ${extraSignableFiles} have been added to the JAR.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.Companion$val extraSignableFiles = extraFilesNotFoundInEntries.filterNot { JarSignatureCollector.isNotSignable(it) }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$( @Id @Column(name = "att_id", nullable = false) var attId: String, @Column(name = "content", nullable = false) @Lob var content: ByteArray, @Column(name = "insertion_date", nullable = false, updatable = false) var insertionDate: Instant = Instant.now(), @Column(name = "uploader", nullable = true) var uploader: String? = null, @Column(name = "filename", updatable = false, nullable = true) var filename: String? = null, @ElementCollection @Column(name = "contract_class_name", nullable = false) @CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_contracts", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__ctr_class__attachments")) var contractClassNames: List&lt;ContractClassName&gt;? = null, @ElementCollection(targetClass = PublicKey::class, fetch = FetchType.EAGER) @Column(name = "signer", nullable = false) @CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_signers", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__signers__attachments")) var signers: List&lt;PublicKey&gt;? = null, // Assumption: only Contract Attachments are versioned, version unknown or value for other attachments other than Contract Attachment defaults to 1 @Column(name = "version", nullable = false) var version: Int = DEFAULT_CORDAPP_VERSION )</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$@CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_contracts", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__ctr_class__attachments"))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$@CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_signers", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__signers__attachments"))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.HashCheckingStream$private val stream: HashingInputStream = HashingInputStream(Hashing.sha256(), counter)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$(uploaderCondition("complexB").and(filenamerCondition("archiveB.zip"))).or(filenamerCondition("archiveC.zip"))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `The strict JAR verification function fails signed JARs with removed or extra files that are valid according to the usual jarsigner`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing a single public key`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing multiple public keys`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can import duplicated contract class and version from signed attachment if an unsigned attachment already exists`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can import duplicated contract class and version from unsigned attachment if a signed attachment already exists`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can import jar with duplicated contract class, version and signers - when one uploader is trusted and other isnt`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `can promote to trusted uploader if other trusted attachment already has duplicated contract class, version and signers`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `development mode - retrieve latest versions of signed contracts - multiple versions of same version id exist in store`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION)))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertEquals(listOf(jarAndSigner.second.hash), storage.openAttachment(attachmentId)!!.signerKeys.map { it.hash })</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThat((storage.openAttachment(expectedAttachmentId) as ContractAttachment).uploader).isEqualTo(initialUploader)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThat((storage.openAttachment(expectedAttachmentId) as ContractAttachment).uploader).isEqualTo(trustedUploader)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThatThrownBy { attachment.read { storage.privilegedImportAttachment(it, untrustedUploader, null) } }.isInstanceOf(DuplicateAttachmentException::class.java)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract", "com.example.AnotherContract"))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$contractJarV2.read { attachmentIdV2Unsigned = storage.privilegedImportAttachment(it, "app", "contract-V2.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$fun filenameSort(direction: Sort.Direction)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJar.read { attachmentIdV1Signed = storage.privilegedImportAttachment(it, "app", "contract-signed.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJarSameVersion.read { attachmentIdSameVersionLatest = devModeStorage.privilegedImportAttachment(it, "app", "contract-signed-same-version.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJarV2.read { attachmentIdV2Signed = storage.privilegedImportAttachment(it, "app", "contract-signed-V2.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$storage.queryAttachments(AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract")))).size</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$storage.queryAttachments(AttachmentsQueryCriteria(signersCondition = Builder.equal(listOf(publicKey)))).size</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val (signedContractJarSameVersion, _) = makeTestSignedContractJar(file.path,"com.example.MyContract", versionSeed = Random().nextInt())</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherAttachmentId = anotherContractJar.read { storage.privilegedImportAttachment(it, "app", "another-sample.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherContractJar = makeTestContractJar(file.path, listOf( "com.example.MyContract", "com.example.AnotherContract"), generateManifest = false, jarFileName = "another-sample.jar")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherContractJar = makeTestContractJar(file.path, listOf( "com.example.MyContract", "com.example.AnotherContract"), true, generateManifest = false, jarFileName = "another-sample.jar")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val attachments = storage.queryAttachments(AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract"))))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val corruptAttachment = NodeAttachmentService.DBAttachment(attId = id.toString(), content = bytes, version = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val overriddenAttachmentId = attachment.read { storage.privilegedImportAttachment(it, trustedUploader, null) }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val reimportedAttachmentId = contractJar.read { storage.privilegedImportAttachment(it, "app", "sample.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val signedAttachments = storage.queryAttachments(AttachmentsQueryCriteria(isSignedCondition = Builder.equal(true)))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val unsignedAttachments = storage.queryAttachments(AttachmentsQueryCriteria(isSignedCondition = Builder.equal(false)))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest.FetchAttachmentsFlow$serviceHub.attachments.importAttachment(baos.toByteArray().inputStream(), "$P2P_UPLOADER:${ourIdentity.name}", null)</ID>
    <ID>MaxLineLength:NodeAttachmentTrustCalculator.kt$NodeAttachmentTrustCalculator : AttachmentTrustCalculatorSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:NodeAttachmentTrustCalculator.kt$NodeAttachmentTrustCalculator$( // `isSignedCondition` is not included here as attachments uploaded by trusted uploaders are considered trusted AttachmentQueryCriteria.AttachmentsQueryCriteria( uploaderCondition = Builder.`in`( TRUSTED_UPLOADERS ) ) )</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$InProcessNode : EnterpriseNode</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$InProcessNode$assertFalse(isInvalidJavaVersion(), "You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8." )</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$NodeBasedTest : IntegrationTest</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$NodeBasedTest$abstract</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$NodeBasedTest$val customCordapps = cordappsForPackages(getCallerPackage(NodeBasedTest::class)?.let { cordappPackages + it } ?: cordappPackages)</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder$localDockerClient.buildImageCmd() .withDockerfile(File(nodeDir, "Dockerfile")) .withBaseDirectory(nodeDir)</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder.&lt;no name provided&gt;$future.completeExceptionally(IllegalStateException("Could not build image for: $nodeDir, reason: ${result?.errorDetail}"))</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder.&lt;no name provided&gt;$val config = nodeConfig.parseAsNodeConfigWithFallback(ConfigFactory.parseFile(copiedNode.configFile)).value()</ID>
    <ID>MaxLineLength:NodeBuilder.kt$fun Config.parseAsNodeConfigWithFallback(preCopyConfig: Config): Validated&lt;NodeConfiguration, Configuration.Validation.Error&gt;</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$InitialRegistrationCmdLineOptions$"Cannot perform initial registration when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true."</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$InitialRegistrationCmdLineOptions$"compatibilityZoneURL or networkServices must be present in the node configuration file in registration mode."</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$"compatibilityZoneURL or networkServices must be present in the node configuration file in registration mode."</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Clears local copy of network map, on node startup it will be restored from server or file system."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Performs the node start-up tasks necessary to generate the nodeInfo file, saves it to disk, then exits."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Starts initial node registration with Corda network to obtain certificate from the permissioning server."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$valid(ConfigHelper.loadConfig(baseDirectory, configFile, configOverrides = ConfigFactory.parseMap(configOverrides)))</ID>
    <ID>MaxLineLength:NodeConfig.kt$NodeConfig$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:NodeConfig.kt$NodeConfig$return NodeConfigurationData(myLegalName, p2pAddress, this.rpcSettings.address, notary, h2port, rpcUsers, useTestClock, detectPublicIp, devMode) .toConfig() .withoutPath("rpcAddress") .withoutPath("rpcAdminAddress") .withValue("rpcSettings", rpcSettings)</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$CertChainPolicyConfig$@Deprecated("Do not use") data</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$DevModeOptions$data</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NetworkParameterAcceptanceSettings</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NetworkServicesConfig</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NodeConfiguration$@Deprecated(message = "Use of single compatibility zone URL is deprecated", replaceWith = ReplaceWith("networkServices.networkMapURL"))</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$NodeConfiguration$val flowMonitorSuspensionLoggingThresholdMillis: Duration get() = DEFAULT_FLOW_MONITOR_SUSPENSION_LOGGING_THRESHOLD_MILLIS</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$SecurityConfiguration.AuthService.DataSource$AuthDataSourceType.DB -&gt; require(users == null &amp;&amp; connection != null) { "Database-backed authentication must not specify a user list, and must configure a database" }</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$SecurityConfiguration.AuthService.DataSource$AuthDataSourceType.INMEMORY -&gt; require(users != null &amp;&amp; connection == null) { "In-memory authentication must specify a user list, and must not configure a database" }</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$fun Config.parseAsNodeConfiguration(options: Configuration.Options = Configuration.Options(strict = true)): Valid&lt;NodeConfiguration&gt;</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$// TODO: There are two implications here: // 1. "signingCertificateStore" and "p2pKeyStore" have the same passwords. In the future we should re-visit this "rule" and see of they can be made different; // 2. The passwords for store and for keys in this store are the same, this is due to limitations of Artemis. override val signingCertificateStore = FileBasedCertificateStoreSupplier(signingCertificateStorePath, keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$@Suppress("DEPRECATION") @Deprecated("Do not configure") override</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$dataSourceProperties[CordaPersistence.DataSourceConfigTag.DATA_SOURCE_URL] = "$dataSourceUrl;sendStringParametersAsUnicode=false"</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$errors += "cannot enable network proxy by specifying 'networkServices.proxyType' without providing 'networkServices.proxyAddress'"</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$if (networkServices != null &amp;&amp; networkServices!!.proxyType != Proxy.Type.DIRECT &amp;&amp; networkServices!!.proxyAddress == null) { errors += "cannot enable network proxy by specifying 'networkServices.proxyType' without providing 'networkServices.proxyAddress'" }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$logger</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$logger.warn("Top-level declaration of property 'rpcAddress' is deprecated. Please use 'rpcSettings.address' instead.")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override val flowMonitorSuspensionLoggingThresholdMillis: Duration = Defaults.flowMonitorSuspensionLoggingThresholdMillis</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override val networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings = Defaults.networkParameterAcceptanceSettings</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$private val p2pTrustStore = FileBasedCertificateStoreSupplier(p2pTrustStoreFilePath, trustStorePassword, trustStorePassword)</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(dataSourceProperties["autoCommit"] != true) { "Datbase auto commit cannot be enabled, Corda requires transactional behaviour" }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(enterpriseConfiguration.messagingServerSslConfiguration != null) { "Missing SSL configuration required by broker connection." }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(h2port == null || h2Settings == null) { "Cannot specify both 'h2port' and 'h2Settings' in configuration" }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(rpcSettings.address == null) { "Can't provide top-level rpcAddress and rpcSettings.address (they control the same property)." }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$return listOf("cannot specify 'compatibilityZoneURL' when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$return listOf("cannot specify 'networkServices' when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$val requiredThreadPoolSize = enterpriseConfiguration.tuning.flowThreadPoolSize + enterpriseConfiguration.tuning.rpcThreadPoolSize + 2</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl${ actualRpcSettings = when { rpcAddress != null -&gt; { require(rpcSettings.address == null) { "Can't provide top-level rpcAddress and rpcSettings.address (they control the same property)." } logger.warn("Top-level declaration of property 'rpcAddress' is deprecated. Please use 'rpcSettings.address' instead.") rpcSettings.copy(address = rpcAddress) } else -&gt; { rpcSettings.address ?: throw ConfigException.Missing("rpcSettings.address") rpcSettings } } // This is a sanity feature do not remove. require(!useTestClock || devMode) { "Cannot use test clock outside of dev mode" } require(devModeOptions == null || devMode) { "Cannot use devModeOptions outside of dev mode" } require(security == null || rpcUsers.isEmpty()) { "Cannot specify both 'rpcUsers' and 'security' in configuration" } // ensure our datasource configuration is sane require(dataSourceProperties["autoCommit"] != true) { "Datbase auto commit cannot be enabled, Corda requires transactional behaviour" } dataSourceProperties["autoCommit"] = false if (dataSourceProperties["transactionIsolation"] == null) { dataSourceProperties["transactionIsolation"] = database.transactionIsolationLevel.jdbcString } // enforce that SQLServer does not get sent all strings as Unicode - hibernate handles this "cleverly" val dataSourceUrl = dataSourceProperties.getProperty(CordaPersistence.DataSourceConfigTag.DATA_SOURCE_URL, "") if (dataSourceUrl.contains(":sqlserver:") &amp;&amp; !dataSourceUrl.contains("sendStringParametersAsUnicode", true)) { dataSourceProperties[CordaPersistence.DataSourceConfigTag.DATA_SOURCE_URL] = "$dataSourceUrl;sendStringParametersAsUnicode=false" } // Adjust connection pool size depending on N=flow thread pool size + rpc thread pool size + scheduler thread + network map updater thread. // If there is no configured pool size set it to N + 1, otherwise check that it's greater than N. val requiredThreadPoolSize = enterpriseConfiguration.tuning.flowThreadPoolSize + enterpriseConfiguration.tuning.rpcThreadPoolSize + 2 val maxConnectionPoolSize = dataSourceProperties.getProperty("maximumPoolSize") if (maxConnectionPoolSize == null) { dataSourceProperties.setProperty("maximumPoolSize", (requiredThreadPoolSize + 1).toString()) } else { require(maxConnectionPoolSize.toInt() &gt; requiredThreadPoolSize) } @Suppress("DEPRECATION") if (certificateChainCheckPolicies.isNotEmpty()) { logger.warn("""You are configuring certificateChainCheckPolicies. This is a setting that is not used, and will be removed in a future version. |Please contact the R3 team on the public Slack to discuss your use case. """.trimMargin()) } if (messagingServerExternal &amp;&amp; messagingServerAddress != null) { require(enterpriseConfiguration.messagingServerSslConfiguration != null) { "Missing SSL configuration required by broker connection." } } // Support the deprecated method of configuring network services with a single compatibilityZoneURL option @Suppress("DEPRECATION") if (compatibilityZoneURL != null &amp;&amp; networkServices == null) { networkServices = NetworkServicesConfig(compatibilityZoneURL, compatibilityZoneURL, inferred = true) } require(h2port == null || h2Settings == null) { "Cannot specify both 'h2port' and 'h2Settings' in configuration" } }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$initialiseAppSchema = if(devMode) SchemaInitializationType.UPDATE else SchemaInitializationType.VALIDATE</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$val flowMonitorSuspensionLoggingThresholdMillis: Duration = NodeConfiguration.DEFAULT_FLOW_MONITOR_SUSPENSION_LOGGING_THRESHOLD_MILLIS</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$val networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings = NetworkParameterAcceptanceSettings()</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeRpcSettings.&lt;no name provided&gt;$return "address: $address, adminAddress: $adminAddress, standAloneBroker: $standAloneBroker, useSsl: $useSsl, sslConfig: $sslConfig"</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$@Test fun `validation succeeds when compatibilityZoneURL is present and devMode is true and allowCompatibilityZoneURL is set`()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals( Paths.get("./azure.conf"), nodeConfig.value().enterpriseConfiguration.artemisCryptoServiceConfig?.conf)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals("jdbc:h2:///some/dir/persistence", testConfiguration(dataSourceProperties).dataSourceProperties.getProperty(DataSourceConfigTag.DATA_SOURCE_URL))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals("jdbc:sqlserver://localhost:10433;databaseName=perftesting;sendStringParametersAsUnicode=false", testConf.dataSourceProperties.getProperty(DataSourceConfigTag.DATA_SOURCE_URL))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals("jdbc:sqlserver://localhost:10433;databaseName=perftesting;sendStringParametersAsUnicode=false", testConfiguration(dataSourceProperties).dataSourceProperties.getProperty(DataSourceConfigTag.DATA_SOURCE_URL))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals("jdbc:sqlserver://localhost:10433;databaseName=perftesting;sendStringParametersAsUnicode=true", testConfiguration(dataSourceProperties).dataSourceProperties.getProperty(DataSourceConfigTag.DATA_SOURCE_URL))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals(InetAddress.getLocalHost().hostName, config.enterpriseConfiguration.mutualExclusionConfiguration.machineName)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals(SupportedCryptoServices.AZURE_KEY_VAULT, nodeConfig.value().enterpriseConfiguration.artemisCryptoServiceConfig?.name)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertEquals(listOf(baseDirPath / "./myCorDapps1", baseDirPath / "./myCorDapps2"), nodeConfiguration.value().cordappDirectories)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-DevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-empty.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-noDevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(config.errors.asSequence().map(Configuration.Validation.Error::message).filter { it.contains("has no constant of the name 'UNSUPPORTED'") }.toList()).isNotEmpty</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(config.errors.asSequence().map(Configuration.Validation.Error::message).filter { it.contains("rpcSettings.adminAddress") }.toList()).isNotEmpty</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(errors).contains("cannot enable network proxy by specifying 'networkServices.proxyType' without providing 'networkServices.proxyAddress'")</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(errors).hasOnlyOneElementSatisfying { error -&gt; error.contains("compatibilityZoneURL") &amp;&amp; error.contains("devMode") }</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(errors).hasOnlyOneElementSatisfying { error -&gt; error.contains("networkServices") &amp;&amp; error.contains("devMode") }</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(rawConfig.parseAsNodeConfiguration().errors.single())</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThatThrownBy { configDebugOptions(false, debugOptions) }.hasMessageMatching("Cannot use devModeOptions outside of dev mode")</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-DevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-empty.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-noDevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$dataSourceProperties[DataSourceConfigTag.DATA_SOURCE_URL] = "jdbc:sqlserver://localhost:10433;databaseName=perftesting"</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$dataSourceProperties[DataSourceConfigTag.DATA_SOURCE_URL] = "jdbc:sqlserver://localhost:10433;databaseName=perftesting;sendStringParametersAsUnicode=false"</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$dataSourceProperties[DataSourceConfigTag.DATA_SOURCE_URL] = "jdbc:sqlserver://localhost:10433;databaseName=perftesting;sendStringParametersAsUnicode=true"</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$enterpriseConfiguration = EnterpriseConfiguration((MutualExclusionConfiguration(false, "", 20000, 40000)))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$private</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$rawConfig = rawConfig.withValue("enterpriseConfiguration.artemisCryptoServiceConfig.cryptoServiceName", ConfigValueFactory.fromAnyRef("UNSUPPORTED"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$return testConfiguration.copy(tlsCertCrlDistPoint = tlsCertCrlDistPoint, tlsCertCrlIssuer = tlsCertCrlIssuer?.let { X500Principal(it) }, crlCheckSoftFail = crlCheckSoftFail)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val config = getConfig("test-config-mutualExclusion-noMachineName.conf").parseAsNodeConfiguration(options = Configuration.Options(strict = false)).value()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val configValidationResult = configTlsCertCrlOptions(null, "C=US, L=New York, OU=Corda, O=R3 HoldCo LLC, CN=Corda Root CA").validate()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val nodeConfig = rawConfig.parseAsNodeConfiguration(Configuration.Options(strict = true, hardwareAddress = byteArrayOf(0, 0, 0, 0, 0, 0), seed = byteArrayOf(0))).value()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val nodeConfig = rawConfig.parseAsNodeConfiguration(Configuration.Options(strict = true, hardwareAddress = byteArrayOf(1, 2, 3, 4, 5, 6), seed = byteArrayOf(0))).value()</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val rawConfig = ConfigFactory.parseResources("working-config.conf", ConfigParseOptions.defaults().setAllowMissing(false))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val rawConfig = getConfig("notary-config.conf", ConfigFactory.parseMap(mapOf("cryptoServiceName" to "AZURE_KEY_VAULT")))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val rawConfig = getConfig("working-config.conf", ConfigFactory.parseMap(mapOf("dataSourceProperties.dataSource.password" to "&lt;{I+/c+bIYfIrhxjyP0ANK6Q==:7f46ICS1hogaB3Vfaz47xCH6zgI=}&gt;")))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val rawConfig = getConfig("working-config.conf", ConfigFactory.parseMap(mapOf("emailAddress" to "&lt;{7JW92M2zxMtf8LVhHA3B1Q==:nGBvd90AdSs7psEJqabBURvbpggPLBqQIFqTPthoU3il}&gt;")))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$var rawConfig = ConfigFactory.parseResources("working-config.conf", ConfigParseOptions.defaults().setAllowMissing(false))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest${ it.contains("The enum class SupportedCryptoServices has no constant of the name 'UNSUPPORTED'") }</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection : Closeable</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$fun clearDb()</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$return runShellCommandGetOutput("sudo netstat -tlpn | grep ${remoteNode.rpcPort} | awk '{print $7}' | grep -oE '[0-9]+'").getResultOrThrow().replace("\n", "")</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$runShellCommandGetOutput("until sudo netstat -tlpn | grep ${remoteNode.rpcPort} &gt; /dev/null ; do sleep 1 ; done")</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$val proxy: CordaRPCOps get() = rpcConnection?.proxy ?: throw IllegalStateException("proxy requested, but the client is not running")</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection.ShellCommandOutput$data</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$(cordappConfigDir / "${CordappController.FINANCE_WORKFLOWS_CORDAPP_FILENAME}.conf").writeText(config.nodeConfig.toFinanceConfText())</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$issuableCurrencies = nodeData.extraServices.filterIsInstance&lt;CurrencyIssuer&gt;().map { it.currency.toString() }</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$require((config.nodeConfig.notary != null).xor(notaryIdentity != null)) { "There must be exactly one notary in the network" }</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$val nextPort = 1 + arrayOf(config.p2pAddress.port, config.rpcSettings.address.port, config.webAddress.port, config.h2port).max() as Int</ID>
    <ID>MaxLineLength:NodeData.kt$SuggestedDetails$( // Mike: Rome? Why Rome? // Roger: Notaries public (also called "notaries", "notarial officers", or "public notaries") hold an office // which can trace its origins back to the ancient Roman Republic, when they were called scribae ("scribes"), // tabelliones forenses, or personae publicae.[4] // Mike: Can't argue with that. It's even got a citation. "Notary" to "Rome", "Bank of Breakfast Tea" to "Liverpool", "Bank of Big Apples" to "New York", "Bank of Baguettes" to "Paris", "Bank of Fondue" to "Geneve", "Bank of Maple Syrup" to "Toronto", "Bank of Golden Gates" to "San Francisco" )</ID>
    <ID>MaxLineLength:NodeFlowManagerTest.kt$NodeFlowManagerTest$val nodeFlowManager = NodeFlowManager(FlowOverrideConfig(listOf(FlowOverride(Init::class.qualifiedName!!, Resp::class.qualifiedName!!))))</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfo</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$@Option(names = ["--address"], paramLabel = "host:port", description = ["Public address of node"], converter = [NetworkHostAndPortConverter::class])</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$@Option(names = ["--platform-version"], paramLabel = "int", description = ["Platform version that this node supports"])</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$require(keyStorePath != null &amp;&amp; keyAlias != null) { "The --keystore and --keyalias parameters must be specified" }</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner.AMQPInspectorSerializationScheme$override</ID>
    <ID>MaxLineLength:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$atomicCopy(previouslySeenFile, newNodeFile.additionalNodeInfoDirectory.resolve(previouslySeenFile.fileName))</ID>
    <ID>MaxLineLength:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$for (destination in this.values.filter { it.nodeDir != nodeData.nodeDir }.map { it.additionalNodeInfoDirectory }) { val fullDestinationPath = destination.resolve(path.fileName) atomicCopy(path, fullDestinationPath) }</ID>
    <ID>MaxLineLength:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun allPreviouslySeenFiles()</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1$mappedTypes = listOf(PersistentNodeInfo::class.java, DBPartyAndCertificate::class.java, DBHostAndPort::class.java, NodePropertiesPersistentStore.DBNodeProperty::class.java)</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.DBPartyAndCertificate$@ManyToMany(mappedBy = "legalIdentitiesAndCerts", cascade = [(CascadeType.ALL)])</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$(this.legalIdentitiesAndCerts.filter { it.isMain } + this.legalIdentitiesAndCerts.filter { !it.isMain }).map { it.toLegalIdentityAndCert() }</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$inverseJoinColumns = [(JoinColumn(name = "party_name", foreignKey = ForeignKey(name = "FK__link_ni_p__info_p_cert")))]</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$joinColumns = [(JoinColumn(name = "node_info_id", foreignKey = ForeignKey(name = "FK__link_nodeinfo_party__infos")))]</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher$ fun nodeInfoUpdates(): Observable&lt;List&lt;NodeInfoUpdate&gt;&gt;</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher$nodeInfoFilesMap[file] = NodeInfoFromFile(nodeInfoSigned.signed.raw.hash, file.lastModifiedTime())</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher$val newOrChangedFile = previousLastModifiedTime == null || lastModifiedTime &gt; previousLastModifiedTime</ID>
    <ID>MaxLineLength:NodeInfoWatcher.kt$NodeInfoWatcher.Companion${ // By using the hash of the node's first name we ensure: // 1) node info files for the same node map to the same filename and thus avoid having duplicate files for // the same node // 2) avoid having to deal with characters in the X.500 name which are incompatible with the local filesystem val fileNameHash = nodeInfoAndSigned.nodeInfo.legalIdentities[0].name.serialize().hash nodeInfoAndSigned .signed .serialize() .open() .copyTo(path / "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}$fileNameHash", REPLACE_EXISTING) }</ID>
    <ID>MaxLineLength:NodeInfoWatcherTest.kt$NodeInfoWatcherTest$keyManagementService = MockKeyManagementService(identityService, pkToIdCache = MockPublicKeyToOwningIdentityCache())</ID>
    <ID>MaxLineLength:NodeInfoWatcherTest.kt$NodeInfoWatcherTest$val nodeInfoFiles = tempFolder.root.list().filter { it.startsWith(NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX) }</ID>
    <ID>MaxLineLength:NodeInstanceRequest.kt$NodeInstanceRequest$localImageId</ID>
    <ID>MaxLineLength:NodeInstanceRequest.kt$NodeInstanceRequest$return "NodeInstanceRequest(nodeInstanceName='$nodeInstanceName', actualX500='$actualX500', expectedFqName='$expectedFqName') ${super.toString()}"</ID>
    <ID>MaxLineLength:NodeInstantiator.kt$NodeInstantiator$return instantiateNodeInstance(request.remoteImageName, request.instanceName, request.fqdn, request.instanceX500).thenApplyAsync { InstanceInfo(request.groupName, request.instanceName, request.fqdn, it.first, it.second) }</ID>
    <ID>MaxLineLength:NodeInstantiator.kt$NodeInstantiator$return instantiateNodeInstance(request.remoteImageName, request.nodeInstanceName, request.expectedFqName, request.actualX500) .thenApplyAsync { (reachableName, portMapping) -&gt; request.toNodeInstance(reachableName, portMapping) }</ID>
    <ID>MaxLineLength:NodeInterestRates.kt$NodeInterestRates.Oracle$// TODO There is security problem with that. What if transaction contains several commands of the same type, but // Oracle gets signing request for only some of them with a valid partial tree? We sign over a whole transaction. // It will be fixed by adding partial signatures later. // DOCSTART 1 fun sign(ftx: FilteredTransaction): TransactionSignature</ID>
    <ID>MaxLineLength:NodeInterestRates.kt$NodeInterestRates.Oracle$knownFixes = parseFile(IOUtils.toString(this::class.java.classLoader.getResourceAsStream("net/corda/irs/simulation/example.rates.txt"), Charsets.UTF_8.name()))</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy ALICE, Cash.PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$assertFailsWith&lt;IllegalArgumentException&gt; { oracle.sign(ftx) }</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null })</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$private val services = MockServices(listOf("net.corda.finance.contracts.asset"), dummyCashIssuer, rigorousMock(), MEGA_CORP_KEY)</ID>
    <ID>MaxLineLength:NodeJanitor.kt$NodeJanitor$"${ProcessedMessageCleanup::retainForDays.name} must be within the range of [1, $maxRetainForDays] and ${ProcessedMessageCleanup::retainPerSender.name} must be positive. "</ID>
    <ID>MaxLineLength:NodeJanitor.kt$NodeJanitor$log</ID>
    <ID>MaxLineLength:NodeJanitor.kt$NodeJanitor$log.info("Finished cleaning up processed message id table, total records removed: $removed, total duration: $totalElapsedTime")</ID>
    <ID>MaxLineLength:NodeJanitor.kt$NodeJanitor$log.info("Starting processed message id table cleanup. Removing records older than $retainForDays days, keeping only $retainPerSender records per unique sender")</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, nodeCA.keyPair.private, listOf(badNodeCACert, badRoot), signingCertStore.entryPassword)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val badNodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, badRoot, badRootKeyPair, ALICE_NAME.x500Principal, nodeCA.keyPair.public)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val badRoot = X509Utilities.createSelfSignedCACertificate(X500Principal("O=Bad Root,L=Lodnon,C=GB"), badRootKeyPair)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val p2pSslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = keystorePassword, trustStorePassword = keystorePassword)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, keystorePassword)</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject)</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$val (statesSnapshot, vaultUpdates) = rpc.vaultTrackBy&lt;ContractState&gt;(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE))</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel$val stateMachineTransactionMapping: Observable&lt;StateMachineTransactionMapping&gt; = stateMachineTransactionMappingSubject</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel${ rpc = ReconnectingCordaRPCOps(nodeHostAndPort, username, password) proxyObservable.value = rpc // Vault snapshot (force single page load with MAX_PAGE_SIZE) + updates val (statesSnapshot, vaultUpdates) = rpc.vaultTrackBy&lt;ContractState&gt;(QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE)) val unconsumedStates = statesSnapshot.states.filterIndexed { index, _ -&gt; statesSnapshot.statesMetadata[index].status == Vault.StateStatus.UNCONSUMED }.toSet() val consumedStates = statesSnapshot.states.toSet() - unconsumedStates val initialVaultUpdate = Vault.Update(consumedStates, unconsumedStates, references = emptySet()) vaultUpdates.startWith(initialVaultUpdate).subscribe(vaultUpdatesSubject::onNext) // Transactions val (transactions, newTransactions) = @Suppress("DEPRECATION") rpc.internalVerifiedTransactionsFeed() newTransactions.startWith(transactions).subscribe(transactionsSubject::onNext) // SM -&gt; TX mapping val (smTxMappings, futureSmTxMappings) = rpc.stateMachineRecordedTransactionMappingFeed() futureSmTxMappings.startWith(smTxMappings).subscribe(stateMachineTransactionMappingSubject::onNext) // Parties on network val (parties, futurePartyUpdate) = rpc.networkMapFeed() futurePartyUpdate.startWith(parties.map(MapChange::Added)).subscribe(networkMapSubject::onNext) val stateMachines = rpc.stateMachinesSnapshot() notaryIdentities = rpc.notaryIdentities() // Extract the flow tracking stream // TODO is there a nicer way of doing this? Stream of streams in general results in code like this... // TODO `progressTrackingSubject` doesn't seem to be used anymore - should it be removed? val currentProgressTrackerUpdates = stateMachines.mapNotNull { stateMachine -&gt; ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachine) } val futureProgressTrackerUpdates = stateMachineUpdatesSubject.map { stateMachineUpdate -&gt; if (stateMachineUpdate is StateMachineUpdate.Added) { ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachineUpdate.stateMachineInfo) ?: Observable.empty&lt;ProgressTrackingEvent&gt;() } else { Observable.empty&lt;ProgressTrackingEvent&gt;() } } // We need to retry, because when flow errors, we unsubscribe from progressTrackingSubject. So we end up with stream of state machine updates and no progress trackers. futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject) }</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$ProgressTrackingEvent.Companion$future.map { ProgressTrackingEvent(stateMachine.id, it) }.startWith(ProgressTrackingEvent(stateMachine.id, current))</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name == "HibernateConfiguration_sessionFactories" -&gt; caffeine.maximumSize(database.mappedSchemaCacheSize)</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name == "NodeAttachmentService_attachmentContent" -&gt; caffeine.maximumWeight(attachmentContentCacheSizeBytes)</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name.startsWith("RPCSecurityManagerShiroCache_") -&gt; with(security?.authService?.options?.cache!!) { caffeine.maximumSize(maxEntries).expireAfterWrite(expireAfterSecs, TimeUnit.SECONDS) }</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$open</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$/** * Create a new node parameters object with default values. Each parameter can be specified with its wither method which returns a copy * with that value. */ constructor() : this(providedName = null)</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withAdditionalCordapps(additionalCordapps: Set&lt;TestCordapp&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withCustomOverrides(customOverrides: Map&lt;String, Any?&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withFlowOverrides(flowOverrides: Map&lt;Class&lt;out FlowLogic&lt;*&gt;&gt;, Class&lt;out FlowLogic&lt;*&gt;&gt;&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withStartInSameProcess(startInSameProcess: Boolean?): NodeParameters</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$connection.proxy.startFlow(::CashIssueAndPaymentFlow, 1.DOLLARS, OpaqueBytes.of(0), defaultNotaryIdentity, false, defaultNotaryIdentity).returnValue</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$connection.proxy.startFlow(::CashIssueAndPaymentNoSelection, 1.DOLLARS, OpaqueBytes.of(0), alice.nodeInfo.legalIdentities[0], false, defaultNotaryIdentity).returnValue</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$connection.proxy.startFlow(::CashIssueAndPaymentNoSelection, 1.DOLLARS, OpaqueBytes.of(0), bob.nodeInfo.legalIdentities[0], false, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$driver</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$val metricRegistry = startReporter((this as InternalDriverDSL).shutdownManager, a.internalServices.monitoringService.metrics)</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$val metricRegistry = startReporter((this as InternalDriverDSL).shutdownManager, alice.internalServices.monitoringService.metrics)</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests$val metricRegistry = startReporter((this as InternalDriverDSL).shutdownManager, notary.internalServices.monitoringService.metrics)</ID>
    <ID>MaxLineLength:NodePerformanceTests.kt$NodePerformanceTests.Companion$@ClassRule @JvmField val databaseSchemas = IntegrationTestSchemas(DUMMY_NOTARY_NAME.toDatabaseSchemaNames("_0", "_1", "_2") + DUMMY_BANK_A_NAME.toDatabaseSchemaName())</ID>
    <ID>MaxLineLength:NodeProcess.kt$NodeProcess$Factory</ID>
    <ID>MaxLineLength:NodeProcess.kt$NodeProcess.Factory$networkParametersCopier = NetworkParametersCopier(testNetworkParameters(notaries = listOf(notaryInfo)))</ID>
    <ID>MaxLineLength:NodeProcess.kt$NodeProcess.Factory.Companion$val formatter: DateTimeFormatter = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss.SSS").withZone(systemDefault())</ID>
    <ID>MaxLineLength:NodePropertiesPersistentStore.kt$FlowsDrainingModeOperationsImpl : FlowsDrainingModeOperations</ID>
    <ID>MaxLineLength:NodePropertiesPersistentStore.kt$NodePropertiesPersistentStore : NodePropertiesStore</ID>
    <ID>MaxLineLength:NodeRPC.kt$NodeRPC : AutoCloseable</ID>
    <ID>MaxLineLength:NodeRPCTests.kt$NodeRPCTests$driver</ID>
    <ID>MaxLineLength:NodeRegistrationTest.kt$RegistrationHandler$require(!name.organisation.contains("\\s".toRegex())) { "Whitespace in the organisation name not supported" }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService : SchedulerServiceAutoCloseableSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService$nextScheduledAction = schedulerRepo.getLatest(deduplicate.size + 1).firstOrNull { !deduplicate.contains(it.second) }?.second</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService$private val schedulerRepo: ScheduledFlowRepository = PersistentScheduledFlowRepository(database)</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService$val deduplicate = HashSet(startingStateRefs) // Take an immutable copy to remove races with afterDatabaseCommit.</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService${ // We are earliest rescheduleWakeUp() }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService${ log.trace { "Scheduler starting FlowLogic $flowLogic" } //Add this to the in memory list of starting refs so it is not picked up on the next rescheduleWakeUp() startingStateRefs.add(scheduledState) flowLogic }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion$ // We should try to make the Clock used in our code injectable (for tests etc) and to use the extension below // to wait in our code, rather than &lt;code&gt;Thread.sleep()&lt;/code&gt; or other time-based pauses. @Suspendable @VisibleForTesting // We specify full classpath on SettableFuture to differentiate it from the Quasar class of the same name fun awaitWithDeadline(clock: CordaClock, deadline: Instant, future: Future&lt;*&gt; = GuavaSettableFuture.create&lt;Any&gt;()): Boolean</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion$ private fun &lt;T : Any&gt; makeStrandFriendlySettableFuture(future: Future&lt;T&gt;)</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion$private</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.Companion${ // This will return when it times out, or when the clock mutates or when when the original future completes. originalFutureCompleted.get(nanos, TimeUnit.NANOSECONDS) }</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.FlowStartDeduplicationHandler$private inner</ID>
    <ID>MaxLineLength:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTest$private val database = configureDatabase(MockServices.makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null })</ID>
    <ID>MaxLineLength:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTestBase$verify(flowStarter, timeout(5000)).startFlow(argForWhich&lt;ExternalEvent.ExternalStartFlowEvent&lt;*&gt;&gt; { this.flowLogic == flowLogic })</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService : SchemaServiceSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$fun internalSchemas()</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$override val schemaOptions: Map&lt;MappedSchema, SchemaService.SchemaOptions&gt; = requiredSchemas + extraSchemas.associateBy({ it }, { SchemaOptions() })</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$return VaultSchemaV1.VaultFungibleStates(owner = null, quantity = state.amount.quantity, issuer = null, issuerRef = null)</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$return VaultSchemaV1.VaultFungibleStates(state.owner, state.amount.quantity, state.amount.token.issuer.party, state.amount.token.issuer.reference)</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$NodeSchemaServiceTest$val mockNet = InternalMockNetwork(cordappsForAllNodes = cordappsForPackages(DummyLinearStateSchemaV1::class.packageName))</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$TestSchema.Child$@JoinColumns(JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"), JoinColumn(name = "output_index", referencedColumnName = "output_index"))</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$TestSchema.Parent$@JoinColumns(JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"), JoinColumn(name = "output_index", referencedColumnName = "output_index"))</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeCliCommand$abstract</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"""\____/ /_/ \__,_/\__,_/"""</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Check your contracts carefully. The fine print\nis usually a clause for suspicion ${Emoji.santaClaus}"</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"How did my parents fight boredom before the internet?\nI asked my 17 siblings and they didn't know either."</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"My boss asked me who is the stupid one, me or him?\nI said everyone knows he doesn't hire stupid people."</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Please see https://docs.corda.net/troubleshooting.html#slow-localhost-resolution for information on how to fix this. "</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"The good thing about lending out your time machine\nis that you basically get it back immediately."</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Your computer took over a second to resolve localhost due an incorrect configuration. Corda will work but start very slowly until this is fixed. "</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$Node.printWarning("This node is running in development mode! ${Emoji.developer} This is not safe for production deployment.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$fun initialiseAndRun(cmdLineOptions: SharedNodeCmdLineOptions, afterNodeInitialisation: RunAfterNodeInitialisation, requireCertificates: Boolean = false): Int</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (attempt { banJavaSerialisation(configuration) }.doOnFailure(Consumer { error -&gt; error.logAsUnexpected("Exception while configuring serialisation") }) !is Try.Success) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (attempt { preNetworkRegistration(configuration) }.doOnFailure(Consumer(::handleRegistrationError)) !is Try.Success) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (requireCertificates &amp;&amp; !canReadCertificatesDirectory(configuration.certificatesDirectory, configuration.devMode)) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$logger.info("The Corda node is running in production mode. If this is a developer environment you can set 'devMode=true' in the node.conf file.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$logger.warn("${it.info} will be unable to run on Corda in the future due to missing entries in JAR's manifest file.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$nodeStartedMessage = "$nodeStartedMessage with additional Network Map keys ${conf.extraNetworkMapKeys.joinToString(prefix = "[", postfix = "]", separator = ", ")}"</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$printError("Unable to access certificates directory ${certDirectory}. This could be because the node has not been registered with the Identity Operator.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$println("Application user '$appUser' does not have necessary permissions for Node base directory '$baseDirectory'.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$println("Corda Node process in now exiting. Please check directory permissions and try starting the Node again.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$val configuration = cmdLineOptions.parseConfiguration(rawConfig).doIfValid { logRawConfig(rawConfig) }.doOnErrors(::logConfigurationErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup.Companion$private val logger by lazy { loggerFor&lt;Node&gt;() } // I guess this is lazy to allow for logging init, but why Node?</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --clear-network-map-cache flag has been deprecated and will be removed in a future version. Use the clear-network-cache command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --initial-registration flag has been deprecated and will be removed in a future version. Use the initial-registration command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --just-generate-node-info flag has been deprecated and will be removed in a future version. Use the generate-node-info command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --just-generate-rpc-ssl-settings flag has been deprecated and will be removed in a future version. Use the generate-rpc-ssl-settings command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$initialRegistrationCli.networkRootTrustStorePathParameter = cmdLineOptions.networkRootTrustStorePathParameter</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$override fun additionalSubCommands()</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$println("Node was started before in `initial-registration` mode, but the registration was not completed.\nResuming registration.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$requireNotNull(cmdLineOptions.networkRootTrustStorePassword) { "Network root trust store password must be provided in registration mode using --network-root-truststore-password." }</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is Errors.NativeIoException &amp;&amp; error.message?.contains("Address already in use") == true -&gt; error.logAsExpected("One of the ports required by the Corda node is already in use.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is Errors.NativeIoException &amp;&amp; error.message?.contains("Can't assign requested address") == true -&gt; error.logAsExpected("Exception during node startup. Check that addresses in node config resolve correctly.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is UnresolvedAddressException -&gt; error.logAsExpected("Exception during node startup. Check that addresses in node config resolve correctly.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error.isOpenJdkKnownIssue() -&gt; error.logAsExpected("Exception during node startup - ${error.message}. This is a known OpenJDK issue on some Linux distributions, please use OpenJDK from zulu.org or Oracle JDK.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$fun Throwable.logAsExpected(message: String? = this.message, print: (String?) -&gt; Unit = logger::error)</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$fun Throwable.logAsUnexpected(message: String? = this.message, error: Throwable = this, print: (String?, Throwable) -&gt; Unit = logger::error)</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging.Companion$val startupErrors = setOf(MultipleCordappsForFlowException::class, CheckpointIncompatibleException::class, AddressBindingException::class, NetworkParametersReader::class, DatabaseIncompatibleException::class)</ID>
    <ID>MaxLineLength:NodeStartup.kt$System.setProperty("defaultLogLevel", specifiedLogLevel)</ID>
    <ID>MaxLineLength:NodeStartupCliTest.kt$NodeStartupCliTest$Assertions.assertThat(startup.cmdLineOptions.configFile).isEqualTo(workingDirectory / "another-base-dir" / "node.conf")</ID>
    <ID>MaxLineLength:NodeStartupCliTest.kt$NodeStartupCliTest$CommandLine.populateCommand(startup, CommonCliConstants.BASE_DIR, (workingDirectory / "another-base-dir").toString())</ID>
    <ID>MaxLineLength:NodeStartupForWrappedKeysTest.kt$NodeStartupForWrappedKeysTest$@Test fun `when initial registration is done without secure confidential identities enabled but with devMode=true, then subsequent startup will create the key if missing`()</ID>
    <ID>MaxLineLength:NodeStartupForWrappedKeysTest.kt$NodeStartupForWrappedKeysTest$@Test fun `when initial registration is done without secure confidential identities enabled, then subsequent startup with this enabled will fail`()</ID>
    <ID>MaxLineLength:NodeStartupForWrappedKeysTest.kt$NodeStartupForWrappedKeysTest$assertThatThrownBy { startNode(this, secureConfidentialIdentitiesEnabled = true, devMode = false) } .isInstanceOf(IllegalStateException::class.java) .hasMessageContaining("The crypto service configured for fresh identities (BC_SIMPLE) does not contain a key under the alias: wrapping-key-alias.")</ID>
    <ID>MaxLineLength:NodeStartupForWrappedKeysTest.kt$NodeStartupForWrappedKeysTest$private</ID>
    <ID>MaxLineLength:NodeStartupPerformanceTests.kt$NodeStartupPerformanceTests$// Measure the startup time of nodes. Note that this includes an RPC roundtrip, which causes e.g. Kryo initialisation. @Test fun `single node startup time`()</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$val nodeHandle = startNode(providedName = nodeName, rpcUsers = listOf(user), customOverrides = mapOf("devMode" to "false")).getOrThrow()</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$val user = User("mark", "dadada", setOf(Permissions.startFlow&lt;SendMessageFlow&gt;(), Permissions.invokeRpc("vaultQuery")))</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$SendMessageFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:NodeTabView.kt$NodeTabView$CityDatabase.cityMap.values.map { it.countryCode }.toSet().map { it to Image(resources["/net/corda/demobench/flags/$it.png"]) }.toMap()</ID>
    <ID>MaxLineLength:NodeTabView.kt$NodeTabView$notaryTypeToggleGroup.selectedValueProperty&lt;NotaryService&gt;()</ID>
    <ID>MaxLineLength:NodeTerminalView.kt$NodeTerminalView${ // TODO: Remove this special case once Rick's serialisation work means we can deserialise states that weren't on our own classpath. }</ID>
    <ID>MaxLineLength:NodeTest.kt$NodeTest$assertEquals(node.generateNodeInfo(), node.generateNodeInfo())</ID>
    <ID>MaxLineLength:NodeTest.kt$NodeTest$mutualExclusionConfiguration = MutualExclusionConfiguration(updateInterval = 0, waitInterval = 0)</ID>
    <ID>MaxLineLength:NodeTestUtils.kt$ fun testActor(owningLegalIdentity: CordaX500Name = CordaX500Name("Test Company Inc.", "London", "GB"))</ID>
    <ID>MaxLineLength:NodeTestUtils.kt$ fun testContext(owningLegalIdentity: CordaX500Name = CordaX500Name("Test Company Inc.", "London", "GB"))</ID>
    <ID>MaxLineLength:NodeUnloadHandlerTests.kt$NodeUnloadHandlerTests$assertTrue("Timed out waiting for AbstractNode to invoke the test service shutdown callback", shutdownLatch.await(30, TimeUnit.SECONDS))</ID>
    <ID>MaxLineLength:NodeUnloadHandlerTests.kt$NodeUnloadHandlerTests$private val mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(enclosedCordapp()), notarySpecs = emptyList())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$ @Throws(VaultQueryException::class) override fun &lt;T : ContractState&gt; _trackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$ private fun &lt;T: ContractState&gt; hasBeenSeen(update: Vault.Update&lt;T&gt;, snapshotStatesRefs: Set&lt;StateRef&gt;, snapshotConsumedStatesRefs: Set&lt;StateRef&gt;): Boolean</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Returns only output states that can be deserialised successfully. fun WireTransaction.deserializableOutputStates(): Map&lt;Int, TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Returns only reference states that can be deserialised successfully. fun LedgerTransaction.deserializableRefStates(): Map&lt;Int, StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) override</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$@VisibleForTesting internal</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$Vault.Page(states = statesAndRefs, statesMetadata = statesMeta, stateTypes = criteriaParser.stateTypes, totalStatesAvailable = totalStates, otherResults = otherResults)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$detailedLogger.trace { "Contract(action=query_end;type=$contractStateType;criteria=$criteria;pagination=$paging;sorting=$paging)" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$detailedLogger.trace { "Contract(action=query_start;type=$contractStateType;criteria=$criteria;pagination=$paging;sorting=$paging)" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$detailedLogger.trace { "State(action=save_end;className=${stateToAdd.contractStateClassName};status=${stateToAdd.stateStatus})" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$detailedLogger.trace { "State(action=save_start;className=${stateToAdd.contractStateClassName};status=${stateToAdd.stateStatus})" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$fun &lt;T&gt; withValidDeserialization(list: List&lt;T&gt;, txId: SecureHash): Map&lt;Int, T&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$fun execute(configure: Root&lt;*&gt;.(CriteriaUpdate&lt;*&gt;, Array&lt;Predicate&gt;) -&gt; Any?)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageNumber &lt; DEFAULT_PAGE_NUM) throw VaultQueryException("Page specification: invalid page number ${paging.pageNumber} [page numbers start from $DEFAULT_PAGE_NUM]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageSize &lt; 1) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [minimum is 1]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageSize &gt; MAX_PAGE_SIZE) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [maximum is $MAX_PAGE_SIZE]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$isRelevant(state.data, keyManagementService.filterMyKeys(outputs.flatMap { it.value.data.participants.map { it.owningKey } }).toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.debug { "Vault Query for contract type: $contractStateType, criteria: $criteria, pagination: $paging, sorting: $sorting" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.trace { "Removing $consumedStateRefs consumed contract states and adding $producedStateRefs produced contract states to the database." }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.warn("There are unknown contract state types in the vault, which will prevent these states from being used. The relevant CorDapps must be loaded for these states to be used. The types not on the classpath are ${unknownTypes.joinToString(", ", "[", "]")}.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.warn("trackBy is called with an already existing, open DB transaction. As a result, there might be states missing from both the snapshot and observable, included in the returned data feed, because of race conditions.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$override</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$private</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$private val criteriaBuilder: CriteriaBuilder by lazy { database.hibernateConfig.sessionFactoryForRegisteredSchemas.criteriaBuilder }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$query.maxResults = if (pageSize &gt; 0) pageSize else Integer.MAX_VALUE</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$relevancyStatus = if (isRelevant) Vault.RelevancyStatus.RELEVANT else Vault.RelevancyStatus.NOT_RELEVANT</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$return Vault.Update(consumedStateAndRefs.toSet(), producedStateAndRefs.toSet(), null, updateType, referenceStateAndRefs.toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$return Vault.Update(consumedStates.toSet(), ourNewStates.toSet(), references = newReferenceStateAndRefs.toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$return snapshotStatesRefs.containsAll(updateProducedStatesRefs) &amp;&amp; snapshotConsumedStatesRefs.containsAll(updateConsumedStatesRefs)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).`in`(consumedStateRefsBatch.map { PersistentStateRef(it) })</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$root.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(lockId))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$throw StatesNotAvailableException("Attempted to reserve $stateRefs for $lockId but only $updatedRows rows available")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$throw VaultQueryException("There are ${results.size} results, which exceeds the limit of $DEFAULT_PAGE_SIZE for queries that do not specify paging. In order to retrieve these results, provide a `PageSpecification(pageNumber, pageSize)` to the method invoked.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$update.set(get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$update.set&lt;String&gt;(get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$updateQuery.set(root.get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$updateQuery.set(root.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.CONSUMED)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$updateQuery.where(root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).`in`(consumedStateRefsBatch.map { PersistentStateRef(it) }))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val compositeKey = root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).get&lt;String&gt;(PersistentStateRef::txId.name)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val criteriaParser = HibernateQueryCriteriaParser(contractStateType, contractStateTypeMappings, criteriaBuilder, criteriaQuery, queryRootVaultStates)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val lockIdPredicate = criteriaBuilder.equal(get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), lockId.toString())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val lockUpdateTime = criteriaBuilder.equal(get&lt;Instant&gt;(VaultSchemaV1.VaultStates::lockUpdateTime.name), softLockTimestamp)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val myKeys by lazy { keyManagementService.filterMyKeys(ltx.outputs.flatMap { it.data.participants.map { it.owningKey } }) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val persistentStateRefs = stateRefs.map { PersistentStateRef(it.txhash.bytes.toHexString(), it.index) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val results = _queryBy(criteria.and(countCriteria), PageSpecification(), Sort(emptyList()), contractStateType, true) // only skip pagination checks for total results count query</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateOnly = stateAndRef.value.state.data val uuid = if (produced &amp;&amp; stateOnly is FungibleState&lt;*&gt;) { FlowStateMachineImpl.currentStateMachine()?.id?.uuid?.toString() } else null if (uuid != null) { FlowStateMachineImpl.currentStateMachine()?.hasSoftLockedStates = true log.trace { "Reserving soft lock for flow id $uuid and state ${stateAndRef.key}" } } // TODO: Optimise this. // // For EVERY state to be committed to the vault, this checks whether it is spendable by the recording // node. The behaviour is as follows: // // 1) All vault updates marked as RELEVANT will, of course, all have relevancy_status = 1 in the // "vault_states" table. // 2) For ALL_VISIBLE updates, those which are not relevant according to the relevancy rules will have // relevancy_status = 0 in the "vault_states" table. // // This is useful when it comes to querying for fungible states, when we do not want irrelevant states // included in the result. // // The same functionality could be obtained by passing in a list of participants to the vault query, // however this: // // * requires a join on the participants table which results in slow queries // * states may flip from being non-relevant to relevant // * it's more complicated for CorDapp developers // // Adding a new column in the "VaultStates" table was considered the best approach. val keys = stateOnly.participants.map { it.owningKey } val persistentStateRef = PersistentStateRef(stateAndRef.key) // This check is done to set the "relevancyStatus". When one performs a vault query, it is possible to return ALL states, ONLY // RELEVANT states or NOT relevant states. val isRelevant = isRelevant(stateOnly, keyManagementService.filterMyKeys(keys).toSet()) val constraintInfo = Vault.ConstraintInfo(stateAndRef.value.state.constraint) // Save a row for each party in the state_party table. // TODO: Perhaps these can be stored in a batch? stateOnly.participants.groupBy { it.owningKey }.forEach { participants -&gt; val persistentParty = VaultSchemaV1.PersistentParty(persistentStateRef, participants.value.first()) detailedLogger.trace { "Party(action=save_start;party=${persistentParty.x500Name})" } session.save(persistentParty) detailedLogger.trace { "Party(action=save_end;party=${persistentParty.x500Name})" } } val stateToAdd = VaultSchemaV1.VaultStates( notary = stateAndRef.value.state.notary, contractStateClassName = stateAndRef.value.state.data.javaClass.name, stateStatus = Vault.StateStatus.UNCONSUMED, lockId = uuid, lockUpdateTime = if (uuid == null) null else now, recordedTime = clock.instant(), relevancyStatus = if (isRelevant) Vault.RelevancyStatus.RELEVANT else Vault.RelevancyStatus.NOT_RELEVANT, constraintType = constraintInfo.type(), constraintData = constraintInfo.data() ) stateToAdd.stateRef = persistentStateRef detailedLogger.trace { "State(action=save_start;className=${stateToAdd.contractStateClassName};status=${stateToAdd.stateStatus})" } session.save(stateToAdd) detailedLogger.trace { "State(action=save_end;className=${stateToAdd.contractStateClassName};status=${stateToAdd.stateStatus})" }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateRef = StateRef(SecureHash.parse(vaultState.stateRef!!.txId), vaultState.stateRef!!.index)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateStatusPredication = criteriaBuilder.equal(get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.UNCONSUMED)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val txIdPredicate = criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultTxnNote::txId.name), txnId.toString())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val updateQuery = criteriaBuilder.createCriteriaUpdate(VaultSchemaV1.VaultStates::class.java) val root = updateQuery.from(VaultSchemaV1.VaultStates::class.java) updateQuery.set(root.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.CONSUMED) updateQuery.set(root.get&lt;Instant&gt;(VaultSchemaV1.VaultStates::consumedTime.name), now) updateQuery.set(root.get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java)) // If this transaction has been seen before, then add an extra term to the where clause excluding those states that are // already consumed. This prevents the timestamp for already consumed states from being updated. if (previouslySeen) { updateQuery.where( criteriaBuilder.and( root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).`in`(consumedStateRefsBatch.map { PersistentStateRef(it) }), criteriaBuilder.equal( root.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.UNCONSUMED ) ) ) } else { updateQuery.where(root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).`in`(consumedStateRefsBatch.map { PersistentStateRef(it) })) } session.createQuery(updateQuery).executeUpdate()</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // For transactions being re-recorded, the node must check its vault to find out what states it has already seen. Note // that some of the outputs previously seen may have been consumed in the meantime, so the check must look for all state // statuses. val outputRefs = tx.outRefsOfType&lt;ContractState&gt;().map { it.ref } val seenRefs = loadStatesWithVaultFilter(outputRefs).map { it.ref } val unseenRefs = outputRefs - seenRefs val unseenOutputIdxs = unseenRefs.map { it.index }.toSet() outputs.filter { it.key in unseenOutputIdxs } }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // We decrement by one if the client requests MAX_PAGE_SIZE, assuming they can not notice this because they don't have enough memory // to request `MAX_PAGE_SIZE` states at once. val paging = if (paging_.pageSize == Integer.MAX_VALUE) { paging_.copy(pageSize = Integer.MAX_VALUE - 1) } else { paging_ } log.debug { "Vault Query for contract type: $contractStateType, criteria: $criteria, pagination: $paging, sorting: $sorting" } return database.transaction { // calculate total results where a page specification has been defined var totalStates = -1L if (!skipPagingChecks &amp;&amp; !paging.isDefault) { val count = builder { VaultSchemaV1.VaultStates::recordedTime.count() } val countCriteria = QueryCriteria.VaultCustomQueryCriteria(count, Vault.StateStatus.ALL) val results = _queryBy(criteria.and(countCriteria), PageSpecification(), Sort(emptyList()), contractStateType, true) // only skip pagination checks for total results count query totalStates = results.otherResults.last() as Long } detailedLogger.trace { "Contract(action=query_start;type=$contractStateType;criteria=$criteria;pagination=$paging;sorting=$paging)" } val session = getSession() val criteriaQuery = criteriaBuilder.createQuery(Tuple::class.java) val queryRootVaultStates = criteriaQuery.from(VaultSchemaV1.VaultStates::class.java) // TODO: revisit (use single instance of parser for all queries) val criteriaParser = HibernateQueryCriteriaParser(contractStateType, contractStateTypeMappings, criteriaBuilder, criteriaQuery, queryRootVaultStates) // parse criteria and build where predicates criteriaParser.parse(criteria, sorting) // prepare query for execution val query = session.createQuery(criteriaQuery) // pagination checks if (!skipPagingChecks &amp;&amp; !paging.isDefault) { // pagination if (paging.pageNumber &lt; DEFAULT_PAGE_NUM) throw VaultQueryException("Page specification: invalid page number ${paging.pageNumber} [page numbers start from $DEFAULT_PAGE_NUM]") if (paging.pageSize &lt; 1) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [minimum is 1]") if (paging.pageSize &gt; MAX_PAGE_SIZE) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [maximum is $MAX_PAGE_SIZE]") } // For both SQLServer and PostgresSQL, firstResult must be &gt;= 0. So we set a floor at 0. // TODO: This is a catch-all solution. But why is the default pageNumber set to be -1 in the first place? // Even if we set the default pageNumber to be 1 instead, that may not cover the non-default cases. // So the floor may be necessary anyway. query.firstResult = maxOf(0, (paging.pageNumber - 1) * paging.pageSize) val pageSize = paging.pageSize + 1 query.maxResults = if (pageSize &gt; 0) pageSize else Integer.MAX_VALUE // detection too many results, protected against overflow // execution val results = query.resultList detailedLogger.trace { "Contract(action=query_end;type=$contractStateType;criteria=$criteria;pagination=$paging;sorting=$paging)" } // final pagination check (fail-fast on too many results when no pagination specified) if (!skipPagingChecks &amp;&amp; paging.isDefault &amp;&amp; results.size &gt; DEFAULT_PAGE_SIZE) { throw VaultQueryException("There are ${results.size} results, which exceeds the limit of $DEFAULT_PAGE_SIZE for queries that do not specify paging. In order to retrieve these results, provide a `PageSpecification(pageNumber, pageSize)` to the method invoked.") } val statesAndRefs: MutableList&lt;StateAndRef&lt;T&gt;&gt; = mutableListOf() val statesMeta: MutableList&lt;Vault.StateMetadata&gt; = mutableListOf() val otherResults: MutableList&lt;Any&gt; = mutableListOf() val stateRefs = mutableSetOf&lt;StateRef&gt;() results.asSequence() .forEachIndexed { index, result -&gt; if (result[0] is VaultSchemaV1.VaultStates) { if (!paging.isDefault &amp;&amp; index == paging.pageSize) // skip last result if paged return@forEachIndexed val vaultState = result[0] as VaultSchemaV1.VaultStates val stateRef = StateRef(SecureHash.parse(vaultState.stateRef!!.txId), vaultState.stateRef!!.index) stateRefs.add(stateRef) statesMeta.add(Vault.StateMetadata(stateRef, vaultState.contractStateClassName, vaultState.recordedTime, vaultState.consumedTime, vaultState.stateStatus, vaultState.notary, vaultState.lockId, vaultState.lockUpdateTime, vaultState.relevancyStatus, constraintInfo(vaultState.constraintType, vaultState.constraintData) )) } else { // TODO: improve typing of returned other results log.debug { "OtherResults: ${Arrays.toString(result.toArray())}" } otherResults.addAll(result.toArray().asList()) } } if (stateRefs.isNotEmpty()) statesAndRefs.addAll(uncheckedCast(servicesForResolution.loadStates(stateRefs))) Vault.Page(states = statesAndRefs, statesMetadata = statesMeta, stateTypes = criteriaParser.stateTypes, totalStatesAvailable = totalStates, otherResults = otherResults) } }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // We have to do this so that the session does not hold onto the prior version of the states status. i.e. // it is not aware of this query. session.flush() session.clear() val criteriaBuilder = session.criteriaBuilder // check if we need to batch the vault update - the default is one large batch val batchSize = database.hibernateConfig.vaultUpdateBatchSize ?: consumedStateRefs.size consumedStateRefs.chunked(batchSize).forEach { consumedStateRefsBatch -&gt; val updateQuery = criteriaBuilder.createCriteriaUpdate(VaultSchemaV1.VaultStates::class.java) val root = updateQuery.from(VaultSchemaV1.VaultStates::class.java) updateQuery.set(root.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.CONSUMED) updateQuery.set(root.get&lt;Instant&gt;(VaultSchemaV1.VaultStates::consumedTime.name), now) updateQuery.set(root.get&lt;String&gt;(VaultSchemaV1.VaultStates::lockId.name), criteriaBuilder.nullLiteral(String::class.java)) // If this transaction has been seen before, then add an extra term to the where clause excluding those states that are // already consumed. This prevents the timestamp for already consumed states from being updated. if (previouslySeen) { updateQuery.where( criteriaBuilder.and( root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).`in`(consumedStateRefsBatch.map { PersistentStateRef(it) }), criteriaBuilder.equal( root.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.UNCONSUMED ) ) ) } else { updateQuery.where(root.get&lt;PersistentStateRef&gt;(VaultSchemaV1.VaultStates::stateRef.name).`in`(consumedStateRefsBatch.map { PersistentStateRef(it) })) } session.createQuery(updateQuery).executeUpdate() } }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ // When resolving transaction dependencies we might encounter contracts we haven't installed locally. // This will cause a failure as we can't deserialize such states in the context of the `appClassloader`. // For now we ignore these states. // In the future we will use the AttachmentsClassloader to correctly deserialize and asses the relevancy. log.debug { "Could not deserialize state $idx from transaction $txId. Cause: $e" } null }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService${ val outputs: Map&lt;Int, TransactionState&lt;ContractState&gt;&gt; = tx.deserializableOutputStates() val outputsBitSet = BitSet(outputs.size) val ourNewStates = when (statesToRecord) { StatesToRecord.NONE -&gt; throw AssertionError("Should not reach here") StatesToRecord.ONLY_RELEVANT -&gt; outputs.filter { (_, state) -&gt; isRelevant(state.data, keyManagementService.filterMyKeys(outputs.flatMap { it.value.data.participants.map { it.owningKey } }).toSet()) } StatesToRecord.ALL_VISIBLE -&gt; if (previouslySeen) { // For transactions being re-recorded, the node must check its vault to find out what states it has already seen. Note // that some of the outputs previously seen may have been consumed in the meantime, so the check must look for all state // statuses. val outputRefs = tx.outRefsOfType&lt;ContractState&gt;().map { it.ref } val seenRefs = loadStatesWithVaultFilter(outputRefs).map { it.ref } val unseenRefs = outputRefs - seenRefs val unseenOutputIdxs = unseenRefs.map { it.index }.toSet() outputs.filter { it.key in unseenOutputIdxs } } else { outputs } }.map { outputsBitSet[it.key] = true tx.outRef&lt;ContractState&gt;(it.key) } val cachedBitSet = producedStatesMapping.get(tx.id) { outputsBitSet } if (cachedBitSet != outputsBitSet) { // If any outputBitSet bits are not set in the cached value, invalidate. val intersection = outputsBitSet.clone() as BitSet intersection.and(cachedBitSet) if (intersection != outputsBitSet) { // For some reason, we cached the vault entries for this transaction previously. producedStatesMapping.invalidate(tx.id) } } // Retrieve all unconsumed states for this transaction's inputs val consumedStates = loadStatesWithVaultFilter(tx.inputs) // Is transaction irrelevant? If so, then we don't care about the reference states either. if (consumedStates.isEmpty() &amp;&amp; ourNewStates.isEmpty()) { log.trace { "tx ${tx.id} was irrelevant to this vault, ignoring" } return null } // This list should only contain NEW states which we have not seen before as an output in another transaction. If we can't // obtain the references from the vault then the reference must be a state we have not seen before, therefore we should store it // in the vault. If StateToRecord is set to ALL_VISIBLE or ONLY_RELEVANT then we should store all of the previously unseen // states in the reference list. The assumption is that we might need to inspect them at some point if they were referred to // in the contracts of the input or output states. If states to record is none then we shouldn't record any reference states. val newReferenceStateAndRefs = if (tx.references.isEmpty()) { emptyList() } else { when (statesToRecord) { StatesToRecord.NONE -&gt; throw AssertionError("Should not reach here") StatesToRecord.ALL_VISIBLE, StatesToRecord.ONLY_RELEVANT -&gt; { val notSeenReferences = tx.references - loadStatesWithVaultFilter(tx.references).map { it.ref } // TODO: This is expensive - is there another way? tx.toLedgerTransaction(servicesForResolution).deserializableRefStates() .filter { (_, stateAndRef) -&gt; stateAndRef.ref in notSeenReferences } .values } } } return Vault.Update(consumedStates.toSet(), ourNewStates.toSet(), references = newReferenceStateAndRefs.toSet()) }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService.Companion$ fun isRelevant(state: ContractState, myKeys: Set&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService.InnerState$// For use during publishing only. val updatesPublisher: rx.Observer&lt;Vault.Update&lt;ContractState&gt;&gt; get() = _updatesPublisher.bufferUntilDatabaseCommit().tee(_rawUpdatesPublisher)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$private</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$(services.validatedTransactions as WritableTransactionStorage).addTransaction(SignedTransaction(changeNotaryTx, listOf(NullKeys.NULL_SIGNATURE)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$Cash().generateIssue(this, 100.DOLLARS `issued by` MEGA_CORP.ref(1), AnonymousParty(freshKey), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$Cash().generateIssue(this, 200.POUNDS `issued by` MEGA_CORP.ref(1), AnonymousParty(freshKey), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$CashUtils.generateSpend(services, this, Amount(amount.quantity, GBP), identity, thirdPartyIdentity.party.anonymise())</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$FungibleFoo : FungibleState</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$TransactionState(Cash.State(amount `issued by` issuer.ref(depositRef), identity.party), Cash.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(DummyDealContract.State(listOf(megaCorp.party), "Dummy linear id"), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(UniqueDummyFungibleContract.State(10.DOLLARS `issued by` DUMMY_CASH_ISSUER, megaCorp.party), UNIQUE_DUMMY_FUNGIBLE_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(UniqueDummyLinearContract.State(listOf(megaCorp.party), "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer).isNotEqualTo(spendableStatesUSD[1].state.data.amount.token.issuer)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer.reference).isIn(BOC.ref(1).reference, BOC.ref(2).reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer.reference).isNotEqualTo(spendableStatesUSD[1].state.data.amount.token.issuer.reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[1].state.data.amount.token.issuer.reference).isIn(BOC.ref(1).reference, BOC.ref(2).reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$cash.generateIssue(issuance, Amount(howMuch.quantity, Issued(DUMMY_CASH_ISSUER, howMuch.token)), services.myInfo.singleIdentity(), dummyNotary.party)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, DUMMY_CASH_ISSUER_IDENTITY, DUMMY_NOTARY_IDENTITY)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$private</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$services.recordTransactions(StatesToRecord.ALL_VISIBLE, listOf(createTx(6, megaCorp.party, bankOfCorda.party)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$services.recordTransactions(StatesToRecord.ONLY_RELEVANT, listOf(createTx(3, miniCorp.party, megaCorp.party)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val cashStateWithNewNotary = StateAndRef(initialCashState.state.copy(notary = newNotary), StateRef(changeNotaryTx.id, 0))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val changeNotaryTx = NotaryChangeTransactionBuilder(listOf(initialCashState.ref), issueStx.notary!!, newNotary, services.networkParametersService.currentHash).build()</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId1 = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId1)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId2 = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId2)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val expectedNotaryChangeUpdate = Vault.Update(setOf(initialCashState), setOf(cashStateWithNewNotary), null, Vault.UpdateType.NOTARY_CHANGE)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val myKeys = services.keyManagementService.filterMyKeys(listOf(identity.owningKey, myAnonymousIdentity.owningKey)).toSet()</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val states = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(stateRefs = listOf(w1[1].ref, w1[2].ref))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val thirdPartyIdentity = thirdPartyServices.keyManagementService.freshKeyAndCert(thirdPartyServices.myInfo.singleIdentityAndCert(), false)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates1 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates2 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val w1 = vaultService.queryBy&lt;Cash.State&gt;(PageSpecification(pageNumber = 1, pageSize = Integer.MAX_VALUE)).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$vaultService.queryBy(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(relevancyStatus = Vault.RelevancyStatus.ALL), PageSpecification(1)).totalStatesAvailable</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$withIssuerRefs: Set&lt;OpaqueBytes&gt;? = null</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest.Companion$val cordappPackages = listOf("net.corda.finance.contracts.asset", CashSchemaV1::class.packageName, "net.corda.testing.contracts", "net.corda.testing.internal.vault")</ID>
    <ID>MaxLineLength:NodeVersioningTest.kt$NodeVersioningTest$assertThat(rpc.startFlow(NodeVersioningTest::GetPlatformVersionFlow).returnValue.getOrThrow()).isEqualTo(PLATFORM_VERSION)</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$/** Fetch WebServerPluginRegistry classes registered in META-INF/services/net.corda.webserver.services.WebServerPluginRegistry files that exist in the classpath */ val pluginRegistries: List&lt;WebServerPluginRegistry&gt; by lazy { ServiceLoader.load(WebServerPluginRegistry::class.java).toList() }</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$if (e is BindException || e is Errors.NativeIoException &amp;&amp; e.message?.contains("Address already in use") == true) { throw AddressBindingException(address) } else { throw e }</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$private fun reconnectingCordaRPCOps()</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer$val sslConnector = ServerConnector(server, SslConnectionFactory(sslContextFactory, "http/1.1"), HttpConnectionFactory(httpsConfiguration))</ID>
    <ID>MaxLineLength:NodeWebServer.kt$NodeWebServer.&lt;no name provided&gt;$@Throws(IOException::class) override</ID>
    <ID>MaxLineLength:NonEmptySet.kt$NonEmptySet.Companion$elements.forEach { copy += it }</ID>
    <ID>MaxLineLength:NonInvalidatingCache.kt$NonInvalidatingCache.Companion$private</ID>
    <ID>MaxLineLength:NonInvalidatingCache.kt$NonInvalidatingWeightBasedCache.Companion$private</ID>
    <ID>MaxLineLength:NonInvalidatingUnboundCache.kt$NonInvalidatingUnboundCache$constructor(name: String, cacheFactory: NamedCacheFactory, loadFunction: (K) -&gt; V, removalListener: RemovalListener&lt;K, V&gt; = RemovalListener { _, _, _ -&gt; }, keysToPreload: () -&gt; Iterable&lt;K&gt; = { emptyList() }) : this(buildCache(name, cacheFactory, loadFunction, removalListener, keysToPreload))</ID>
    <ID>MaxLineLength:NonInvalidatingUnboundCache.kt$NonInvalidatingUnboundCache.Companion$private</ID>
    <ID>MaxLineLength:NonInvalidatingUnboundCache.kt$NonInvalidatingUnboundCache.Companion$val builder = Caffeine.newBuilder().removalListener(removalListener).executor(SameThreadExecutor.getExecutor())</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow : NotaryServiceFlow</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$"Notary specified by the transaction ($notary) is not on the network parameter whitelist: ${notaryWhitelist.joinToString()}"</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$"expected either ${FilteredTransaction::class.java.simpleName} or ${NotaryChangeWireTransaction::class.java.simpleName}"</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$?:</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$is FilteredTransaction -&gt; TransactionParts(tx.id, tx.inputs, tx.timeWindow, tx.notary, tx.references, networkParametersHash = tx.networkParametersHash)</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$is NotaryChangeWireTransaction</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$private</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests$val modifiedSignature = NotarisationRequestSignature(randomKeyPair.sign(bytesToSign), aliceNode.services.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests.&lt;no name provided&gt;$val alteredMessage = InMemoryMessage(message.topic, OpaqueBytes(alteredMessageData.serialize().bytes), message.uniqueMessageId)</ID>
    <ID>MaxLineLength:Notarise.kt$NotaryDemoClientApi$rpc.startFlow(::RPCStartableNotaryFlowClient, it).returnValue.toCompletableFuture().thenApply { it.map { it.by.toStringShort() } }</ID>
    <ID>MaxLineLength:NotaryChangeFlow.kt$NotaryChangeFlow$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$assertTrue { originalLinkedStates.size == notaryChangeLinkedStates.size &amp;&amp; originalLinkedStates.containsAll(notaryChangeLinkedStates) }</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$clientNodeB.services.recordTransactions(clientNodeA.services.validatedTransactions.getTransaction(issued.ref.txhash)!!)</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$private</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$fun issueInvalidState(services: ServiceHub, identity: Party, notary: Party): StateAndRef&lt;DummyContract.SingleOwnerState&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$fun issueMultiPartyState(nodeA: StartedMockNode, nodeB: StartedMockNode, notaryNode: StartedMockNode, notaryIdentity: Party): StateAndRef&lt;DummyContract.MultiOwnerState&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$fun issueState(services: ServiceHub, nodeIdentity: Party, notaryIdentity: Party): StateAndRef&lt;DummyContract.SingleOwnerState&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$ private fun checkNewNotaryWhitelisted()</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$@Deprecated("NotaryChangeLedgerTransaction should not be created directly, use NotaryChangeWireTransaction.resolve instead.")</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction$val inputPositionIndex: Map&lt;StateRef, Int&gt; = inputs.mapIndexed { index, stateAndRef -&gt; stateAndRef.ref to index }.toMap()</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @CordaInternal internal fun resolveOutputComponent( services: ServicesForResolution, stateRef: StateRef, @Suppress("UNUSED_PARAMETER") params: NetworkParameters ): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @DeleteForDJVM fun resolve(services: ServiceHub, sigs: List&lt;TransactionSignature&gt;)</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING)</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING) constructor(inputs: List&lt;StateRef&gt;, notary: Party, newNotary: Party) : this(listOf(inputs, notary, newNotary).map { it.serialize() })</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$return NotaryChangeLedgerTransaction.create(resolvedInputs, notary, newNotary, id, sigs, resolvedNetworkParameters)</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"${consumedStates.asSequence().joinToString(",\n", limit = 5) { it.key.toString() + " -&gt; " + it.value }}.\n"</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"To find out if any of the conflicting transactions have been generated by this node you can use the hashLookup Corda shell command."</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$override</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.TimeWindowInvalid$override fun toString()</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.WrongNotary$@Deprecated("Deprecated since platform version 4. This object is no longer used, [TransactionInvalid] will be reported in case of notary mismatch")</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryException$/** Id of the transaction to be notarised. Can be _null_ if an error occurred before the id could be resolved. */ val txId: SecureHash? = null</ID>
    <ID>MaxLineLength:NotaryError.kt$StateConsumptionDetails$fun copy(hashOfTransactionId: SecureHash): StateConsumptionDetails</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$ private fun generateRequestSignature(): NotarisationRequestSignature</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$"Notary $notaryParty is not on the network parameter whitelist. A non-whitelisted notary can only be used for notary change transactions"</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$?:</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$NotarySendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$check</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$it is StateRef || it is ReferenceStateRef || it is TimeWindow || it == notaryParty || it is NetworkParametersHash</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$protected</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val historicNotary = (serviceHub.networkParametersService as NetworkParametersStorage).getHistoricNotary(notaryParty) ?: throw IllegalStateException("The notary party $notaryParty specified by transaction ${stx.id}, is not recognised as a current or historic notary.")</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val notarisationRequest = NotarisationRequest(stx.inputs.map { it.copy(txhash = SecureHash.parse(it.txhash.toString())) }, stx.id)</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$@Suspendable override</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$net.corda.core.flows.NotaryFlow.kt</ID>
    <ID>MaxLineLength:NotaryFunctionalSamplers.kt$NotariseDoubleSpendSampler$return FlowInvoke&lt;CashIssueAndDoublePayment&gt;(CashIssueAndDoublePayment::class.java, arrayOf(amount, OpaqueBytes.of(1), counterParty, false, notaryIdentity))</ID>
    <ID>MaxLineLength:NotaryFunctionalSamplers.kt$NotariseDuplicateTransactionSampler : AbstractSampler</ID>
    <ID>MaxLineLength:NotaryFunctionalSamplers.kt$NotariseDuplicateTransactionSampler$return FlowInvoke&lt;CashIssueAndDuplicatePayment&gt;(CashIssueAndDuplicatePayment::class.java, arrayOf(amount, OpaqueBytes.of(1), counterParty, false, notaryIdentity))</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun maybeInstallSerializationFilter(serviceClass: Class&lt;out NotaryService&gt;)</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun scanCorDapps(cordappLoader: CordappLoader): Class&lt;out NotaryService&gt;</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun validateNotaryType(myNotaryIdentity: PartyAndCertificate?, services: ServiceHubInternal)</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$+</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$?:</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$fun loadService(myNotaryIdentity: PartyAndCertificate?, services: ServiceHubInternal, cordappLoader: CordappLoader): NotaryService</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$throw IllegalStateException("There is a discrepancy in the configured notary type and the one advertised in the network parameters - shutting down. " + "Configured as validating: ${configuredAsValidatingNotary}. Advertised as validating: ${validatingNotaryInNetworkMapCache}")</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$val notaryParty = myNotaryIdentity?.party ?: throw IllegalStateException("Could not establish notary identity of this node")</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool : CordaCliWrapper</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$?:</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$@Option(names = ["--config-file", "-f"], paramLabel = "FILE", description = ["The path to the node config file"], required = true, defaultValue = "node.conf")</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$@Option(names = ["-b", BASE_DIR], paramLabel = "FOLDER", description = ["The node working directory where all the files are kept."])</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$@Option(names = ["-p", "--network-root-truststore-password"], paramLabel = "PASSWORD", description = ["Network root trust store password obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$@Option(names = ["-t", "--network-root-truststore"], paramLabel = "FILE", description = ["Network root trust store obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$ConfigValueFactory.fromAnyRef(resolveRelativeCryptoConfPath(configFileParentPath, cryptoServiceConfPath).toString())</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool$private fun unsupportedHsmException()</ID>
    <ID>MaxLineLength:NotaryRegistrationTool.kt$NotaryRegistrationTool${ validateNodeHsmConfigs(listOf(configFile)) val parsedConfig = parseNodeConfiguration() val serviceLegalName = parsedConfig.notary?.serviceLegalName ?: throw IllegalStateException("Notary service legal name not specified. Please include the notary.serviceLegalName entry in the node configuration file.") logger.info("Processing notary service registration for: $serviceLegalName") // This is a workaround for using the service legal name instead of node's legal name for the certificate signing request // TODO: Update NetworkRegistrationHelper to allow specifying a legal name for the CSR val configurationForRegistration = object : NodeConfiguration by parsedConfig { override val myLegalName: CordaX500Name get() = serviceLegalName } with(configurationForRegistration) { val networkRegistrationService = HTTPNetworkRegistrationService( NetworkServicesConfig(this.networkServices!!.doormanURL, URL("http://dummy-host")), VERSION_INFO ) val registrationHelper = NetworkRegistrationHelper( NodeRegistrationConfiguration(this), networkRegistrationService, networkRootTrustStorePath, networkRootTrustStorePassword, NOTARY_PRIVATE_KEY_ALIAS, CertRole.SERVICE_IDENTITY ) registrationHelper.generateKeysAndRegister() } ExitCodes.SUCCESS }</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow : FlowLogicIdempotentFlow</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$ @Suspendable abstract fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$"The notary specified on the transaction: [$notary] does not match the notary service's identity: [${service.notaryIdentityKey}] "</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$abstract</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$logger.info("Received a notarisation request for Tx [$transactionId] from [${otherSideSession.counterparty.name}]")</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$logger.info("Transaction [$txId] successfully notarised, sending signature back to [${otherSideSession.counterparty.name}]")</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests$assertThat(notaryError.cause).hasMessageContaining("Transaction for notarisation contains unknown parameters hash: $hash")</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests$assertThat(notaryError.cause).hasMessageContaining("Transaction for notarisation doesn't contain network parameters hash.")</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests.Companion$ fun notariseWithTooManyInputs(node: TestStartedNode, party: Party, notary: Party, network: InternalMockNetwork)</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests.Companion$val signableData = SignableData(tx.id, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotarySpec.kt$NotarySpec</ID>
    <ID>MaxLineLength:NotarySpec.kt$NotarySpec$// These extra fields are handled this way to preserve Kotlin wire compatibility wrt additional parameters with default values. constructor(name: CordaX500Name, validating: Boolean = true, rpcUsers: List&lt;User&gt; = emptyList(), verifierType: VerifierType = VerifierType.InMemory, cluster: ClusterSpec? = null, maximumHeapSize: String = "512m"): this(name, validating, rpcUsers, verifierType, cluster) { this.maximumHeapSize = maximumHeapSize }</ID>
    <ID>MaxLineLength:NotaryUtils.kt$"Expected a signature by ${intendedSigner.owningKey.toBase58String()}, but received by ${signature.by.toBase58String()}}"</ID>
    <ID>MaxLineLength:NotaryUtils.kt$require(notary.owningKey.isFulfilledBy(signingKeys)) { "Insufficient signatures to fulfill the notary signing requirement for $notary" }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can perform notary change on a de-listed notary`()</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can't perform a regular transaction on a de-listed notary`()</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$notarySpecs = listOf(MockNetworkNotarySpec(oldNotaryName, validating = isValidating), MockNetworkNotarySpec(newNotaryName, validating = isValidating))</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$private</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ // Issue a state using the old notary. It is currently whitelisted. val stateFakeNotary = issueStateOnOldNotary(oldNotary) // Remove old notary from the whitelist val parameters = aliceNode.services.networkParameters val newParameters = removeOldNotary(parameters) mockNet.nodes.forEach { (it.networkParametersStorage as MockNetworkParametersStorage).setCurrentParametersUnverified(newParameters) } // Re-point the state to the remaining whitelisted notary. The transaction itself should be considered valid, even though the old notary is not whitelisted. val futureChange = aliceNode.services.startFlow(NotaryChangeFlow(stateFakeNotary, newNotary)).resultFuture mockNet.runNetwork() val newSTate = futureChange.getOrThrow() // Create a valid transaction consuming the re-pointed state. val validTxBuilder = TransactionBuilder(newNotary) .addInputState(newSTate) .addCommand(dummyCommand(alice.owningKey)) val validStx = aliceNode.services.signInitialTransaction(validTxBuilder) // The transaction verifies. validStx.verify(aliceNode.services, false) // Notarisation should succeed. val future = runNotaryClient(validStx) future.getOrThrow() }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ Assume.assumeTrue(isValidating) // Skip the test for non-validating notaries val fakeNotaryKeyPair = generateKeyPair() val fakeNotaryParty = Party(DUMMY_NOTARY_NAME.copy(organisation = "Fake notary"), fakeNotaryKeyPair.public) // Issue a state using an unlisted notary. This transaction should not verify when checked by counterparties. val stateFakeNotary = issueStateWithFakeNotary(fakeNotaryParty, fakeNotaryKeyPair) // Re-point the state to the whitelisted notary. The transaction itself should be considered valid, even though the old notary is not whitelisted. val notaryChangeLtx = changeNotary(stateFakeNotary, fakeNotaryParty, fakeNotaryKeyPair) // Create a valid transaction consuming the re-pointed state. val inputStateValidNotary = notaryChangeLtx.outRef&lt;DummyContract.State&gt;(0) val validTxBuilder = TransactionBuilder(oldNotary) .addInputState(inputStateValidNotary) .addCommand(dummyCommand(alice.owningKey)) val validStx = aliceNode.services.signInitialTransaction(validTxBuilder) // The transaction itself verifies, as no resolution is done here. validStx.verify(aliceNode.services, false) val future = runNotaryClient(validStx) // The notary should reject this transaction  the issue transaction in the dependencies should not verify. val ex = assertFailsWith(NotaryException::class) { future.getOrThrow() } assert(ex.error is NotaryError.TransactionInvalid) assertEquals(validStx.id, ex.txId) }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ val notaryChangeTx = NotaryChangeTransactionBuilder( listOf(inputState.ref), fakeNotaryParty, oldNotary, aliceNode.services.networkParametersService.currentHash ).build() val notaryChangeAliceSig = getAliceSig(notaryChangeTx) val notaryChangeNotarySig = run { val metadata = SignatureMetadata(4, Crypto.findSignatureScheme(fakeNotaryParty.owningKey).schemeNumberID) val data = SignableData(notaryChangeTx.id, metadata) fakeNotaryKeyPair.sign(data) } val notaryChangeStx = SignedTransaction(notaryChangeTx, listOf(notaryChangeAliceSig, notaryChangeNotarySig)) aliceNode.services.validatedTransactions.addTransaction(notaryChangeStx) // Resolving the ledger transaction verifies the whitelist checking logic  for notary change transactions the old notary // does not need to be whitelisted. val notaryChangeLtx = notaryChangeStx.resolveNotaryChangeTransaction(aliceNode.services) notaryChangeLtx.verifyRequiredSignatures() return notaryChangeLtx }</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationPayload</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationRequest</ID>
    <ID>MaxLineLength:NotaryWireFormat.kt$NotarisationRequest$/** States this request specifies to be consumed. Sorted to ensure the serialized form does not get affected by the state order. */ val statesToConsume: List&lt;StateRef&gt; get() = _statesToConsumeSorted // Getter required for AMQP serialization</ID>
    <ID>MaxLineLength:NullKeys.kt$NullKeys$/** A signature with a key and value of zero. Useful when you want a signature object that you know won't ever be used. */ val NULL_SIGNATURE = TransactionSignature(ByteArray(32), NullPublicKey, SignatureMetadata(1, -1))</ID>
    <ID>MaxLineLength:OGStub.kt$BimmAnalysisUtils$first: CurrencyParameterSensitivities</ID>
    <ID>MaxLineLength:OGStub.kt$BimmAnalysisUtils$fun computeMargin(combinedRatesProvider: ImmutableRatesProvider?, normalizer: PortfolioNormalizer, calculatorTotal: RwamBimmNotProductClassesCalculator, first: CurrencyParameterSensitivities, second: MultiCurrencyAmount): Triple&lt;Double, Double, Double&gt;</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val defnsCcp1 = RatesCalibrationCsvLoader.load(GROUPS_RESOURCE_CCP1, SETTINGS_RESOURCE_CCP1, CALIBRATION_RESOURCE_CCP1)</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val defnsCcp2 = RatesCalibrationCsvLoader.load(GROUPS_RESOURCE_CCP2, SETTINGS_RESOURCE_CCP2, CALIBRATION_RESOURCE_CCP2)</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val marketData = ImmutableMarketData.builder(VAL_DATE).addValueMap(quotesCcp1).addValueMap(quotesCcp2).addTimeSeriesMap(fixings).build()</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val marketDataConfig = MarketDataConfig.builder().add(CURVE_GROUP_NAME_CCP1, curveGroupDefinitionCcp1).add(CURVE_GROUP_NAME_CCP2, curveGroupDefinitionCcp2).build()</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val tradeInfo = TradeInfo.builder().id(StandardId.of("example", "1")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 3m").counterparty(ctptyId).settlementDate(LocalDate.of(2014, 9, 12)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2016, 6, 12)) .frequency(Frequency.P3M) .businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY))</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2016, 6, 12)) .stubConvention(StubConvention.SHORT_INITIAL) .frequency(Frequency.P6M)</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2020, 9, 12)) .frequency(Frequency.P3M) .businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY))</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "10")).addAttribute(TradeAttributeType.DESCRIPTION, "Zero-coupon fixed vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "11")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding fixed vs fed funds").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 2, 5)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "12")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding fed funds vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "13")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding libor 6m vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 8, 27)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "15")).addAttribute(TradeAttributeType.DESCRIPTION, "USD fixed vs GBP Libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "16")).addAttribute(TradeAttributeType.DESCRIPTION, "USD fixed vs GBP Libor 3m (notional exchange)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "2")).addAttribute(TradeAttributeType.DESCRIPTION, "Libor 3m + spread vs Libor 6m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "7")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 3m (1m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "8")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 6m (interpolated 3m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "9")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 6m (interpolated 4m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(receiveLeg, payLeg)).info(TradeInfo.builder().id(StandardId.of("example", "14")).addAttribute(TradeAttributeType.DESCRIPTION, "GBP Libor 3m vs USD Libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val calculationResults = ReportCalculationResults.of(valuationDate, trades, columns, results, functions, refData)</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.GBP, 61600000.0)).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.builder().currency(Currency.USD).amount(ValueSchedule.of(100000000.0)).initialExchange(true).finalExchange(true).build()).calculation(FixedRateCalculation.of(0.03, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.USD, 100000000.0)).calculation(FixedRateCalculation.of(0.03, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 2, 5)).endDate(LocalDate.of(2014, 4, 7)).frequency(Frequency.TERM).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.00123, DayCounts.ACT_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 8, 27)).endDate(LocalDate.of(2024, 8, 27)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_6M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 6, 12)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_6M).initialStub(IborRateStubCalculation.ofIborInterpolatedRate(IborIndices.USD_LIBOR_3M, IborIndices.USD_LIBOR_6M)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_6M).initialStub(IborRateStubCalculation.ofIborInterpolatedRate(IborIndices.USD_LIBOR_3M, IborIndices.USD_LIBOR_6M)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2020, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2021, 9, 12)).frequency(Frequency.P12M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.015, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.builder().currency(Currency.GBP).amount(ValueSchedule.of(61600000.0)).initialExchange(true).finalExchange(true).build()).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.GBP, 61600000.0)).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.USD, 100000000.0)).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_3M).spread(ValueSchedule.of(0.0091)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 2, 5)).endDate(LocalDate.of(2014, 4, 7)).frequency(Frequency.TERM).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(OvernightRateCalculation.of(OvernightIndices.USD_FED_FUND)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 8, 27)).endDate(LocalDate.of(2024, 8, 27)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 6, 12)).stubConvention(StubConvention.SHORT_INITIAL).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.01, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).stubConvention(StubConvention.SHORT_INITIAL).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.01, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2020, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(OvernightRateCalculation.builder().index(OvernightIndices.USD_FED_FUND).accrualMethod(OvernightAccrualMethod.AVERAGED).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2021, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGTrade.kt$OGTrade$val groups: List&lt;LedgerTransaction.InOutGroup&lt;IRSState, UniqueIdentifier&gt;&gt; = tx.groupStates { state -&gt; state.linearId }</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ConstructorCaller$"Constructor for ${javaConstructor.declaringClass} (isAccessible=${javaConstructor.isAccessible}) "</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$EvolutionObjectBuilder.Companion$ fun makeProvider(typeIdentifier: TypeIdentifier, constructor: LocalConstructorInformation, localProperties: Map&lt;String, LocalPropertyInformation&gt;, remoteTypeInformation: RemoteTypeInformation.Composable, mustPreserveData: Boolean): () -&gt; ObjectBuilder</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilder.Companion$ConstructorBasedObjectBuilder(ConstructorCaller(constructor.observedMethod), constructorIndices.values.toIntArray())</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilder.Companion$is LocalPropertyInformation.PrivateConstructorPairedProperty -&gt; property.constructorSlot.parameterIndex</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilder.Companion$private</ID>
    <ID>MaxLineLength:ObjectBuilder.kt$ObjectBuilderProvider : </ID>
    <ID>MaxLineLength:ObjectDiffer.kt$DiffTree$is Step -&gt; branches.flatMap { (step, tree) -&gt; tree.toPaths().map { it.copy(path = listOf(step) + it.path) } }</ID>
    <ID>MaxLineLength:ObjectDiffer.kt$ObjectDiffer$val branches = aFields.mapNotNull { field -&gt; diff(field.get(a), field.get(b))?.let { field.name to it } }</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$AbstractObjectSerializer$override</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ComposableObjectReader$"${propertySerializers.size} properties in described type ${typeIdentifier.prettyPrint(false)}"</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ComposableObjectReader$fun readObject(obj: Any, schemas: SerializationSchemas, input: DeserializationInput, context: SerializationContext): Any</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ComposableObjectSerializer$override</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$EvolutionObjectSerializer$override</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$ComposableTypePropertySerializer.makeForEvolution(name, isCalculated, property.type.typeIdentifier, type)</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$val type = localProperty?.type?.observedType ?: property.type.typeIdentifier.getLocalType(classLoader)</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ObjectSerializer.Companion$serializers.isNotEmpty() -&gt; "Registered custom serializers:\n ${serializers.joinToString("\n ")}"</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ObjectSerializer.Companion$val writer = ComposableObjectWriter(typeNotation, typeInformation.interfacesOrEmptyList, propertySerializers)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$ @JvmStatic fun &lt;P : Any&gt; generateCloseOutNetting(tx: TransactionBuilder, signer: AbstractParty, vararg inputs: StateAndRef&lt;Obligation.State&lt;P&gt;&gt;)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states have the same beneficiary" using (statesAndRefs.all { it.state.data.beneficiary == obligationOwner })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states have the same obligor" using (statesAndRefs.all { it.state.data.obligor == obligationIssuer })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all states are in the normal lifecycle state " using (states.all { it.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$Obligation.State(Obligation.Lifecycle.NORMAL, obligor, issuanceDef, amount.quantity, beneficiary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$deriveState = { state, amount, owner -&gt; state.copy(data = state.data.withNewOwnerAndAmount(amount, owner)) }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$private</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$require(states.all { it.lifecycle == existingLifecycle }) { "initial lifecycle must be $existingLifecycle for all input states" }</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(change, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$val changeOwner = assetStates.map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amountIssued)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils${ val states = statesAndRefs.map { it.state } val obligationIssuer = states.first().data.obligor val obligationOwner = states.first().data.beneficiary requireThat { "all fungible asset states use the same notary" using (assetStatesAndRefs.all { it.state.notary == notary }) "all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL }) "all obligation states use the same notary" using (statesAndRefs.all { it.state.notary == notary }) "all obligation states have the same obligor" using (statesAndRefs.all { it.state.data.obligor == obligationIssuer }) "all obligation states have the same beneficiary" using (statesAndRefs.all { it.state.data.beneficiary == obligationOwner }) } // TODO: A much better (but more complex) solution would be to have two iterators, one for obligations, // one for the assets, and step through each in a semi-synced manner. For now however we just bundle all the states // on each side together val issuanceDef = getIssuanceDefinitionOrThrow(statesAndRefs.map { it.state.data }) val template: Obligation.Terms&lt;P&gt; = issuanceDef.product val obligationTotal: Amount&lt;P&gt; = Amount(states.map { it.data }.sumObligations&lt;P&gt;().quantity, template.product) var obligationRemaining: Amount&lt;P&gt; = obligationTotal val assetSigners = HashSet&lt;AbstractParty&gt;() statesAndRefs.forEach { tx.addInputState(it) } // Move the assets to the new beneficiary assetStatesAndRefs.forEach { ref -&gt; if (obligationRemaining.quantity &gt; 0L) { tx.addInputState(ref) val assetState = ref.state.data val amount = Amount(assetState.amount.quantity, assetState.amount.token.product) obligationRemaining -= if (obligationRemaining &gt;= amount) { tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount, obligationOwner), Obligation.PROGRAM_ID, notary) amount } else { val change = Amount(obligationRemaining.quantity, assetState.amount.token) // Split the state in two, sending the change back to the previous beneficiary tx.addOutputState(assetState.withNewOwnerAndAmount(change, obligationOwner), Obligation.PROGRAM_ID, notary) tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary) Amount(0L, obligationRemaining.token) } assetSigners.add(assetState.owner) } } // If we haven't cleared the full obligation, add the remainder as an output if (obligationRemaining.quantity &gt; 0L) { tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary) } else { // Destroy all of the states } // Add the asset move command and obligation settle tx.addCommand(moveCommand, assetSigners.map { it.owningKey }) tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey) }</ID>
    <ID>MaxLineLength:ObservableFold.kt$ fun &lt;A, K&gt; Observable&lt;A&gt;.recordAsAssociation(toKey: (A) -&gt; K, merge: (K, oldValue: A, newValue: A) -&gt; A = { _, _, newValue -&gt; newValue }): ObservableMap&lt;K, A&gt;</ID>
    <ID>MaxLineLength:ObservableFold.kt$ fun &lt;T, R&gt; Observable&lt;T&gt;.fold(accumulator: R, folderFun: (R, T) -&gt; Unit): R</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;A&gt; Collection&lt;ObservableValue&lt;out A&gt;&gt;.sequence(): ObservableList&lt;A&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;K : Any, A : Any, B&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K, assemble: (K, A) -&gt; B): ObservableMap&lt;K, ObservableList&lt;B&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ fun &lt;K : Any, A : Any&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K): ObservableMap&lt;K, ObservableList&lt;A&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$Pair(left, ChosenList(rightValue.map { it ?: FXCollections.emptyObservableList() }, "ChosenList from leftOuterJoin"))</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$return AssociatedList(AggregatedList(this, toKey) { key, members -&gt; Pair(key, members) }, { it.first }) { key, pair -&gt; pair.second.map { assemble(key, it) } }</ID>
    <ID>MaxLineLength:ObservableUtilities.kt${ //TODO This is a tactical work round for an issue with SAM conversion (https://youtrack.jetbrains.com/issue/ALL-1552) so that the M10 explorer works. return uncheckedCast(uncheckedCast&lt;Any, ObservableList&lt;A?&gt;&gt;(this).filtered { t -&gt; t != null }) }</ID>
    <ID>MaxLineLength:ObservablesTests.kt$ObservablesTests$val database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null })</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$StartMessageChainFlow : FlowLogic</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$alice.services.startFlow(SplitMessagesFlow(message, bob.info.singleIdentity(), notary)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests$node.services.startFlow(SendTransaction(regulator.info.singleIdentity(), transactionList[transactionIdx])).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow$val txCommand = Command(MessageChainContract.Commands.Send(), messageState.participants.map { it.owningKey })</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow$val txCommand = Command(MessageChainContract.Commands.Split(), listOf(ourIdentity.owningKey, counterparty.owningKey))</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CHAIN_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow$val txCommand = Command(MessageChainContract.Commands.Send(), messageState.participants.map { it.owningKey })</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$fun tracker()</ID>
    <ID>MaxLineLength:OffsetDateTimeSerializer.kt$OffsetDateTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:OffsetDateTimeSerializer.kt$OffsetDateTimeSerializer$override fun toProxy(obj: OffsetDateTime): OffsetDateTimeProxy</ID>
    <ID>MaxLineLength:OffsetDateTimeSerializer.kt$OffsetDateTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalDateTimeSerializer(factory), ZoneIdSerializer(factory))</ID>
    <ID>MaxLineLength:OffsetTimeSerializer.kt$OffsetTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:OffsetTimeSerializer.kt$OffsetTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalTimeSerializer(factory), ZoneIdSerializer(factory))</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$abstract</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset$abstract fun extractCommands(commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;): Collection&lt;CommandWithParties&lt;C&gt;&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$ @Throws(InsufficientBalanceException::class) @JvmStatic fun &lt;S : FungibleAsset&lt;T&gt;, T: Any&gt; generateExit(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData): Set&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$amount: Amount&lt;T&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$generateMoveCommand: () -&gt; CommandData</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$log.trace { "Gathered coins: requested $amount, available $gatheredAmount, change: ${gatheredAmount - amount}" }</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$return generateSpend(tx, listOf(PartyAndAmount(to, amount)), acceptableStates, payChangeTo, deriveState, generateMoveCommand)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion${ // Discussion // // This code is analogous to the Wallet.send() set of methods in bitcoinj, and has the same general outline. // // First we must select a set of asset states (which for convenience we will call 'coins' here, as in bitcoinj). // The input states can be considered our "vault", and may consist of different products, and with different // issuers and deposits. // // Coin selection is a complex problem all by itself and many different approaches can be used. It is easily // possible for different actors to use different algorithms and approaches that, for example, compete on // privacy vs efficiency (number of states created). Some spends may be artificial just for the purposes of // obfuscation and so on. // // Having selected input states of the correct asset, we must craft output states for the amount we're sending and // the "change", which goes back to us. The change is required to make the amounts balance. We may need more // than one change output in order to avoid merging assets from different deposits. The point of this design // is to ensure that ledger entries are immutable and globally identifiable. // // Finally, we add the states to the provided partial transaction. // TODO: We should be prepared to produce multiple transactions spending inputs from // different notaries, or at least group states by notary and take the set with the // highest total value. // TODO: Check that re-running this on the same transaction multiple times does the right thing. // The notary may be associated with a locked state only. tx.notary = acceptableStates.firstOrNull()?.state?.notary // Calculate the total amount we're sending (they must be all of a compatible token). val totalSendAmount = payments.map { it.amount }.sumOrThrow() // Select a subset of the available states we were given that sums up to &gt;= totalSendAmount. val (gathered, gatheredAmount) = gatherCoins(acceptableStates, totalSendAmount) check(gatheredAmount &gt;= totalSendAmount) val keysUsed = gathered.map { it.state.data.owner.owningKey } // Now calculate the output states. This is complicated by the fact that a single payment may require // multiple output states, due to the need to keep states separated by issuer. We start by figuring out // how much we've gathered for each issuer: this map will keep track of how much we've used from each // as we work our way through the payments. val statesGroupedByIssuer = gathered.groupBy { it.state.data.amount.token } val remainingFromEachIssuer = statesGroupedByIssuer .mapValues { it.value.map { it.state.data.amount }.sumOrThrow() }.toList().toMutableList() val outputStates = mutableListOf&lt;TransactionState&lt;S&gt;&gt;() for ((party, paymentAmount) in payments) { var remainingToPay = paymentAmount.quantity while (remainingToPay &gt; 0) { val (token, remainingFromCurrentIssuer) = remainingFromEachIssuer.last() val templateState = statesGroupedByIssuer[token]!!.first().state val delta = remainingFromCurrentIssuer.quantity - remainingToPay when { delta &gt; 0 -&gt; { // The states from the current issuer more than covers this payment. outputStates += deriveState(templateState, Amount(remainingToPay, token), party) remainingFromEachIssuer[0] = Pair(token, Amount(delta, token)) remainingToPay = 0 } delta == 0L -&gt; { // The states from the current issuer exactly covers this payment. outputStates += deriveState(templateState, Amount(remainingToPay, token), party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay = 0 } delta &lt; 0 -&gt; { // The states from the current issuer don't cover this payment, so we'll have to use &gt;1 output // state to cover this payment. outputStates += deriveState(templateState, remainingFromCurrentIssuer, party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay -= remainingFromCurrentIssuer.quantity } } } } // Whatever values we have left over for each issuer must become change outputs. for ((token, amount) in remainingFromEachIssuer) { val templateState = statesGroupedByIssuer[token]!!.first().state outputStates += deriveState(templateState, amount, payChangeTo) } for (state in gathered) tx.addInputState(state) for (state in outputStates) tx.addOutputState(state) // What if we already have a move command with the right keys? Filter it out here or in platform code? tx.addCommand(generateMoveCommand(), keysUsed) return Pair(tx, keysUsed) }</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion${ // The states from the current issuer don't cover this payment, so we'll have to use &gt;1 output // state to cover this payment. outputStates += deriveState(templateState, remainingFromCurrentIssuer, party) remainingFromEachIssuer.removeAt(remainingFromEachIssuer.lastIndex) remainingToPay -= remainingFromCurrentIssuer.quantity }</ID>
    <ID>MaxLineLength:OpaqueBytesSubSequenceSerializer.kt$OpaqueBytesSubSequenceSerializer$CustomSerializer.Proxy&lt;OpaqueBytesSubSequence, OpaqueBytes&gt;(OpaqueBytesSubSequence::class.java, OpaqueBytes::class.java, factory)</ID>
    <ID>MaxLineLength:OpaqueBytesSubSequenceSerializer.kt$OpaqueBytesSubSequenceSerializer$override fun fromProxy(proxy: OpaqueBytes): OpaqueBytesSubSequence</ID>
    <ID>MaxLineLength:OpenGammaCordaUtils.kt$ fun InitialMarginTriple.toCordaCompatible()</ID>
    <ID>MaxLineLength:OpenGammaCordaUtils.kt$return MultiCurrencyAmount.of(this.amounts.map { CurrencyAmount.of(Currency.of(it.currency.code).serialize().deserialize(), twoDecimalPlaces((it.amount))) })</ID>
    <ID>MaxLineLength:OptInLogCollector.kt$OptInLogCollector$Files.list(logs) // Only include log files .filter { path -&gt; path.toString().endsWith(".log", true) } // Only include files that have been modified over the past 3 days .filter { path -&gt; Files.getLastModifiedTime(path).toInstant() &gt; Instant.now().minusSeconds(3 * 24 * 60 * 60) }</ID>
    <ID>MaxLineLength:OptionalSerializer.kt$OptionalSerializer : Proxy</ID>
    <ID>MaxLineLength:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$TransactionBuilder(DUMMY_NOTARY) .withItems(TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy alice.party, Cash.PROGRAM_ID, DUMMY_NOTARY))</ID>
    <ID>MaxLineLength:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy alice.party, Cash.PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$mockNet = @Suppress("DEPRECATION") MockNetwork(cordappPackages = listOf("net.corda.finance.contracts", "net.corda.irs"))</ID>
    <ID>MaxLineLength:OverridePKSerializerTest.kt$OverridePKSerializerTest.TestPublicKeySerializer$get() = TODO("not implemented") //To change initializer of created properties use File | Settings | File Templates.</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$driver</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.rpc.hasCancelledDrainingShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted { successful = true }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.rpc.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted(nodeA::stop)</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.waitForShutdown().doOnError(Throwable::printStackTrace).doAfterTerminate { successful = false }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted { successful = true }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$val nodeA = startNode(providedName = ALICE_NAME, rpcUsers = users).getOrThrow() var successful = false val latch = CountDownLatch(1) // This would not be needed, as `terminate(true)` sets draining mode anyway, but it's here to ensure that it removes the persistent value anyway. nodeA.rpc.setFlowsDrainingModeEnabled(true) nodeA.rpc.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted(nodeA::stop).doOnCompleted { val nodeARestarted = startNode(providedName = ALICE_NAME, rpcUsers = users).getOrThrow() successful = !nodeARestarted.rpc.isFlowsDrainingModeEnabled() }.doAfterTerminate(latch::countDown).subscribe() nodeA.rpc.terminate(true) latch.await() assertThat(successful).isTrue()</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$ private fun highestSeqNoHWMInDatabaseFor(senderKey: SenderKey): SenderHashToSeqNo</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$ private fun isDuplicateWithPotentialOptimization(receivedSenderUUID: String, receivedSenderSeqNo: Long, msg: ReceivedMessage): Boolean</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$fromPersistentEntity = { Pair(DeduplicationId(it.id), MessageMeta(it.insertionTime, it.hash, it.seqNo)) }</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$log.debug { "${formatMessageForLogging(msg)} is a duplicate in the database but senderHash=$senderHash differs from the original. The identity changed." }</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$log.trace { "${formatMessageForLogging(msg)} senderHash=$senderHash is new high water mark vs. $existingSeqNoHWM" }</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$log.trace { "${formatMessageForLogging(msg)} senderHash=${senderHashToSeqNo.first} fetched highest sequence number from database of ${senderHashToSeqNo.second}" }</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$private</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator${ if (beingProcessedMessages.containsKey(msg.uniqueMessageId)) { log.trace { "${formatMessageForLogging(msg)} is currently being processed." } return true } log.trace { "${formatMessageForLogging(msg)} is NOT currently being processed." } val receivedSenderUUID = msg.senderUUID val receivedSenderSeqNo = msg.senderSeqNo // If we have received a new higher sequence number, then it cannot be a duplicate, and we don't need to check database. // If we are seeing a sender for the first time, fall back to a database check. // If we have no information about the sender, also fall back to a database check. return if (receivedSenderUUID != null &amp;&amp; receivedSenderSeqNo != null) { isDuplicateWithPotentialOptimization(receivedSenderUUID, receivedSenderSeqNo, msg) } else { isDuplicateInDatabase(msg) } }</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator.Companion$private fun formatMessageForLogging(msg: ReceivedMessage): String</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator.Companion$private fun formatMetaForLogging(deduplicationId: DeduplicationId, messageMeta: MessageMeta?): String</ID>
    <ID>MaxLineLength:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest$val msg = generateMessage(senderSeqNo = sequenceNo.toLong(), peer = senderName, senderUUID = senderUUID.toString())</ID>
    <ID>MaxLineLength:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest$val receivedFromDifferentPeer = generateMessage(uniqueMessageId = receivedMessage.uniqueMessageId, senderUUID = receivedMessage.senderUUID, senderSeqNo = receivedMessage.senderSeqNo)</ID>
    <ID>MaxLineLength:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest${ val senderCount = 10 val messagePerSender = 100 // Fill table with messages - part 1 fillMessages(senderCount, messagePerSender) assertEquals(senderCount * messagePerSender, getRowCount()) // Advance clock so the messages expire testClock.advanceBy(retainForDays.days + 1.minutes) // Fill table with messages - part 2 fillMessages(senderCount, messagePerSender) // Fill table with null sender messages fillNullSenderMessages(messagePerSender) assertEquals(senderCount * messagePerSender * 2 + messagePerSender, getRowCount()) // Clean up old messages. All messages from part 1 should be removed + (messagePerSender - retainPerSender) from part 2. val duration = elapsedTime { NodeJanitor.cleanUpProcessedMessages(database, testClock, retainForDays, retainPerSender) } log.info("Cleaning up messages: $duration") // Expecting only [retainPerSender] messages per sender to remain + the null sender messages assertEquals(senderCount * retainPerSender + messagePerSender, getRowCount()) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$ fun start(myIdentity: PublicKey, serviceIdentity: PublicKey?, maxMessageSize: Int, advertisedAddress: NetworkHostAndPort = serverAddress, legalName: String)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$// Never time out on our loopback Artemis connections. If we switch back to using the InVM transport this // would be the default and the two lines below can be deleted. connectionTTL = 60000 clientFailureCheckPeriod = 30000 callFailoverTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT) callTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT) minLargeMessageSize = maxMessageSize + JOURNAL_HEADER_SIZE isUseGlobalPools = nodeSerializationEnv != null confirmationWindowSize = config.enterpriseConfiguration.tuning.p2pConfirmationWindowSize producerWindowSize = -1 // Configuration for dealing with external broker failover if (config.messagingServerExternal) { connectionLoadBalancingPolicyClassName = RoundRobinConnectionPolicy::class.java.canonicalName reconnectAttempts = config.enterpriseConfiguration.messagingServerConnectionConfiguration.reconnectAttempts(isHA) retryInterval = config.enterpriseConfiguration.messagingServerConnectionConfiguration.retryInterval().toMillis() retryIntervalMultiplier = config.enterpriseConfiguration.messagingServerConnectionConfiguration.retryIntervalMultiplier() maxRetryInterval = config.enterpriseConfiguration.messagingServerConnectionConfiguration.maxRetryInterval(isHA).toMillis() isFailoverOnInitialConnection = config.enterpriseConfiguration.messagingServerConnectionConfiguration.failoverOnInitialAttempt(isHA) initialConnectAttempts = config.enterpriseConfiguration.messagingServerConnectionConfiguration.initialConnectAttempts(isHA) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$BridgeEntry(messagingAddress.queueName, node.addresses, node.legalIdentities.map(Party::name), serviceAddress = false)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$callFailoverTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$callTimeout = java.lang.Long.getLong(CORDA_ARTEMIS_CALL_TIMEOUT_PROP_NAME, CORDA_ARTEMIS_CALL_TIMEOUT_DEFAULT)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$createQueueIfAbsent(internalTargetQueue, producerSession!!, exclusive = exclusive, isServiceAddress = isServiceAddress)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$deliverTo(msg, HandlerRegistration(msg.topic, deliverTo), MessageDeduplicationHandler(artemisMessage, msg))</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$detailedLogger.trace { "Message(action=receive;flowId=$currentFlowId;size=${artemisMessage.encodeSize};id=${msg.uniqueMessageId.toString};platformVersion=${msg.platformVersion};from=${msg.peer})" }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$detailedLogger.trace { "Message(action=send;flowId=$currentFlowId;size=${message.data.size};id=${message.uniqueMessageId.toString};to=$target)" }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$errorAndTerminate("Could not reconnect to the broker after ${config.enterpriseConfiguration.messagingServerConnectionConfiguration.reconnectAttempts(locator!!.isHA)} attempts. Node is shutting down.", null)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$initialConnectAttempts = config.enterpriseConfiguration.messagingServerConnectionConfiguration.initialConnectAttempts(isHA)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$isFailoverOnInitialConnection = config.enterpriseConfiguration.messagingServerConnectionConfiguration.failoverOnInitialAttempt(isHA)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$locator</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.debug { "Discard duplicate message id: ${cordaMessage.uniqueMessageId} senderUUID: ${cordaMessage.senderUUID} senderSeqNo: ${cordaMessage.senderSeqNo} isSessionInit: ${cordaMessage.isSessionInit}" }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.debug { "Received message from: ${message.address} user: $user topic: $topic id: $uniqueMessageId senderUUID: $receivedSenderUUID senderSeqNo: $receivedSenderSeqNo isSessionInit: $isSessionInit size: ${message.bodySize}" }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.info("Back-up message broker addresses: ${config.enterpriseConfiguration.messagingServerBackupAddresses}")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.warn("Received message ${msg.uniqueMessageId} for ${msg.topic} that doesn't have any registered handlers yet")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$maxRetryInterval = config.enterpriseConfiguration.messagingServerConnectionConfiguration.maxRetryInterval(isHA).toMillis()</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$override</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$p2pConsumer = P2PMessagingConsumer(inboxes, createNewSession, isDrainingModeOn, drainingModeWasChangedEvents, metricRegistry)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$p2pConsumer!!.messages // this `run()` method is semantically meant to block until the message consumption runs, hence the latch here .doOnCompleted(latch::countDown)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$private</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$reconnectAttempts = config.enterpriseConfiguration.messagingServerConnectionConfiguration.reconnectAttempts(isHA)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$retryInterval = config.enterpriseConfiguration.messagingServerConnectionConfiguration.retryInterval().toMillis()</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$retryIntervalMultiplier = config.enterpriseConfiguration.messagingServerConnectionConfiguration.retryIntervalMultiplier()</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$return ArtemisReceivedMessage(topic, CordaX500Name.parse(user), platformVersion, uniqueMessageId, receivedSenderUUID, receivedSenderSeqNo, isSessionInit, message)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$return NodeClientMessage(topic, OpaqueBytes(data), deduplicationId.deduplicationId, deduplicationId.senderUUID, additionalHeaders)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$throw IllegalStateException("Cannot add another acking handler for $topic, there is already an acking one")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val backupTransports = p2pConnectorTcpTransportFromList(config.enterpriseConfiguration.messagingServerBackupAddresses, sslOptions, keyStoreProvider = artemisSigningServiceName(sslOptions))</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val bridge = BridgeEntry(queueName, node.addresses, node.legalIdentities.map { it.name }, isServiceAddress)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val bridge = BridgeEntry(queueName.toString(), node.addresses, node.legalIdentities.map { it.name }, serviceAddress = false)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val createNewSession = { sessionFactory!!.createSession(ArtemisMessagingComponent.NODE_P2P_USER, ArtemisMessagingComponent.NODE_P2P_USER, false, true, true, false, ActiveMQClient.DEFAULT_ACK_BATCH_SIZE) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val isSessionInit = message.getStringProperty(P2PMessagingHeaders.Type.KEY) == P2PMessagingHeaders.Type.SESSION_INIT_VALUE</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val receivedSenderSeqNo = if (message.containsProperty(P2PMessagingHeaders.senderSeqNo)) message.getLongProperty(P2PMessagingHeaders.senderSeqNo) else null</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val tcpTransport = p2pConnectorTcpTransport(serverAddress, sslOptions, keyStoreProvider = artemisSigningServiceName(sslOptions))</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val uniqueMessageId = message.required(HDR_DUPLICATE_DETECTION_ID) { DeduplicationId(message.getStringProperty(it)) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient${ val queueQuery = session.queueQuery(SimpleString(queueName)) if (!queueQuery.isExists) { log.info("Create fresh queue $queueName bound on same address") session.createQueue(queueName, RoutingType.ANYCAST, queueName, null, true, false, ActiveMQDefaultConfiguration.getDefaultMaxQueueConsumers(), ActiveMQDefaultConfiguration.getDefaultPurgeOnNoConsumers(), exclusive, null) } // When there are multiple nodes sharing the firewall, the peer queue may already exist as it was created when // another node tried communicating with the target. A bridge is still needed as there has to be one per source-queue-target sendBridgeCreateMessage() }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient.ArtemisReceivedMessage$override val data: ByteSequence by lazy { OpaqueBytes(ByteArray(message.bodySize).apply { message.bodyBuffer.readBytes(this) }) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient.MessageDeduplicationHandler$private inner</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingConsumer$logger.warn("Node is currently in draining mode, new flows will not be processed! Flows in flight: ${metricsRegistry.gauges["Flows.InFlight"]?.value}")</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingConsumer.Companion$private const val initialSessionMessages = "${P2PMessagingHeaders.Type.KEY}&lt;&gt;'${P2PMessagingHeaders.Type.SESSION_INIT_VALUE}'"</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest$ inline fun MessagingService.runOnNextMessage(topic: String, crossinline callback: (ReceivedMessage) -&gt; Unit)</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest$internalServices.networkService.send("test.request", TestRequest(replyTo = internalServices.networkService.myAddress), target)</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest$private</ID>
    <ID>MaxLineLength:P2PMessagingTest.kt$P2PMessagingTest${ // Setup each node in the distributed service to return back it's NodeInfo so that we can know which node is being used participatingServiceNodes.forEach { node -&gt; node.respondWith(node.services.myInfo) } val serviceAddress = originatingNode.services.networkMapCache.run { originatingNode.internalServices.networkService.getAddressOfParty(getPartyInfo(getNotary(serviceName)!!)!!) } val participatingNodes = HashSet&lt;Any&gt;() // Try several times so that we can be fairly sure that any node not participating is not due to Artemis' selection // strategy. 3 attempts for each node seems to be sufficient. // This is not testing the distribution of the requests - DistributedServiceTests already does that for (it in 1..participatingServiceNodes.size * 3) { participatingNodes += originatingNode.receiveFrom(serviceAddress).getOrThrow(10.seconds) if (participatingNodes.size == participatingServiceNodes.size) { break } } assertThat(participatingNodes).containsOnlyElementsOf(participatingServiceNodes.map { it.services.myInfo }) }</ID>
    <ID>MaxLineLength:PackageOwnershipVerificationTests.kt$PackageOwnershipVerificationTests$output(DUMMY_CONTRACT, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(SecureHash.allOnesHash), DummyContractState())</ID>
    <ID>MaxLineLength:Parameters.kt$Parameters$@CommandLine.Option(names = ["-d", "--double-spend-ratio"], description = ["The double spend ratio (default: 0.02)"])</ID>
    <ID>MaxLineLength:Parameters.kt$Parameters$@CommandLine.Option(names = ["-n", "--num-transactions"], description = ["How many transactions to generate (default: 20)"])</ID>
    <ID>MaxLineLength:ParametersUtilities.kt$ fun NetworkParameters.addNotary(party: Party, validating: Boolean = true): NetworkParameters</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree$PartialTree</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree$if (!leafIndexHelper(leaf, this.root, flagPath)) throw MerkleTreeException("The provided hash $leaf is not in the tree.")</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$ fun rootAndUsedHashes(node: PartialTree, usedHashes: MutableList&lt;SecureHash&gt;): SecureHash</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$// Check if a MerkleTree is full binary tree. Returns the height of the tree if full, otherwise throws exception. private fun checkFull(tree: MerkleTree, level: Int = 0): Int</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$assertFailsWith&lt;MerkleTreeException&gt; { PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("20"))) }</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$assertFailsWith&lt;MerkleTreeException&gt; { PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("20"), SecureHash.sha256("1"), SecureHash.sha256("5"))) }</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = listOf(NotaryInfo(DUMMY_NOTARY, true)))</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$val pmt = PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("1"), SecureHash.sha256("5"), SecureHash.sha256("0"), SecureHash.sha256("19")))</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest${ // We even use the same privacySalt, and thus the only difference between the two transactions is the notary party. val privacySalt = PrivacySalt() val wtx1 = makeSimpleCashWtx(DUMMY_NOTARY, privacySalt) val wtx2 = makeSimpleCashWtx(MEGA_CORP, privacySalt) assertEquals(wtx1.privacySalt, wtx2.privacySalt) assertNotEquals(wtx1.id, wtx2.id) }</ID>
    <ID>MaxLineLength:Party.kt$Party : DestinationAbstractParty</ID>
    <ID>MaxLineLength:Party.kt$Party$constructor(certificate: X509Certificate) : this(CordaX500Name.build(certificate.subjectX500Principal), Crypto.toSupportedPublicKey(certificate.publicKey))</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$require(role?.isIdentity ?: false) { "Party certificate ${certificate.subjectDN} does not have a well known or confidential identity role. Found: $role" }</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("Child certificate whose issuer includes a Corda role, must also specify Corda role")</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("The issuing certificate for $certificateString has role $parentRole, expected one of ${role.validParents}")</ID>
    <ID>MaxLineLength:PathManager.kt$PathManager&lt;T : PathManager&lt;T&gt;&gt; : Closeable</ID>
    <ID>MaxLineLength:PathManagerTests.kt$PathManagerTests$MyPathManager : PathManager</ID>
    <ID>MaxLineLength:PathUtils.kt$ fun Path.attributes(vararg options: LinkOption): BasicFileAttributes</ID>
    <ID>MaxLineLength:PathUtils.kt$inline</ID>
    <ID>MaxLineLength:Perceivable.kt$@Suppress("UNUSED_PARAMETER") start: Perceivable&lt;Instant&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$@Suppress("UNUSED_PARAMETER") start: String</ID>
    <ID>MaxLineLength:Perceivable.kt$Interest$val interest: Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$Interest(Const(amount), dayCountConvention, interest, const(parseDate(start).toInstant()), const(parseDate(end).toInstant()))</ID>
    <ID>MaxLineLength:Perceivable.kt$PerceivableComparison&lt;T&gt; : Perceivable</ID>
    <ID>MaxLineLength:Perceivable.kt$PerceivableOperation&lt;T&gt; : Perceivable</ID>
    <ID>MaxLineLength:Perceivable.kt$fun fix(source: String, date: LocalDate, tenor: Tenor): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: BigDecimal /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: Perceivable&lt;Instant&gt;, @Suppress("UNUSED_PARAMETER") end: Perceivable&lt;Instant&gt;): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: BigDecimal /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: String, @Suppress("UNUSED_PARAMETER") end: String): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: Perceivable&lt;BigDecimal&gt; /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: Perceivable&lt;Instant&gt;, @Suppress("UNUSED_PARAMETER") end: Perceivable&lt;Instant&gt;): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: Perceivable&lt;BigDecimal&gt; /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: String, @Suppress("UNUSED_PARAMETER") end: String): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$operator fun Perceivable&lt;BigDecimal&gt;.minus(n: Double)</ID>
    <ID>MaxLineLength:Perceivable.kt$operator fun Perceivable&lt;BigDecimal&gt;.times(n: Double)</ID>
    <ID>MaxLineLength:PeriodSerializer.kt$PeriodSerializer : Proxy</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$generatedStatements.addAll(MigrationData(oldPkHash, partyAndCertificate).let { listOf(updateHashToIdentityRow(it, dataSource), updateNameToHashRow(it, dataSource)) })</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$return UpdateStatement(dataSource.connection.catalog, dataSource.connection.schema, PUB_KEY_HASH_TO_PARTY_AND_CERT_TABLE) .setWhereClause("pk_hash=?") .addNewColumnValue("pk_hash", migrationData.newPkHash) .addWhereParameter(migrationData.oldPkHash)</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$return UpdateStatement(dataSource.connection.catalog, dataSource.connection.schema, X500_NAME_TO_PUB_KEY_HASH_TABLE) .setWhereClause("pk_hash=? AND name=?") .addNewColumnValue("pk_hash", migrationData.newPkHash) .addWhereParameters(migrationData.oldPkHash, migrationData.x500.toString())</ID>
    <ID>MaxLineLength:PersistentIdentityMigration.kt$PersistentIdentityMigration$val partyAndCertificate = PartyAndCertificate(X509CertificateFactory().delegate.generateCertPath(identityBytes.inputStream()))</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentitiesMigrationSchema</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable : CordaMigration</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$logger.info("Migrating persistent identities with certificates table into persistent table with no certificate data.")</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$throw PersistentIdentitiesMigrationException("Cannot migrate persistent states as liquibase failed to provide a suitable database connection")</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$val name = PartyAndCertificate(X509CertificateFactory().delegate.generateCertPath(partyBytes.inputStream())).party.name</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$notaryServices = MockServices(listOf("net.corda.finance.contracts"), dummyNotary, identityService, dummyCashIssuer.keyPair, BOC_KEY)</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$session.save(PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.hash.toString(), it.certPath.encoded))</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$val identityService = makeTestIdentityService(PersistentIdentityMigrationNewTableTest.dummyNotary.identity, BOB_IDENTITY, ALICE_IDENTITY)</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$ @Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private fun verifyAndRegisterIdentity(trustAnchor: TrustAnchor, identity: PartyAndCertificate): PartyAndCertificate?</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$/** Stores notary identities obtained from the network parameters, for which we don't need to perform a database lookup. */ private val notaryIdentityCache = HashSet&lt;Party&gt;()</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$// Allows us to eliminate keys we know belong to others by using the cache contents that might have been seen during other identity activity. // Concentrating activity on the identity cache works better than spreading checking across identity and key management, because we cache misses too. fun stripNotOurKeys(keys: Iterable&lt;PublicKey&gt;): Iterable&lt;PublicKey&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class)</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$@Throws(CertificateExpiredException::class, CertificateNotYetValidException::class, InvalidAlgorithmParameterException::class) private</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$@Throws(UnknownAnonymousPartyException::class) override</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$_caCertStore = CertStore.getInstance("Collection", CollectionCertStoreParameters(caCertificates.toSet() + trustRoot))</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$fun loadIdentities(identities: Collection&lt;PartyAndCertificate&gt; = emptySet(), confidentialIdentities: Collection&lt;PartyAndCertificate&gt; = emptySet())</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$fun start(trustRoot: X509Certificate, caCertificates: List&lt;X509Certificate&gt; = emptyList(), notaryIdentities: List&lt;Party&gt; = emptyList())</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$it.filter { x500Matches(query, exactMatch, it.first) }.map { keyToPartyAndCert[it.second]!!.party }.toSet()</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService$throw IllegalArgumentException("The public key ${key.hash} is already assigned to a different party than the supplied .")</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService${ // If there is no entry in the legal keyToPartyAndCert table then the party must be a confidential identity so we perform // a lookup in the keyToName table. If an entry for that public key exists, then we attempt val name = keyToName[party.owningKey.toStringShort()] if (name != null) { wellKnownPartyFromX500Name(name) } else { null } }</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService${ // Skip database lookup if the party is a notary identity. // This also prevents an issue where the notary identity can't be resolved if it's not in the network map cache. The node obtains // a trusted list of notary identities from the network parameters automatically. return if (party is Party &amp;&amp; party in notaryIdentityCache) { party } else { database.transaction { // Try and resolve the party from the table to public keys to party and certificates // If we cannot find it then we perform a lookup on the public key to X500 name table val legalIdentity = super.wellKnownPartyFromAnonymous(party) if (legalIdentity == null) { // If there is no entry in the legal keyToPartyAndCert table then the party must be a confidential identity so we perform // a lookup in the keyToName table. If an entry for that public key exists, then we attempt val name = keyToName[party.owningKey.toStringShort()] if (name != null) { wellKnownPartyFromX500Name(name) } else { null } } else { legalIdentity } } } }</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$PartyAndCertificate(X509CertificateFactory().delegate.generateCertPath(it.identity.inputStream()))</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$fun createKeyToPartyAndCertMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;String, PartyAndCertificate, PersistentPublicKeyHashToCertificate, String&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$fun createKeyToX500Map(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;String, CordaX500Name, PersistentPublicKeyHashToParty, String&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityService.kt$PersistentIdentityService.Companion$fun createX500ToKeyMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;CordaX500Name, String, PersistentPartyToPublicKeyHash, String&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$ @Test fun `assert ownership`()</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$ @Test fun `get anonymous identity by key`()</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$listOf("Organisation A", "Organisation B", "Organisation C") .map { getTestPartyAndCertificate(CordaX500Name(organisation = it, locality = "London", country = "GB"), generateKeyPair().public) }</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$val alicente = getTestPartyAndCertificate(CordaX500Name(organisation = "Alicente Worldwide", locality = "London", country = "GB"), generateKeyPair().public)</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$val bobReload = @Suppress("DEPRECATION") newPersistentIdentityService.certificateFromKey(anonymousBob.party.owningKey)</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap$ExplicitRemoval&lt;K, V, E, EK&gt; : RemovalListener</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap$cache.getAll(session.createQuery(criteriaQuery).resultList.map { e -&gt; fromPersistentEntity(e as E).first }.asIterable())</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap${ // This happens when the key was queried before with no value associated. We invalidate the cached null // value and recursively call set again. This is to avoid race conditions where another thread queries after // the invalidate but before the set. cache.invalidate(key) return set(key, value) }</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap.NotReallyMutableEntry$private</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT l FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.name = :name"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.addresses a WHERE a.host = :host AND a.port = :port"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.name = :name"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.owningKeyHash = :owningKeyHash"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$logger.info("Previous node was found for ${node.legalIdentities.first().name} as: $previousNode")</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$private</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$private val identityService: IdentityService</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$query.maxResults = 1</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$val failures = node.legalIdentitiesAndCerts.mapNotNull { Try.on { it.verify(identityService.trustAnchor) } as? Try.Failure }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey).singleOrNull { it.serial == nodeInfo.serial }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$where(builder.equal(get&lt;String&gt;(NodeInfoSchemaV1.PersistentNodeInfo::hash.name), nodeHash.toString()))</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache${ // TODO For now the main legal identity is left in NodeInfo, this should be set comparision/come up with index for NodeInfo? val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey) val nodeInfoEntry = generateMappedObject(nodeInfo) if (info.isNotEmpty()) { nodeInfoEntry.id = info.first().id } session.merge(nodeInfoEntry) // invalidate cache last - this way, we might serve up the wrong info for a short time, but it will get refreshed // on the next load invalidateCaches(nodeInfo) }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache${ // findByIdentityKey might returns multiple node info with the same key, need to pick the right one by comparing serial. val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey).singleOrNull { it.serial == nodeInfo.serial } info?.let { session.remove(it) } // invalidate cache last - this way, we might serve up the wrong info for a short time, but it will get refreshed // on the next load invalidateCaches(nodeInfo) }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$//Enterprise only - objects created in the setup method, below initialized with dummy values to avoid need for nullable type declaration private var database = CordaPersistence(DatabaseConfig(), emptySet(), TestingNamedCacheFactory())</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$assertThat(charlieNetMapCache.getNodesByLegalName(DUMMY_NOTARY_NAME)).containsOnlyElementsOf(distServiceNodeInfos)</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$charlieNetMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, InMemoryIdentityService(trustRoot = DEV_ROOT_CA.certificate))</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$database = configureDatabase(makeTestDataSourceProperties(CHARLIE_NAME.toDatabaseSchemaName()), makeTestDatabaseProperties(CHARLIE_NAME.toDatabaseSchemaName()), { null }, { null })</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$private var charlieNetMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, InMemoryIdentityService(trustRoot = DEV_ROOT_CA.certificate))</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest${ //Enterprise only - for test in database mode ensure the remote database is setup before creating CordaPersistence super.setUp() database = configureDatabase(makeTestDataSourceProperties(CHARLIE_NAME.toDatabaseSchemaName()), makeTestDatabaseProperties(CHARLIE_NAME.toDatabaseSchemaName()), { null }, { null }) charlieNetMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, InMemoryIdentityService(trustRoot = DEV_ROOT_CA.certificate)) }</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$criteriaQuery.orderBy(session.criteriaBuilder.asc(shed.get&lt;NodeSchedulerService.PersistentScheduledState&gt;("scheduledAt")))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$private</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$return Pair(StateRef(SecureHash.parse(txId), index), ScheduledStateRef(StateRef(SecureHash.parse(txId), index), scheduledStateRecord.scheduledAt))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$val criteriaQuery = session.criteriaBuilder.createQuery(NodeSchedulerService.PersistentScheduledState::class.java)</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$val elem = session.find(NodeSchedulerService.PersistentScheduledState::class.java, toPersistentEntityKey(key))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$val existingEntry = session.find(NodeSchedulerService.PersistentScheduledState::class.java, toPersistentEntityKey(value.ref))</ID>
    <ID>MaxLineLength:PersistentStateService.kt$PersistentStateService</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests$persistentStateService.persist(setOf(StateAndRef(TransactionState(TestState(), DummyContract.PROGRAM_ID, MEGA_CORP, constraint = AlwaysAcceptAttachmentConstraint), StateRef(SecureHash.sha256("dummy"), 0))))</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests$val database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null }, schemaService)</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests.&lt;no name provided&gt;$override val schemaOptions: Map&lt;MappedSchema, SchemaService.SchemaOptions&gt; = mapOf(testSchema to SchemaService.SchemaOptions())</ID>
    <ID>MaxLineLength:PersistentTypes.kt$DirectStatePersistable : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$IndirectStatePersistable&lt;T : DirectStatePersistable&gt; : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator$SchemaCrossReferenceReport</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator$annotations.any { annotation -&gt; annotation.toString().startsWith("@javax.persistence.") &amp;&amp; annotation !is javax.persistence.Transient }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ field -&gt; field.type.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(field.type.enclosingClass) &amp;&amp; hasJpaAnnotation(field.declaredAnnotations) &amp;&amp; field.type.enclosingClass != schema.javaClass }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ method -&gt; method.returnType.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(method.returnType.enclosingClass) &amp;&amp; method.returnType.enclosingClass != schema.javaClass &amp;&amp; hasJpaAnnotation(method.declaredAnnotations) }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator.SchemaCrossReferenceReport$"MappedSchema '${schema.substringAfterLast(".")}' entity '$entity' field '$fieldOrMethod' is of type '$fieldOrMethodType' "</ID>
    <ID>MaxLineLength:PersistentTypes.kt$PersistentState : DirectStatePersistable</ID>
    <ID>MaxLineLength:PhysicalLocationStructures.kt$WorldCoordinate$fun latitudeToScreenY(lat: Double)</ID>
    <ID>MaxLineLength:PhysicalLocationStructures.kt$WorldCoordinate$require(longitude in leftLongitude..rightLongitude){"Longitude must be between $leftLongitude and $rightLongitude"}</ID>
    <ID>MaxLineLength:PlatformSecureRandom.kt$PlatformSecureRandomService$logger.error("Unable to initialise LinuxSecureRandomSpi. The exception logged with this message might assist with diagnosis. The process will now exit.", e)</ID>
    <ID>MaxLineLength:PlatformSecureRandom.kt$PlatformSecureRandomService$private val instance: SecureRandomSpi = if (SystemUtils.IS_OS_LINUX) tryAndUseLinuxSecureRandomSpi() else PlatformSecureRandomSpi()</ID>
    <ID>MaxLineLength:PlatformSecureRandom.kt$private</ID>
    <ID>MaxLineLength:PluginRegistrationTest.kt$PluginRegistrationTest$assertThatCode { Class.forName("net.corda.smoketesting.plugins.DummyJDBCDriver") }.isInstanceOf(ClassNotFoundException::class.java)</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest$val iterCount = 8_000 // Default port range 10000-30000 since we will have 2 processes we want to make sure there is enough leg room</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest$val terminationStatuses = processes.parallelStream().map { if (it.waitFor(1, TimeUnit.MINUTES)) "OK" else "STILL RUNNING" }.toList()</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest$while (spinnerBuffer.getShort(1) != 10.toShort() &amp;&amp; spinnerBuffer.getShort(2) != 10.toShort() &amp;&amp; timeWaited &lt; 60_000) { logger.info("Waiting to childProcesses to report back. waited ${timeWaited}ms") Thread.sleep(1000) timeWaited += 1000 }</ID>
    <ID>MaxLineLength:PortAllocationTest.kt$PortAllocationTest${ assumeFalse(System.getProperty("os.name").toLowerCase().contains("windows")) logger.info("Starting multiprocess port allocation test") val spinnerFile = Files.newTemporaryFile().also { it.deleteOnExit() }.absolutePath val iterCount = 8_000 // Default port range 10000-30000 since we will have 2 processes we want to make sure there is enough leg room // If we rollover, we may well receive the ports that were already given to a different process val process1 = buildJvmProcess(spinnerFile, 1, iterCount) val process2 = buildJvmProcess(spinnerFile, 2, iterCount) logger.info("Started child processes") val processes = listOf(process1, process2) val spinnerBackingFile = RandomAccessFile(spinnerFile, "rw") logger.info("Mapped spinner file at: $spinnerFile") val spinnerBuffer = spinnerBackingFile.channel.map(FileChannel.MapMode.READ_WRITE, 0, 512) logger.info("Created spinner buffer") var timeWaited = 0L while (spinnerBuffer.getShort(1) != 10.toShort() &amp;&amp; spinnerBuffer.getShort(2) != 10.toShort() &amp;&amp; timeWaited &lt; 60_000) { logger.info("Waiting to childProcesses to report back. waited ${timeWaited}ms") Thread.sleep(1000) timeWaited += 1000 } //GO! logger.info("Instructing child processes to start allocating ports") spinnerBuffer.putShort(0, 8) logger.info("Waiting for child processes to terminate") val terminationStatuses = processes.parallelStream().map { if (it.waitFor(1, TimeUnit.MINUTES)) "OK" else "STILL RUNNING" }.toList() logger.info("child processes terminated: $terminationStatuses") fun List&lt;String&gt;.setOfPorts(): Set&lt;Int&gt; { // May include warnings when ports are busy return map { Try.on { Integer.parseInt(it) } }.filter { it.isSuccess }.map { it.getOrThrow() }.toSet() } val lines1 = process1.inputStream.reader().readLines() val portsAllocated1 = lines1.setOfPorts() val lines2 = process2.inputStream.reader().readLines() val portsAllocated2 = lines2.setOfPorts() logger.info("child process out captured") Assert.assertThat(lines1.joinToString(), portsAllocated1.size, `is`(iterCount)) Assert.assertThat(lines2.joinToString(), portsAllocated2.size, `is`(iterCount)) //there should be no overlap between the outputs as each process should have been allocated a unique set of ports val intersect = portsAllocated1.intersect(portsAllocated2) Assert.assertThat(intersect.joinToString(), intersect, `is`(emptySet())) }</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$ @POST @Path("{party}/portfolio/valuations/calculate") @Produces(MediaType.APPLICATION_JSON) fun startPortfolioCalculations(params: ValuationCreationParams = ValuationCreationParams(LocalDate.of(2016, 6, 6)), @PathParam("party") partyName: String): Response</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$counterparties = counterParties.flatMap { it.legalIdentitiesAndCerts.map { ApiParty(it.owningKey.toBase58String(), it.name) } }</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$rpc.startFlow(SimmRevaluation::Initiator, getPortfolioStateAndRefWith(otherParty).ref, params.valuationDate)</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$val history = AggregatedHistoryView(state.valuation!!.trades, notional.toDouble(), LocalDate.now(), state.valuation!!.margin.first, mtm)</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi.AggregatedHistoryView$data</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$"fixedRatePayer" to (fixedRatePayer.nameOrNull()?.organisation ?: fixedRatePayer.owningKey.toBase58String())</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$"floatingRatePayer" to (floatingRatePayer.nameOrNull()?.organisation ?: floatingRatePayer.owningKey.toBase58String())</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$InitialMarginView</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val completeSubgroups = subgroups.mapValues { it.value.mapValues { it.value[0].third.toDouble() }.toSortedMap() }</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val processedSensitivities = valuation.totalSensivities.sensitivities.map { it.marketDataName to it.parameterMetadata.map { it.label }.zip(it.sensitivity.toList()).toMap() }.toMap()</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val trade = if (state.buyer == ownParty as AbstractParty) state.swap.toFloatingLeg() else state.swap.toFloatingLeg()</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val yieldCurveCurrenciesValues = marketData.filter { !it.key.contains("/") }.map { it -&gt; Triple(it.key.split("-")[0], it.key.split("-", limit = 2)[1], it.value) }</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$override</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$return ScheduledActivity(flow, LocalDate.now().plus(1, ChronoUnit.DAYS).atStartOfDay().toInstant(ZoneOffset.UTC))</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$return TransactionBuilder(notary).withItems(StateAndContract(copy(), PORTFOLIO_SWAP_PROGRAM_ID), Command(PortfolioSwap.Commands.Agree(), participants.map { it.owningKey }))</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$val flow = flowLogicRefFactory.create("net.corda.vega.flows.SimmRevaluation\$Initiator", thisStateRef, LocalDate.now())</ID>
    <ID>MaxLineLength:PortfolioSwap.kt$PortfolioSwap$val groups: List&lt;LedgerTransaction.InOutGroup&lt;PortfolioState, UniqueIdentifier&gt;&gt; = tx.groupStates { state -&gt; state.linearId }</ID>
    <ID>MaxLineLength:PrettyPrint.kt$PrettyPrint$println("val ${createPartyName(it)} = Party(\"${it.name.organisation}\", \"${it.owningKey.toStringShort()}\")")</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService : JCACryptoService</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$Crypto.ECDSA_SECP256R1_SHA256, Crypto.ECDSA_SECP256K1_SHA256 -&gt; PrimusWrap.aesUnwrapPadEcSign(wrappedPrivateKey.signatureScheme.signatureName, payloadToSign, wrappingKey, wrappedPrivateKey.keyMaterial)</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$Crypto.ECDSA_SECP256R1_SHA256, Crypto.ECDSA_SECP256K1_SHA256 -&gt; PrimusWrap.aesWrapPadEc(wrappingKey, keyPair.private as ECPrivateKey)</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$Crypto.RSA_SHA256 -&gt; PrimusWrap.aesUnwrapPadRsaSign("SHA256withRSA", payloadToSign, wrappingKey, wrappedPrivateKey.keyMaterial)</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$else -&gt; throw IllegalArgumentException("The scheme ID ${childKeyScheme.schemeNumberID} is not supported.")</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$else -&gt; throw IllegalArgumentException("The scheme ID ${wrappedPrivateKey.signatureScheme.schemeNumberID} is not supported.")</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$override</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$val ephemeralKeyAlias = UUID.randomUUID().toString() val wrappingKey = getKey(masterKeyAlias) as? SecretKey ?: throw IllegalStateException("There is no master key under the alias: $masterKeyAlias") val keyPairGenerator = keyPairGeneratorFromScheme(childKeyScheme) val keyPair = withAttributes(true, true) { PrimusName.generateKeyPair(keyPairGenerator, ephemeralKeyAlias) } val privateKeyMaterialWrapped = when (childKeyScheme) { Crypto.ECDSA_SECP256R1_SHA256, Crypto.ECDSA_SECP256K1_SHA256 -&gt; PrimusWrap.aesWrapPadEc(wrappingKey, keyPair.private as ECPrivateKey) Crypto.RSA_SHA256 -&gt; PrimusWrap.aesWrapPadRsa(wrappingKey, keyPair.private as RSAPrivateKey) else -&gt; throw IllegalArgumentException("The scheme ID ${childKeyScheme.schemeNumberID} is not supported.") } // ephemeral keys are garbage collected eventually, but we explicitly delete them because we have noticed this can lag and lead to resource exhaustion. keyStore.deleteEntry(ephemeralKeyAlias) Pair(keyPair.public, WrappedPrivateKey(privateKeyMaterialWrapped, childKeyScheme))</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$val wrappingKey = getKey(masterKeyAlias) as? SecretKey ?: throw IllegalStateException("There is no master key under the alias: $masterKeyAlias")</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService$when(wrappedPrivateKey.signatureScheme) { Crypto.ECDSA_SECP256R1_SHA256, Crypto.ECDSA_SECP256K1_SHA256 -&gt; PrimusWrap.aesUnwrapPadEcSign(wrappedPrivateKey.signatureScheme.signatureName, payloadToSign, wrappingKey, wrappedPrivateKey.keyMaterial) // reason for passing custom string: PrimusX APIs are case-sensitive, so it won't work with the signature name "SHA256WITHRSA" provided by Crypto. Crypto.RSA_SHA256 -&gt; PrimusWrap.aesUnwrapPadRsaSign("SHA256withRSA", payloadToSign, wrappingKey, wrappedPrivateKey.keyMaterial) else -&gt; throw IllegalArgumentException("The scheme ID ${wrappedPrivateKey.signatureScheme.schemeNumberID} is not supported.") }</ID>
    <ID>MaxLineLength:PrimusXCryptoService.kt$PrimusXCryptoService.Companion$is ConfigException, is UnknownConfigurationKeysException -&gt; throw Exception("Error in ${cryptoServiceConf.toFile().absolutePath} : ${e.message}")</ID>
    <ID>MaxLineLength:PrimusXCryptoServiceTest.kt$PrimusXCryptoServiceTest : CryptoServiceSpec</ID>
    <ID>MaxLineLength:PrimusXCryptoServiceTest.kt$PrimusXCryptoServiceTest$override fun getSupportedSchemes(): List&lt;SignatureScheme&gt;</ID>
    <ID>MaxLineLength:PrimusXCryptoServiceTest.kt$PrimusXCryptoServiceTest$override fun getSupportedSchemesForWrappingOperations(): List&lt;SignatureScheme&gt;</ID>
    <ID>MaxLineLength:PrimusXCryptoServiceTest.kt$PrimusXCryptoServiceTest$val auth = { PrimusXCryptoService.Companion.PrimusXConfiguration(TEST_HSM_HOST, TEST_HSM_PORT, TEST_HSM_USERNAME, TEST_HSM_PASSWORD) }</ID>
    <ID>MaxLineLength:PrimusXNodeRegistrationTest.kt$PrimusXNodeRegistrationTest$val config = ConfigFactory.parseFile(configPath().toFile()).resolve().parseAs(PrimusXCryptoService.Companion.PrimusXConfiguration::class)</ID>
    <ID>MaxLineLength:PrimusXWrappedKeysTest.kt$PrimusXWrappedKeysTest$val config = ConfigFactory.parseFile(configPath().toFile()).resolve().parseAs(PrimusXCryptoService.Companion.PrimusXConfiguration::class)</ID>
    <ID>MaxLineLength:PrintingInterceptor.kt$PrintingInterceptor$val (continuation, nextState) = delegate.executeTransition(fiber, previousState, event, transition, actionExecutor)</ID>
    <ID>MaxLineLength:PrintingInterceptor.kt$PrintingInterceptor$val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation)</ID>
    <ID>MaxLineLength:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch : Closeable</ID>
    <ID>MaxLineLength:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$watchedClient.children.usingWatcher(ElectionWatcher(this)).inBackground(NoNodeCallback(this)).forPath(path)</ID>
    <ID>MaxLineLength:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$watchedClient.create() .creatingParentContainersIfNeeded() .withProtection().withMode(CreateMode.EPHEMERAL) .inBackground(joinElectionCallback)</ID>
    <ID>MaxLineLength:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch.Companion$private val sorter = LockInternalsSorter { str, lockName -&gt; StandardLockInternalsDriver.standardFixForSorting(str, lockName) }</ID>
    <ID>MaxLineLength:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch.ElectionWatcher$latch.watchedClient.children.usingWatcher(ElectionWatcher(latch)).inBackground(NoNodeCallback(latch)).forPath(latch.path)</ID>
    <ID>MaxLineLength:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch.ElectionWatcher$log.info("Client ${latch.nodeId}: change detected in children nodes of path ${latch.path}; checking candidates.")</ID>
    <ID>MaxLineLength:PrivateKeySerializationTest.kt$PrivateKeySerializationTest$assertTrue { privateKey.checkpointSerialize(context = CheckpointSerializationDefaults.CHECKPOINT_CONTEXT).bytes.isNotEmpty() }</ID>
    <ID>MaxLineLength:PrivateKeySerializationTest.kt$PrivateKeySerializationTest.Companion$return privateKeys.map { arrayOf&lt;Any&gt;(it, PrivateKeySerializationTest::class.java.simpleName + "-" + it.javaClass.simpleName) }</ID>
    <ID>MaxLineLength:PrivateKeySerializationTest.kt$PrivateKeySerializationTest.Companion$val privateKeys: List&lt;PrivateKey&gt; = Crypto.supportedSignatureSchemes().filterNot { Crypto.COMPOSITE_KEY === it } .map { Crypto.generateKeyPair(it).private }</ID>
    <ID>MaxLineLength:PrivateKeySerializer.kt$PrivateKeySerializer$override val schemaForDocumentation = Schema(listOf(RestrictedType(type.toString(), "", listOf(type.toString()), AMQPTypeIdentifiers.primitiveTypeName(ByteArray::class.java), descriptor, emptyList())))</ID>
    <ID>MaxLineLength:ProcessUtilities.kt$ProcessUtilities$return startJavaProcess(C::class.java.name, arguments, classPath, workingDirectory, jdwpPort, extraJvmArguments, maximumHeapSize)</ID>
    <ID>MaxLineLength:ProfileController.kt$ProfileController$StreamSupport.stream(fs.rootDirectories.spliterator(), false) .flatMap { Files.find(it, 2, BiPredicate { p, attr -&gt; "node.conf" == p?.fileName.toString() &amp;&amp; attr.isRegularFile }) }</ID>
    <ID>MaxLineLength:ProfileController.kt$ProfileController$StreamSupport.stream(fs.rootDirectories.spliterator(), false) .flatMap { Files.find(it, 3, BiPredicate { p, attr -&gt; p.inCordappsDir &amp;&amp; p.isCordapp &amp;&amp; attr.isRegularFile }) }</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$"By default, the tool will obfuscate the provided configuration file and print the result to the terminal. "</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$"the MAC address of the running machine will be used. Supplying 'DEFAULT' will explicitly use the default value."</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$System.err.println(" Please change the configuration so that a maximum of one field appears per line.")</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$System.err.println("Warning: No fields found during ${if (deobfuscate) "deobfuscation" else "obfuscation"}.")</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$description</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$description = ["Bytes seeding the encryption key used for obfuscation. Leave blank or supply 'DEFAULT' to use the default seed bytes."]</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$description = ["Write the obfuscated output to disk, using the same file name as the input (if left blank), or the provided file name."]</ID>
    <ID>MaxLineLength:Program.kt$ConfigObfuscatorCli$val result = ConfigObfuscator.obfuscateConfiguration(configContent, hardwareAddressBytes, seedBytes, inputDelegate)</ID>
    <ID>MaxLineLength:Program.kt$println(" ${yellow("Error:")} Some specified configuration paths do not point to existing files or directories. Paths were: ${nonExistentPaths.joinToString(separator = ", ", prefix = "[", postfix = "]")}")</ID>
    <ID>MaxLineLength:Program.kt$private</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$/** * A list of all steps label in this ProgressTracker and the children, with the indent level provided starting at zero. * Note that UNSTARTED is never counted, and DONE is only counted at the calling level. */ val allStepsLabels: List&lt;Pair&lt;Int, String&gt;&gt; get() = _allStepsLabels()</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$if (it is Change.Structural || it is Change.Rendering) rebuildStepsTree() else recalculateStepsTreeIndex()</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$log.warnOnce("Found ProgressTracker Step(s) with the same label: ${labels.groupBy { it }.filter { it.value.size &gt; 1 }.map { it.key }}")</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker${ // This gets the index of the current step in the context of this progress tracker, so it will always be at the top level in // the allStepsCache. val index = _allStepsCache.indexOf(Pair(0, currentStep)) return if (index &gt;= 0) index else 0 }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker${ steps.forEach { configureChildTrackerForStep(it) } // Immediately update the step tree observable to ensure the first update the client receives is the initial state of the progress // tracker. _stepsTreeChanges.onNext(allStepsLabels) this.currentStep = UNSTARTED }</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker.Step$private fun definitionLocation(): String</ID>
    <ID>MaxLineLength:Properties.kt$DelegatedProperty$private abstract</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$list.asSequence() .map { configObject(key to ConfigValueFactory.fromAnyRef(it)) } .mapIndexed { index, value -&gt; delegate.validate(value.toConfig(), options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Configuration.Validation.Error&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$return delegate.schema?.let { schema -&gt; valueDescription(valueIn(configuration, options).asSequence() .map { element -&gt; valueDescription(element, serialiseValue) } .map { it as ConfigObject } .map(ConfigObject::toConfig) .map { schema.describe(it, serialiseValue, options) } .toList(), serialiseValue) } ?: valueDescription(valueIn(configuration, options), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$errors += convert.invoke(delegate.valueIn(target, options)).mapErrors { error -&gt; error.with(delegate.key, mappedTypeName) }.errors</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun &lt;M&gt; mapValid(mappedTypeName: String, convert: (MAPPED) -&gt; Valid&lt;M&gt;): Configuration.Property.Definition.Standard&lt;M&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue, options: Configuration.Options)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun valueIn(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override val typeName: String = if (super.typeName == "#$mappedTypeName") super.typeName else "$mappedTypeName(${super.typeName})"</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty&lt;TYPE, MAPPED&gt; : RequiredDelegatedPropertyStandard</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$errors += convert.invoke(delegate.valueIn(target, options)).mapErrors { error -&gt; error.with(delegate.key, mappedTypeName) }.errors</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue, options: Configuration.Options): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override fun valueIn(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$override</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Configuration.Validation.Error&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$override fun valueIn(configuration: Config, options: Configuration.Options): List&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$val elementsDescription = valueIn(configuration, options).asSequence().map { it as ConfigObject }.map(ConfigObject::toConfig).map { delegate.schema.describe(it, serialiseValue, options) }.toList()</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$valueIn(target, options).asSequence() .map { element -&gt; element as ConfigObject } .map(ConfigObject::toConfig) .mapIndexed { index, targetConfig -&gt; schema.validate(targetConfig, options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$internal</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$return invalid(ConfigException.WrongType(target.origin(), key, Long::class.javaObjectType.simpleName, Double::class.javaObjectType.simpleName).toValidationError(key, typeName))</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue, options: Configuration.Options)</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun withDefaultValue(defaultValue: TYPE): Configuration.Property.Definition&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$val missingValueError = errors.asSequence().filterIsInstance&lt;Configuration.Validation.Error.MissingValue&gt;().filter { it.pathAsString == key }.singleOrNull()</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue, options: Configuration.Options): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun validate(target: Config, options: Configuration.Options): Valid&lt;Config&gt;</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun valueIn(configuration: Config, options: Configuration.Options): TYPE</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$private</ID>
    <ID>MaxLineLength:Properties.kt$RequiredDelegatedProperty$private abstract</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$errors += nestedSchema.validate(nestedConfig, options).errors.map { error -&gt; error.withContainingPathPrefix(*key.split(".").toTypedArray()) }</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$internal open</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$override</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$override fun valueIn(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$return schema?.describe(configuration.getConfig(key), serialiseValue, options) ?: valueDescription(valueIn(configuration, options), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$private</ID>
    <ID>MaxLineLength:Properties.kt$private fun isErrorExpected(error: ConfigException)</ID>
    <ID>MaxLineLength:Properties.kt$private val expectedExceptionTypes = setOf(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigException.BadPath::class, ConfigException.Parse::class)</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$// Construct a map of PropertyDescriptors by name, by merging the raw field map with the map of classified property methods private fun Map&lt;String, Map&lt;MethodClassifier, Method&gt;&gt;.toClassProperties(fieldMap: Map&lt;String, Field&gt;): Map&lt;String, PropertyDescriptor&gt;</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$// Merge the given method into a map of methods by method classifier, picking the least generic method for each classifier. private fun EnumMap&lt;MethodClassifier, Method&gt;.merge(classifier: MethodClassifier, method: Method): EnumMap&lt;MethodClassifier, Method&gt;</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$?:</ID>
    <ID>MaxLineLength:PropertyDescriptor.kt$private</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$assertThatThrownBy { property.valueIn(configuration, Configuration.Options.defaults) }.isInstanceOf(ConfigException.Missing::class.java)</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$assertThatThrownBy { property.valueIn(configuration, Configuration.Options.defaults) }.isInstanceOf(ConfigException.WrongType::class.java)</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$val property = Configuration.Property.Definition.long(key).map(::AtomicLong).list().map { list -&gt; list.map(AtomicLong::get).max() }</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$val property = Configuration.Property.Definition.long(key).map(::AtomicLong).list().map { list -&gt; list.map(AtomicLong::get).max() }.optional()</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$assertThat(errors.first())</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$return invalid(Configuration.Validation.Error.BadValue.of("Value must be of format \"host(String):port(Int &gt; 0)\" e.g., \"127.0.0.1:8080\""))</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$val nestedPropertySchema = Configuration.Schema.withProperties(Configuration.Property.Definition.long(nestedKey))</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$createAmqpConfigWithMultipleCerts(clientNames, sourceLegalName.toString(), MAX_MESSAGE_SIZE, true, sslSetup.clientNative)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$createAmqpConfigWithMultipleCerts(serverNames, null, maxMessageSize, crlCheckSoftFail, sslSetup.serverNative)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000))).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$expectedRemoteLegalNames: Set&lt;CordaX500Name&gt; = setOf(ALICE_NAME, CHARLIE_NAME)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$private</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$signingCertificateStore.get(true).also { it.installDevNodeCaCertPath(ALICE_NAME, rootCa.certificate, intermediateCa) }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$sslConfig.keyStore.get(true).also { it.registerDevP2pCertificates(ALICE_NAME, rootCa.certificate, intermediateCa) }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val amqpClient = createClientWithMultipleCerts(listOf(BOC_NAME, BOB_NAME), BOB_NAME, setOf(DUMMY_BANK_A_NAME))</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val client = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", artemisPort), maxMessageSize)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val p2pSslConfiguration = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, useOpenSsl = sslSetup.clientNative)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val p2pSslConfiguration = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, useOpenSsl = sslSetup.serverNative)</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val pspSslConfigurations = certificatesDirectories.mapValues { CertificateStoreStubs.P2P.withCertificatesDirectory(it.value, useOpenSsl = sslSetup.serverNative) }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val signingCertificateStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "serverstorepass")</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val signingCertificateStores = certificatesDirectories.mapValues { CertificateStoreStubs.Signing.withCertificatesDirectory(it.value) }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests$val sslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests${ val maxMessageSize = 100_000 val (server, artemisClient) = createArtemisServerAndClient(maxMessageSize) val amqpClient = createClient(maxMessageSize) val clientConnected = amqpClient.onConnection.toFuture() amqpClient.start() assertEquals(true, clientConnected.get().connected) assertEquals(CHARLIE_NAME, CordaX500Name.build(clientConnected.get().remoteCert!!.subjectX500Principal)) val artemis = artemisClient.started!! val sendAddress = P2P_PREFIX + "Test" artemis.session.createQueue(sendAddress, RoutingType.ANYCAST, "queue", true) val consumer = artemis.session.createConsumer("queue") val testProperty = mutableMapOf&lt;String, Any?&gt;() testProperty["TestProp"] = "1" // Send normal message. val testData = ByteArray(maxMessageSize) val message = amqpClient.createMessage(testData, sendAddress, CHARLIE_NAME.toString(), testProperty) amqpClient.write(message) assertEquals(MessageStatus.Acknowledged, message.onComplete.get()) val received = consumer.receive() assertEquals("1", received.getStringProperty("TestProp")) assertArrayEquals(testData, ByteArray(received.bodySize).apply { received.bodyBuffer.readBytes(this) }) // Send message larger then max message size. val largeData = ByteArray(maxMessageSize + 1) // Create message will fail. assertThatThrownBy { amqpClient.createMessage(largeData, sendAddress, CHARLIE_NAME.toString(), testProperty) }.hasMessageContaining("Message exceeds maxMessageSize network parameter") // Send normal message again to confirm the large message didn't reach the server and client is not killed by the message. val message2 = amqpClient.createMessage(testData, sendAddress, CHARLIE_NAME.toString(), testProperty) amqpClient.write(message2) assertEquals(MessageStatus.Acknowledged, message2.onComplete.get()) val received2 = consumer.receive() assertEquals("1", received2.getStringProperty("TestProp")) assertArrayEquals(testData, ByteArray(received2.bodySize).apply { received2.bodyBuffer.readBytes(this) }) amqpClient.stop() artemisClient.stop() server.stop() }</ID>
    <ID>MaxLineLength:ProtonWrapperTests.kt$ProtonWrapperTests.Companion.SslSetup$override fun toString(): String</ID>
    <ID>MaxLineLength:ProviderMap.kt$// Among the others, we should register [CordaSecurityProvider] as the first provider, to ensure that when invoking [SecureRandom()] // the [platformSecureRandom] is returned (which is registered in CordaSecurityProvider). // Note that internally, [SecureRandom()] will look through all registered providers. // Then it returns the first PRNG algorithm of the first provider that has registered a SecureRandom // implementation (in our case [CordaSecurityProvider]), or null if none of the registered providers supplies // a SecureRandom implementation. Security.insertProviderAt(it, 1) // The position is 1-based.</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This map is required to defend against users that forcibly call Security.addProvider / Security.removeProvider // that could cause unexpected and suspicious behaviour. // i.e. if someone removes a Provider and then he/she adds a new one with the same name. // The val is private to avoid any harmful state changes. val providerMap = listOf(cordaBouncyCastleProvider, cordaSecurityProvider, bouncyCastlePQCProvider).map { it.name to it }.toMap()</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This registration is needed for reading back EdDSA key from java keystore. // TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider. Security.addProvider(it)</ID>
    <ID>MaxLineLength:ProviderMap.kt$&lt;no name provided&gt;$override fun generatePublic(keyInfo: SubjectPublicKeyInfo)</ID>
    <ID>MaxLineLength:ProviderMap.kt$@DeleteForDJVM fun platformSecureRandomFactory(): SecureRandom</ID>
    <ID>MaxLineLength:ProxyUtils.kt$ProxyUtils.&lt;no name provided&gt;$PasswordAuthentication(proxyConfig.userName, proxyConfig.password?.toCharArray() ?: CharArray(0))</ID>
    <ID>MaxLineLength:PublicKeySerializer.kt$PublicKeySerializer$override val schemaForDocumentation = Schema(listOf(RestrictedType(type.toString(), "", listOf(type.toString()), AMQPTypeIdentifiers.primitiveTypeName(ByteArray::class.java), descriptor, emptyList())))</ID>
    <ID>MaxLineLength:PublicKeySerializer.kt$PublicKeySerializer${ // TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser. output.writeObject(obj.encoded, data, clazz, context) }</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCache.kt$PublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl : WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ override operator fun get(key: PublicKey): KeyOwningIdentity?</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ override operator fun set(key: PublicKey, value: KeyOwningIdentity)</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ private fun isKeyIdentityKey(key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$ private fun isKeyPartOfNodeKeyPairs(key: PublicKey): Boolean</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(BasicHSMKeyManagementService.PersistentKey::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(PersistentIdentityService.PersistentPublicKeyHashToCertificate::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(PublicKeyHashToExternalId::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$log.debug { "Attempted to find owning identity for public key ${key.toStringShort()}, but key is unknown to node" }</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$log.debug { "Database lookup for public key ${key.toStringShort()}, found signing entity $signingEntity" }</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$private val cache = cacheFactory.buildNamed&lt;PublicKey, KeyOwningIdentity&gt;(Caffeine.newBuilder(), "PublicKeyToOwningIdentityCache_cache")</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$val queryRoot = criteriaQuery.from(PersistentIdentityService.PersistentPublicKeyHashToCertificate::class.java)</ID>
    <ID>MaxLineLength:PublicKeyToTextConverter.kt$PublicKeyToTextConverter$override fun convertToEntityAttribute(text: String?): PublicKey?</ID>
    <ID>MaxLineLength:PushedNode.kt$PushedNode$fun toNodeInstanceRequest(nodeInstanceName: String, actualX500: String, expectedFqName: String): NodeInstanceRequest</ID>
    <ID>MaxLineLength:PushedNode.kt$PushedNode$return NodeInstanceRequest(configFile, baseDirectory, copiedNodeConfig, copiedNodeDir, nodeConfig, localImageId, remoteImageName, nodeInstanceName, actualX500, expectedFqName)</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$ fun recordUsedInstrumentedCallStack()</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$val instrumentClassMethods = clazz.methods.filter { it.name == "instrumentClass" } // TODO this is very brittle, we want to match on a specific instrumentClass() function. We could use the function signature, but that may change between versions anyway. Why is this function overloaded?? instrumentClassMethods[0].insertBefore( "$hookClassName.${::recordScannedClass.name}(className);" )</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$println("Instrumented classes: ${classRecorder.instrumentedClasses.size}") classRecorder.instrumentedClasses.forEach { println(" $it") } println("Used instrumented classes: ${classRecorder.usedInstrumentedClasses.size}") classRecorder.usedInstrumentedClasses.forEach { println(" $it") } println("Scanned classes: ${classRecorder.scannedClasses.size}") classRecorder.scannedClasses.keys.take(20).forEach { println(" $it") } println(" (...)") val scannedTree = PackageTree.fromStrings(classRecorder.scannedClasses.keys.toList(), '/') val instrumentedTree = PackageTree.fromStrings(classRecorder.instrumentedClasses.keys.toList(), '/') val alwaysExclude = arguments.alwaysExcluded?.let { PackageTree.fromStrings(it, arguments.separator) } val alwaysExcludedTree = alwaysExclude?.let { instrumentedTree.truncate(it) } ?: instrumentedTree println("Suggested exclude globs:") val truncate = arguments.truncate?.let { PackageTree.fromStrings(it, arguments.separator) } // The separator append is a hack, it causes a package with an empty name to be added to the exclude tree, // which practically causes that level of the tree to be always expanded in the output globs. val expand = arguments.expand?.let { PackageTree.fromStrings(it.map { "$it${arguments.separator}" }, arguments.separator) } val truncatedTree = truncate?.let { scannedTree.truncate(it) } ?: scannedTree val expandedTree = expand?.let { alwaysExcludedTree.merge(it) } ?: alwaysExcludedTree val globs = truncatedTree.toGlobs(expandedTree) globs.forEach { println(" $it") } println("Quasar exclude expression:") println(" x(${globs.joinToString(";")})")</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$val expand = arguments.expand?.let { PackageTree.fromStrings(it.map { "$it${arguments.separator}" }, arguments.separator) }</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$AndComposition : AttachmentQueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$OrComposition : AttachmentQueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(uploaderCondition: ColumnPredicate&lt;String&gt;?, filenameCondition: ColumnPredicate&lt;String&gt;?) : this(uploaderCondition, filenameCondition, null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun isSigned(isSignedPredicate: ColumnPredicate&lt;Boolean&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withContractClassNames(contractClassNamesPredicate: ColumnPredicate&lt;List&lt;ContractClassName&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withFilename(filenamePredicate: ColumnPredicate&lt;String&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withSigners(signersPredicate: ColumnPredicate&lt;List&lt;PublicKey&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploadDate(uploadDatePredicate: ColumnPredicate&lt;Instant&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploader(uploaderPredicate: ColumnPredicate&lt;String&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withVersion(versionPredicate: ColumnPredicate&lt;Int&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$uploadDateCondition: ColumnPredicate&lt;Instant&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$val contractClassNamesCondition: ColumnPredicate&lt;List&lt;ContractClassName&gt;&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$val versionCondition: ColumnPredicate&lt;Int&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentsQueryCriteriaParser : BaseQueryCriteriaParser</ID>
    <ID>MaxLineLength:QueryCriteria.kt$BaseQueryCriteriaParser&lt;Q: GenericQueryCriteria&lt;Q, P&gt;, in P: BaseQueryCriteriaParser&lt;Q,P,S&gt;, in S : BaseSort&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$AndVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$OrVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$AndComposition : QueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$OrComposition : QueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = null, owner: List&lt;AbstractParty&gt;? = null, quantity: ColumnPredicate&lt;Long&gt;? = null, issuer: List&lt;AbstractParty&gt;? = null, issuerRef: List&lt;OpaqueBytes&gt;? = null, status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$( participants: List&lt;AbstractParty&gt;? = null, linearId: List&lt;UniqueIdentifier&gt;? = null, status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withParticipants(participants: List&lt;AbstractParty&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withExpression(expression: CriteriaExpression&lt;L, Boolean&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?) : this(status, contractStateTypes, participants = null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 3) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?) : this( status, contractStateTypes, stateRefs, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 4) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?, notary: List&lt;AbstractParty&gt;?) : this( status, contractStateTypes, stateRefs, notary, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 5) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?, notary: List&lt;AbstractParty&gt;?, softLockingCondition: SoftLockingCondition?) : this( status, contractStateTypes, stateRefs, notary, softLockingCondition, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraintTypes(constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraints(constraints: Set&lt;Vault.ConstraintInfo&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withSoftLockingCondition(softLockingCondition: SoftLockingCondition): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$/** * Note: use [PageSpecification] to correctly handle a number of bounded pages of a pre-configured page size. */ // Here we subtract 1 to allow the Vault to figure out whether there are more results and pages by querying for `pageSize + 1`. const val MAX_PAGE_SIZE = Int.MAX_VALUE - 1</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;Any, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.equal(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.notEqual(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O&gt; KProperty1&lt;O, String?&gt;.like(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O&gt; KProperty1&lt;O, String?&gt;.notLike(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; `in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R&gt; equal(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R&gt; notEqual(value: R, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun notLike(string: String, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R : Comparable&lt;R&gt;&gt; Field.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.avg(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.max(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.min(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.sum(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.greaterThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThan(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.count()</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;O, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; compare(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R : Comparable&lt;R&gt;&gt; greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;Any, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Column.Companion$when (property) { // This is to ensure that, for a JPA Entity, a field declared in a MappedSuperclass will not cause Hibernate to reject a query referencing it. // TODO remove the cast and access the owner properly after it will be exposed as Kotlin's public API (https://youtrack.jetbrains.com/issue/KT-24170). is CallableReference -&gt; ((property as CallableReference).owner as KClass&lt;*&gt;).javaObjectType else -&gt; property.javaGetter!!.declaringClass }</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$BinaryComparison&lt;C : Comparable&lt;C&gt;&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$CollectionExpression&lt;C&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$ColumnPredicate$EqualityComparison&lt;C&gt; : ColumnPredicate</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$BinaryLogical&lt;O&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$ColumnPredicateExpression&lt;O, C&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:R3Pty.kt$R3Pty : AutoCloseable</ID>
    <ID>MaxLineLength:R3Pty.kt$R3Pty$private</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient$FailedToDeserializeReply : RuntimeException</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val id = message.invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val observableId = message.invocationId(OBSERVABLE_ID_FIELD_NAME, OBSERVABLE_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val payload = message.getBodyAsByteArray().deserialize&lt;Notification&lt;*&gt;&gt;(context = poolWithIdContext)</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion${ val id = message.invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.") val poolWithIdContext = context.withProperty(RpcRequestOrObservableIdKey, id) // The result here is a Try&lt;&gt; that represents the attempt to try the operation on the server side. // If anything goes wrong with deserialisation of the response, we propagate it differently because // we also need to pass through the invocation and dedupe IDs. val result: Try&lt;Any?&gt; = try { message.getBodyAsByteArray().deserialize(context = poolWithIdContext) } catch (e: Exception) { throw FailedToDeserializeReply(id, e) } RpcReply( id = id, deduplicationIdentity = deduplicationIdentity, result = result ) }</ID>
    <ID>MaxLineLength:RPCApi.kt$net.corda.nodeapi.RPCApi.kt</ID>
    <ID>MaxLineLength:RPCApi.kt$private</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun ClientMessage.invocationId(valueProperty: String, timestampProperty: String): InvocationId?</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun ClientMessage.sessionId(valueProperty: String, timestampProperty: String): SessionId?</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun SessionId.mapTo(message: ClientMessage)</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun Trace.mapToExternal(message: ClientMessage)</ID>
    <ID>MaxLineLength:RPCApi.kt$return invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot extract reply id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$return sessionId(RPC_SESSION_ID_FIELD_NAME, RPC_SESSION_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot extract the session id from client message.")</ID>
    <ID>MaxLineLength:RPCClient.kt$RPCClient$reconnectAttempts = if (haPoolTransportConfigurations.isEmpty()) rpcConfiguration.maxReconnectAttempts else 0</ID>
    <ID>MaxLineLength:RPCClient.kt$RPCClient$throw RPCException("Requested minimum protocol version (${rpcConfiguration.minimumServerProtocolVersion}) is higher" + " than the server's supported protocol version ($serverProtocolVersion)")</ID>
    <ID>MaxLineLength:RPCClient.kt$RPCClient$val ops: I = uncheckedCast(Proxy.newProxyInstance(rpcOpsClass.classLoader, arrayOf(rpcOpsClass), proxyHandler))</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$ObservableContext</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$ fun notifyServerAndClose()</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$artemisMessage.putLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME, deduplicationSequenceNumber.getAndIncrement())</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$if (deduplicationChecker.checkDuplicateMessageId(serverToClient.deduplicationIdentity, deduplicationSequenceNumber)) { log.info("Message duplication detected, discarding message") return }</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$log</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$log.debug("Server locator is closed or garbage collected. Proxy may have been closed during reconnect.")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$log.error("RPC reply arrived to unknown RPC ID ${serverToClient.id}, this indicates an internal RPC error.")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$private</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$private val deduplicationChecker = DeduplicationChecker(rpcConfiguration.deduplicationCacheExpiry, cacheFactory = cacheFactory)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$private val serializationContextWithObservableContext = RpcClientObservableDeSerializer.createContext(serializationContext, observableContext)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$producerSession = sessionFactory!!.createSession(rpcUsername, rpcPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$retryInterval = minOf(maxRetryInterval, retryInterval.times(rpcConfiguration.connectionRetryIntervalMultiplier.toLong()))</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$return "{rpcUsername='$rpcUsername', clientAddress=$clientAddress, sessionId=$sessionId, targetLegalIdentity=$targetLegalIdentity}"</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$return cacheFactory.buildNamed(Caffeine.newBuilder().weakValues().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()), "RpcClientProxyHandler_rpcObservable")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$throw UnsupportedOperationException("Method $calledMethod was added in RPC protocol version $sinceVersion but the server is running $serverProtocolVersion")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$val observable: UnicastSubject&lt;Notification&lt;*&gt;&gt;? = observableContext.observableMap.getIfPresent(serverToClient.id)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$val serialisedArguments = (arguments?.toList() ?: emptyList()).serialize(context = serializationContextWithObservableContext)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$var reconnectAttempts = rpcConfiguration.maxReconnectAttempts.times(serverLocator.staticTransportConfigurations.size)</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler${ // Deserialize the reply from the server, both the wrapping metadata and the actual body of the return value. val serverToClient: RPCApi.ServerToClient = try { RPCApi.ServerToClient.fromClientMessage(serializationContextWithObservableContext, message) } catch (e: RPCApi.ServerToClient.FailedToDeserializeReply) { // Might happen if something goes wrong during mapping the response to classes, evolution, class synthesis etc. log.error("Failed to deserialize RPC body", e) completeExceptionally(e.id, e, rpcReplyMap.remove(e.id)) return } val deduplicationSequenceNumber = message.getLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME) if (deduplicationChecker.checkDuplicateMessageId(serverToClient.deduplicationIdentity, deduplicationSequenceNumber)) { log.info("Message duplication detected, discarding message") return } log.debug { "Got message from RPC server $serverToClient" } when (serverToClient) { is RPCApi.ServerToClient.RpcReply -&gt; { val replyFuture = rpcReplyMap.remove(serverToClient.id) if (replyFuture == null) { log.error("RPC reply arrived to unknown RPC ID ${serverToClient.id}, this indicates an internal RPC error.") } else { val result: Try&lt;Any?&gt; = serverToClient.result when (result) { is Try.Success -&gt; replyFuture.set(result.value) is Try.Failure -&gt; { completeExceptionally(serverToClient.id, result.exception, replyFuture) } } } } is RPCApi.ServerToClient.Observation -&gt; { val observable: UnicastSubject&lt;Notification&lt;*&gt;&gt;? = observableContext.observableMap.getIfPresent(serverToClient.id) if (observable == null) { log.debug("Observation ${serverToClient.content} arrived to unknown Observable with ID ${serverToClient.id}. " + "This may be due to an observation arriving before the server was " + "notified of observable shutdown") } else { // We schedule the onNext() on an executor sticky-pooled based on the Observable ID. observationExecutorPool.run(serverToClient.id) { executor -&gt; executor.submit { val content = serverToClient.content if (content.isOnCompleted || content.isOnError) { observableContext.observableMap.invalidate(serverToClient.id) } // Add call site information on error if (content.isOnError) { val rpcCallSite = callSiteMap?.get(serverToClient.id) if (rpcCallSite != null) addRpcCallSiteToThrowable(content.throwable, rpcCallSite) } observable.onNext(content) } } } } } }</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler${ // Might happen if something goes wrong during mapping the response to classes, evolution, class synthesis etc. log.error("Failed to deserialize RPC body", e) completeExceptionally(e.id, e, rpcReplyMap.remove(e.id)) return }</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler${ // This is going to send remote message, see `org.apache.activemq.artemis.core.client.impl.ClientConsumerImpl.doCleanUp()`. sessionFactory?.close() }</ID>
    <ID>MaxLineLength:RPCConcurrencyTests.kt$RPCConcurrencyTests$// We construct a rose tree of immediate Observables and check that parent observations arrive before children. val proxy = testProxy() val treeDepth = 6 val treeBranchingFactor = 3 val remainingLatch = CountDownLatch((intPower(treeBranchingFactor, treeDepth + 1) - 1) / (treeBranchingFactor - 1)) val depthsSeen = Collections.synchronizedSet(HashSet&lt;Int&gt;()) fun ObservableRose&lt;Int&gt;.subscribeToAll() { remainingLatch.countDown() this.branches.subscribe { tree -&gt; (tree.value + 1 until treeDepth).forEach { require(it in depthsSeen) { "Got ${tree.value} before $it" } } depthsSeen.add(tree.value) tree.subscribeToAll() } } proxy.ops.getImmediateObservableTree(treeDepth, treeBranchingFactor).subscribeToAll() remainingLatch.await()</ID>
    <ID>MaxLineLength:RPCConcurrencyTests.kt$RPCConcurrencyTests$val remainingLatch = CountDownLatch((intPower(treeBranchingFactor, treeDepth + 1) - 1) / (treeBranchingFactor - 1))</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val artemisConfig = createRpcServerArtemisConfig(maxFileSize, maxBufferedBytesPerClient, driverDSL.driverDirectory / serverName, hostAndPort)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val process = ProcessUtilities.startJavaProcess&lt;RandomRpcUser&gt;(listOf(rpcOpsClass.name, rpcAddress.toString(), username, password))</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val rpcSecurityManager = RPCSecurityManagerImpl.fromUserList(users = listOf(InternalUser(rpcUser.username, rpcUser.password, rpcUser.permissions)), id = AuthServiceId("TEST_SECURITY_MANAGER"))</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val session = sessionFactory.createSession(username, password, false, true, true, locator.isPreAcknowledge, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL.Companion$fun createRpcServerArtemisConfig(maxFileSize: Int, maxBufferedBytesPerClient: Long, baseDirectory: Path, hostAndPort: NetworkHostAndPort): Configuration</ID>
    <ID>MaxLineLength:RPCDriver.kt$RandomRpcUser.Companion$private inline fun &lt;reified T&gt; HashMap&lt;Class&lt;*&gt;, Generator&lt;*&gt;&gt;.add(generator: Generator&lt;T&gt;)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RandomRpcUser.Companion$val handle = RPCClient&lt;RPCOps&gt;(hostAndPort, null, serializationContext = AMQP_RPC_CLIENT_CONTEXT).start(rpcClass, username, password)</ID>
    <ID>MaxLineLength:RPCDriver.kt$SingleUserSecurityManager$override</ID>
    <ID>MaxLineLength:RPCDriver.kt$SingleUserSecurityManager$override fun validateUserAndRole(user: String?, password: String?, roles: MutableSet&lt;Role&gt;?, checkType: CheckType?)</ID>
    <ID>MaxLineLength:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests$val proxy = testProxy() // This tests that the observations are transmitted correctly, also check that server side doesn't try to serialize the whole lot // till client consumed some of the output produced. val observations = proxy.makeObservable() val observationsList = observations.take(4).toBlocking().toIterable().toList() assertEquals(listOf(1, 2, 3, 4), observationsList)</ID>
    <ID>MaxLineLength:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests.TestOpsImpl$override fun makeObservable(): Observable&lt;Int&gt;</ID>
    <ID>MaxLineLength:RPCOpsWithContext.kt$fun makeRPCOps(getCordaRPCOps: (username: String, credential: String) -&gt; InternalCordaRPCOps, username: String, credential: String): InternalCordaRPCOps</ID>
    <ID>MaxLineLength:RPCOpsWithContext.kt$return Proxy.newProxyInstance(InternalCordaRPCOps::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java)) { _, method, args -&gt; try { method.invoke(cordaRPCOps, *(args ?: arrayOf())) } catch (e: InvocationTargetException) { // Unpack exception. throw e.targetException } } as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:RPCPerformanceTests.kt$RPCPerformanceTests$Mbps = bigSize.toDouble() * numberOfMessages.toDouble() / elapsed * (1000000.0 / (1024.0 * 1024.0))</ID>
    <ID>MaxLineLength:RPCProxyServer.kt$RPCProxyServer$val jerseyServlet = ServletHolder(ServletContainer(resourceConfig)).apply { initOrder = 0 }// Initialise at server start</ID>
    <ID>MaxLineLength:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$assertThat(response.toString()).matches("NodeInfo\\(addresses=\\[.*\\], legalIdentitiesAndCerts=\\[.*\\], platformVersion=.*, serial=.*\\)")</ID>
    <ID>MaxLineLength:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$rpcProxyClientC.startFlow(::CashIssueFlow, SWISS_FRANCS(500), OpaqueBytes.of(1), notary).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:RPCSecurityManagerImpl.kt$RPCPermission$/** * Helper constructor directly setting actions and target field * * @param methods Set of allowed RPC methods * @param target An optional "target" type on which methods act */ constructor(methods: Set&lt;String&gt;, target: String? = null) : super(methods, target?.let { setOf(it.replace(".", ":")) })</ID>
    <ID>MaxLineLength:RPCSecurityManagerTest.kt$RPCSecurityManagerTest$val userRealms = RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(listOf(user)), TestingNamedCacheFactory())</ID>
    <ID>MaxLineLength:RPCSecurityManagerWithAdditionalUser.kt$RPCSecurityManagerWithAdditionalUser : RPCSecurityManager</ID>
    <ID>MaxLineLength:RPCSecurityManagerWithAdditionalUser.kt$RPCSecurityManagerWithAdditionalUser$private</ID>
    <ID>MaxLineLength:RPCServer.kt$// TODO replace this by creating a new CordaRPCImpl for each request, passing the context, after we fix Shell and WebServer @JvmField internal val CURRENT_RPC_CONTEXT: ThreadLocal&lt;RpcAuthContext&gt; = CurrentRpcContext()</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$( ops: OPS, rpcServerUsername: String, rpcServerPassword: String, serverLocator: ServerLocator, securityManager: RPCSecurityManager, nodeLegalName: CordaX500Name, rpcConfiguration: RPCServerConfiguration, cacheFactory: NamedCacheFactory )</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$?:</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$consumerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$private val deduplicationChecker = DeduplicationChecker(rpcConfiguration.deduplicationCacheExpiry, cacheFactory = cacheFactory)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$producerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$require(notificationType == CoreNotificationType.BINDING_ADDED.name){"Message contained notification type of $notificationType instead of expected ${CoreNotificationType.BINDING_ADDED.name}"}</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$require(notificationType == CoreNotificationType.BINDING_REMOVED.name){"Message contained notification type of $notificationType instead of expected ${CoreNotificationType.BINDING_REMOVED.name}"}</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return Pair(Actor(Id(validatedUser), securityManager.id, targetLegalIdentity), securityManager.buildSubject(validatedUser))</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return RpcAuthContext(InvocationContext.rpc(rpcActor.first, trace, externalTrace, impersonatedActor), rpcActor.second)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return cacheFactory.buildNamed(Caffeine.newBuilder().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()), "RPCServer_observableSubscription")</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val deduplicationSequenceNumber = artemisMessage.getLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val targetLegalIdentity = message.getStringProperty(RPCApi.RPC_TARGET_LEGAL_IDENTITY)?.let(CordaX500Name.Companion::parse) ?: nodeLegalName</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val validatedUser = message.getStringProperty(Message.HDR_VALIDATED_USER) ?: throw IllegalArgumentException("Missing validated user from the Artemis message")</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer${ lifeCycle.requireState(State.UNSTARTED) log.info("Starting RPC server with configuration $rpcConfiguration") senderThread = startSenderThread() rpcExecutor = Executors.newScheduledThreadPool( rpcConfiguration.rpcThreadPoolSize, ThreadFactoryBuilder().setNameFormat("rpc-server-handler-pool-%d").build() ) reaperExecutor = Executors.newSingleThreadScheduledExecutor( ThreadFactoryBuilder().setNameFormat("rpc-server-reaper-%d").build() ) reaperScheduledFuture = reaperExecutor!!.scheduleAtFixedRate( this::reapSubscriptions, rpcConfiguration.reapInterval.toMillis(), rpcConfiguration.reapInterval.toMillis(), TimeUnit.MILLISECONDS ) sessionFactory = serverLocator.createSessionFactory() producerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) createRpcProducer(producerSession!!) consumerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE) createRpcConsumer(consumerSession!!) createNotificationConsumers(consumerSession!!) serverControl = activeMqServerControl deduplicationIdentity = UUID.randomUUID().toString() lifeCycle.transition(State.UNSTARTED, State.STARTED) // We delay the consumer session start because Artemis starts delivering messages immediately, so we need to be // fully initialised. producerSession!!.start() consumerSession!!.start() }</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer.ObservableContext$// Seralize the contexts in parallel. When finished with this job, submit the next job for this context, if there is one. private fun parallelSerializeAndSubmit(job: RpcSendJob.Send)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer.ObservableContext$private</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer.ObservableContext$val job = RpcSendJob.Send(contextDatabaseOrNull, clientAddress, serializationContextWithObservableContext, serverToClient)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer.ObservableContext${ // We must form a queue here as any encountered Observables may already have events, which would // trigger more sends. We must make sure that the root of the Observables (e.g. the RPC reply) is sent // before any child observations for this context. val job = RpcSendJob.Send(contextDatabaseOrNull, clientAddress, serializationContextWithObservableContext, serverToClient) // If there is nothing in the queue, immediately serialize, otherwise queue up within the context to maintain ordering. if (localSendJobQueue.isEmpty()) { localSendJobQueue.put(job) parallelSerializeAndSubmit(job) } else { localSendJobQueue.put(job) } }</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$"Threads have leaked. New threads created: $newThreads (total before: ${threadsBefore.size}, total after: ${threadsAfter.size})"</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$@Ignore</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password).close()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$configuration = CordaRPCClientConfiguration.DEFAULT.copy(minimumServerProtocolVersion = 1000)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$message.putLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME, dedupeId.getAndIncrement())</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$pollUntilTrue("number of times subscribe() has been called") { trackSubscriberOpsImpl.subscriberCount.get() == 0 }.get()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$pollUntilTrue("number of times subscribe() has been called") { trackSubscriberOpsImpl.subscriberCount.get() &gt;= 100 }.get()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$private</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$serialisedArguments = emptyList&lt;Any&gt;().serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$serialisedArguments = listOf(100.millis, 1234).serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val client = startRpcClient&lt;ServerOps&gt;(listOf(NetworkHostAndPort("localhost", 12345), serverAddress, NetworkHostAndPort("localhost", 54321))).getOrThrow()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val client = startRpcClient&lt;ServerOps&gt;(listOf(server1.broker.hostAndPort!!, server2.broker.hostAndPort!!, server3.broker.hostAndPort!!)).getOrThrow()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val clientConfiguration = CordaRPCClientConfiguration.DEFAULT.copy(connectionRetryInterval = 1.seconds, maxReconnectAttempts = 5)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val clientConfiguration = CordaRPCClientConfiguration.DEFAULT.copy(connectionRetryInterval = 500.millis, maxReconnectAttempts = 1)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection1 = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection2 = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val server = startRpcServer(maxBufferedBytesPerClient = 10 * 1024 * 1024, ops = SlowConsumerRPCOpsImpl()).get()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val server = startRpcServer(maxBufferedBytesPerClient = 10 * 1024 * 1024, ops = SlowConsumerRPCOpsImpl()).get() // Construct an RPC session manually so that we can hang in the message handler val myQueue = "${RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX}.test.${random63BitValue()}" val session = startArtemisSession(server.broker.hostAndPort!!) session.createTemporaryQueue(myQueue, ActiveMQDefaultConfiguration.getDefaultRoutingType(), myQueue) val consumer = session.createConsumer(myQueue, null, -1, -1, false) consumer.setMessageHandler { Thread.sleep(5000) // Needs to be slower than one per second to get kicked. it.acknowledge() } val producer = session.createProducer(RPCApi.RPC_SERVER_QUEUE_NAME) session.start() pollUntilClientNumber(server, 1) val message = session.createMessage(false) val request = RPCApi.ClientToServer.RpcRequest( clientAddress = SimpleString(myQueue), methodName = SlowConsumerRPCOps::streamAtInterval.name, serialisedArguments = listOf(100.millis, 1234).serialize(context = SerializationDefaults.RPC_SERVER_CONTEXT), replyId = Trace.InvocationId.newInstance(), sessionId = Trace.SessionId.newInstance() ) request.writeToClientMessage(message) message.putLongProperty(RPCApi.DEDUPLICATION_SEQUENCE_NUMBER_FIELD_NAME, 0) producer.send(message) session.commit() // We are consuming slower than the server is producing, so we should be kicked after a while if slow consumers are enabled. pollUntilClientNumber(server, 0)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val servers = mutableMapOf("server1" to serverFollower1, "server2" to serverFollower2, "server3" to serverFollower3)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$val clientAddresses = server.broker.serverControl.addressNames.filter { it.startsWith(RPCApi.RPC_CLIENT_QUEUE_NAME_PREFIX) }</ID>
    <ID>MaxLineLength:RaftNotaryService.kt$RaftNotaryService$?:</ID>
    <ID>MaxLineLength:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$val builder = DummyContract.generateInitial(Random().nextInt(), defaultNotaryIdentity, bankA.services.myInfo.singleIdentity().ref(0)) .setTimeWindow(bankA.services.clock.instant(), 30.seconds)</ID>
    <ID>MaxLineLength:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$val builder = DummyContract.generateInitial(Random().nextInt(), notary, nodeHandle.services.myInfo.singleIdentity().ref(0))</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$fun checkConflict(states: List&lt;StateRef&gt;, type: StateConsumptionDetails.ConsumedStateType)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$log.debug("State machine commit: attempting to store entries with keys (${commitCommand.states.joinToString()})")</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$private</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Companion.CordaKryoSerializer$private val context = CheckpointSerializationDefaults.CHECKPOINT_CONTEXT.withEncoding(CordaSerializationEncoding.SNAPPY)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$private</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommand = RaftTransactionCommitLog.Commands.CommitTransaction(states, txId, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommandFirst = RaftTransactionCommitLog.Commands.CommitTransaction(states, txIdFirst, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommandSecond = RaftTransactionCommitLog.Commands.CommitTransaction(states, txIdSecond, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val database = configureDatabase(makeInternalTestDataSourceProperties( configSupplier = { ConfigFactory.empty() }), DatabaseConfig(runMigration = true), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1)))</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val stateMachineFactory = { RaftTransactionCommitLog(database, Clock.systemUTC(), { RaftUniquenessProvider.createMap(TestingNamedCacheFactory()) }) }</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests${ val storage = Storage.builder().withStorageLevel(StorageLevel.MEMORY).build() val address = Address(myAddress.host, myAddress.port) // Enterprise - OS difference: below configureDatabase parameters differs with OS intentionally to be able run test in remote database val database = configureDatabase(makeInternalTestDataSourceProperties( configSupplier = { ConfigFactory.empty() }), DatabaseConfig(runMigration = true), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1))) databases.add(database) val stateMachineFactory = { RaftTransactionCommitLog(database, Clock.systemUTC(), { RaftUniquenessProvider.createMap(TestingNamedCacheFactory()) }) } val server = CopycatServer.builder(address) .withStateMachine(stateMachineFactory) .withStorage(storage) .withSerializer(RaftTransactionCommitLog.serializer) .build() val serverInitFuture = if (clusterAddress != null) { val cluster = Address(clusterAddress.host, clusterAddress.port) server.join(cluster) } else { server.bootstrap() } val client = CopycatClient.builder(address) .withConnectionStrategy(ConnectionStrategies.EXPONENTIAL_BACKOFF) .withSerializer(RaftTransactionCommitLog.serializer) .build() return serverInitFuture.thenCompose { client.connect(address) }.thenApply { Member(it, server) } }</ID>
    <ID>MaxLineLength:RaftUniquenessProvider.kt$RaftUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:RaftUniquenessProvider.kt$RaftUniquenessProvider.Companion$fun createMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;StateRef, Pair&lt;Long, SecureHash&gt;, CommittedState, String&gt;</ID>
    <ID>MaxLineLength:RaftUniquenessProvider.kt$RaftUniquenessProvider.Companion$it.value.deserialize&lt;SecureHash&gt;(context = SerializationDefaults.STORAGE_CONTEXT)</ID>
    <ID>MaxLineLength:Rate.kt$Rate$override fun toString(): String</ID>
    <ID>MaxLineLength:RatesFixFlow.kt$RatesFixFlow$ @Suspendable protected open fun filtering(elem: Any): Boolean</ID>
    <ID>MaxLineLength:RatesFixFlow.kt$RatesFixFlow$override val progressTracker: ProgressTracker = RatesFixFlow.tracker(fixOf.name)</ID>
    <ID>MaxLineLength:ReactiveArtemisConsumer.kt$MultiplexingReactiveArtemisConsumer$private</ID>
    <ID>MaxLineLength:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$fun multiplex(createSession: () -&gt; ClientSession, queueName: String, filter: String? = null, vararg queueNames: String): ReactiveArtemisConsumer</ID>
    <ID>MaxLineLength:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$fun multiplex(queueNames: Set&lt;String&gt;, createSession: () -&gt; ClientSession, filter: String? = null): ReactiveArtemisConsumer</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$ParallelAlgorithmMap : AlgorithmDefinition</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$nodes[0].startFlowAndRunNetwork(ParallelAlgorithmList(nodes[1].info.singleIdentity(), nodes[2].info.singleIdentity()))</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$nodes[0].startFlowAndRunNetwork(ParallelAlgorithmMap(nodes[1].info.singleIdentity(), nodes[2].info.singleIdentity()))</ID>
    <ID>MaxLineLength:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests.AlgorithmDefinition$@InitiatingFlow abstract</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$bob = mockNet.restartNode(bob, parameters = InternalMockNodeParameters(additionalCordapps = listOf(FINANCE_CONTRACTS_CORDAPP)))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$private val mockNet = InternalMockNetwork(notarySpecs = listOf(MockNetworkNotarySpec(DUMMY_NOTARY_NAME, validating = false)))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$val paymentReceiverFuture = bob.smm.track().updates.filter { it.logic is CashPaymentReceiverFlow }.map { it.logic.runId }.toFuture()</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$var bob = mockNet.createNode(InternalMockNodeParameters(legalName = BOB_NAME, additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP)))</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest${ val alice = mockNet.createNode(InternalMockNodeParameters(legalName = ALICE_NAME, additionalCordapps = FINANCE_CORDAPPS)) // Bob initially does not have the finance contracts CorDapp so that it can throw an exception in ReceiveFinalityFlow when receiving // the payment from Alice var bob = mockNet.createNode(InternalMockNodeParameters(legalName = BOB_NAME, additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP))) val paymentReceiverFuture = bob.smm.track().updates.filter { it.logic is CashPaymentReceiverFlow }.map { it.logic.runId }.toFuture() alice.services.startFlow(CashIssueAndPaymentFlow( 100.POUNDS, OpaqueBytes.of(0), bob.info.singleIdentity(), false, mockNet.defaultNotaryIdentity )) mockNet.runNetwork() val paymentReceiverId = paymentReceiverFuture.getOrThrow() assertThat(bob.services.vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;().states).isEmpty() bob.assertFlowSentForObservationDueToConstraintError(paymentReceiverId) // Restart Bob with the contracts CorDapp so that it can recover from the error bob = mockNet.restartNode(bob, parameters = InternalMockNodeParameters(additionalCordapps = listOf(FINANCE_CONTRACTS_CORDAPP))) mockNet.runNetwork() assertThat(bob.services.getCashBalance(GBP)).isEqualTo(100.POUNDS) }</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveStateAndRefFlow&lt;out T : ContractState&gt; : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$logger.trace { "Receiving a transaction (but without checking the signatures) from ${otherSideSession.counterparty}" }</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$private val statesToRecord: StatesToRecord = StatesToRecord.NONE</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps : AutoCloseableInternalCordaRPCOps</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$ fun runFlowWithLogicalRetry(runFlow: (CordaRPCOps) -&gt; StateMachineRunId, hasFlowStarted: (CordaRPCOps) -&gt; Boolean, onFlowConfirmed: () -&gt; Unit = {}, timeout: Duration = 4.seconds)</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.Companion$private</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$log.error("Node is being shutdown. Operation ${method.name} rejected. Retrying when node is up...", e)</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$private</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$CurrentState.CONNECTING, CurrentState.DIED -&gt; throw IllegalArgumentException("Illegal state: $currentState ")</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$attemptedAddress</ID>
    <ID>MaxLineLength:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$private tailrec</ID>
    <ID>MaxLineLength:ReconnectingObservable.kt$ReconnectingObservable.ReconnectingSubscriber$backingSubscription = dataFeed.updates.subscribe(subscriber::onNext, ::scheduleResubscribe, subscriber::onCompleted)</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = listOf(NotaryInfo(DUMMY_NOTARY, true)))</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$output(ExampleContract::class.java.typeName, "UPDATED REF DATA", "REF DATA".output&lt;ExampleState&gt;().copy(data = "NEW STUFF!"))</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$val stateAndRef = StateAndRef(TransactionState(state, CONTRACT_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), StateRef(SecureHash.zeroHash, 0))</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$UseRefState : FlowLogic</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(2, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(3, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(4, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newRefTx)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newTx)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), updatedRefTx)).resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val updatedQuery = QueryCriteria.VaultQueryCriteria(stateRefs = listOf(newRefState.ref), status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val updatedTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow()</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val useRefTx = nodes[1].services.startFlow(WithReferencedStatesFlow { UseRefState(nodeOneIdentity, newRefState.state.data.linearId) }) .resultFuture</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // Now let's find the specific reference state on nodes[1]. val refStateLinearId = newRefState.state.data.linearId val query = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedState.states.single()) println(theReferencedState.statesMetadata.single()) // nodes[0] should also have the same state. val nodeZeroQuery = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(nodeZeroQuery) assertEquals(newRefState, theReferencedStateOnNodeZero.states.single()) // nodes[0] sends the tx that created the reference state to nodes[1]. nodes[0].services.startFlow(Initiator(newRefState)).resultFuture.getOrThrow() // Query again. val theReferencedStateAgain = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedStateAgain.states.single()) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). val allRefStates = nodes[1].services.vaultService.queryBy&lt;LinearState&gt;() // nodes[1] should have two states. The newly created output and the reference state created by nodes[0]. assertEquals(2, allRefStates.states.size) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" in a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // 3. Update the reference state but don't share the update. val updatedRefTx = nodes[0].services.startFlow(UpdateRefState(newRefState)).resultFuture.getOrThrow() // 4. Now report the transactions that created the two reference states to a third party. nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newRefTx)).resultFuture.getOrThrow() nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), updatedRefTx)).resultFuture.getOrThrow() // Check that there are two linear states in the vault (note that one is consumed) assertEquals(2, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) // 5. Report the transaction that uses the consumed reference state nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newTx)).resultFuture.getOrThrow() // There should be 3 linear states in the vault assertEquals(3, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" in a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // Now let's find the specific reference state on nodes[1]. val refStateLinearId = newRefState.state.data.linearId val query = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedState.states.single()) // The reference state should not be consumed. assertEquals(Vault.StateStatus.UNCONSUMED, theReferencedState.statesMetadata.single().status) // nodes[0] should also have the same state. val nodeZeroQuery = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(nodeZeroQuery) assertEquals(newRefState, theReferencedStateOnNodeZero.states.single()) assertEquals(Vault.StateStatus.UNCONSUMED, theReferencedStateOnNodeZero.statesMetadata.single().status) // 3. Update the reference state but don't share the update. nodes[0].services.startFlow(UpdateRefState(newRefState)).resultFuture.getOrThrow() // 4. Use the evolved state as a reference state. val updatedTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(updatedTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have four states. The originals, plus the newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(4, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) // Now let's find the original reference state on nodes[1]. val updatedQuery = QueryCriteria.VaultQueryCriteria(stateRefs = listOf(newRefState.ref), status = Vault.StateStatus.ALL) val theOriginalReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(updatedQuery) // There should be one result - the original reference state. assertEquals(newRefState, theOriginalReferencedState.states.single()) // The reference state should be consumed. assertEquals(Vault.StateStatus.CONSUMED, theOriginalReferencedState.statesMetadata.single().status) // nodes[0] should also have the same state. val theOriginalReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(updatedQuery) assertEquals(newRefState, theOriginalReferencedStateOnNodeZero.states.single()) assertEquals(Vault.StateStatus.CONSUMED, theOriginalReferencedStateOnNodeZero.statesMetadata.single().status) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests.RefState.State$data</ID>
    <ID>MaxLineLength:RegistrationServer.kt$RegistrationServer : NetworkMapServer</ID>
    <ID>MaxLineLength:RegistrationServer.kt$RegistrationServer.SimpleDoormanService$certificates[requestId] = X509Utilities.createCertificate(CertificateType.NODE_CA, DEV_INTERMEDIATE_CA.certificate, DEV_INTERMEDIATE_CA.keyPair, X500Principal(csr.subject.toString()), csr.publicKey)</ID>
    <ID>MaxLineLength:RegistrationServer.kt$RegistrationServer.SimpleDoormanService$listOf(X509Utilities.CORDA_CLIENT_CA, X509Utilities.CORDA_INTERMEDIATE_CA, X509Utilities.CORDA_ROOT_CA).zip(certificates)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool : HAToolBase</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$" For convenience the tool is also downloading network parameters. Additionally, it can import the TLS keys into the bridge."</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$" However, for the following X500 names it has failed: [${fail.allX500NamesAsStr()}]. Please see log for more details."</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$@Option(names = ["--bridge-config-file", "-g"], paramLabel = "FILE", description = ["The path to the bridge configuration file."])</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$@Option(names = ["--config-files", "-f"], arity = "1..*", paramLabel = "FILE", description = ["The path to the node config file"], required = true)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$@Option(names = ["-b", BASE_DIR], paramLabel = "FOLDER", description = ["The node working directory where all the files are kept."])</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$@Option(names = ["-p", "--network-root-truststore-password"], paramLabel = "PASSWORD", description = ["Network root trust store password obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$@Option(names = ["-t", "--network-root-truststore"], paramLabel = "FILE", description = ["Network root trust store obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$ConfigValueFactory.fromAnyRef(resolveRelativeCryptoConfPath(configFileParentPath, cryptoServiceConfPath).toString())</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$private</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$return CryptoServiceFactory.makeCryptoService(bridgeCryptoServiceName, DUMMY_X500_NAME, null, bridgeCryptoServiceConfigPath)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val alias = x500PrincipalToTLSAlias(legalName.x500Principal) // must be lower case to stay consistent with public .JKS file</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val bridgeCryptoServiceConfigPath = resolveCryptoConfPath(configDir, Paths.get(bridgeCryptoServiceConfig.getString("conf")))</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val cryptoServiceConfigPath = resolveCryptoConfPath(configPath.parentOrDefault, nodeConfig.cryptoServiceConf!!)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val folderName = if (legalName.commonName == null) legalName.organisation else "${legalName.commonName},${legalName.organisation}"</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val helper = NodeRegistrationHelper(NodeRegistrationConfiguration(this), HTTPNetworkRegistrationService(networkServices!!, VERSION_INFO), NodeRegistrationOption(networkRootTrustStorePath, networkRootTrustStorePassword), logProgress = logger::info, logError = logger::error)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val legalName = ConfigHelper.loadConfig(it.parentOrDefault, it).parseAsNodeConfiguration().value().myLegalName</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val nodeConfig = ConfigHelper.loadConfig(configPath.parentOrDefault, configPath).parseAsNodeConfiguration().value()</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool$val versionInfo = VersionInfo(PLATFORM_VERSION, CordaVersion.releaseVersion, CordaVersion.revision, CordaVersion.vendor)</ID>
    <ID>MaxLineLength:RegistrationTool.kt$RegistrationTool.Companion${ val nameHash = SecureHash.sha256(x500Principal.toString()) // Note we use lower case as .JKS aliases are squashed to lowercase during the insert procedure and this breaks any link to the HSM alias. return "${X509Utilities.CORDA_CLIENT_TLS}-$nameHash".toLowerCase() }</ID>
    <ID>MaxLineLength:RegistrationToolTest.kt$RegistrationToolTest$"--config-files"</ID>
    <ID>MaxLineLength:RegistrationToolTest.kt$RegistrationToolTest$javaClass.classLoader.getResourceAsStream(it).replaceMapping(portReplacementMap).copyTo(workingDirectory / it)</ID>
    <ID>MaxLineLength:RegistrationToolTest.kt$RegistrationToolTest$listOf("nodeA_HSM.conf", "nodeB_HSM.conf", "nodeC_HSM.conf", "firewall.conf", "utimaco_config.yml", "utimaco_config2.yml")</ID>
    <ID>MaxLineLength:RegistrationToolTest.kt$RegistrationToolTest$val bridgeKeyStore = X509KeyStore.fromFile((workingDirectory / "bridge.jks"), "cordacadevpass", createNew = false)</ID>
    <ID>MaxLineLength:RegistrationToolTest.kt$RegistrationToolTest$val sslKeyStore = X509KeyStore.fromFile((workingDirectory / it.toFolderName() / "certificates" / "sslkeystore.jks"), "cordacadevpass", createNew = false)</ID>
    <ID>MaxLineLength:RegistrationToolTest.kt$RegistrationToolTest.Companion$val textWithReplacementApplied = replacement.entries.fold(text) { currText, entry -&gt; currText.replace(entry.key, entry.value) }</ID>
    <ID>MaxLineLength:ReleaseLockCli.kt$ReleaseLockCli : CliWrapperBase</ID>
    <ID>MaxLineLength:ReleaseLockCli.kt$ReleaseLockCli$SchemaMigration(emptySet(), it, db.config.database, null, currentDirectory = null).forceReleaseMigrationLock()</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory : RemoteSerializerFactory</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$RemoteAndLocalTypeInformation(remoteInformation, localInformationByIdentifier[remoteInformation.typeIdentifier]!!)</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$logger.trace("get Serializer descriptor=$typeDescriptor") // Interpret all of the types in the schema into RemoteTypeInformation, and reflect that into LocalTypeInformation. val remoteTypeInformationMap = remoteTypeModel.interpret(schema) val reflected = reflect(remoteTypeInformationMap, context) // Get, and record in the registry, serializers for all of the types contained in the schema. // This will save us having to re-interpret the entire schema on re-entry when deserialising individual property values. val serializers = reflected.mapValues { (descriptor, remoteLocalPair) -&gt; descriptorBasedSerializerRegistry.getOrBuild(descriptor) { getUncached(remoteLocalPair.remoteTypeInformation, remoteLocalPair.localTypeInformation) } } // Return the specific serializer the caller asked for. serializers[typeDescriptor] ?: throw NotSerializableException( "Could not find type matching descriptor $typeDescriptor.")</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$DefaultRemoteSerializerFactory$when { // If descriptors match, we can return the local serializer straight away. localDescriptor == remoteDescriptor -&gt; localSerializer // Can we deserialise without evolution, e.g. going from List&lt;Foo&gt; to List&lt;*&gt;? remoteTypeInformation.isDeserialisableWithoutEvolutionTo(localTypeInformation) -&gt; localSerializer // Are the remote/local types evolvable? If so, ask the evolution serializer factory for a serializer, returning // the local serializer if it returns null (i.e. no evolution required). remoteTypeInformation.isEvolvableTo(localTypeInformation) -&gt; evolutionSerializerFactory.getEvolutionSerializer(remoteTypeInformation, localTypeInformation) ?: localSerializer // Descriptors don't match, and something is probably broken, but we let the framework do what it can with the local // serialiser (BlobInspectorTest uniquely breaks if we throw an exception here, and passes if we just warn and continue). else -&gt; { logger.warn(""" Mismatch between type descriptors, but remote type is not evolvable to local type. Remote type (descriptor: $remoteDescriptor) ${remoteTypeInformation.prettyPrint(false)} Local type (descriptor $localDescriptor): ${localTypeInformation.prettyPrint(false)} """) localSerializer } }</ID>
    <ID>MaxLineLength:RemoteSerializerFactory.kt$RemoteSerializerFactory$ @Throws(NotSerializableException::class, ClassNotFoundException::class) fun get(typeDescriptor: TypeDescriptor, schema: SerializationSchemas, context: SerializationContext): AMQPSerializer&lt;Any&gt;</ID>
    <ID>MaxLineLength:RemoteTypeCarpenter.kt$SchemaBuildingRemoteTypeCarpenter$if (typeInformation.typeIdentifier !is TypeIdentifier.Parameterised) typeInformation.carpentComposable()</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation$ fun prettyPrint(simplifyClassNames: Boolean = true): String</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.AnArray$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.AnInterface$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.Parameterised$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.Unparameterised$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformationPrettyPrinter$private data</ID>
    <ID>MaxLineLength:ReplayedList.kt$ReplayedList&lt;A&gt; : TransformationList</ID>
    <ID>MaxLineLength:Reporter.kt$ObjectName("$domain:type=$category,${if (component.isNotEmpty()) "component=$component," else ""}name=$subName")</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$SerializationFactory.defaultFactory.deserialize(receivedMessage.payload.sequence(), responseClass.java, SerializationFactory.defaultFactory.defaultContext)</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$auditService.packetDropEvent(receivedMessage, "Invalid control source legal name!!", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$internal</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val auditService: FirewallAuditService</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val floatClientName: CordaX500Name</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val log: Logger</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val responseClass: KClass&lt;RESP&gt;</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val responseTimeOut: Duration</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val sourceLegalName: String</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val sourceLink: NetworkHostAndPort</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val stateHelper: ServiceStateHelper</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$private val topic: String</ID>
    <ID>MaxLineLength:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$val amqpMessage = amqpControl.createMessage(request.serialize(context = SerializationDefaults.P2P_CONTEXT).bytes, topic, sourceLegalName, sourceLink, emptyMap())</ID>
    <ID>MaxLineLength:RequiresDb.kt$RequiresDb</ID>
    <ID>MaxLineLength:RequiresDb.kt$RequiresSql</ID>
    <ID>MaxLineLength:ResolveStatePointersTest.kt$ResolveStatePointersTest$networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = listOf(NotaryInfo(notary.party, true)))</ID>
    <ID>MaxLineLength:ResolveStatePointersTest.kt$ResolveStatePointersTest.Foo$@BelongsToContract(DummyContract::class) private data</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$ // TODO This can also be done in parallel. See comment to [fetchMissingAttachments] above. @Suspendable fun fetchMissingNetworkParameters(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$ // TODO: This could be done in parallel with other fetches for extra speed. @Suspendable fun fetchMissingAttachments(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$/** * Resolves and validates the dependencies of the specified [SignedTransaction]. Fetches the attachments, but does * *not* validate or store the [SignedTransaction] itself. * * @return a list of verified [SignedTransaction] objects, in a depth-first order. */ constructor(transaction: SignedTransaction, otherSide: FlowSession, statesToRecord: StatesToRecord = StatesToRecord.NONE) : this(transaction, transaction.dependencies, otherSide, statesToRecord)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" }</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val usedStatesToRecord = if (statesToRecord == StatesToRecord.NONE) StatesToRecord.ONLY_RELEVANT else statesToRecord</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow${ // TODO This error should actually cause the flow to be sent to the flow hospital to be retried val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" } // Fetch missing parameters flow was added in version 4. This check is needed so we don't end up with node V4 sending parameters // request to node V3 that doesn't know about this protocol. fetchNetParamsFromCounterpart = counterpartyPlatformVersion &gt;= 4 if (initialTx != null) { fetchMissingAttachments(initialTx) fetchMissingNetworkParameters(initialTx) } val resolver = (serviceHub as ServiceHubCoreInternal).createTransactionsResolver(this) resolver.downloadDependencies() otherSide.send(FetchDataFlow.Request.End) // Finish fetching data. // If transaction resolution is performed for a transaction where some states are relevant, then those should be // recorded if this has not already occurred. val usedStatesToRecord = if (statesToRecord == StatesToRecord.NONE) StatesToRecord.ONLY_RELEVANT else statesToRecord resolver.recordDependencies(usedStatesToRecord) }</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// Used for checking larger chains resolve correctly. Note that this takes a long time to run, and so is not suitable for a CI gate. @Test @Ignore fun `Can resolve large chain of transactions`()</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$currentTx = createContractUpgradeTransaction(currentTx.tx.outRefsOfType&lt;ContractState&gt;().map { it.ref }, currentTx)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val ledgerTx = (currentTx.coreTransaction as ContractUpgradeWireTransaction).resolve(megaCorpNode.services, currentTx.sigs)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val ledgerTx = (currentTx.coreTransaction as NotaryChangeWireTransaction).resolve(megaCorpNode.services, currentTx.sigs)</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val notaryTx = NotaryChangeTransactionBuilder(inputs, notary, newNotary, notaryNode.services.networkParametersService.defaultHash).build()</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val signableData = SignableData(contractTx.id, SignatureMetadata(4, Crypto.findSignatureScheme(notaryKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val signableData = SignableData(notaryTx.id, SignatureMetadata(4, Crypto.findSignatureScheme(notaryKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestFlow$@InitiatingFlow open</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestFlow$constructor(txHashes: Set&lt;SecureHash&gt;, otherSide: Party) : this(otherSide, { ResolveTransactionsFlow(txHashes, it) })</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestNoRightsVendingFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestResponseResolveNoRightsFlow$otherSideSession.sendAndReceive&lt;Any&gt;(FetchDataFlow.Request.Data(NonEmptySet.of(noRightsTx.inputs.first().txhash), FetchDataFlow.DataType.TRANSACTION))</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestResponseResolveTwiceFlow$otherSideSession.sendAndReceive&lt;Any&gt;(FetchDataFlow.Request.Data(NonEmptySet.of(parent1), FetchDataFlow.DataType.TRANSACTION))</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest${ val messagesSent = Collections.synchronizedList(mutableListOf&lt;Message&gt;()) val partyB = nodeB.info.legalIdentities.first() nodeA.setMessagingServiceSpy(object : MessagingServiceSpy() { override fun send(message: Message, target: MessageRecipients, sequenceKey: Any) { messagesSent.add(message) messagingService.send(message, target) } }) val count = 10000 // Lots of iterations so the flow keeps going long enough nodeA.startFlow(KeepSendingFlow(count, partyB)) eventually(duration = Duration.ofSeconds(30), waitBetween = Duration.ofMillis(100)) { assertTrue(messagesSent.isNotEmpty()) assertNotNull(messagesSent.first().senderUUID) } nodeA = mockNet.restartNode(nodeA) // This is a bit racy because restarting the node actually starts it, so we need to make sure there's enough iterations we get here with flow still going. nodeA.setMessagingServiceSpy(object : MessagingServiceSpy() { override fun send(message: Message, target: MessageRecipients, sequenceKey: Any) { messagesSent.add(message) messagingService.send(message, target) } }) // Now short circuit the iterations so the flow finishes soon. KeepSendingFlow.count.set(count - 2) eventually(duration = Duration.ofSeconds(30), waitBetween = Duration.ofMillis(100)) { assertTrue(nodeA.smm.allStateMachines.isEmpty()) } assertNull(messagesSent.last().senderUUID) }</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest.RetryInsertFlow$val tx = DBTransactionStorage.DBTransaction("Foo", null, Utils.EMPTY_BYTES, DBTransactionStorage.TransactionStatus.VERIFIED)</ID>
    <ID>MaxLineLength:RevocationConfig.kt$ fun Boolean.toRevocationConfig()</ID>
    <ID>MaxLineLength:RevocationConfig.kt$RevocationConfig.Mode$HARD_FAIL</ID>
    <ID>MaxLineLength:RevocationConfig.kt$RevocationConfigImpl$data</ID>
    <ID>MaxLineLength:RevocationConfig.kt$RevocationConfigParser$"EXTERNAL_SOURCE" -&gt; RevocationConfigImpl(RevocationConfig.Mode.EXTERNAL_SOURCE, null)</ID>
    <ID>MaxLineLength:RevocationConfig.kt$RevocationConfigParser$require</ID>
    <ID>MaxLineLength:RigorousMock.kt$ fun &lt;T&gt; participant(clazz: Class&lt;out T&gt;)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ fun &lt;T&gt; rigorousMock(clazz: Class&lt;out T&gt;)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ fun &lt;T&gt; spectator(clazz: Class&lt;out T&gt;)</ID>
    <ID>MaxLineLength:RigorousMock.kt$ParticipantDefaultAnswer$"Please specify what should happen when '${invocation.method}' is called, or don't call it. Args: ${Arrays.toString(invocation.arguments)}"</ID>
    <ID>MaxLineLength:RigorousMock.kt$RigorousMockDefaultAnswer$return if (Modifier.isAbstract(invocation.method.modifiers)) ParticipantDefaultAnswer.answerImpl(invocation) else invocation.callRealMethod()</ID>
    <ID>MaxLineLength:RigorousMock.kt$SpectatorDefaultAnswer.MethodInfo$private fun newSpectator(invocation: InvocationOnMock)</ID>
    <ID>MaxLineLength:RigorousMock.kt$SpectatorDefaultAnswer.MethodInfo$return context.actualTypeArguments[clazz.typeParameters.indexOf(resolveType(clazz.genericSuperclass, type))]</ID>
    <ID>MaxLineLength:RigorousMock.kt$UndefinedMockBehaviorException : RuntimeException</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { collaborator.noClearDefault() }.javaClass)</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { m.a }.javaClass)</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { m.kotlinDefaultFun() }.javaClass)</ID>
    <ID>MaxLineLength:RolesAdderOnLogin.kt$RolesAdderOnLogin$internal</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$return Caffeine.newBuilder().weakValues().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()).build()</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$serializationContext</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$val subMap: Cache&lt;Trace.InvocationId, ObservableSubscription&gt; = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.MINUTES) .maximumSize(100) .build()</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$acceptorConfigurationsSet += rpcInternalAcceptorTcpTransport(it, nodeConfiguration, artemisSigningServiceName(nodeConfiguration))</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$deleteNonDurableQueue: Boolean = false</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$internal</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$journalBufferSize_AIO = maxMessageSize</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$journalBufferSize_NIO = maxMessageSize</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$private</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$return Role(name, send, consume, createDurableQueue, deleteDurableQueue, createNonDurableQueue, deleteNonDurableQueue, manage, browse, createDurableQueue || createNonDurableQueue, deleteDurableQueue || deleteNonDurableQueue)</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$securityRoles[RPCApi.RPC_SERVER_QUEUE_NAME] = setOf(nodeInternalRole, restrictedRole(BrokerJaasLoginModule.RPC_ROLE, send = true))</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$val addRPCRoleToUsers = if (shouldStartLocalShell) listOf(ArtemisMessagingComponent.INTERNAL_SHELL_USER) else emptyList()</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$val nodeInternalRole = Role(BrokerJaasLoginModule.NODE_RPC_ROLE, true, true, true, true, true, true, true, true, true, true)</ID>
    <ID>MaxLineLength:RpcClientCordaFutureSerializer.kt$RpcClientCordaFutureSerializer$throw NotSerializableException("Failed to deserialize Future from proxy Observable - ${e.message}\n").apply { initCause(e.cause) }</ID>
    <ID>MaxLineLength:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer : Implements</ID>
    <ID>MaxLineLength:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer$private</ID>
    <ID>MaxLineLength:RpcClientObservableDeSerializer.kt$RpcClientObservableDeSerializer$val observableId: Trace.InvocationId = Trace.InvocationId((obj[0] as String), Instant.ofEpochMilli((obj[1] as Long)))</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertEquals((exception.cause as CordaRuntimeException).originalExceptionClassName, SQLException::class.qualifiedName)</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { devModeNode.throwExceptionFromFlow() }</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { node.throwExceptionFromFlow() }</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { scenario(ALICE_NAME, BOB_NAME,true) }</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest.Companion$@ClassRule @JvmField val databaseSchemas = IntegrationTestSchemas(ALICE_NAME, BOB_NAME, DUMMY_NOTARY_NAME, DUMMY_BANK_A_NAME, DUMMY_BANK_B_NAME)</ID>
    <ID>MaxLineLength:RpcExceptions.kt$OutdatedNetworkParameterHashException.Companion$private const val TEMPLATE = "Refused to accept parameters with hash %s because network map advertises update with hash %s. Please check newest version"</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$ArtemisRpcBroker</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$FileUtils.copyDirectory(config.certificatesDirectory.toFile(), (flowWorkerConfig.baseDirectory / "certificates").toFile())</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$auditServiceConfiguration = AuditServiceConfigurationImpl(120)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$bridgeInnerConfig = null</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$data</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$fun startRpcFlowWorker(legalNames: Set&lt;CordaX500Name&gt;, rpcUsers: List&lt;net.corda.testing.node.User&gt;, numberOfFlowWorkers: Int = 1): CordaFuture&lt;RpcFlowWorkerHandle&gt;</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$fun startRpcFlowWorker(myLegalName: CordaX500Name, rpcUsers: List&lt;net.corda.testing.node.User&gt;, numberOfFlowWorkers: Int = 1): CordaFuture&lt;RpcFlowWorkerHandle&gt;</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$inboundConfig = BridgeInboundConfigurationImpl(bridgeListeningAddress)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$keyStorePassword = "pass"</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$outboundConfig = BridgeOutboundConfigurationImpl(nodeConfig.messagingServerAddress!!, listOf(), null, null)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$p2pAddress = NetworkHostAndPort("localhost", 1)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$private</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$relay = null</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$rpcUsers = listOf()</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$trustRoot: X509Certificate</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val (flowWorker, _) = createFlowWorker(it, myInfo, ourKeyPair, trustRoot, nodeCa, signedNetworkParameters)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val bridge = FirewallInstance(firewallConfiguration, FirewallVersionInfo(PLATFORM_VERSION, "1.1", "Dummy", "Test"))</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val flowWorkerConfig = config.copy(baseDirectory = driverDSL.driverDirectory / myLegalName.organisation / "flowWorker$it")</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val flowWorkerServiceHub = FlowWorkerServiceHub(config, myInfo, ourKeyPair, trustRoot, nodeCa, signedNetworkParameters)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val myInfo = NodeInfo(listOf(bridgeConfig.inboundConfig!!.listeningAddress), listOf(ourPartyAndCertificate), PLATFORM_VERSION, 1)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val rpcWorker = RpcWorker(rpcWorkerBroker.serverControl, rpcWorkerConfig, *rpcWorkerServiceHubs.toTypedArray()).start()</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val rpcWorkerServiceHub = createRpcWorkerServiceHub(config, myInfo, signedNetworkParameters, ourKeyPair, trustRoot, nodeCa)</ID>
    <ID>MaxLineLength:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val securityManager = RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(config.rpcUsers), EnterpriseNamedCacheFactory(config.enterpriseConfiguration.getTracingConfig()))</ID>
    <ID>MaxLineLength:RpcFlowsDrainingModeTest.kt$RpcFlowsDrainingModeTest$driver</ID>
    <ID>MaxLineLength:RpcHelper.kt$fun &lt;T&gt; arithmeticBackoff(retryInterval: Duration, giveUpInterval: Duration, meaningfulDescription: String, op: () -&gt; T): T</ID>
    <ID>MaxLineLength:RpcHelper.kt$giveUpInterval: Duration = 5.minutes</ID>
    <ID>MaxLineLength:RpcHelper.kt$inline</ID>
    <ID>MaxLineLength:RpcHelper.kt$paging: PageSpecification = PageSpecification()</ID>
    <ID>MaxLineLength:RpcHelpers.kt$return Observable.interval(interval, unit).map { isWaitingForShutdown() }.takeFirst { waiting -&gt; waiting == false }.map { Unit }</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests : IntegrationTest</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$assertThat(stateMachineEvents.count { it is StateMachineUpdate.Added }).isGreaterThanOrEqualTo(NUMBER_OF_FLOWS_TO_RUN / 3)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$assertThat(stateMachineEvents.count { it is StateMachineUpdate.Removed }).isGreaterThanOrEqualTo(NUMBER_OF_FLOWS_TO_RUN / 3)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$assertTrue(missingProgressEvents.isEmpty(), "The flow progress tracker is missing events: $missingProgressEvents")</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$bankAReconnectingRpc .vaultQueryByWithPagingSpec(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED), PageSpecification(1, 10000))</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$driver</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$fun startBankA(address: NetworkHostAndPort)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$fun startProxy(addressPair: AddressPair)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$log.info("Timed out waiting for confirmation that all flows have started. Remaining flows: ${flowsCountdownLatch.count}")</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$log.info("vault update produced ${update.produced.map { it.state.data.amount }} consumed ${update.consumed.map { it.ref }}")</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$val bankAReconnectingRpc = client.start(demoUser.username, demoUser.password, gracefulReconnect = true).proxy as ReconnectingCordaRPCOps</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$val criteria = QueryCriteria.VaultCustomQueryCriteria(builder { CashSchemaV1.PersistentCashState::pennies.equal(amount.toLong() * 100) }, status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:RpcServerObservableSerializer.kt$RpcServerObservableSerializer.&lt;no name provided&gt;$observableContext.clientAddressToObservables</ID>
    <ID>MaxLineLength:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$val subMap: Cache&lt;Trace.InvocationId, ObservableSubscription&gt; = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.MINUTES) .maximumSize(100) .build()</ID>
    <ID>MaxLineLength:RpcSslTest.kt$RpcSslTest$val connection = CordaRPCClient(node.rpcAddress, sslConfiguration = clientSslOptions).start(user.username, user.password)</ID>
    <ID>MaxLineLength:RpcSslTest.kt$RpcSslTest$val connection2 = CordaRPCClient(node.rpcAddress, sslConfiguration = clientSslOptions).start(user.username, "wrong")</ID>
    <ID>MaxLineLength:RpcSslTest.kt$RpcSslTest$val node = startNode(rpcUsers = listOf(user), customOverrides = brokerSslOptions.useSslRpcOverrides()).getOrThrow()</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$ArtemisRpcBroker.withSsl(config.p2pSslOptions, rpcOptions.address, rpcOptions.adminAddress, rpcOptions.sslConfig!!, securityManager, maxMessageSize, false, config.baseDirectory / "artemis", false)</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$ArtemisRpcBroker.withoutSsl(config.p2pSslOptions, rpcOptions.address, rpcOptions.adminAddress, securityManager, maxMessageSize, false, config.baseDirectory / "artemis", false)</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$createRpcWorker(rpcWorkerConfig, myInfo, signedNetworkParameters, ourKeyPair, trustRoot, nodeCa, rpcWorkerBroker.serverControl)</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$private</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$val nodeCa = rpcWorkerConfig.signingCertificateStore.get().query { getCertificate(X509Utilities.CORDA_CLIENT_CA) }</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$val rpcWorkerBroker = createRpcWorkerBroker(rpcWorkerConfig, signedNetworkParameters.networkParameters.maxMessageSize)</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$val rpcWorkerServiceHub = RpcWorkerServiceHub(config, myInfo, signedNetworkParameters, ourKeyPair, trustRoot, nodeCa)</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$val securityManager = RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(config.rpcUsers), EnterpriseNamedCacheFactory(config.enterpriseConfiguration.getTracingConfig()))</ID>
    <ID>MaxLineLength:RpcWorker.kt$Main$val trustRoot = rpcWorkerConfig.p2pSslOptions.trustStore.get().query { getCertificate(X509Utilities.CORDA_ROOT_CA) }</ID>
    <ID>MaxLineLength:RpcWorker.kt$RpcWorker</ID>
    <ID>MaxLineLength:RpcWorker.kt$RpcWorker$CordaX500Name.build(rpcWorkerConfig.p2pSslOptions.keyStore.get().query { getCertificate(X509Utilities.CORDA_CLIENT_TLS).subjectX500Principal })</ID>
    <ID>MaxLineLength:RpcWorker.kt$RpcWorker$val internalRpcMessagingClient = InternalRPCMessagingClient&lt;CordaRpcWorkerOps&gt;(rpcWorkerConfig.p2pSslOptions, rpcWorkerConfig.rpcOptions.adminAddress, Node.MAX_RPC_MESSAGE_SIZE, nodeName, rpcServerConfiguration)</ID>
    <ID>MaxLineLength:RpcWorker.kt$RpcWorker$val securityManager = RPCSecurityManagerImpl(SecurityConfiguration.AuthService.fromUsers(rpcWorkerConfig.rpcUsers), rpcWorkerServiceHubs[0].cacheFactory)</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$CordaRPCClient(combinedRpcHandle.rpcAddress).start(rpcUser.username, rpcUser.password, CHARLIE_NAME).proxy</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val bankAProxy = CordaRPCClient(combinedRpcHandle.rpcAddress).start(rpcUser.username, rpcUser.password, DUMMY_BANK_A_NAME).proxy</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val bankBProxy = CordaRPCClient(combinedRpcHandle.rpcAddress).start(rpcUser.username, rpcUser.password, DUMMY_BANK_B_NAME).proxy</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val cashIssueResult = bankAProxy.startFlow(::CashIssueFlow, 11.POUNDS, OpaqueBytes.of(0x01), defaultNotaryIdentity) .returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val cashPayResult = bankAProxy.startFlow(::CashPaymentFlow, 8.POUNDS, bankC.nodeInfo.singleIdentity(), false).returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val cashPayResult2 = bankC.rpc.startFlow(::CashPaymentFlow, 2.POUNDS, bankBProxy.nodeInfo().singleIdentity()).returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val combinedRpcHandle = startRpcFlowWorker(setOf(DUMMY_BANK_A_NAME, DUMMY_BANK_B_NAME), listOf(rpcUser), 1).get()</ID>
    <ID>MaxLineLength:RpcWorkerMultiIdentityTest.kt$RpcWorkerMultiIdentityTest$val rpcUser = User("username", "password", permissions = setOf("ALL")) val combinedRpcHandle = startRpcFlowWorker(setOf(DUMMY_BANK_A_NAME, DUMMY_BANK_B_NAME), listOf(rpcUser), 1).get() val bankC = startNode(providedName = DUMMY_BANK_C_NAME).get() val bankAProxy = CordaRPCClient(combinedRpcHandle.rpcAddress).start(rpcUser.username, rpcUser.password, DUMMY_BANK_A_NAME).proxy val bankBProxy = CordaRPCClient(combinedRpcHandle.rpcAddress).start(rpcUser.username, rpcUser.password, DUMMY_BANK_B_NAME).proxy val cashIssueResult = bankAProxy.startFlow(::CashIssueFlow, 11.POUNDS, OpaqueBytes.of(0x01), defaultNotaryIdentity) .returnValue.get() assertEquals(11.POUNDS, bankAProxy.getCashBalances()[GBP]) val cashPayResult = bankAProxy.startFlow(::CashPaymentFlow, 8.POUNDS, bankC.nodeInfo.singleIdentity(), false).returnValue.get() assertEquals(3.POUNDS, bankAProxy.getCashBalances()[GBP]) assertEquals(8.POUNDS, bankC.rpc.getCashBalances()[GBP]) val cashPayResult2 = bankC.rpc.startFlow(::CashPaymentFlow, 2.POUNDS, bankBProxy.nodeInfo().singleIdentity()).returnValue.get() assertEquals(3.POUNDS, bankAProxy.getCashBalances()[GBP]) assertEquals(6.POUNDS, bankC.rpc.getCashBalances()[GBP]) // assertEquals(2.POUNDS, bankBProxy.getCashBalances()[GBP]) TODO: Investigate race condition, this condition sometimes passes and sometimes not Assertions.assertThatThrownBy { CordaRPCClient(combinedRpcHandle.rpcAddress).start(rpcUser.username, rpcUser.password, CHARLIE_NAME).proxy }.isInstanceOf(CordaRuntimeException::class.java)</ID>
    <ID>MaxLineLength:RpcWorkerPaidTest.kt$RpcWorkerPaidTest$val bankAUser = User("username", "password", permissions = setOf("ALL")) val bankA = startRpcFlowWorker(DUMMY_BANK_A_NAME, listOf(bankAUser)).get() val bankB = startNode().get() val bankAProxy = CordaRPCClient(bankA.rpcAddress).start("username", "password").proxy val cashIssueResult = bankB.rpc.startFlow(::CashIssueFlow, 10.POUNDS, OpaqueBytes.of(0x01), defaultNotaryIdentity).returnValue.get() assertEquals(10.POUNDS, bankB.rpc.getCashBalances()[GBP]) val cashPayResult = bankB.rpc.startFlow(::CashPaymentFlow, 2.POUNDS, bankAProxy.nodeInfo().singleIdentity(), false).returnValue.get() assertEquals(8.POUNDS, bankB.rpc.getCashBalances()[GBP]) Thread.sleep(10000) // This can sometimes fail due to slow update. Similar to the RpcWorkerMultiIdentityTest, a timeout worked but the test should be re-written, perhaps to track the vault? assertEquals(2.POUNDS, bankAProxy.getCashBalances()[GBP])</ID>
    <ID>MaxLineLength:RpcWorkerPaidTest.kt$RpcWorkerPaidTest$val cashIssueResult = bankB.rpc.startFlow(::CashIssueFlow, 10.POUNDS, OpaqueBytes.of(0x01), defaultNotaryIdentity).returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerPaidTest.kt$RpcWorkerPaidTest$val cashPayResult = bankB.rpc.startFlow(::CashPaymentFlow, 2.POUNDS, bankAProxy.nodeInfo().singleIdentity(), false).returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$@Suppress("LeakingThis") override</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$database.startHikariPool(configuration.dataSourceProperties, configuration.database, schemaService.schemaOptions.keys, ourName = myInfo.legalIdentities.first().name)</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$override val cacheFactory = EnterpriseNamedCacheFactory(configuration.enterpriseConfiguration.getTracingConfig()).bindWithConfig(configuration).bindWithMetrics(metricRegistry)</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$override val cordappProvider = CordappProviderImpl(cordappLoader, CordappConfigFileProvider(emptyList()), attachments)</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$override val nodeProperties = NodePropertiesPersistentStore(StubbedNodeUniqueIdProvider::value, database, cacheFactory)</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$parseSecureHashConfiguration(configuration.blacklistedAttachmentSigningKeys) { "Error while adding signing key $it to blacklistedAttachmentSigningKeys" }</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$private</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$private val networkMapClient: NetworkMapClient? = configuration.networkServices?.let { NetworkMapClient(it, versionInfo) }</ID>
    <ID>MaxLineLength:RpcWorkerServiceHub.kt$RpcWorkerServiceHub$private val servicesForResolution = ServicesForResolutionImpl(identityService, attachments, cordappProvider, networkParametersService, validatedTransactions)</ID>
    <ID>MaxLineLength:RpcWorkerStartStopTest.kt$RpcWorkerStartStopTest$val cashIssueResult = bankAProxy.startFlow(::CashIssueFlow, 10.DOLLARS, OpaqueBytes.of(0x01), defaultNotaryIdentity).returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerTest.kt$RpcWorkerTest$val cashIssueResult = bankAProxy.startFlow(::CashIssueFlow, 10.DOLLARS, OpaqueBytes.of(0x01), defaultNotaryIdentity).returnValue.get()</ID>
    <ID>MaxLineLength:RpcWorkerTest.kt$RpcWorkerTest$val cashPayResult = bankAProxy.startFlow(::CashPaymentFlow, 2.DOLLARS, bankB.nodeInfo.singleIdentity(), false).returnValue.get()</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService$"If the master has only just terminated try again in ${Duration.ofMillis(waitInterval).seconds} seconds."</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService$MutualExclusion : Serializable</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService$log</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService$throw RuntimeException("Configuration Error: Node must wait longer than update rate otherwise someone else might be running!" + " Wait interval: $waitInterval, Update interval: $updateInterval")</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService$val hql = "UPDATE RunOnceService\$MutualExclusion SET $MACHINE_NAME = :machineName, $TIMESTAMP = CURRENT_TIMESTAMP, $PID = :pid, $VERSION = :newVersion " + "WHERE $ID = 'X' AND " + // we are master node "($MACHINE_NAME = :machineName OR " + // change master node "($MACHINE_NAME != :machineName AND " + // no one else has updated timestamp whilst we attempted this update "$VERSION = :oldVersion AND " + // old timestamp "CAST(CURRENT_TIMESTAMP as LocalDateTime) &gt; CAST(:waitTime as LocalDateTime)))"</ID>
    <ID>MaxLineLength:RunOnceService.kt$RunOnceService$val query = session.createNativeQuery("INSERT INTO $TABLE VALUES ('X', :machineName, :pid, CURRENT_TIMESTAMP, :version)", MutualExclusion::class.java)</ID>
    <ID>MaxLineLength:RunOnceServiceTest.kt$RunOnceServiceTest$val query = session.createNativeQuery(updateMachineNameQuery, RunOnceService.MutualExclusion::class.java)</ID>
    <ID>MaxLineLength:SNIBridgeTest.kt$SNIBridgeTest$internalDriver</ID>
    <ID>MaxLineLength:SNIBridgeTest.kt$SNIBridgeTest$startBridge(driverDirectory, artemisPort, advertisedP2PPort, bankAPath / "certificates" / "sslkeystore.jks", bankBPath / "certificates" / "sslkeystore.jks", floatPort = floatPort).getOrThrow()</ID>
    <ID>MaxLineLength:SNIBridgeTest.kt$SNIBridgeTest$val c = startNode(providedName = DUMMY_BANK_C_NAME, rpcUsers = listOf(demoUser), customOverrides = mapOf("p2pAddress" to "localhost:${portAllocation.nextPort()}", "baseDirectory" to "$bankCPath")).getOrThrow()</ID>
    <ID>MaxLineLength:SNIBridgeTest.kt$SNIBridgeTest.Companion$@ClassRule @JvmField val databaseSchemas = IntegrationTestSchemas(DUMMY_BANK_A_NAME, DUMMY_BANK_B_NAME, DUMMY_BANK_C_NAME, DUMMY_NOTARY_NAME)</ID>
    <ID>MaxLineLength:SNIKeyManager.kt$SNIKeyManager$internal</ID>
    <ID>MaxLineLength:SNIKeyManager.kt$SNIKeyManager$override</ID>
    <ID>MaxLineLength:SSLHelper.kt$// As per Javadoc in: https://docs.oracle.com/javase/8/docs/api/javax/net/ssl/KeyManagerFactory.html `init` method // 2nd parameter `password` - the password for recovering keys in the KeyStore fun KeyManagerFactory.init(keyStore: CertificateStore)</ID>
    <ID>MaxLineLength:SSLHelper.kt$ExternalSourceRevocationChecker(revocationConfig.externalCrlSource!!) { Date() }</ID>
    <ID>MaxLineLength:SSLHelper.kt$LoggingTrustManagerWrapper$AuthorityKeyIdentifier.getInstance(bcCert.getExtension(Extension.authorityKeyIdentifier).parsedValue).keyIdentifier.toHex()</ID>
    <ID>MaxLineLength:SSLHelper.kt$LoggingTrustManagerWrapper$SubjectKeyIdentifier.getInstance(bcCert.getExtension(Extension.subjectKeyIdentifier).parsedValue).keyIdentifier.toHex()</ID>
    <ID>MaxLineLength:SSLHelper.kt$internal</ID>
    <ID>MaxLineLength:SSLHelper.kt$private</ID>
    <ID>MaxLineLength:SSLHelper.kt$val sslContext = SslContextBuilder.forClient().sslProvider(SslProvider.OPENSSL).keyManager(keyManagerFactory).trustManager(LoggingTrustManagerFactoryWrapper(trustManagerFactory)).build()</ID>
    <ID>MaxLineLength:SSLHelper.kt$val trustManagers = trustManagerFactory.trustManagers.filterIsInstance(X509ExtendedTrustManager::class.java).map { LoggingTrustManagerWrapper(it) }.toTypedArray()</ID>
    <ID>MaxLineLength:SSLHelper.kt${ val secureHash = SecureHash.sha256(x500Name.toString()) // RFC 1035 specifies a limit 255 bytes for hostnames with each label being 63 bytes or less. Due to this, the string // representation of the SHA256 hash is truncated to 32 characters. return String.format(HOSTNAME_FORMAT, secureHash.toString().take(32).toLowerCase()) }</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$assertEquals("$legalNameHash.corda.net", (sslHandler.engine().sslParameters.serverNames.first() as SNIHostName).asciiName)</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$keyManagerFactory.init(CertificateStore.fromFile(keyStore.path, keyStore.storePassword, keyStore.entryPassword, false))</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$trustManagerFactory.init(initialiseTrustStoreAndEnableCrlChecking(CertificateStore.fromFile(trustStore.path, trustStore.storePassword, trustStore.entryPassword, false), RevocationConfigImpl(RevocationConfig.Mode.HARD_FAIL)))</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$val sslHandler = createClientSslHelper(NetworkHostAndPort("localhost", 1234), setOf(legalName), keyManagerFactory, trustManagerFactory)</ID>
    <ID>MaxLineLength:SampleCashSchemaV1.kt$SampleCashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:SampleCashSchemaV1.kt$SampleCashSchemaV1.PersistentCashState$@Table(name = "contract_cash_states_v1", indexes = [Index(name = "ccy_code_idx1", columnList = "ccy_code"), Index(name = "pennies_idx1", columnList = "pennies")])</ID>
    <ID>MaxLineLength:SampleCashSchemaV2.kt$SampleCashSchemaV2.PersistentCashState$@CollectionTable(name = "cash_states_v2_participants", joinColumns = [JoinColumn(name = "output_index", referencedColumnName = "output_index"), JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id")])</ID>
    <ID>MaxLineLength:SampleCashSchemaV3.kt$SampleCashSchemaV3.PersistentCashState$@CollectionTable(name = "cash_states_v3_participants", joinColumns = [JoinColumn(name = "output_index", referencedColumnName = "output_index"), JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id")])</ID>
    <ID>MaxLineLength:Samplers.kt$CashIssueAndPaySampler$return FlowInvoke&lt;CashIssueAndPaymentFlow&gt;(CashIssueAndPaymentFlow::class.java, arrayOf(amount, OpaqueBytes.of(1), counterParty, useAnonymousIdentities, notaryIdentity))</ID>
    <ID>MaxLineLength:Samplers.kt$CashIssueAndPaySampler$return FlowInvoke&lt;CashIssueAndPaymentNoSelection&gt;(CashIssueAndPaymentNoSelection::class.java, arrayOf(amount, OpaqueBytes.of(1), counterParty, useAnonymousIdentities, notaryIdentity))</ID>
    <ID>MaxLineLength:Samplers.kt$CashIssueAndPaySampler$useAnonymousIdentities = testContext.getParameter(anonymousIdentities.name, anonymousIdentities.value).toBoolean()</ID>
    <ID>MaxLineLength:Samplers.kt$CashIssueAndPaySampler.JMeterProperties$val anonymousIdentities = Argument("anonymousIdentities", "false", "&lt;meta&gt;", "True to use anonymous identities and false (or anything else) to use well known identities.")</ID>
    <ID>MaxLineLength:Samplers.kt$CashIssueAndPaySampler.JMeterProperties$val coinSelection = Argument("useCoinSelection", "false", "&lt;meta&gt;", "True to use coin selection and false (or anything else) to avoid coin selection.")</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler : AbstractSampler</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler$numberOfChangeStatesPerTxCount = testContext.getParameter(numberOfChangeStatesPerTx.name, numberOfChangeStatesPerTx.value).toInt()</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler$return FlowInvoke&lt;CashPaymentFromKnownStatesFlow&gt;(CashPaymentFromKnownStatesFlow::class.java, arrayOf(inputs, numberOfStatesPerTxCount, numberOfChangeStatesPerTxCount, amount, counterParty, useAnonymousIdentities))</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler$useAnonymousIdentities = testContext.getParameter(anonymousIdentities.name, anonymousIdentities.value).toBoolean()</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler$val flowInvoke = FlowInvoke&lt;CashIssueFlow&gt;(CashIssueFlow::class.java, arrayOf(amount, OpaqueBytes.of(1), notaryIdentity))</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler.JMeterProperties$val anonymousIdentities = Argument("anonymousIdentities", "false", "&lt;meta&gt;", "True to use anonymous identities and false (or anything else) to use well known identities.")</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler.JMeterProperties$val numberOfChangeStatesPerTx = Argument("numberOfChangeStatesPerTx", "1", "&lt;meta&gt;", "The number of change states per transaction.")</ID>
    <ID>MaxLineLength:Samplers.kt$CashPaySampler.JMeterProperties$val numberOfStatesPerTx = Argument("numberOfStatesPerTx", "1", "&lt;meta&gt;", "The number of payment states per transaction.")</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler : AbstractSampler</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler$override</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler$override val additionalArgs: Set&lt;Argument&gt; = setOf(notary, numberOfStates, numberOfIterations, logIterations, numberOfTps, repeat)</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler$result.sampleLabel = if (!topLevelSample.isSuccessful) "${topLevelSample.sampleLabel}-$currentIteration" else "${topLevelSample.sampleLabel}-END"</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler$return FlowInvoke&lt;LinearStateBatchNotariseFlow&gt;(LinearStateBatchNotariseFlow::class.java, arrayOf(notaryIdentity, n, x, log, tps))</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler$val result = SampleResult(measurement.end.toEpochMilli(), measurement.end.toEpochMilli() - measurement.start.toEpochMilli())</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler.JMeterProperties$val logIterations = Argument("enableLog", "false", "&lt;meta&gt;", "Print in the logs what iteration the test is on etc.")</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler.JMeterProperties$val numberOfIterations = Argument("numIterations", "1", "&lt;meta&gt;", "Number of iterations / evolutions to do. Each iteration generates one transaction.")</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler.JMeterProperties$val numberOfStates = Argument("numStates", "1", "&lt;meta&gt;", "Number of linear states to include in each transaction.")</ID>
    <ID>MaxLineLength:Samplers.kt$LinearStateBatchNotariseSampler.JMeterProperties$val repeat = Argument("repeatInvoke", "false", "&lt;meta&gt;", "If true, invoke the flow again if JMeter expects more iterations.")</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler : AbstractSampler</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler$FlowInvoke&lt;CashPaymentFromKnownStatesFlow&gt;(CashPaymentFromKnownStatesFlow::class.java, arrayOf(inputs, numberOfStatesPerTxCount, numberOfChangeStatesPerTxCount, amount, mainCounterParty, useAnonymousIdentities))</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler$FlowInvoke&lt;CashPaymentFromKnownStatesFlow&gt;(CashPaymentFromKnownStatesFlow::class.java, arrayOf(inputs, numberOfStatesPerTxCount, numberOfChangeStatesPerTxCount, amount, otherCounterParty, useAnonymousIdentities))</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler$get() = setOf(notary, counterParty1, counterParty2, numberOfStatesPerTx, numberOfChangeStatesPerTx, anonymousIdentities, txToResolve)</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler$numberOfChangeStatesPerTxCount = testContext.getParameter(numberOfChangeStatesPerTx.name, numberOfChangeStatesPerTx.value).toInt()</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler$useAnonymousIdentities = testContext.getParameter(anonymousIdentities.name, anonymousIdentities.value).toBoolean()</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler$val flowInvoke = FlowInvoke&lt;CashIssueFlow&gt;(CashIssueFlow::class.java, arrayOf(amount, OpaqueBytes.of(1), notaryIdentity))</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler.JMeterProperties$val anonymousIdentities = Argument("anonymousIdentities", "false", "&lt;meta&gt;", "True to use anonymous identities and false (or anything else) to use well known identities.")</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler.JMeterProperties$val counterParty1 = Argument("counterParty1Name", "", "&lt;meta&gt;", "The X500 name of the payee for the bulk of the txs.")</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler.JMeterProperties$val counterParty2 = Argument("counterParty2Name", "", "&lt;meta&gt;", "The X500 name of the payee having to resolve the tx chain.")</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler.JMeterProperties$val numberOfChangeStatesPerTx = Argument("numberOfChangeStatesPerTx", "1", "&lt;meta&gt;", "The number of change states per transaction.")</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler.JMeterProperties$val numberOfStatesPerTx = Argument("numberOfStatesPerTx", "1", "&lt;meta&gt;", "The number of payment states per transaction.")</ID>
    <ID>MaxLineLength:Samplers.kt$TxResolutionSampler.JMeterProperties$val txToResolve = Argument("numberOfTxToResolve", "1000", "&lt;meta&gt;", "The number of payments flows to run with counterparty 1 before paying counterparty 2.")</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver$val scheduledAt = sandbox { producedState.nextScheduledActivity(produced.ref, FlowLogicRefFactory)?.scheduledAt } ?: return</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver.Companion$@JvmStatic fun install(vaultService: VaultService, schedulerService: SchedulerService, flowLogicRefFactory: FlowLogicRefFactory)</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver.Companion$consumed.forEach { if (it.state.data is SchedulableState) schedulerService.unscheduleStateActivity(it.ref) }</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow : FlowLogic</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$finalBuilder.addOutputState(SchedulingContract.FailedCheckState(state.linearId, state.participants), SchedulingContract.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$finalBuilder.addOutputState(SchedulingContract.SuccessfulCheckState(state.linearId, state.participants, successTime), SchedulingContract.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$log.info("${state.target} Waiting for previous flows since $earliestStartTime ${formatLastSuccess(lastSuccessTime)}")</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$log.info("${state.target}: Check failed in ${Duration.between(runningState.startTime, failTime).toHumanReadable()} ${formatLastSuccess(lastSuccessTime)} Failure: ${e}")</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$log.info("${state.target}: Check successful in ${Duration.between(runningState.startTime, successTime).toHumanReadable()}")</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$log.info("${state.target}: Checks in flight: ${statesToCheck.size} Running for: ${duration.toHumanReadable()}.")</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow$monitoringService.also { it.metrics.timer(Metrics.maxInflightTime(prefix)).update(duration.seconds, TimeUnit.SECONDS) }</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow.Companion$LatestStates</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow.Companion$private</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow.Companion$val criteria = QueryCriteria.LinearStateQueryCriteria(linearId = idsToCheck, status = Vault.StateStatus.UNCONSUMED)</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow.Companion$val statesToCheck = vaultService.queryBy&lt;SchedulingContract.RunningCheckState&gt;(criteria).states.map { it.state.data }</ID>
    <ID>MaxLineLength:ScheduledCheckFlow.kt$ScheduledCheckFlow.Companion$val statesToCheck = vaultService.queryBy&lt;SchedulingContract.SuccessfulCheckState&gt;(criteria).states.map { it.state.data }</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, cordappWithPackages("net.corda.testMessage"), enclosedCordapp())</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val (alice, bob) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow()</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val N = 23 val rpcUser = User("admin", "admin", setOf("ALL")) val (alice, bob) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow() val aliceClient = CordaRPCClient(alice.rpcAddress).start(rpcUser.username, rpcUser.password) val bobClient = CordaRPCClient(bob.rpcAddress).start(rpcUser.username, rpcUser.password) val scheduledFor = Instant.now().plusSeconds(10) val initialiseFutures = mutableListOf&lt;CordaFuture&lt;*&gt;&gt;() for (i in 0 until N) { initialiseFutures.add(aliceClient.proxy.startFlow( ::InsertInitialStateFlow, bob.nodeInfo.legalIdentities.first(), defaultNotaryIdentity, i, scheduledFor ).returnValue) initialiseFutures.add(bobClient.proxy.startFlow( ::InsertInitialStateFlow, alice.nodeInfo.legalIdentities.first(), defaultNotaryIdentity, i + 100, scheduledFor ).returnValue) } initialiseFutures.getOrThrowAll() val spendAttemptFutures = mutableListOf&lt;CordaFuture&lt;*&gt;&gt;() for (i in (0 until N).reversed()) { spendAttemptFutures.add(aliceClient.proxy.startFlow(::AnotherFlow, (i).toString()).returnValue) spendAttemptFutures.add(bobClient.proxy.startFlow(::AnotherFlow, (i + 100).toString()).returnValue) } spendAttemptFutures.getOrThrowAll() // TODO: the queries below are not atomic so we need to allow enough time for the scheduler to finish. Would be better to query scheduler. Thread.sleep(20.seconds.toMillis()) val aliceStates = aliceClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed } val aliceSpentStates = aliceClient.proxy.vaultQuery(SpentState::class.java).states val bobStates = bobClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed } val bobSpentStates = bobClient.proxy.vaultQuery(SpentState::class.java).states assertEquals(aliceStates.count() + aliceSpentStates.count(), N * 2) assertEquals(bobStates.count() + bobSpentStates.count(), N * 2) assertEquals(aliceSpentStates.count(), bobSpentStates.count())</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val aliceStates = aliceClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed }</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val bobStates = bobClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed }</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests.AnotherFlow$val results = serviceHub.vaultService.queryBy&lt;ScheduledState&gt;(QueryCriteria.LinearStateQueryCriteria(externalId = ImmutableList.of(identity)))</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests$mockNet = InternalMockNetwork(cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()), threadPerNode = true)</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests.Companion$val SORTING = Sort(listOf(Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF_TXN_ID), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests.ScheduledState$override</ID>
    <ID>MaxLineLength:ScheduledFlowTests.kt$ScheduledFlowTests.ScheduledState$override val linearId: UniqueIdentifier = UniqueIdentifier()</ID>
    <ID>MaxLineLength:ScheduledFlowsDrainingModeTest.kt$ScheduledFlowsDrainingModeTest.ScheduledState$override</ID>
    <ID>MaxLineLength:ScheduledFlowsDrainingModeTest.kt$ScheduledFlowsDrainingModeTest.ScheduledState$override val linearId: UniqueIdentifier = UniqueIdentifier()</ID>
    <ID>MaxLineLength:ScheduledState.kt$ScheduledState$override</ID>
    <ID>MaxLineLength:ScheduledState.kt$ScheduledState$override val linearId: UniqueIdentifier = UniqueIdentifier(externalId = identity)</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract$AbandonedCheckState : LinearState</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract$FailedCheckState : LinearState</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract$ScheduledCheckState : SchedulableStateLinearState</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract$SuccessfulCheckState : LinearState</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract.AbandonedCheckState$data</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract.FailedCheckState$data</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract.RunningCheckState$data</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract.ScheduledCheckState$override</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract.ScheduledCheckState$val logicRef = flowLogicRefFactory.create(ScheduledCheckFlow::class.jvmName, thisStateRef, waitTimeSeconds, waitForOutstandingFlowsSeconds)</ID>
    <ID>MaxLineLength:SchedulingContract.kt$SchedulingContract.SuccessfulCheckState$data</ID>
    <ID>MaxLineLength:Schema.kt$ClassSchema$superclass: Schema? = null</ID>
    <ID>MaxLineLength:Schema.kt$CompositeType.Companion$return CompositeType(list[0] as String, list[1] as? String, uncheckedCast(list[2]), list[3] as Descriptor, uncheckedCast(list[4]))</ID>
    <ID>MaxLineLength:Schema.kt$CompositeType.Companion$return newInstance(listOf(list[0], list[1], list[2], Descriptor.get(list[3]!!), (list[4] as List&lt;*&gt;).map { Field.get(it!!) }))</ID>
    <ID>MaxLineLength:Schema.kt$Field.Companion$return Field(list[0] as String, list[1] as String, uncheckedCast(list[2]), list[3] as? String, list[4] as? String, list[5] as Boolean, list[6] as Boolean)</ID>
    <ID>MaxLineLength:Schema.kt$RestrictedType.Companion$return RestrictedType(list[0] as String, list[1] as? String, uncheckedCast(list[2]), list[3] as String, list[4] as Descriptor, uncheckedCast(list[5]))</ID>
    <ID>MaxLineLength:Schema.kt$RestrictedType.Companion$return newInstance(listOf(list[0], list[1], list[2], list[3], Descriptor.get(list[4]!!), (list[5] as List&lt;*&gt;).map { Choice.get(it!!) }))</ID>
    <ID>MaxLineLength:Schema.kt$Schema$internal</ID>
    <ID>MaxLineLength:Schema.kt$Schema$override</ID>
    <ID>MaxLineLength:Schema.kt$Schema$return properties.asSequence().map { it.key to it.describe(configuration, serialiseValue, options) }.filter { it.second != null }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$throw IllegalArgumentException("More than one property was found for keys ${invalid.keys.joinToString(", ", "[", "]")}.")</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val invalid = properties.groupBy(Configuration.Property.Definition&lt;*&gt;::key).mapValues { entry -&gt; entry.value.size }.filterValues { propertiesForKey -&gt; propertiesForKey &gt; 1 }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val nestedProperties = (properties + properties.flatMap { it.schema?.properties ?: emptySet() }).asSequence().distinctBy(Configuration.Property.Definition&lt;*&gt;::schema)</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val root = properties.asSequence().map { it.key to ConfigValueFactory.fromAnyRef(it.typeName) }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Schema.kt$fun typeDescriptorFor(typeId: TypeIdentifier): Symbol</ID>
    <ID>MaxLineLength:Schema.kt$return if (obj == null || obj is DescribedType || obj is Binary || forGenericType(type).run { isPrimitive(this) || this == TopType }) { obj } else { /** * This must be a primitive [obj] that has a non-primitive [type]. * Rewrap it with the required descriptor for further deserialization. */ RedescribedType(typeDescriptorFor(type), obj) }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$CheckpointsException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$CheckpointsException$"This is dangerous because the node might not be able to restore the flows correctly and could consequently fail. "</ID>
    <ID>MaxLineLength:SchemaMigration.kt$DatabaseIncompatibleException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$DatabaseIncompatibleException.Companion$fun errorMessageFor(reason: String): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$MissingMigrationException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$MissingMigrationException.Companion$fun errorMessageFor(mappedSchema: MappedSchema): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$OutstandingDatabaseChangesException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$OutstandingDatabaseChangesException.Companion$fun errorMessageFor(count: Int): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$ fun runMigration(existingCheckpoints: Boolean, statusLogger: Logger? = null)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CashSchemaV1" || mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CommercialPaperSchemaV1") &amp;&amp; mappedSchema.migrationResource == null -&gt; null</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(run &amp;&amp; !check) &amp;&amp; (shouldBlockOnCheckpoints &amp;&amp; existingCheckpoints!!) -&gt; throw CheckpointsException()</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$// Collect all changelog file referenced in the included schemas. // For backward compatibility reasons, when failOnMigrationMissing=false, we don't manage CorDapps via Liquibase but use the hibernate hbm2ddl=update. val changelogList = schemas.mapNotNull { mappedSchema -&gt; val resource = getMigrationResource(mappedSchema, classLoader) when { resource != null -&gt; resource // Corda OS FinanceApp in v3 has no Liquibase script, so no error is raised (mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CashSchemaV1" || mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CommercialPaperSchemaV1") &amp;&amp; mappedSchema.migrationResource == null -&gt; null else -&gt; throw MissingMigrationException(mappedSchema) } } val path = currentDirectory?.toString() if (path != null) { System.setProperty(NODE_BASE_DIR_KEY, path) // base dir for any custom change set which may need to load a file (currently AttachmentVersionNumberMigration) } if (ourName != null) { System.setProperty(NODE_X500_NAME, ourName.toString()) } val customResourceAccessor = CustomResourceAccessor(dynamicInclude, changelogList, classLoader) checkResourcesInClassPath(changelogList) // current version of Liquibase appears to be non-threadsafe // this is apparent when multiple in-process nodes are all running migrations simultaneously mutex.withLock { val liquibase = Liquibase(dynamicInclude, customResourceAccessor, getLiquibaseDatabase(JdbcConnection(connection))) val schemaName: String? = databaseConfig.schema if (!schemaName.isNullOrBlank()) { if (liquibase.database.defaultSchemaName != schemaName) { logger.debug("defaultSchemaName=${liquibase.database.defaultSchemaName} changed to $schemaName") liquibase.database.defaultSchemaName = schemaName } if (liquibase.database.liquibaseSchemaName != schemaName) { logger.debug("liquibaseSchemaName=${liquibase.database.liquibaseSchemaName} changed to $schemaName") liquibase.database.liquibaseSchemaName = schemaName } } logger.info("defaultSchemaName=${liquibase.database.defaultSchemaName}") logger.info("liquibaseSchemaName=${liquibase.database.liquibaseSchemaName}") logger.info("outputDefaultSchema=${liquibase.database.outputDefaultSchema}") val unRunChanges = liquibase.listUnrunChangeSets(Contexts(), LabelExpression()) // When migrating between Corda versions, it's possible that changes may be made that invalidates the contents of the checkpoint // table. If there are any checkpoint entries in this case, then prevent the migration occurring. Note however that this should // not happen in all cases. Apps may also provide migrations, and blocking these may prevent a finalized transaction from // being recovered from a checkpoint, if the migration is provided by a jar that also provides the contract for that // transaction's states. val shouldBlockOnCheckpoints = unRunChanges.any { it.id == "modify checkpoint_value column type" || // Changes the checkpoint blob type in the database it.id == "nullability" || // Changes column constraint on checkpoint table it.id == "column_host_name" || // Node was previously running version prior to ENT3.2 it.id == "create-external-id-to-state-party-view" // Node was previously running a version prior to ENT4.0 } if (unRunChanges.isNotEmpty()) { statusLogger?.info("Changesets to run: ${unRunChanges.size} (${unRunChanges.joinToString(limit = 3)})") } else { statusLogger?.info("Database is up to date.") } when { (run &amp;&amp; !check) &amp;&amp; (shouldBlockOnCheckpoints &amp;&amp; existingCheckpoints!!) -&gt; throw CheckpointsException() // Do not allow database migration when there are checkpoints run &amp;&amp; !check -&gt; liquibase.update(Contexts()) check &amp;&amp; !run &amp;&amp; unRunChanges.isNotEmpty() -&gt; throw OutstandingDatabaseChangesException(unRunChanges.size) check &amp;&amp; !run -&gt; {} // Do nothing will be interpreted as "check succeeded" (outputWriter != null) &amp;&amp; !check &amp;&amp; !run -&gt; { System.setProperty(DRY_RUN, "true") // Enterprise only: disable VaultSchemaMigration for dry-run liquibase.update(Contexts(), outputWriter) } else -&gt; throw IllegalStateException("Invalid usage.") } }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$LockServiceFactory.getInstance().getLockService(getLiquibaseDatabase(JdbcConnection(connection))).forceReleaseLock()</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$System.setProperty(NODE_BASE_DIR_KEY, path)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$check &amp;&amp; !run &amp;&amp; unRunChanges.isNotEmpty() -&gt; throw OutstandingDatabaseChangesException(unRunChanges.size)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.execute("SELECT COUNT(*) FROM DATABASECHANGELOG WHERE FILENAME IN ('migration/cash.changelog-init.xml','migration/commercial-paper.changelog-init.xml')")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.id == "column_host_name"</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.id == "create-external-id-to-state-party-view"</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.id == "modify checkpoint_value column type"</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.id == "nullability"</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$logger.debug("liquibaseSchemaName=${liquibase.database.liquibaseSchemaName} changed to $schemaName")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$statusLogger?.info("Changesets to run: ${unRunChanges.size} (${unRunChanges.joinToString(limit = 3)})")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$throw DatabaseMigrationException("Could not find Liquibase database migration script $resource. Please ensure the jar file containing it is deployed in the cordapps directory.")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val (isExistingDBWithoutLiquibase, isFinanceAppWithLiquibaseNotMigrated, migrationFromV3_2) = dataSource.connection.use { val existingDatabase = it.metaData.getTables(null, null, "NODE%", null).next() val hasLiquibase = it.metaData.getTables(null, null, "DATABASECHANGELOG%", null).next() val isFinanceAppWithLiquibaseNotMigrated = isFinanceAppWithLiquibase // If Finance App is pre v4.0 then no need to migrate it so no need to check. &amp;&amp; existingDatabase &amp;&amp; (!hasLiquibase // Migrate as other tables. || (hasLiquibase &amp;&amp; it.createStatement().use { noLiquibaseEntryLogForFinanceApp(it) })) // If Liquibase is already in the database check if Finance App schema log is missing. // Enterprise only: the patch v3.2 baseline differs from v3.0 release val migrationFromV3_2 = existingDatabase &amp;&amp; !hasLiquibase &amp;&amp; it.metaData.getColumns(null, null, "NODE_INFO_HOSTS", "HOST_NAME").next() Triple(existingDatabase &amp;&amp; !hasLiquibase, isFinanceAppWithLiquibaseNotMigrated, migrationFromV3_2) }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val dynamicInclude = "master.changelog.json" // Virtual file name of the changelog that includes all schemas.</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val isFinanceAppWithLiquibaseNotMigrated = isFinanceAppWithLiquibase // If Finance App is pre v4.0 then no need to migrate it so no need to check. &amp;&amp; existingDatabase &amp;&amp; (!hasLiquibase // Migrate as other tables. || (hasLiquibase &amp;&amp; it.createStatement().use { noLiquibaseEntryLogForFinanceApp(it) })) // If Liquibase is already in the database check if Finance App schema log is missing.</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val liquibase = Liquibase(dynamicInclude, customResourceAccessor, getLiquibaseDatabase(JdbcConnection(connection)))</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val liquibase = Liquibase(dynamicInclude, customResourceAccessor, getLiquibaseDatabase(JdbcConnection(connection))) val schemaName: String? = databaseConfig.schema if (!schemaName.isNullOrBlank()) { if (liquibase.database.defaultSchemaName != schemaName) { logger.debug("defaultSchemaName=${liquibase.database.defaultSchemaName} changed to $schemaName") liquibase.database.defaultSchemaName = schemaName } if (liquibase.database.liquibaseSchemaName != schemaName) { logger.debug("liquibaseSchemaName=${liquibase.database.liquibaseSchemaName} changed to $schemaName") liquibase.database.liquibaseSchemaName = schemaName } } logger.info("defaultSchemaName=${liquibase.database.defaultSchemaName}") logger.info("liquibaseSchemaName=${liquibase.database.liquibaseSchemaName}") logger.info("outputDefaultSchema=${liquibase.database.outputDefaultSchema}") val unRunChanges = liquibase.listUnrunChangeSets(Contexts(), LabelExpression()) // When migrating between Corda versions, it's possible that changes may be made that invalidates the contents of the checkpoint // table. If there are any checkpoint entries in this case, then prevent the migration occurring. Note however that this should // not happen in all cases. Apps may also provide migrations, and blocking these may prevent a finalized transaction from // being recovered from a checkpoint, if the migration is provided by a jar that also provides the contract for that // transaction's states. val shouldBlockOnCheckpoints = unRunChanges.any { it.id == "modify checkpoint_value column type" || // Changes the checkpoint blob type in the database it.id == "nullability" || // Changes column constraint on checkpoint table it.id == "column_host_name" || // Node was previously running version prior to ENT3.2 it.id == "create-external-id-to-state-party-view" // Node was previously running a version prior to ENT4.0 } if (unRunChanges.isNotEmpty()) { statusLogger?.info("Changesets to run: ${unRunChanges.size} (${unRunChanges.joinToString(limit = 3)})") } else { statusLogger?.info("Database is up to date.") } when { (run &amp;&amp; !check) &amp;&amp; (shouldBlockOnCheckpoints &amp;&amp; existingCheckpoints!!) -&gt; throw CheckpointsException() // Do not allow database migration when there are checkpoints run &amp;&amp; !check -&gt; liquibase.update(Contexts()) check &amp;&amp; !run &amp;&amp; unRunChanges.isNotEmpty() -&gt; throw OutstandingDatabaseChangesException(unRunChanges.size) check &amp;&amp; !run -&gt; {} // Do nothing will be interpreted as "check succeeded" (outputWriter != null) &amp;&amp; !check &amp;&amp; !run -&gt; { System.setProperty(DRY_RUN, "true") // Enterprise only: disable VaultSchemaMigration for dry-run liquibase.update(Contexts(), outputWriter) } else -&gt; throw IllegalStateException("Invalid usage.") }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val migrationFromV3_2 = existingDatabase &amp;&amp; !hasLiquibase &amp;&amp; it.metaData.getColumns(null, null, "NODE_INFO_HOSTS", "HOST_NAME").next()</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$||</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration.CustomResourceAccessor$private</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration.CustomResourceAccessor$val includeAllFiles = mapOf("databaseChangeLog" to changelogList.filter { it != null }.map { file -&gt; mapOf("include" to mapOf("file" to file)) })</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration.PostgresDatabaseFixed$// For PostgreSQL if a schema name has uppercase or lowercase characters only then Liquibase would add it to generated query // without double quotes and effectively make them lowercase. This is inconsistent with Corda which wraps schema name for PostgreSQL in double quotes. // The overridden method ensures Liquibase wraps schema name into double quotes. override fun mustQuoteObjectName(objectName: String, objectType: Class&lt;out DatabaseObject&gt;?): Boolean</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$DummyTestSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$it.createStatement().executeQuery("select count(*) from DATABASECHANGELOG where filename ='migration/$fileName'")</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$return createCordaPersistence(databaseConfig, { null }, { null }, schemaService, TestingNamedCacheFactory(), null).apply { startHikariPool(hikariProperties, databaseConfig, schemaService.schemaOptions.keys, ourName = TestIdentity(ALICE_NAME, 70).name) }</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$startHikariPool(hikariProperties, databaseConfig, schemaService.schemaOptions.keys, ourName = TestIdentity(ALICE_NAME, 70).name)</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$val db = configureDatabase(dataSourceProps, DatabaseConfig(runMigration = true), NodeSchemaService(extraSchemas = setOf(DummyTestSchemaV1)))</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$val fileName = MigrationExporter(tmpFolder, dataSourceProps, Thread.currentThread().contextClassLoader, HikariDataSource(HikariConfig(dataSourceProps))) .generateMigrationForCorDapp(DummyTestSchemaV1).second.fileName</ID>
    <ID>MaxLineLength:SchemaMigrationTest.kt$SchemaMigrationTest$val value = this.session.createNativeQuery("SELECT NEXT VALUE FOR hibernate_sequence").uniqueResult() as BigInteger</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$assertThat(descriptionObj.getAnyRef("prop3.prop5")).isEqualTo(Configuration.Property.Definition.SENSITIVE_DATA_PLACEHOLDER)</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$assertThat(obj.toConfig().getString("prop5")).isEqualTo(Configuration.Property.Definition.SENSITIVE_DATA_PLACEHOLDER)</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties(name = "Bar") { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties(name = "Bar") { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema).list()) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val configuration = configObject(prop1 to prop1Value, prop2 to prop2Value, prop3 to prop3Value, "prop4" to "value4").toConfig()</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val fooConfigSchema = Configuration.Schema.withProperties(name = "Foo") { setOf(boolean("prop4"), double("prop5")) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val fooConfigSchema = Configuration.Schema.withProperties(name = "Foo") { setOf(boolean("prop4"), string("prop5", sensitive = true)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val prop3Value = ConfigValueFactory.fromIterable(listOf(configObject(prop4 to prop4Value, prop5 to prop5Value), configObject(prop4 to prop4Value, prop5 to prop5Value)))</ID>
    <ID>MaxLineLength:SearchField.kt$SearchField${ clearButton.setOnMouseClicked { event: MouseEvent -&gt; if (event.button == MouseButton.PRIMARY) { textField.clear() } } searchCategory.items = filterCriteria.map { it.first }.observable() searchCategory.items.add(0, ALL) searchCategory.value = ALL val search = FontAwesomeIconView(FontAwesomeIcon.SEARCH) searchCategory.buttonCell = object : ListCell&lt;String&gt;() { override fun updateItem(item: String?, empty: Boolean) { super.updateItem(item, empty) setText(item) setGraphic(search) setAlignment(Pos.CENTER) } } // TODO : find a way to replace these magic numbers. textField.paddingProperty().bind(searchCategory.widthProperty().map { Insets(5.0, 5.0, 5.0, it.toDouble() + 10) }) textField.promptTextProperty().bind(searchCategory.valueProperty().map { val category = if (it == ALL) { filterCriteria.joinToString(", ") { it.first.toLowerCase() } } else { it.toLowerCase() } "Filter by $category." }) textField.visibleProperty().bind(searchCategory.valueProperty().map { it !in disabledFields }) // TODO Maybe it will be better to replace these categories with comboBox? For example Result with choice: succes, in progress, error. }</ID>
    <ID>MaxLineLength:SearchField.kt$SearchField${ val text = textField.text val category = searchCategory.value data.filtered { data -&gt; (text.isNullOrBlank() &amp;&amp; textField.isVisible) || if (category == ALL) { filterCriteria.any { it.second(data, text) } } else { filterCriteria.toMap()[category]?.invoke(data, text) == true } } }</ID>
    <ID>MaxLineLength:SecureArtemisConfiguration.kt$SecureArtemisConfiguration${ // Artemis allows multiple servers to be grouped together into a cluster for load balancing purposes. The cluster // user is used for connecting the nodes together. It has super-user privileges and so it's imperative that its // password be changed from the default (as warned in the docs). Since we don't need this feature we turn it off // by having its password be an unknown securely random 128-bit value. clusterPassword = BigInteger(128, newSecureRandom()).toString(16) }</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$ @JvmStatic fun parse(str: String?): SHA256</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$else -&gt; throw IllegalArgumentException("Provided string is ${it.size} bytes not 32 bytes in hex: $str")</ID>
    <ID>MaxLineLength:SelfIssueTest.kt$diffString += "${node.propertyPath}: simulated[${node.canonicalGet(previousState.vaultsSelfIssued)}], actual[${node.canonicalGet(selfIssueVaults)}]\n"</ID>
    <ID>MaxLineLength:SellerFlow.kt$SellerFlow$serviceHub.vaultService.queryBy(CommercialPaper.State::class.java) .states</ID>
    <ID>MaxLineLength:SellerFlow.kt$SellerFlow.Companion$SELF_ISSUING : Step</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$@Suspendable protected open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction))</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow${ // The first payload will be the transaction data, subsequent payload will be the transaction/attachment/network parameters data. var payload = payload // Depending on who called this flow, the type of the initial payload is different. // The authorisation logic is to maintain a dynamic list of transactions that the caller is authorised to make based on the transactions that were made already. // Each time an authorised transaction is requested, the input transactions are added to the list. // Once a transaction has been requested, it will be removed from the authorised list. This means that it is a protocol violation to request a transaction twice. val authorisedTransactions = when (payload) { is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction)) is SignedTransaction -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload)) is RetrieveAnyTransactionPayload -&gt; TransactionAuthorisationFilter(acceptAll = true) is List&lt;*&gt; -&gt; TransactionAuthorisationFilter().addAuthorised(payload.flatMap { stateAndRef -&gt; if (stateAndRef is StateAndRef&lt;*&gt;) { getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash } else { throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?") } }.toSet()) else -&gt; throw Exception("Unknown payload type: ${payload::class.java} ?") } // This loop will receive [FetchDataFlow.Request] continuously until the `otherSideSession` has all the data they need // to resolve the transaction, a [FetchDataFlow.EndRequest] will be sent from the `otherSideSession` to indicate end of // data request. while (true) { val dataRequest = sendPayloadAndReceiveDataRequest(otherSideSession, payload).unwrap { request -&gt; when (request) { is FetchDataFlow.Request.Data -&gt; { // Security TODO: Check for abnormally large or malformed data requests verifyDataRequest(request) request } FetchDataFlow.Request.End -&gt; return null } } payload = when (dataRequest.dataType) { FetchDataFlow.DataType.TRANSACTION -&gt; dataRequest.hashes.map { txId -&gt; if (!authorisedTransactions.isAuthorised(txId)) { throw FetchDataFlow.IllegalTransactionRequest(txId) } val tx = serviceHub.validatedTransactions.getTransaction(txId) ?: throw FetchDataFlow.HashNotFound(txId) authorisedTransactions.removeAuthorised(tx.id) authorisedTransactions.addAuthorised(getInputTransactions(tx)) tx } FetchDataFlow.DataType.ATTACHMENT -&gt; dataRequest.hashes.map { serviceHub.attachments.openAttachment(it)?.open()?.readFully() ?: throw FetchDataFlow.HashNotFound(it) } FetchDataFlow.DataType.PARAMETERS -&gt; dataRequest.hashes.map { (serviceHub.networkParametersService as NetworkParametersStorage).lookupSigned(it) ?: throw FetchDataFlow.MissingNetworkParameters(it) } } } }</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow.TransactionAuthorisationFilter$private</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow$open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendTransactionFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:SerDeserCarpentryTest.kt$SerDeserCarpentryTest$val data = readTestResource().deserialize&lt;AInterface&gt;(context = SerializationFactory.defaultFactory.defaultContext.withLenientCarpenter())</ID>
    <ID>MaxLineLength:SerializationAPI.kt$@DeleteForDJVM inline</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$ fun withPreferredSerializationVersion(magic: SerializationMagic): SerializationContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * A whitelist that determines (mostly for security purposes) whether a particular encoding may be used when deserializing. */ val encodingWhitelist: EncodingWhitelist</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * If true the carpenter will happily synthesis classes that implement interfaces containing methods that are not * getters for any AMQP fields. Invoking these methods will throw an [AbstractMethodError]. If false then an exception * will be thrown during deserialization instead. * * The default is false. */ val lenientCarpenterEnabled: Boolean</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationContext$/** * If true the serialization evolver will fail if the binary to be deserialized contains more fields then the current object from * the classpath. * * The default is false. */ val preventDataLoss: Boolean</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$ abstract fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$ fun &lt;T&gt; asCurrent(block: SerializationFactory.() -&gt; T): T</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$/** * A context to use as a default if you do not require a specially configured context. It will be the current context * if the use is somehow nested (see [currentContext]). */ val defaultContext: SerializationContext get() = currentContext ?: effectiveSerializationEnv.p2pContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current context used to start serialization/deserialization. */ val currentContext: SerializationContext? get() = _currentContext.get()</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$abstract</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory.Companion$/** * A default factory for serialization/deserialization, taking into account the [currentFactory] if set. */ val defaultFactory: SerializationFactory get() = currentFactory ?: effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory.Companion$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current factory used to start serialization/deserialization. */ val currentFactory: SerializationFactory? get() = _currentFactory.get()</ID>
    <ID>MaxLineLength:SerializationAPI.kt$context: SerializationContext = serializationFactory.defaultContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$inline</ID>
    <ID>MaxLineLength:SerializationAnnotations.kt$CordaSerializable</ID>
    <ID>MaxLineLength:SerializationCompatibilityTests.kt$SerializationCompatibilityTests$assertThat(factory.get(Exception::class.java).typeDescriptor.toString()).isEqualTo("net.corda:ApZ2a/36VVskaoDZMbiZ8A==")</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$"Expected exactly 1 of {${serializationEnvFields.joinToString(", ") { it.name }}} but got: {${it.joinToString(", ") { it.first }}}"</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$(e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread")</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$private val serializationEnvFields = listOf(_nodeSerializationEnv, _driverSerializationEnv, _contextSerializationEnv, _inheritableContextSerializationEnv)</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>MaxLineLength:SerializationEnvironmentRule.kt$SerializationEnvironmentRule.Companion$Executors.newCachedThreadPool(testThreadFactory(true)) // Close enough to what InVMConnector makes normally.</ID>
    <ID>MaxLineLength:SerializationEnvironmentRule.kt$SerializationEnvironmentRule.Companion$InVMConnector::class.staticField&lt;ExecutorService&gt;("threadPoolExecutor").value</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$ abstract fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$ fun &lt;T&gt; asCurrent(block: SerializationFactory.() -&gt; T): T</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$/** * A context to use as a default if you do not require a specially configured context. It will be the current context * if the use is somehow nested (see [currentContext]). */ val defaultContext: SerializationContext get() = currentContext ?: effectiveSerializationEnv.p2pContext</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current context used to start serialization/deserialization. */ val currentContext: SerializationContext? get() = _currentContext</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$abstract</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory.Companion$/** * A default factory for serialization/deserialization, taking into account the [currentFactory] if set. */ val defaultFactory: SerializationFactory get() = currentFactory ?: effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory.Companion$/** * If there is a need to nest serialization/deserialization with a modified context during serialization or deserialization, * this will return the current factory used to start serialization/deserialization. */ val currentFactory: SerializationFactory? get() = _currentFactory</ID>
    <ID>MaxLineLength:SerializationFormat.kt$FlushAverseOutputStream : OutputStream</ID>
    <ID>MaxLineLength:SerializationFormat.kt$SectionId$DATA_AND_STOP</ID>
    <ID>MaxLineLength:SerializationFormat.kt$SectionId$ENCODING</ID>
    <ID>MaxLineLength:SerializationHelper.kt$CommonPropertyNames</ID>
    <ID>MaxLineLength:SerializationOutput.kt$SerializationOutput$ @Throws(NotSerializableException::class) fun &lt;T : Any&gt; serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>MaxLineLength:SerializationOutput.kt$SerializationOutput$writeObject(obj, data, if (type == TypeIdentifier.UnknownType.getLocalType()) obj.javaClass else type, context, debugIndent)</ID>
    <ID>MaxLineLength:SerializationOutput.kt$SerializationOutput${ serializer.writeObject(obj, data, type, this, context, debugIndent) // Important to do it after serialization such that dependent object will have preceding reference numbers // assigned to them first as they will be first read from the stream on receiving end. // Skip for primitive types as they are too small and overhead of referencing them will be much higher than their content if (serializerFactory.isSuitableForObjectReference(obj.javaClass)) { objectHistory[obj] = objectHistory.size } }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$assertArrayEquals(data, DeserializationInput(factory).deserialize(compressed, testSerializationContext.withEncodingWhitelist(encodingWhitelist)))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$assertThat(des.deserialize(OpaqueBytes(copy), NonZeroByte::class.java, testSerializationContext.withEncodingWhitelist(encodingWhitelist)).value).isEqualTo(3)</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$catchThrowable { input.deserialize(compressed, testSerializationContext.withEncodingWhitelist(encodingWhitelist)) }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$des.deserialize(OpaqueBytes(copy), NonZeroByte::class.java, testSerializationContext.withEncodingWhitelist(encodingWhitelist))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$private</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$return SerializationFactory.defaultFactory.asCurrent { withCurrentContext(newContext) { serdes(t, factory, factory2, expectedEqual) } }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$t.suppressed.zip(desThrowable.suppressed).forEach { (before, after) -&gt; assertSerializedThrowableEquivalent(before, after) }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val crlHolder = builder.build(ContentSignerBuilder.build(Crypto.RSA_SHA256, Crypto.generateKeyPair(Crypto.RSA_SHA256).private, provider))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val desObj2 = des2.deserialize(ser2.serialize(obj, compression), testSerializationContext.withEncodingWhitelist(encodingWhitelist))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val newContext = SerializationFactory.defaultFactory.defaultContext.withProperty(CommonPropertyNames.IncludeInternalInfo, true)</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val obj = WrapFooListArray(arrayOf(listOf(Foo("Fred", 1), Foo("Ginger", 2)), listOf(Foo("Rogers", 3), Foo("Hammerstein", 4))))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests${ val ser = SerializationOutput(SerializerFactoryBuilder.build(AllWhitelist, ClassCarpenterImpl(AllWhitelist, ClassLoader.getSystemClassLoader()) )) val obj = ByteArray(20000) val uncompressedSize = ser.serialize(obj).bytes.size val compressedSize = ser.serialize(obj, CordaSerializationEncoding.SNAPPY).bytes.size // Ordinarily this might be considered high maintenance, but we promised wire compatibility, so they'd better not change! assertEquals(20059, uncompressedSize) assertEquals(1018, compressedSize) }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests.GenericSubclass$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$@KeepForDJVM data</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override fun withEncodingWhitelist(encodingWhitelist: EncodingWhitelist)</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override fun withPreferredSerializationVersion(magic: SerializationMagic)</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override val customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt; = emptySet()</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override val encodingWhitelist: EncodingWhitelist = NullEncodingWhitelist</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$@Throws(NotSerializableException::class) override</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$private</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$private val registeredSchemes: MutableCollection&lt;SerializationScheme&gt; = Collections.synchronizedCollection(mutableListOf())</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$private val schemes: MutableMap&lt;Pair&lt;CordaSerializationMagic, SerializationContext.UseCase&gt;, SerializationScheme&gt;</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$registeredSchemes.filter { it.canDeserializeVersion(magic, target) }.forEach { return@computeIfAbsent it }</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$return asCurrent { withCurrentContext(context) { schemeFor(byteSequence, context.useCase).first.deserialize(byteSequence, clazz, context) } }</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$return asCurrent { withCurrentContext(context) { schemeFor(context.preferredSerializationVersion, context.useCase).first.serialize(obj, context) } }</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken$fun registerWithContext(context: SerializeAsTokenContext, toBeTokenized: SerializeAsToken)</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken.Companion$fun &lt;T : SerializeAsToken&gt; singletonSerializationToken(toBeTokenized: Class&lt;T&gt;)</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializeAsToken : SerializeAsToken</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$context = testCheckpointSerialization.checkpointSerializationContext.withWhitelisted(SingletonSerializationToken::class.java)</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$private fun serializeAsTokenContext(toBeTokenized: Any)</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$val serializedBytes = tokenizableBefore.toToken(serializeAsTokenContext(emptyList&lt;Any&gt;())).checkpointSerialize(testContext)</ID>
    <ID>MaxLineLength:SerializationWhitelist.kt$SerializationWhitelist$/** * Optionally whitelist types for use in object serialization, as we lock down the types that can be serialized. * * For example, if you add a new [net.corda.core.contracts.ContractState] it needs to be whitelisted. You can do that * either by adding the [net.corda.core.serialization.CordaSerializable] annotation or via this method. */ val whitelist: List&lt;Class&lt;*&gt;&gt;</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl : SerializeAsTokenContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl$constructor(toBeTokenized: Any, serializer: CheckpointSerializer, context: CheckpointSerializationContext, serviceHub: ServiceHub) : this(serviceHub, { serializer.serialize(toBeTokenized, context.withTokenContext(this)) })</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl$throw UnsupportedOperationException("Attempt to write token for lazy registered $className. All tokens should be registered during context construction.")</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl : SerializeAsTokenContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl$constructor(toBeTokenized: Any, serializationFactory: SerializationFactory, context: SerializationContext, serviceHub: ServiceHub) : this(serviceHub, { serializationFactory.serialize(toBeTokenized, context.withTokenContext(this)) })</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl$throw UnsupportedOperationException("Attempt to write token for lazy registered $className. All tokens should be registered during context construction.")</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$fun CheckpointSerializationContext.withTokenContext(serializationContext: SerializeAsTokenContext): CheckpointSerializationContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$fun SerializationContext.withTokenContext(serializationContext: SerializeAsTokenContext): SerializationContext</ID>
    <ID>MaxLineLength:SerializeAsTokenSerializer.kt$SerializeAsTokenSerializer$?:</ID>
    <ID>MaxLineLength:SerializerFactoryBuilder.kt$NoEvolutionSerializerFactory$override</ID>
    <ID>MaxLineLength:ServerSNIMatcher.kt$ServerSNIMatcher$log.warn("The requested SNI value [$requestedSNIValue] does not match any of the following known SNI values [$knownSNIValues]")</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun addSignature(signedTransaction: SignedTransaction): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun addSignature(signedTransaction: SignedTransaction, publicKey: PublicKey): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(filteredTransaction: FilteredTransaction): TransactionSignature</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(filteredTransaction: FilteredTransaction, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun createSignature(signedTransaction: SignedTransaction, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$ fun signInitialTransaction(builder: TransactionBuilder, publicKey: PublicKey)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$/** * A network map contains lists of nodes on the network along with information about their identity keys, services * they provide and host names or IP addresses where they can be connected to. The cache wraps around a map fetched * from an authoritative service, and adds easy lookup of the data stored within it. Generally it would be initialised * with a specified network map service, which it fetches data from and then subscribes to updates of. */ val networkMapCache: NetworkMapCache</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(filteredTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(signedTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$private</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$signInitialTransaction(builder, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$val stx = validatedTransactions.getTransaction(stateRef.txhash) ?: throw TransactionResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServicesForResolution$ // TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load // as the existing transaction store will become encrypted at some point @Throws(TransactionResolutionException::class) fun loadStates(stateRefs: Set&lt;StateRef&gt;): Set&lt;StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:ServiceHub.kt$StatesToRecord$ONLY_RELEVANT</ID>
    <ID>MaxLineLength:ServiceHubCoreInternal.kt$ServiceHubCoreInternal : ServiceHub</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal$TopologicalSort</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal$override fun createTransactionsResolver(flow: ResolveTransactionsFlow): TransactionsResolver</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal$txs as? Collection ?: txs.toList()</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.Companion$// Divide transactions into those seen before and those that are new to this node if ALL_VISIBLE states are being recorded. // This allows the node to re-record transactions that have previously only been seen at the ONLY_RELEVANT level. Note that // for transactions being recorded at ONLY_RELEVANT, if this transaction has been seen before its outputs should already // have been recorded at ONLY_RELEVANT, so there shouldn't be anything to re-record here. val (recordedTransactions, previouslySeenTxs) = if (statesToRecord != StatesToRecord.ALL_VISIBLE) { orderedTxs.filter(validatedTransactions::addTransaction) to emptyList() } else { orderedTxs.partition (validatedTransactions::addTransaction) } val stateMachineRunId = FlowStateMachineImpl.currentStateMachine()?.id if (stateMachineRunId != null) { recordedTransactions.forEach { stateMachineRecordedTransactionMapping.addMapping(stateMachineRunId, it.id) } } else { log.warn("Transactions recorded from outside of a state machine") } // When the user has requested StatesToRecord.ALL we may end up recording and relationally mapping states // that do not involve us and that we cannot sign for. This will break coin selection and thus a warning // is present in the documentation for this feature (see the "Observer nodes" tutorial on docs.corda.net). // // The reason for this is three-fold: // // 1) We are putting in place the observer mode feature relatively quickly to meet specific customer // launch target dates. // // 2) The right design for vaults which mix observations and relevant states isn't entirely clear yet. // // 3) If we get the design wrong it could create security problems and business confusions. // // Back in the bitcoinj days I did add support for "watching addresses" to the wallet code, which is the // Bitcoin equivalent of observer nodes: // // https://bitcoinj.github.io/working-with-the-wallet#watching-wallets // // The ability to have a wallet containing both irrelevant and relevant states complicated everything quite // dramatically, even methods as basic as the getBalance() API which required additional modes to let you // query "balance I can spend" vs "balance I am observing". In the end it might have been better to just // require the user to create an entirely separate wallet for observing with. // // In Corda we don't support a single node having multiple vaults (at the time of writing), and it's not // clear that's the right way to go: perhaps adding an "origin" column to the VAULT_STATES table is a better // solution. Then you could select subsets of states depending on where the report came from. // // The risk of doing this is that apps/developers may use 'canned SQL queries' not written by us that forget // to add a WHERE clause for the origin column. Those queries will seem to work most of the time until // they're run on an observer node and mix in irrelevant data. In the worst case this may result in // erroneous data being reported to the user, which could cause security problems. // // Because the primary use case for recording irrelevant states is observer/regulator nodes, who are unlikely // to make writes to the ledger very often or at all, we choose to punt this issue for the time being. vaultService.notifyAll(statesToRecord, recordedTransactions.map { it.coreTransaction }, previouslySeenTxs.map { it.coreTransaction })</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.Companion$vaultService.notifyAll(statesToRecord, recordedTransactions.map { it.coreTransaction }, previouslySeenTxs.map { it.coreTransaction })</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.TopologicalSort$// Note that we use a LinkedHashSet here to make the traversal deterministic (as long as the input list is). forwardGraph.computeIfAbsent(it) { LinkedHashSet() }.add(stx)</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$WritableTransactionStorage$ // TODO: Throw an exception if trying to add a transaction with fewer signatures than an existing entry. fun addTransaction(transaction: SignedTransaction): Boolean</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$WritableTransactionStorage$ fun &lt;T&gt; lockObjectsForWrite(ids: Collection&lt;SecureHash&gt;, dbTx: DatabaseTransaction, writePessimistically: Boolean, block: () -&gt; T): T</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$WritableTransactionStorage$ fun getTransactionInternal(id: SecureHash): Pair&lt;SignedTransaction, Boolean&gt;?</ID>
    <ID>MaxLineLength:ServiceLifecycleSupport.kt$ServiceLifecycleSupport$ fun start()</ID>
    <ID>MaxLineLength:ServiceLifecycleSupport.kt$ServiceStateSupport</ID>
    <ID>MaxLineLength:ServiceLifecycleSupport.kt$ServiceStateSupport$/** * Reads the current dynamic status of the service, which should only become true after the service has been started, * any dynamic resources have been started/registered and any network connections have been completed. * Failure to acquire a resource, or manual stop of the service, should return this to false. */ val active: Boolean</ID>
    <ID>MaxLineLength:ServiceLifecycleSupport.kt$ServiceStateSupport$/** * This Observer signals changes in the [active] variable, it should not be triggered for events that don't flip the [active] state. */ val activeChange: Observable&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:ServiceStateHelper.kt$ServiceStateCombiner : ServiceStateSupport</ID>
    <ID>MaxLineLength:ServiceStateHelper.kt$ServiceStateCombiner$private val _activeChange = Observable.combineLatest(services.map { it.activeChange }, { x -&gt; x.all { y -&gt; y as Boolean } }).serialize().distinctUntilChanged()</ID>
    <ID>MaxLineLength:ServiceStateTest.kt$ServiceStateTest$ServiceAImpl : ServiceAServiceStateSupport</ID>
    <ID>MaxLineLength:ServiceStateTest.kt$ServiceStateTest$ServiceBImpl : ServiceBServiceStateSupport</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$else -&gt; throw UnsupportedOperationException("Attempting to resolve attachment for index ${stateRef.index} of a ${ctx.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$if (attachment is ContractAttachment &amp;&amp; (forContractClassName ?: transactionState.contract) in attachment.allContracts) { return attachment }</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$override</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$return attachments.openAttachment(ctx.upgradedContractAttachmentId) ?: throw AttachmentResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$return ctx.inputs.map { inner(it, transactionState.contract) }.firstOrNull() ?: throw AttachmentResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$val stx = validatedTransactions.getTransaction(stateRef.txhash) ?: throw TransactionResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$val transactionState = SerializedStateAndRef(resolveStateRefBinaryComponent(stateRef, this)!!, stateRef).toStateAndRef().state</ID>
    <ID>MaxLineLength:SessionMessage.kt$ErrorSessionMessage : ExistingSessionMessagePayload</ID>
    <ID>MaxLineLength:SessionRejectException.kt$SessionRejectException$NotRegistered : SessionRejectException</ID>
    <ID>MaxLineLength:SessionRejectException.kt$SessionRejectException$UnknownClass : SessionRejectException</ID>
    <ID>MaxLineLength:SetsSerializationTest.kt$net.corda.serialization.internal.SetsSerializationTest.kt</ID>
    <ID>MaxLineLength:Settings.kt$Settings$clientPane.disableProperty() .map { if (!it) FontAwesomeIconView(FontAwesomeIcon.TIMES) else FontAwesomeIconView(FontAwesomeIcon.EDIT) }</ID>
    <ID>MaxLineLength:SharedMemoryIncremental.kt$SharedMemoryIncremental$file: File = File(System.getProperty("user.home"), "corda-$startPort-to-$endPort-port-allocator.bin")</ID>
    <ID>MaxLineLength:SharedMemoryIncremental.kt$SharedMemoryIncremental$mb = backingFile.channel.map(FileChannel.MapMode.READ_WRITE, 0, 16)</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellCmdLineOptions$description = ["The path to the directory containing CorDapp JARs, CorDapps are required when starting flows."]</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellCmdLineOptions$description = ["The path to the shell configuration file, used instead of providing the rest of command line options."]</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellConfigurationFile.ShellConfigFile$sshHostKeyDirectory = extensions?.sshd?.let { if (it.enabled &amp;&amp; it.hostkeypath != null) Paths.get(it.hostkeypath) else null }</ID>
    <ID>MaxLineLength:ShutdownManager.kt$ShutdownManager${ isShutdown = true val result = ArrayList(registeredShutdowns) // It is important to clear `registeredShutdowns` that has been actioned upon as more than 1 driver can be created per test. // Given that `ShutdownManager` is reachable from `ApplicationShutdownHooks`, everything that was scheduled for shutdown // during 1st driver launch will not be eligible for GC during second driver launch therefore retained in memory. registeredShutdowns.clear() result }</ID>
    <ID>MaxLineLength:SignableData.kt$SignableData</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$"The AutomaticPlaceholderConstraint of the second state should become the same HashConstraint used in other state"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$"The constraint from the issuance transaction should be the same constraint used in the consuming transaction"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `HashConstraint cannot be migrated to SignatureConstraint if a HashConstraint is specified for one state and another uses an AutomaticPlaceholderConstraint`()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$it.proxy.startFlow(::ConsumeMessage, result!!, defaultNotaryIdentity, false, false).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$val nodeHandle = startNode(NodeParameters(rpcUsers = listOf(user), additionalCordapps = listOf(oldCordapp))).getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$var result: StateAndRef&lt;MessageState&gt;? = CordaRPCClient(nodeHandle.rpcAddress).start(user.username, user.password).use { val page = it.proxy.vaultQuery(MessageState::class.java) page.states.singleOrNull() }</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$"The constraint from the issuance transaction should be the same constraint used in the consuming transaction for the first state"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint will only transition states that do not have a constraint specified`()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$Assertions.assertThatExceptionOfType(CordaRuntimeException::class.java).isThrownBy { upgradeCorDappBetweenTransactions( cordapp = oldUnsignedCordapp, newCordapp = newCordapp, whiteListedCordapps = mapOf(TEST_MESSAGE_CONTRACT_PROGRAM_ID to emptyList()), systemProperties = emptyMap(), startNodesInProcess = true ) } .withMessageContaining("Selected output constraint: $WhitelistedByZoneAttachmentConstraint not satisfying")</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$Assume.assumeFalse(System.getProperty("os.name").toLowerCase().startsWith("win"))</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$it.proxy.startFlow(::ConsumeMessage, result!!, defaultNotaryIdentity, false, false).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$val nodeHandle = startNode(NodeParameters(rpcUsers = listOf(user), additionalCordapps = listOf(oldCordapp))).getOrThrow()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$var result: StateAndRef&lt;MessageState&gt;? = CordaRPCClient(nodeHandle.rpcAddress).start(user.username, user.password).use { val page = it.proxy.vaultQuery(MessageState::class.java) page.states.singleOrNull() }</ID>
    <ID>MaxLineLength:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$private</ID>
    <ID>MaxLineLength:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$private val baseUnsigned = cordappWithPackages(MessageState::class.packageName, DummyMessageContract::class.packageName)</ID>
    <ID>MaxLineLength:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$val user = User("mark", "dadada", setOf(startFlow&lt;CreateMessage&gt;(), startFlow&lt;ConsumeMessage&gt;(), invokeRpc("vaultQuery")))</ID>
    <ID>MaxLineLength:SignatureMetadata.kt$SignatureMetadata</ID>
    <ID>MaxLineLength:SignatureScheme.kt$SignatureScheme</ID>
    <ID>MaxLineLength:SignedNodeInfo.kt$NodeInfoAndSigned$constructor(nodeInfo: NodeInfo, signer: (PublicKey, SerializedBytes&lt;NodeInfo&gt;) -&gt; DigitalSignature) : this(nodeInfo, nodeInfo.sign(signer))</ID>
    <ID>MaxLineLength:SignedNodeInfoTest.kt$SignedNodeInfoTest$private</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM fun resolveNotaryChangeTransaction(services: ServiceHub)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM private fun verifyContractUpgradeTransaction(services: ServicesForResolution, checkSufficientSignatures: Boolean)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ @DeleteForDJVM private fun verifyNotaryChangeTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ private fun copyWithCache(sigList: Iterable&lt;TransactionSignature&gt;): SignedTransaction</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR.</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$"""Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |"""</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$(services.transactionVerifierService as TransactionVerifierServiceInternal).verify(ltx, listOf(attachment)).getOrThrow()</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$/** Cache the deserialized form of the transaction. This is useful when building a transaction or collecting signatures. */ @Volatile @Transient private var cachedTransaction: CoreTransaction? = null</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$/** Returns the contained [WireTransaction], or throws if this is a notary change or contract upgrade transaction. */ val tx: WireTransaction get() = coreTransaction as WireTransaction</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$?:</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$@Throws(SignatureException::class, AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$SignaturesMissingException : NamedByHashSignatureExceptionCordaThrowable</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$if (e.cause is NotSerializableException &amp;&amp; e.cause.cause is ClassNotFoundException &amp;&amp; e.cause.cause!!.message != null) { verifyWithExtraDependency(e.cause.cause!!.message!!.replace(".", "/"), ltx, services, e) } else { throw e }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$is FilteredTransaction -&gt; throw IllegalStateException("Persistence of filtered transactions is not supported.")</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$private</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$require(sigs.isNotEmpty()) { "Tried to instantiate a ${SignedTransaction::class.java.simpleName} without any signatures " }</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$throw TransactionVerificationException.TransactionNetworkParameterOrderingException(id, entry.value.first(), txNetworkParameters, params)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction${ // If that transaction was created with and after Corda 4 then just fail. // The lenient dependency verification is only supported for Corda 3 transactions. // To detect if the transaction was created before Corda 4 we check if the transaction has the NetworkParameters component group. if (this.networkParametersHash != null) { throw exception } val attachment = requireNotNull(services.attachments.internalFindTrustedAttachmentForClass(missingClass)) { """Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |""".trimMargin() } log.warn("""Detected that transaction ${this.id} does not contain all cordapp dependencies. |This may be the result of a bug in a previous version of Corda. |Attempting to verify using the additional trusted dependency: $attachment for class $missingClass. |Please check with the originator that this is a valid transaction.""".trimMargin()) (services.transactionVerifierService as TransactionVerifierServiceInternal).verify(ltx, listOf(attachment)).getOrThrow() }</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$ @Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val PVs = OGTrades.map { it.info.id.get().value to pricer.presentValue(it.product, combinedRatesProvider).toCordaCompatible() }.toMap()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val calculatorTotal = RwamBimmNotProductClassesCalculator(fxRateProvider, Currency.EUR, IsdaConfiguration.INSTANCE)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val imBatch = analyticsEngine.calculateMarginBatch(sensBatch, combinedRatesProvider, fxRateProvider, cordaMargin)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val margin = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, sensitivities.first, sensitivities.second)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val portfolio = serviceHub.vaultService.queryBy&lt;IRSState&gt;(VaultQueryCriteria(stateRefs = stateRef.state.data.portfolio)).states.toPortfolio()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val valuer = serviceHub.identityService.wellKnownPartyFromAnonymous(stateRef.state.data.valuer) ?: throw IllegalStateException("Unknown valuer party ${stateRef.state.data.valuer}")</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$notary = serviceHub.networkMapCache.notaryIdentities.first()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$otherPartySession.sendAndReceive&lt;Ack&gt;(OfferMessage(notary, stateAndRef.state.data, existing?.ref, valuationDate))</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val PVs = OGTrades.map { it.info.id.get().value to pricer.presentValue(it.product, combinedRatesProvider).toCordaCompatible() }.toMap()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val calculatorTotal = RwamBimmNotProductClassesCalculator(fxRateProvider, Currency.EUR, IsdaConfiguration.INSTANCE)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val imBatch = analyticsEngine.calculateMarginBatch(sensBatch, combinedRatesProvider, fxRateProvider, cordaMargin)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val margin = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, sensitivities.first, sensitivities.second)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val portfolio = serviceHub.vaultService.queryBy&lt;IRSState&gt;(VaultQueryCriteria(stateRefs = state.portfolio)).states.toPortfolio()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester.StateRevisionFlowRequester$private</ID>
    <ID>MaxLineLength:SimmRevaluation.kt$SimmRevaluation.Initiator$val stateAndRef = serviceHub.vaultService.queryBy&lt;PortfolioState&gt;(VaultQueryCriteria(stateRefs = listOf(curStateRef))).states.single()</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$cordappsForAllNodes = listOf(findCordapp("net.corda.vega.flows"), findCordapp("net.corda.vega.contracts")) + FINANCE_CORDAPPS</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$partyApi.postJson("${counterparty.id}/portfolio/valuations/calculate", PortfolioApi.ValuationCreationParams(valuationDate))</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$startNodesInProcess = false</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$val logConfigFile = projectRootDir / "samples" / "simm-valuation-demo" / "src" / "main" / "resources" / "log4j2.xml"</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$val nodeAApi = HttpApi.fromHostAndPort(nodeAWebServerFuture.getOrThrow().listenAddress, "api/simmvaluationdemo")</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$val nodeBApi = HttpApi.fromHostAndPort(nodeBWebServerFuture.getOrThrow().listenAddress, "api/simmvaluationdemo")</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$valuationDate</ID>
    <ID>MaxLineLength:SimpleMQClient.kt$SimpleMQClient$session = sessionFactory.createSession(username, password, false, true, true, locator.isPreAcknowledge, locator.ackBatchSize)</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$artemisMessage.putStringProperty(P2PMessagingHeaders.bridgedCertificateSubject, SimpleString(inboundMessage.sourceLegalName))</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$auditService.packetDropEvent(inboundMessage, "Packet Failed validation checks: " + ex.message, RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$auditService.packetDropEvent(inboundMessage, "Packet arrived while dependencies down.", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$inboundSession = artemisConnectionService.started!!.sessionFactory.createSession(ArtemisMessagingComponent.NODE_P2P_USER, ArtemisMessagingComponent.NODE_P2P_USER, false, true, true, false, ActiveMQClient.DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$private val statusFollower = ServiceStateCombiner(listOf(auditService, artemisConnectionService, bridgeSenderService))</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$require(inboundMessage.applicationProperties.keys.all { it in whiteListedAMQPHeaders }) { "Disallowed header present in ${inboundMessage.applicationProperties.keys}" }</ID>
    <ID>MaxLineLength:SimpleMessageFilterService.kt$SimpleMessageFilterService$require(validInboxTopic) { "Topic not a legitimate Inbox for a node on this Artemis Broker ${inboundMessage.topic}" }</ID>
    <ID>MaxLineLength:SingleInstanceMasterService.kt$SingleInstanceMasterService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:SinglePartyNotaryService.kt$SinglePartyNotaryService$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ #See https://docs.corda.net/head/testing.html#running-tests-in-intellij - 'Fiber classes not instrumented' for more details.</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ override fun stop(allowedUnsuspendedFiberCount: Int)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$"""Missing the '-javaagent' JVM argument. Make sure you run the tests with the Quasar java agent attached to your JVM. #See https://docs.corda.net/head/testing.html#running-tests-in-intellij - 'Fiber classes not instrumented' for more details."""</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$DataFeed(flows.values.map { it.fiber.logic }, changesPublisher.bufferUntilSubscribed().wrapWithDatabaseTransaction(database))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$changesPublisher.onNext(StateMachineManager.Change.Removed(lastState.flowLogic, Try.Failure&lt;Nothing&gt;(exception)))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$changesPublisher.onNext(StateMachineManager.Change.Removed(lastState.flowLogic, Try.Success(removalReason.flowReturnValue)))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$check(!foundUnrestorableFibers) { "Unrestorable checkpoints were created, please check the logs for details." }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$errorAndTerminate("Caught unrecoverable error from flow. Forcibly terminating the JVM, this might leave resources open, and most likely will.", throwable)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$is ExistingSessionMessage -&gt; onExistingSessionMessage(sessionMessage, event.deduplicationHandler, sender)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$is InitiatedFlowFactory.CorDapp -&gt; FlowInfo(initiatedFlowFactory.flowVersion, initiatedFlowFactory.appName)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.debug { "Ignoring request to set time-out on timed flow $flowId to $timeoutSeconds seconds which is shorter than default of ${serviceHub.configuration.flowTimeout.timeout.seconds} seconds." }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.error("Unable to deserialize checkpoint for flow $flowId. Something is very wrong and this flow will be ignored.", e)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.error("Unable to find database checkpoint for flow $flowId. Something is very wrong. The flow will not retry.")</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private inline</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private val fiberDeserializationChecker = if (serviceHub.configuration.shouldCheckCheckpoints()) FiberDeserializationChecker() else null</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$require(lastState.pendingDeduplicationHandlers.isEmpty()) { "Flow cannot be removed until all pending deduplications have completed" }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$return serviceHub.getFlowFactory(initiatorFlowClass) ?: throw SessionRejectException.NotRegistered(initiatorFlowClass)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$startInitiatedFlow(flowLogic, event.deduplicationHandler, senderSession, initiatedSessionId, sessionMessage, senderCoreFlowVersion, initiatedFlowInfo)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val externalEvents = currentState.pendingDeduplicationHandlers.map { it.externalCause } + unprocessedExternalEvents</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val flowCorDappVersion = createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val flowStart = FlowStart.Initiated(peerSession, initiatedSessionId, initiatingMessage, senderCoreFlowVersion, initiatedFlowInfo)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val frozenFlowLogic = (flowLogic as FlowLogic&lt;*&gt;).checkpointSerialize(context = checkpointSerializationContext!!)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val future = startFlow(event.flowLogic, event.context, ourIdentity = null, deduplicationHandler = event.deduplicationHandler)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val timeoutDelaySeconds = timeout.seconds * Math.pow(backoffBase, min(retryCount, maxRestartCount).toDouble()).toLong()</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager${ // If the node is running as a notary service, we don't retain errored session initiation requests in case of missing Cordapps // to avoid memory leaks if the notary is under heavy load. val isNotary = serviceHub.configuration.notary != null return StaffedFlowHospital(flowMessaging, ourSenderUUID, !isNotary) }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager${ // It may be that the id refers to a checkpoint that couldn't be deserialised into a flow, so we delete it if it exists. database.transaction { checkpointStorage.removeCheckpoint(id) } }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager${ // We intentionally grab the checkpoint from storage rather than relying on the one referenced by currentState. This is so that // we mirror exactly what happens when restarting the node. val serializedCheckpoint = checkpointStorage.getCheckpoint(flowId) if (serializedCheckpoint == null) { logger.error("Unable to find database checkpoint for flow $flowId. Something is very wrong. The flow will not retry.") return } // Resurrect flow createFlowFromCheckpoint( id = flowId, serializedCheckpoint = serializedCheckpoint, initialDeduplicationHandler = null, isAnyCheckpointPersisted = true, isStartIdempotent = false ) ?: return }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager${ val flowId = StateMachineRunId.createRandom() // Before we construct the state machine state by freezing the FlowLogic we need to make sure that lazy properties // have access to the fiber (and thereby the service hub) val flowStateMachineImpl = FlowStateMachineImpl(flowId, flowLogic, scheduler) val resultFuture = openFuture&lt;Any?&gt;() flowStateMachineImpl.transientValues = TransientReference(createTransientValues(flowId, resultFuture)) flowLogic.stateMachine = flowStateMachineImpl val frozenFlowLogic = (flowLogic as FlowLogic&lt;*&gt;).checkpointSerialize(context = checkpointSerializationContext!!) val flowCorDappVersion = createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion) val initialCheckpoint = Checkpoint.create( invocationContext, flowStart, flowLogic.javaClass, frozenFlowLogic, ourIdentity, flowCorDappVersion, flowLogic.isEnabledTimedFlow() ).getOrThrow() val startedFuture = openFuture&lt;Unit&gt;() val initialState = StateMachineState( checkpoint = initialCheckpoint, pendingDeduplicationHandlers = deduplicationHandler?.let { listOf(it) } ?: emptyList(), isFlowResumed = false, isTransactionTracked = false, isAnyCheckpointPersisted = false, isStartIdempotent = isStartIdempotent, isRemoved = false, flowLogic = flowLogic, senderUUID = ourSenderUUID ) flowStateMachineImpl.transientState = TransientReference(initialState) mutex.locked { startedFutures[flowId] = startedFuture } totalStartedFlows.inc() addAndStartFlow(flowId, Flow(flowStateMachineImpl, resultFuture)) return startedFuture.map { flowStateMachineImpl as FlowStateMachine&lt;A&gt; } }</ID>
    <ID>MaxLineLength:SingletonSerializer.kt$SingletonSerializer : AMQPSerializer</ID>
    <ID>MaxLineLength:SingletonSerializer.kt$SingletonSerializer$internal val typeNotation: TypeNotation = RestrictedType(type.typeName, "Singleton", generateProvides(), "boolean", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:SingletonSerializer.kt$SingletonSerializer$override</ID>
    <ID>MaxLineLength:SocksTests.kt$SocksTests$doReturn(EnterpriseConfiguration(MutualExclusionConfiguration(false, "", 20000, 40000))).whenever(it).enterpriseConfiguration</ID>
    <ID>MaxLineLength:SocksTests.kt$SocksTests$val client = ArtemisMessagingClient(artemisConfig.p2pSslOptions, NetworkHostAndPort("localhost", artemisPort), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:SocksTests.kt$SocksTests.&lt;no name provided&gt;$override val proxyConfig: ProxyConfig? = ProxyConfig(ProxyVersion.SOCKS5, NetworkHostAndPort("127.0.0.1", socksPort), null, null)</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override fun withDefaultValue(defaultValue: TYPE): PropertyDelegate&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String?, prefix: String?, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun boolean(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun double(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun duration(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun float(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun int(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun long(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun nestedObject(schema: Configuration.Schema?, key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun string(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Optional$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Optional&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Required$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Required&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.RequiredList&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Single$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Single&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Standard&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun list(): PropertyDelegate.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Standard&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl.&lt;no name provided&gt;$override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Configuration.Property.Definition.Required&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$assertThat(result.errors.first())</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$assertThat(rpcSettings.errors.first())</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:${principalAddressValue.port}", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:-10", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.&lt;no name provided&gt;$override fun parseValid(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec$override fun parseValid(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec.AddressesSpec$override fun parseValid(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec.AddressesSpec$return Address.validFromRawValue(rawValue) { error -&gt; Configuration.Validation.Error.BadValue.of(error) }</ID>
    <ID>MaxLineLength:SpringDriver.kt$SpringBootDriverDSL$ fun startSpringBootWebapp(clazz: Class&lt;*&gt;, handle: NodeHandle, checkUrl: String): CordaFuture&lt;WebserverHandle&gt;</ID>
    <ID>MaxLineLength:SpringDriver.kt$SpringBootDriverDSL$val client = OkHttpClient.Builder().connectTimeout(5, TimeUnit.SECONDS).readTimeout(10, TimeUnit.SECONDS).build()</ID>
    <ID>MaxLineLength:SpringDriver.kt$SpringBootDriverDSL$val webReadyFuture = addressMustBeBoundFuture(driverDSL.executorService, (handle as NodeHandleInternal).webAddress, process)</ID>
    <ID>MaxLineLength:Ssh.kt$Ssh.Companion$?:</ID>
    <ID>MaxLineLength:Ssh.kt$Ssh.Companion$createInboundTunnel(session, NetworkHostAndPort("localhost", clientRmiLocalPort), NetworkHostAndPort("localhost", clientRmiLocalPort))</ID>
    <ID>MaxLineLength:Ssh.kt$Ssh.Companion$createOutboundTunnel(session, NetworkHostAndPort("localhost", localHostAndPort.port), NetworkHostAndPort("localhost", serverRmiPort))</ID>
    <ID>MaxLineLength:Ssh.kt$Ssh.Companion$createOutboundTunnel(session, NetworkHostAndPort("localhost", serverRmiLocalPort), NetworkHostAndPort("localhost", serverRmiLocalPort))</ID>
    <ID>MaxLineLength:Ssh.kt$Ssh.Companion$fun createSshTunnels(hosts: Array&lt;String&gt;, jmeterProperties: String, serverRmiMappings: Map&lt;String, Int&gt;, userName: String)</ID>
    <ID>MaxLineLength:SslConfiguration.kt$// There may be multiple nodes in a JVM e.g integration tests, each node will have its own DelegatedKeyStore, so this makes sure // each node has a distinct name. fun artemisSigningServiceName(sslOptions: MutualSslConfiguration?): String</ID>
    <ID>MaxLineLength:SslConfiguration.kt$MutualSslOptions : MutualSslConfiguration</ID>
    <ID>MaxLineLength:SslConfiguration.kt$SslConfiguration.Companion$fun mutual(keyStore: FileBasedCertificateStoreSupplier, trustStore: FileBasedCertificateStoreSupplier, useOpenSsl: Boolean = false ): MutualSslConfiguration</ID>
    <ID>MaxLineLength:SslConfiguration.kt$const val DEFAULT_SSL_HANDSHAKE_TIMEOUT_MILLIS = 60000L // Set at least 3 times higher than sun.security.provider.certpath.URICertStore.DEFAULT_CRL_CONNECT_TIMEOUT which is 15 sec</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$SelfIssueCommand(IssueAndPaymentRequest(Amount(100000, USD), OpaqueBytes.of(0), issuer.mainIdentity, notaryIdentity, anonymous = true), issuer)</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$is IssueAndPaymentRequest -&gt; command.node.proxy.startFlow(::CashIssueAndPaymentFlow, request).returnValue</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$simpleNodes.flatMap { payer -&gt; simpleNodes.map { payer to it } } .filter { it.first != it.second } .map { (payer, payee) -&gt; CrossCashCommand(PaymentRequest(Amount(1, USD), payee.mainIdentity, anonymous = true), payer) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$ fun dropSessionInit(id: UUID): Boolean</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$ fun sessionInitErrored(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent, error: Throwable)</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$"the UUID $id (from the node shell you can run 'flow kill $id'). BE VERY CAUTIOUS OF THIS SECOND APPROACH AS THE "</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$/** * If enabled, initiation requests for unknown flows will be kept in the hospital until the relevant * CorDapps are installed. * * In such case the initiation message will remain un-acked in the Artemis inbox, and will be replayed * on node restart. * * For service nodes like notaries this feature should be disabled, as client nodes might unintentionally * overload the node by accidentally sending transaction instead of notarisation requests. */ private val enableSessionInitTreatment: Boolean = true</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$flowMessaging.sendSessionMessage(sender, replyError, SenderDeduplicationId(DeduplicationId.createRandom(secureRandom), ourSenderUUID))</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log.info("Flow error discharged from hospital (delay ${backOff.seconds}s) by ${report.by} (error was ${report.error.message})")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log.info("Flow error kept for overnight observation by ${report.by} (error was ${report.error.message})")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log.info("Initializing Flow Hospital. Session initialization error treatment ${if (enableSessionInitTreatment) "enabled" else "disabled"}." )</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$private</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val diagnoses: Map&lt;Diagnosis, List&lt;Staff&gt;&gt; = staff.groupBy { it.consult(flowFiber, currentState, error, medicalHistory) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val record = MedicalRecord.Flow(time, flowFiber.id, currentState.checkpoint.numberOfSuspends, errors, report.by, outcome)</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val record = sessionMessage.run { MedicalRecord.SessionInit(id, time, outcome, initiatorFlowClassName, flowVersion, appName, sender, error) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val snapshot = (flowPatients.values.flatMap { it.records } + treatableSessionInits.values.map { it.publicRecord }).sortedBy { it.time }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital${ log.info("Flow error kept for overnight observation by ${report.by} (error was ${report.error.message})") // We don't schedule a next event for the flow - it will automatically retry from its checkpoint on node restart Triple(Outcome.OVERNIGHT_OBSERVATION, null, 0.seconds) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital${ private companion object { private val log = contextLogger() private val staff = listOf( DeadlockNurse, DuplicateInsertSpecialist, DoctorTimeout, CryptoServiceDoctor, FinalityDoctor, TransientConnectionCardiologist ) } init { log.info("Initializing Flow Hospital. Session initialization error treatment ${if (enableSessionInitTreatment) "enabled" else "disabled"}." ) } init { log.info("Initializing Flow Hospital. Session initialization error treatment ${if (enableSessionInitTreatment) "enabled" else "disabled"}." ) } private val mutex = ThreadBox(object { val flowPatients = HashMap&lt;StateMachineRunId, FlowMedicalHistory&gt;() val treatableSessionInits = HashMap&lt;UUID, InternalSessionInitRecord&gt;() val recordsPublisher = PublishSubject.create&lt;MedicalRecord&gt;() }) private val secureRandom = newSecureRandom() private val delayedDischargeTimer = Timer("FlowHospitalDelayedDischargeTimer", true) /** * The node was unable to initiate the [InitialSessionMessage] from [sender]. */ fun sessionInitErrored(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent, error: Throwable) { val time = Instant.now() val id = UUID.randomUUID() val outcome = if (error is SessionRejectException.UnknownClass &amp;&amp; enableSessionInitTreatment) { // We probably don't have the CorDapp installed so let's pause the message in the hopes that the CorDapp is // installed on restart, at which point the message will be able proceed as normal. If not then it will need // to be dropped manually. Outcome.OVERNIGHT_OBSERVATION } else { Outcome.UNTREATABLE } val record = sessionMessage.run { MedicalRecord.SessionInit(id, time, outcome, initiatorFlowClassName, flowVersion, appName, sender, error) } mutex.locked { if (outcome != Outcome.UNTREATABLE) { treatableSessionInits[id] = InternalSessionInitRecord(sessionMessage, event, record) log.warn("$sender has sent a flow request for an unknown flow ${sessionMessage.initiatorFlowClassName}. Install the missing " + "CorDapp this flow belongs to and restart.") log.warn("If you know it's safe to ignore this flow request then it can be deleted permanently using the killFlow RPC and " + "the UUID $id (from the node shell you can run 'flow kill $id'). BE VERY CAUTIOUS OF THIS SECOND APPROACH AS THE " + "REQUEST MAY CONTAIN A NOTARISED TRANSACTION THAT NEEDS TO BE RECORDED IN YOUR VAULT.") } recordsPublisher.onNext(record) } if (outcome == Outcome.UNTREATABLE) { sendBackError(error, sessionMessage, sender, event) } } private fun sendBackError(error: Throwable, sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent) { val message = (error as? SessionRejectException)?.message ?: "Unable to establish session" val payload = RejectSessionMessage(message, secureRandom.nextLong()) val replyError = ExistingSessionMessage(sessionMessage.initiatorSessionId, payload) flowMessaging.sendSessionMessage(sender, replyError, SenderDeduplicationId(DeduplicationId.createRandom(secureRandom), ourSenderUUID)) event.deduplicationHandler.afterDatabaseTransaction() } /** * Drop the errored session-init message with the given ID ([MedicalRecord.SessionInit.id]). This will cause the node * to send back the relevant session error to the initiator party and acknowledge its receipt from the message broker * so that it never gets redelivered. */ fun dropSessionInit(id: UUID): Boolean { val (sessionMessage, event, publicRecord) = mutex.locked { treatableSessionInits.remove(id) ?: return false } log.info("Errored session-init permanently dropped: $publicRecord") sendBackError(publicRecord.error, sessionMessage, publicRecord.sender, event) return true } /** * The flow running in [flowFiber] has errored. */ fun flowErrored(flowFiber: FlowFiber, currentState: StateMachineState, errors: List&lt;Throwable&gt;) { val time = Instant.now() log.info("Flow ${flowFiber.id} admitted to hospital in state $currentState") val (event, backOffForChronicCondition) = mutex.locked { val medicalHistory = flowPatients.computeIfAbsent(flowFiber.id) { FlowMedicalHistory() } val report = consultStaff(flowFiber, currentState, errors, medicalHistory) val (outcome, event, backOffForChronicCondition) = when (report.diagnosis) { Diagnosis.DISCHARGE -&gt; { val backOff = calculateBackOffForChronicCondition(report, medicalHistory, currentState) log.info("Flow error discharged from hospital (delay ${backOff.seconds}s) by ${report.by} (error was ${report.error.message})") Triple(Outcome.DISCHARGE, Event.RetryFlowFromSafePoint, backOff) } Diagnosis.OVERNIGHT_OBSERVATION -&gt; { log.info("Flow error kept for overnight observation by ${report.by} (error was ${report.error.message})") // We don't schedule a next event for the flow - it will automatically retry from its checkpoint on node restart Triple(Outcome.OVERNIGHT_OBSERVATION, null, 0.seconds) } Diagnosis.NOT_MY_SPECIALTY -&gt; { // None of the staff care for these errors so we let them propagate log.info("Flow error allowed to propagate", report.error) Triple(Outcome.UNTREATABLE, Event.StartErrorPropagation, 0.seconds) } } val record = MedicalRecord.Flow(time, flowFiber.id, currentState.checkpoint.numberOfSuspends, errors, report.by, outcome) medicalHistory.records += record recordsPublisher.onNext(record) Pair(event, backOffForChronicCondition) } if (event != null) { if (backOffForChronicCondition.isZero) { flowFiber.scheduleEvent(event) } else { delayedDischargeTimer.schedule(object : TimerTask() { override fun run() { flowFiber.scheduleEvent(event) } }, backOffForChronicCondition.toMillis()) } } } private fun calculateBackOffForChronicCondition(report: ConsultationReport, medicalHistory: FlowMedicalHistory, currentState: StateMachineState): Duration { return report.by.firstOrNull { it is Chronic }?.let { chronicStaff -&gt; return medicalHistory.timesDischargedForTheSameThing(chronicStaff, currentState).let { if (it == 0) { 0.seconds } else { maxOf(10, (10 + (Math.random()) * (10 * 1.5.pow(it)) / 2).toInt()).seconds } } } ?: 0.seconds } private fun consultStaff(flowFiber: FlowFiber, currentState: StateMachineState, errors: List&lt;Throwable&gt;, medicalHistory: FlowMedicalHistory): ConsultationReport { return errors .asSequence() .mapIndexed { index, error -&gt; // Rely on the logging context to print details of the flow ID. log.info("Error ${index + 1} of ${errors.size}:", error) val diagnoses: Map&lt;Diagnosis, List&lt;Staff&gt;&gt; = staff.groupBy { it.consult(flowFiber, currentState, error, medicalHistory) } // We're only interested in the highest priority diagnosis for the error val (diagnosis, by) = diagnoses.entries.minBy { it.key }!! ConsultationReport(error, diagnosis, by) } // And we're only interested in the error with the highest priority diagnosis .minBy { it.diagnosis }!! } private data class ConsultationReport(val error: Throwable, val diagnosis: Diagnosis, val by: List&lt;Staff&gt;) /** * The flow has been removed from the state machine. */ fun flowRemoved(flowId: StateMachineRunId) { mutex.locked { flowPatients.remove(flowId) } } // TODO MedicalRecord subtypes can expose the Staff class, something which we probably don't want when wiring this method to RPC /** Returns a stream of medical records as flows pass through the hospital. */ fun track(): DataFeed&lt;List&lt;MedicalRecord&gt;, MedicalRecord&gt; { return mutex.locked { val snapshot = (flowPatients.values.flatMap { it.records } + treatableSessionInits.values.map { it.publicRecord }).sortedBy { it.time } DataFeed(snapshot, recordsPublisher.bufferUntilSubscribed()) } } operator fun contains(flowId: StateMachineRunId) = mutex.locked { flowId in flowPatients } class FlowMedicalHistory { internal val records: MutableList&lt;MedicalRecord.Flow&gt; = mutableListOf() fun notDischargedForTheSameThingMoreThan(max: Int, by: Staff, currentState: StateMachineState): Boolean { return timesDischargedForTheSameThing(by, currentState) &lt;= max } fun timesDischargedForTheSameThing(by: Staff, currentState: StateMachineState): Int { val lastAdmittanceSuspendCount = currentState.checkpoint.numberOfSuspends return records.count { it.outcome == Outcome.DISCHARGE &amp;&amp; by in it.by &amp;&amp; it.suspendCount == lastAdmittanceSuspendCount } } override fun toString(): String = "${this.javaClass.simpleName}(records = $records)" } private data class InternalSessionInitRecord(val sessionMessage: InitialSessionMessage, val event: ExternalEvent.ExternalMessageEvent, val publicRecord: MedicalRecord.SessionInit) sealed class MedicalRecord { abstract val time: Instant abstract val outcome: Outcome abstract val errors: List&lt;Throwable&gt; /** Medical record for a flow that has errored. */ data class Flow(override val time: Instant, val flowId: StateMachineRunId, val suspendCount: Int, override val errors: List&lt;Throwable&gt;, val by: List&lt;Staff&gt;, override val outcome: Outcome) : MedicalRecord() /** Medical record for a session initiation that was unsuccessful. */ data class SessionInit(val id: UUID, override val time: Instant, override val outcome: Outcome, val initiatorFlowClassName: String, val flowVersion: Int, val appName: String, val sender: Party, val error: Throwable) : MedicalRecord() { override val errors: List&lt;Throwable&gt; get() = listOf(error) } } enum class Outcome { DISCHARGE, OVERNIGHT_OBSERVATION, UNTREATABLE } /** The order of the enum values are in priority order. */ enum class Diagnosis { /** Retry from last safe point. */ DISCHARGE, /** Park and await intervention. */ OVERNIGHT_OBSERVATION, /** Please try another member of staff. */ NOT_MY_SPECIALTY } interface Staff { fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis } interface Chronic /** * SQL Deadlock detection. */ object DeadlockNurse : Staff, Chronic { override fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis { return if (mentionsDeadlock(newError)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY } } private fun mentionsDeadlock(exception: Throwable?): Boolean { return exception.mentionsThrowable(SQLException::class.java, "deadlock") } } /** * Primary key violation detection for duplicate inserts. Will detect other constraint violations too. */ object DuplicateInsertSpecialist : Staff { override fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis { return if (newError.mentionsThrowable(ConstraintViolationException::class.java) &amp;&amp; history.notDischargedForTheSameThingMoreThan(3, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY } } } /** * Restarts [TimedFlow], keeping track of the number of retries and making sure it does not * exceed the limit specified by the [FlowTimeoutException]. */ object DoctorTimeout : Staff { override fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis { if (newError is FlowTimeoutException) { return Diagnosis.DISCHARGE } return Diagnosis.NOT_MY_SPECIALTY } } /** * Restarts [TimedFlow], keeping track of the number of retries and making sure it does not * exceed the limit specified by the [FlowTimeoutException]. */ object CryptoServiceDoctor : Staff { override fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis { return if (newError is CryptoServiceException &amp;&amp; newError.isRecoverable) { if (history.notDischargedForTheSameThingMoreThan(2, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY } } else { Diagnosis.NOT_MY_SPECIALTY } } } object FinalityDoctor : Staff { override fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis { return if (currentState.flowLogic is FinalityHandler) { log.warn("Flow ${flowFiber.id} failed to be finalised. Manual intervention may be required before retrying " + "the flow by re-starting the node. State machine state: $currentState", newError) Diagnosis.OVERNIGHT_OBSERVATION } else if (isFromReceiveFinalityFlow(newError)) { if (isErrorPropagatedFromCounterparty(newError) &amp;&amp; isErrorThrownDuringReceiveFinality(newError)) { // no need to keep around the flow, since notarisation has already failed at the counterparty. Diagnosis.NOT_MY_SPECIALTY } else { log.warn("Flow ${flowFiber.id} failed to be finalised. Manual intervention may be required before retrying " + "the flow by re-starting the node. State machine state: $currentState", newError) Diagnosis.OVERNIGHT_OBSERVATION } } else { Diagnosis.NOT_MY_SPECIALTY } } private fun isFromReceiveFinalityFlow(throwable: Throwable): Boolean { return throwable.stackTrace.any { it.className == ReceiveFinalityFlow::class.java.name } } private fun isErrorPropagatedFromCounterparty(error: Throwable): Boolean { return when(error) { is UnexpectedFlowEndException -&gt; { val peer = DeclaredField&lt;Party?&gt;(UnexpectedFlowEndException::class.java, "peer", error).value peer != null } is FlowException -&gt; { val peer = DeclaredField&lt;Party?&gt;(FlowException::class.java, "peer", error).value peer != null } else -&gt; false } } /** * This method will return true if [ReceiveTransactionFlow] is at the top of the stack during the error. * As a result, if the failure happened during a sub-flow invoked from [ReceiveTransactionFlow], the method will return false. * * This is because in the latter case, the transaction might have already been finalised and deleting the flow * would introduce risk for inconsistency between nodes. */ private fun isErrorThrownDuringReceiveFinality(error: Throwable): Boolean { val strippedStacktrace = error.stackTrace .filterNot { it?.className?.contains("counter-flow exception from peer") ?: false } .filterNot { it?.className?.startsWith("net.corda.node.services.statemachine.") ?: false } return strippedStacktrace.isNotEmpty() &amp;&amp; strippedStacktrace.first().className.startsWith(ReceiveTransactionFlow::class.qualifiedName!! ) } } /** * [SQLTransientConnectionException] detection that arise from failing to connect the underlying database/datasource */ object TransientConnectionCardiologist : Staff { override fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis { return if (mentionsTransientConnection(newError)) { if (history.notDischargedForTheSameThingMoreThan(2, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.OVERNIGHT_OBSERVATION } } else { Diagnosis.NOT_MY_SPECIALTY } } private fun mentionsTransientConnection(exception: Throwable?): Boolean { return exception.mentionsThrowable(SQLTransientConnectionException::class.java, "connection is not available") } } }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.CryptoServiceDoctor$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DeadlockNurse$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DoctorTimeout$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DuplicateInsertSpecialist$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DuplicateInsertSpecialist$return if (newError.mentionsThrowable(ConstraintViolationException::class.java) &amp;&amp; history.notDischargedForTheSameThingMoreThan(3, this, currentState)) { Diagnosis.DISCHARGE } else { Diagnosis.NOT_MY_SPECIALTY }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FinalityDoctor$ private fun isErrorThrownDuringReceiveFinality(error: Throwable): Boolean</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FinalityDoctor$log</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FinalityDoctor$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FinalityDoctor$return strippedStacktrace.isNotEmpty() &amp;&amp; strippedStacktrace.first().className.startsWith(ReceiveTransactionFlow::class.qualifiedName!! )</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FlowMedicalHistory$return records.count { it.outcome == Outcome.DISCHARGE &amp;&amp; by in it.by &amp;&amp; it.suspendCount == lastAdmittanceSuspendCount }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.Staff$fun consult(flowFiber: FlowFiber, currentState: StateMachineState, newError: Throwable, history: FlowMedicalHistory): Diagnosis</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.TransientConnectionCardiologist$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.TransientConnectionCardiologist$return exception.mentionsThrowable(SQLTransientConnectionException::class.java, "connection is not available")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$private</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$return (exceptionType.isAssignableFrom(this::class.java) &amp;&amp; containsMessage) || cause.mentionsThrowable(exceptionType, errorMessage)</ID>
    <ID>MaxLineLength:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$rpcProxy.startFlow(::CashPaymentFlow, 100.POUNDS, notaryNodeIdentity, true, notaryNodeIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.RECORDED_TIME), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:StandaloneJPANotaryService.kt$StandaloneJPANotaryService$?:</ID>
    <ID>MaxLineLength:StandaloneJPANotaryService.kt$StandaloneJPANotaryService$override val uniquenessProvider = StandaloneJPAUniquenessProvider(services.monitoringService.metrics, services.clock, services.configuration.notary!!.jpa!!)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$ override fun commit( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; ): CordaFuture&lt;UniquenessProvider.Result&gt;</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$/** Tracks the distribution of the number of unique transactions that contributed states to the current transaction */ private val uniqueTxHashCount = metrics.histogram("$metricPrefix.NumberOfUniqueTxHashes")</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$@SuppressWarnings("unchecked") val existing = entityManager.createNamedQuery("CommittedState.select", CommittedState::class.java).setParameter("ids", idsBatch).resultList as List&lt;CommittedState&gt;</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$is SQLNonTransientConnectionException</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$is SQLRecoverableException</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$log.info("Processing notarization requests with ${allInputs.size} input states and ${references.size} references")</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$private</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$private val dataSource: DataSource = HibernateEntityManagerFactoryProvider.createDataSource(config.dataSource, metrics)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$private val entityManagerFactory = HibernateEntityManagerFactoryProvider.createEntityManagerFactory(dataSource, config.dataSource, config.databaseConfig, config.maxBatchSize)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$request.future.setException(NotaryInternalException(NotaryError.General(Exception("Internal service error."))))</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$requestSignature = requestSignature.serialize(context = SerializationDefaults.STORAGE_CONTEXT.withEncoding(CordaSerializationEncoding.SNAPPY)).bytes</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$stateRef to StateConsumptionDetails(consumingTxId.sha256(), type = StateConsumptionDetails.ConsumedStateType.REFERENCE_INPUT_STATE)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$throw IllegalStateException("Database operation reached the maximum number of retries: $retryCount, something went wrong.")</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$val conflicts = (request.states + request.references).filter { allConflicts.containsKey(it) }.associate { it to allConflicts[it]!!}</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$val drainedSize = Queues.drain(requestQueue, buffer, config.maxBatchSize, config.batchTimeoutMs, TimeUnit.MILLISECONDS)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$val request = CommitRequest(states, txId, callerIdentity, requestSignature, timeWindow, references, future, requestEntities, stateEntities)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$while (buffer.isNotEmpty() &amp;&amp; inputStateCount + buffer.peek().states.size &lt;= config.maxBatchInputStates) { val request = buffer.poll() batch.add(request) }</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$notaryParty = DevIdentityGenerator.generateDistributedNotarySingularIdentity(listOf(mockNet.baseDirectory(mockNet.nextNodeId)), notaryName)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$private</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$val networkParameters = NetworkParametersCopier(testNetworkParameters(notaries = listOf(NotaryInfo(notaryParty, false)), minimumPlatformVersion = 4))</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests$val schemaMigration = SchemaMigration(setOf(JPANotarySchemaV1), dataSource, DatabaseConfig(runMigration = true), loader, Paths.get(System.getProperty("user.dir")), ourName = notaryName)</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests${ currentDataSourceFactory?.close() currentDataSourceFactory = dataSourceFactory currentDataSourceFactory!!.startup() dataSourceProperties = currentDataSourceFactory!!.getDataSourceProperties() /** CockroachDB is incompatible with Liquibase because it does not support the addition of a primary key after table creation. */ if (!currentDataSourceFactory!!.dockerImageName.contains("cockroach")) { val dataSource = HibernateEntityManagerFactoryProvider.createDataSource(dataSourceProperties, null) val loader = JarScanningCordappLoader.fromDirectories(setOf(Paths.get(System.getProperty("user.dir")))) val schemaMigration = SchemaMigration(setOf(JPANotarySchemaV1), dataSource, DatabaseConfig(runMigration = true), loader, Paths.get(System.getProperty("user.dir")), ourName = notaryName) schemaMigration.runMigration(false, null) } notaryParty = DevIdentityGenerator.generateDistributedNotarySingularIdentity(listOf(mockNet.baseDirectory(mockNet.nextNodeId)), notaryName) val networkParameters = NetworkParametersCopier(testNetworkParameters(notaries = listOf(NotaryInfo(notaryParty, false)), minimumPlatformVersion = 4)) val notaryNodeUnstarted = createNotaryNode() val nodeUnstarted = mockNet.createUnstartedNode() val startedNodes = listOf(notaryNodeUnstarted, nodeUnstarted).map { n -&gt; networkParameters.install(mockNet.baseDirectory(n.id)) n.start() } mockNet.startNodes() notaryNode = startedNodes.first() node = startedNodes.last() }</ID>
    <ID>MaxLineLength:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests.Companion$/** The data source factory that we are using for this particular batch of test runs. This will change every time we move to a new database while testing.*/ private var currentDataSourceFactory: DataSourceFactory? = null</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$Ansi.ansi().fgBrightRed().a( """ ______ __""").newline().a( """ / ____/ _________/ /___ _""").newline().a( """ / / __ / ___/ __ / __ `/ """).newline().fgBrightRed().a( """/ /___ /_/ / / / /_/ / /_/ /""").newline().fgBrightRed().a( """\____/ /_/ \__,_/\__,_/""").reset().fgBrightDefault().bold() .newline()</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$if (System.console() != null) System.console().readPassword(format, *args) else this.readLine(format, *args).toCharArray()</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$it.filter { it.isRegularFile() &amp;&amp; it.toString().endsWith(".jar") }.map { it.toUri().toURL() }.toList()</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun &lt;RESULT&gt; badValue(message: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toCordaX500Name(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toNetworkHostAndPort(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toPrincipal(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal inline fun &lt;reified RESULT, reified ERROR : Exception&gt; attempt(action: () -&gt; RESULT)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$private fun Config.toProperties()</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$private inline</ID>
    <ID>MaxLineLength:StartLocalPerfCorDapp.kt$StartLocalPerfCorDapp.Companion$startNode(providedName = DUMMY_BANK_A_NAME, rpcUsers = listOf(demoUser), maximumHeapSize = "1G")</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendExisting(existingSessionState.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendInitial(existingSessionState.destination, initialMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendInitial(sessionState.destination, initialMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$collectErroredSessionErrors(sessionIds, checkpoint) + collectEndedEmptySessionErrors(sessionIds, checkpoint)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$newSessionMessages[sessionId] = sessionState.copy(receivedMessages = messages.subList(1, messages.size).toList())</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$private</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$return freshErrorTransition(IllegalStateException("Tried to send to ended session $sourceSessionId"))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val initialMessage = createInitialSessionMessage(existingSessionState.initiatingSubFlow, sourceSessionId, existingSessionState.additionalEntropy, message)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val initialMessage = createInitialSessionMessage(sessionState.initiatingSubFlow, sourceSessionId, sessionState.additionalEntropy, null)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val newBufferedMessages = existingSessionState.bufferedMessages + Pair(deduplicationId, sessionMessage)</ID>
    <ID>MaxLineLength:StateHandlingFlows.kt$StartAllChecksFlow : FlowLogic</ID>
    <ID>MaxLineLength:StateHandlingFlows.kt$StartAllChecksFlow$targets.forEach { subFlow(InstallCheckScheduleStateFlow(listOf(ourIdentity), it, emptyList(), startTime, Instant.MIN, waitTimeSeconds, waitForOutstandingFlowsSeconds, UniqueIdentifier(null))) }</ID>
    <ID>MaxLineLength:StateMachineDataModel.kt$StateMachineDataModel$SimpleObjectProperty(StateMachineStatus.Added(update.id, update.stateMachineInfo.flowLogicClassName, flowInitiator))</ID>
    <ID>MaxLineLength:StateMachineDataModel.kt$StateMachineDataModel$private</ID>
    <ID>MaxLineLength:StateMachineDataModel.kt$StateMachineStatus$Added : StateMachineStatus</ID>
    <ID>MaxLineLength:StateMachineManager.kt$StateMachineManager</ID>
    <ID>MaxLineLength:StateMachineManager.kt$StateMachineManager$ fun deliverExternalEvent(event: ExternalEvent)</ID>
    <ID>MaxLineLength:StateMachineManager.kt$StateMachineManager$ fun killFlow(id: StateMachineRunId): Boolean</ID>
    <ID>MaxLineLength:StateMachineManagerUtils.kt$ //TODO: instead of replacing the progress tracker after constructing the flow logic, we should inject it during fiber deserialization fun StateMachineManagerInternal.injectOldProgressTracker(oldTracker: ProgressTracker?, newFlowLogic: FlowLogic&lt;*&gt;)</ID>
    <ID>MaxLineLength:StateMachineState.kt$StateMachineState</ID>
    <ID>MaxLineLength:StateMachineState.kt$SubFlowVersion$CorDappFlow : SubFlowVersion</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer : CordaView</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer$// Column stays the same size, but we don't violate column restricted resize policy for the whole table view. minWidth = 26.0 maxWidth = 26.0</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer$column("Flow name", StateMachineData::stateMachineName).cellFormat { text = FlowNameFormatter.camelCase.format(it) }</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer$fun makeColumns(table: TableView&lt;StateMachineData&gt;, tableItems: ObservableList&lt;StateMachineData&gt;, withResult: Boolean = true)</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer$fun makeIconLabel(icon: FontAwesomeIcon, initText: String, customStyle: String? = null, iconSize: Double = 15.0): Label</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer$label(initiator.scheduledState.scheduledAt.toString()) { gridpaneConstraints { hAlignment = HPos.LEFT } }</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer.StateMachineDetailsView$is FlowInitiator.Scheduled -&gt; makeScheduledGrid(flowInitiatorGrid, smmData.flowInitiator as FlowInitiator.Scheduled)</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer.StateMachineDetailsView$is FlowInitiator.Shell -&gt; makeShellGrid(flowInitiatorGrid)</ID>
    <ID>MaxLineLength:StateMachineViewer.kt$StateMachineViewer.StateMachineDetailsView${ //TODO It would be nice to have flow graph with showing progress steps with subflows + timestamps (left it for second iteration). when (smmData.flowInitiator) { is FlowInitiator.Shell -&gt; makeShellGrid(flowInitiatorGrid) // TODO Extend this when we will have more information on shell user. is FlowInitiator.Peer -&gt; makePeerGrid(flowInitiatorGrid, smmData.flowInitiator as FlowInitiator.Peer) is FlowInitiator.RPC -&gt; makeRPCGrid(flowInitiatorGrid, smmData.flowInitiator as FlowInitiator.RPC) is FlowInitiator.Scheduled -&gt; makeScheduledGrid(flowInitiatorGrid, smmData.flowInitiator as FlowInitiator.Scheduled) } val status = smmData.smmStatus.first.value if (status is StateMachineStatus.Removed) { val result = status.result when (result) { is Try.Success -&gt; makeResultVBox(flowResultVBox, result.value) is Try.Failure -&gt; makeErrorVBox(flowResultVBox, result.exception) } } }</ID>
    <ID>MaxLineLength:StatePointer.kt$LinearPointer$// Here either one of two things has happened: // 1. The pointed-to state has not been seen by the resolver node. It is unlikely that this is the case. // The state can probably be obtained via subscribing to the data distribution group which created and // and maintains this data. // 2. Uh oh... The pointed-to state has been exited from the ledger! // It is unlikely this would ever happen as most reference data states will be created such that they cannot // be exited from the ledger. At this point there are two options; use an old consumed version of the state, // or don't use it at all. "The LinearState with ID ${pointer.id} is unknown to this node or it has been exited from the ledger."</ID>
    <ID>MaxLineLength:StatePointer.kt$LinearPointer&lt;T : LinearState&gt; : StatePointer</ID>
    <ID>MaxLineLength:StatePointer.kt$StatePointer.Companion$ inline fun &lt;reified T : ContractState&gt; staticPointer( stateAndRef: StateAndRef&lt;T&gt;, isResolved: Boolean = false )</ID>
    <ID>MaxLineLength:StatePointer.kt$StatePointer.Companion$ inline fun &lt;reified T : LinearState&gt; linearPointer( state: T, isResolved: Boolean = true )</ID>
    <ID>MaxLineLength:StateRevisionFlow.kt$StateRevisionFlow.Receiver$open</ID>
    <ID>MaxLineLength:StateRevisionFlow.kt$StateRevisionFlow.Requester$updatedData: T</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;T : Any&gt; Iterable&lt;ContractState&gt;.sumFungibleOrNull()</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;T : Any&gt; Iterable&lt;ContractState&gt;.sumFungibleOrZero(token: Issued&lt;T&gt;)</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCash(): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashBy(owner: AbstractParty): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashOrNull(): Amount&lt;Issued&lt;Currency&gt;&gt;?</ID>
    <ID>MaxLineLength:StaticInitialisationOfSerializedObjectTest.kt$StaticInitialisationOfSerializedObjectTest$val url = EvolvabilityTests::class.java.getResource("StaticInitialisationOfSerializedObjectTest.deserializeTest")</ID>
    <ID>MaxLineLength:StaticInitialisationOfSerializedObjectTest.kt$StaticInitialisationOfSerializedObjectTest$val url = EvolvabilityTests::class.java.getResource("StaticInitialisationOfSerializedObjectTest.deserializeTest2")</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$?:</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$if (options.isEmpty()) throw IllegalStateException("Transition [$input -(${command.javaClass.simpleName})-&gt; $output] not allowed")</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$private vararg val ts: TransitionDef&lt;S, R&gt;</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions$require(relevantCmds.isNotEmpty()) { "Transaction must have at least one Command relevant to its defined transitions" }</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions${ // which state determines who is the signer? by default the input, unless it's the initial transition val state = (inp ?: outp)!! val signerParty = state.roleToParty(signer) if (!cmd.signers.contains(signerParty.owningKey)) throw IllegalStateException("Command ${cmd.value.javaClass} must be signed by $signer") }</ID>
    <ID>MaxLineLength:StatusTransitions.kt$StatusTransitions&lt;out S, in R, T : StatusTrackingContractState&lt;S, R&gt;&gt;</ID>
    <ID>MaxLineLength:StatusTransitions.kt$TransitionDef&lt;out S, out R&gt;</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$/** A map of method name to parameter names for the target type. */ val methodParamNames: Map&lt;String, List&lt;String&gt;&gt; = targetType.declaredMethods.filterNot(Method::isSynthetic).mapNotNull { try { it.name to paramNamesFromMethod(it) } catch (e: KotlinReflectionInternalError) { // Kotlin reflection doesn't support every method that can exist on an object (in particular, reified // inline methods) so we just ignore those here. null } }.toMap()</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$kf != null -&gt; kf.parameters[index + 1].name ?: throw UnparseableCallException.ReflectionDataMissing(method.name, index)</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$kf != null -&gt; kf.parameters[index].name ?: throw UnparseableCallException.ReflectionDataMissing("&lt;init&gt;", index)</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$private</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser$when { param.isNamePresent -&gt; param.name // index + 1 because the first Kotlin reflection param is 'this', but that doesn't match Java reflection. kf != null -&gt; kf.parameters[index + 1].name ?: throw UnparseableCallException.ReflectionDataMissing(method.name, index) else -&gt; throw UnparseableCallException.ReflectionDataMissing(method.name, index) }</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.Companion$for ((key, value) in clazz.methods.filterNot { it.isSynthetic &amp;&amp; it.name !in ignoredNames }.map { it.name to it }) { result.put(key, value) }</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$MissingParameter : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$ReflectionDataMissing : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$TooManyParameters : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$open</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser&lt;in T : Any&gt;</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$"twoStrings a: Some words, b: ' and some words, like, Kirk, would, speak'" to "Some words and some words, like, Kirk, would, speak"</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$val args: Array&lt;Any?&gt; = parser.parseArguments(clazz.name, names.zip(ctor.parameterTypes), "alternativeWord: Foo bar!")</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$val args: Array&lt;Any?&gt; = parser.parseArguments(clazz.name, names.zip(ctor.parameterTypes), "someWord: Blah blah blah, aDifferentThing: 12")</ID>
    <ID>MaxLineLength:Structures.kt$Command$private fun commandDataToString()</ID>
    <ID>MaxLineLength:Structures.kt$CommandWithParties$@Deprecated("Should not be used in contract verification code as it is non-deterministic, will be disabled for some future target platform version onwards and will take effect only for CorDapps targeting those versions.")</ID>
    <ID>MaxLineLength:Structures.kt$Contract</ID>
    <ID>MaxLineLength:Structures.kt$Issued$require(issuer.reference.size &lt;= MAX_ISSUER_REF_SIZE) { "Maximum issuer reference size is $MAX_ISSUER_REF_SIZE." }</ID>
    <ID>MaxLineLength:Structures.kt$OwnableState$ fun withNewOwner(newOwner: AbstractParty): CommandAndState</ID>
    <ID>MaxLineLength:Structures.kt$PrivacySalt : OpaqueBytes</ID>
    <ID>MaxLineLength:Structures.kt$SchedulableState$ @DeleteForDJVM fun nextScheduledActivity(thisStateRef: StateRef, flowLogicRefFactory: FlowLogicRefFactory): ScheduledActivity?</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContract&lt;in OldState : ContractState, out NewState : ContractState&gt; : Contract</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContractWithLegacyConstraint&lt;in OldState : ContractState, out NewState : ContractState&gt; : UpgradedContract</ID>
    <ID>MaxLineLength:Structures.kt$return mapNotNull { if (it.state.data is T) StateAndRef(TransactionState(it.state.data, it.state.contract, it.state.notary), it.ref) else null }</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Companion$Try.Success(Initiating(flowClass, initiatingAnnotation.first, flowContext, subFlowVersion, isEnabledTimedFlow))</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Companion$fun create(flowClass: Class&lt;FlowLogic&lt;*&gt;&gt;, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean): Try&lt;SubFlow&gt;</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Companion$private</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Inlined$data</ID>
    <ID>MaxLineLength:SupportedTransforms.kt$SupportedTransform</ID>
    <ID>MaxLineLength:SwapData.kt$FixedLeg$data</ID>
    <ID>MaxLineLength:SwapData.kt$FloatingLeg$data</ID>
    <ID>MaxLineLength:SwapData.kt$SwapData$return getSwapConvention(convention).createTrade(startDate, Tenor.TENOR_4Y, buySell, notional.toDouble(), fixedRate.toDouble(), ReferenceData.standard()) .toBuilder() .info(tradeInfo) .build()</ID>
    <ID>MaxLineLength:SwapDataModel.kt$SwapDataModel$Pair("swap", id)</ID>
    <ID>MaxLineLength:SwapExample.kt$SwapExample$val resolvedTrades = trades.stream().map({ trade -&gt; trade.resolve(ReferenceData.standard()) }).collect(toList&lt;ResolvedSwapTrade&gt;())</ID>
    <ID>MaxLineLength:SwapExample.kt$SwapExample$val resolvedTrades = trades1.stream().map({ trade -&gt; trade.resolve(ReferenceData.standard()) }).collect(toList&lt;ResolvedSwapTrade&gt;())</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesException : FlowException</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow : FlowLogic</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Deprecated("It is unsafe to use this constructor as it requires nodes to automatically vend anonymous identities without first " + "checking if they should. Instead, use the constructor that takes in an existing FlowSession.")</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Deprecated("It is unsafe to use this constructor as it requires nodes to automatically vend anonymous identities without first " + "checking if they should. Instead, use the constructor that takes in an existing FlowSession.") constructor(otherParty: Party, @Suppress("UNUSED_PARAMETER") revocationEnabled: Boolean, progressTracker: ProgressTracker) : this(null, otherParty, progressTracker)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@JvmOverloads constructor(otherSideSession: FlowSession, progressTracker: ProgressTracker = tracker()) : this(otherSideSession, null, progressTracker)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$logger</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$val theirAnonymousIdentity = session.sendAndReceive&lt;IdentityWithSignature&gt;(ourIdentWithSig).unwrap { theirIdentWithSig -&gt; progressTracker.currentStep = VERIFYING_IDENTITY validateAndRegisterIdentity(serviceHub, session.counterparty, theirIdentWithSig.identity.deserialize(), theirIdentWithSig.signature) }</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$validateAndRegisterIdentity(serviceHub, session.counterparty, theirIdentWithSig.identity.deserialize(), theirIdentWithSig.signature)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$@JvmStatic fun tracker(): ProgressTracker</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion${ if (theirAnonymousIdentity.name != otherSide.name) { throw SwapIdentitiesException("Certificate subject must match counterparty's well known identity.") } try { theirAnonymousIdentity.owningKey.verify(buildDataToSign(theirAnonymousIdentity), signature) } catch (ex: SignatureException) { throw SwapIdentitiesException("Signature does not match the expected identity ownership assertion.", ex) } // Validate then store their identity so that we can prove the key in the transaction is owned by the counterparty. serviceHub.identityService.verifyAndRegisterIdentity(theirAnonymousIdentity) return theirAnonymousIdentity }</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.IdentityWithSignature$@CordaSerializable data</ID>
    <ID>MaxLineLength:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests$private</ID>
    <ID>MaxLineLength:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests.&lt;no name provided&gt;$ is resolved by </ID>
    <ID>MaxLineLength:SwapIdentitiesFlowTests.kt$SwapIdentitiesFlowTests.HoldsOwningKeyMatcher$private data</ID>
    <ID>MaxLineLength:SwapIdentitiesHandler.kt$SwapIdentitiesHandler : FlowLogic</ID>
    <ID>MaxLineLength:SwapIdentitiesHandler.kt$SwapIdentitiesHandler$logger.warnOnce("Insecure API to swap anonymous identities was used by ${otherSide.counterparty} (${otherSide.getCounterpartyFlowInfo()})")</ID>
    <ID>MaxLineLength:Swaption.kt$Swaption$val floating = interest(notional, "act/365", fix("LIBOR", start, Tenor("3M")), start, end)</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$// Check that all 4 transactions are present // There are 4 transactions because: 1 Cash issuance, 2 * fully processed payments, 1 payment that been restarted mid-flight val snapshot = aliceProxy.stateMachineRecordedTransactionMappingSnapshot() if(snapshot.size &lt; 4) { null } else { @Suppress("DEPRECATION") val transactions = snapshot.mapNotNull { aliceProxy.internalFindVerifiedTransaction(it.transactionId) } assertEquals(4, snapshot.size) assertEquals(4, transactions.size) Assertions.assertThat(snapshot.map { it.transactionId }.toSet()).containsAll(successfulPayments.map { it.stx.id }) val groupedByAmount = transactions.groupBy { (it.coreTransaction.outputStates.first() as Cash.State).amount.withoutIssuer() } assertEquals(1, groupedByAmount[100.POUNDS]!!.size) assertEquals(2, groupedByAmount[5.POUNDS]!!.size) assertEquals(1, groupedByAmount[6.POUNDS]!!.size) logger.info("All 4 transactions present") }</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$@Suppress("DEPRECATION") val transactions = snapshot.mapNotNull { aliceProxy.internalFindVerifiedTransaction(it.transactionId) }</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$Assertions.assertThat(snapshot.map { it.transactionId }.toSet()).containsAll(successfulPayments.map { it.stx.id })</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$Assertions.assertThatThrownBy { aliceProxy.nodeInfo() }.isInstanceOf(RPCException::class.java).hasMessageContaining("RPC server is not available")</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$Assertions.assertThatThrownBy { paySelf(6.POUNDS) }.isInstanceOf(RPCException::class.java).hasMessageContaining("Connection failure detected")</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$alice = startNode(NodeParameters(providedName = ALICE_NAME, rpcUsers = listOf(testUser)), bytemanPort = bytemanPort).getOrThrow()</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$assertEquals(7.POUNDS, (anotherPaymentOutcome.stx.tx.outputStates.first() as Cash.State).amount.withoutIssuer())</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$private fun paySelf(amount: Amount&lt;Currency&gt;)</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$val deploymentOutcome = submit.addScripts(listOf(ScriptText("Restart script for ${terminationData.terminationTarget}", ruleText)))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest$val groupedByAmount = transactions.groupBy { (it.coreTransaction.outputStates.first() as Cash.State).amount.withoutIssuer() }</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$( // We try to locate a single method where termination is meant to be performed. // This of course doesn't perform any compile time check, but at least at runtime we can be sure that we // are aiming at something that indeed exists within a class. // Note: methods listed in the order they are invoked during flow execution. arrayOf&lt;Any&gt;(TerminationData(RPCServer::class.java.declaredMethods.single { it.name == "context" }, 3)), arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeCreateTransaction" }, 4)), arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executePersistCheckpoint" }, 4)), arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executePersistDeduplicationIds" }, 4)), arrayOf&lt;Any&gt;(TerminationData(OnLedgerAsset.Companion::class.java.declaredMethods.single { it.name == "gatherCoins" }, 4)), arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeRemoveCheckpoint" }, 4)), arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeReleaseSoftLocks" }, 4)), arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeCommitTransaction" }, 4)), arrayOf&lt;Any&gt;(TerminationData(ClientMessageImpl::class.java.methods.single { it.name == "acknowledge" &amp;&amp; !it.isSynthetic }, 4)) )</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeCommitTransaction" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeCreateTransaction" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executePersistCheckpoint" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executePersistDeduplicationIds" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeReleaseSoftLocks" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ActionExecutorImpl::class.java.declaredMethods.single { it.name == "executeRemoveCheckpoint" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(ClientMessageImpl::class.java.methods.single { it.name == "acknowledge" &amp;&amp; !it.isSynthetic }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(OnLedgerAsset.Companion::class.java.declaredMethods.single { it.name == "gatherCoins" }, 4))</ID>
    <ID>MaxLineLength:SystematicTerminationTest.kt$SystematicTerminationTest.Companion$arrayOf&lt;Any&gt;(TerminationData(RPCServer::class.java.declaredMethods.single { it.name == "context" }, 3))</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$arrayOf("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$arrayOf("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$private</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$serverParams.needClientAuth = true</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$testConnect(serverSocket, clientSocket, "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$testConnect(serverSocket, clientSocket, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$val serverSocket = serverSocketFactory.createServerSocket(serverPort) as SSLServerSocket // use 0 to get first free socket.</ID>
    <ID>MaxLineLength:TendermintAdapter.kt$TendermintStateMachine : IDeliverTxICheckTxICommitIBeginBlock</ID>
    <ID>MaxLineLength:TenorDateParameterMetadataSerializer.kt$TenorDateParameterMetadataSerializer$override fun fromProxy(proxy: Proxy): TenorDateParameterMetadata</ID>
    <ID>MaxLineLength:TestAuditService.kt$TestAuditService$override</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$assertEquals(1, pendingChecksAfterCleanUp.states.size, "Expected 1 pending check to be removed, got ${pendingChecksAfterCleanUp.states.size}")</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$assertEquals(2, pendingChecks.states.size, "Expected exactly 2 pending (scheduled) checks, got ${pendingChecks.states.size}")</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$assertTrue(pendingChecksAfterCleanUp.states.isEmpty(), "Expected all pending checks to be removed, got ${pendingChecksAfterCleanUp.states.size}")</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$cordappsForAllNodes = listOf(findCordapp("net.corda.notaryhealthcheck.contract"), findCordapp("net.corda.notaryhealthcheck.cordapp"))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$getTestPartyAndCertificate(Party(CordaX500Name("Some node", "New York", "US"), generateKeyPair().public))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$nodeA.services.vaultService.queryBy&lt;SchedulingContract.ScheduledCheckState&gt;(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$val flowFuture1 = nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target, emptyList(), Instant.now().plusSeconds(1), Instant.MIN, 1, 5, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$val flowFuture1 = nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target, emptyList(), Instant.now().plusSeconds(1000), Instant.MIN, 2, 5, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$val flowFuture2 = nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target, emptyList(), Instant.now().plusSeconds(1000), Instant.MIN, 2, 5, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$val flowFuture2 = nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target2, emptyList(), Instant.now().plusSeconds(1), Instant.MIN, 1, 5, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestCheckScheduleManagementFlow.kt$TestCheckScheduleManagementFlow$val pendingChecks = nodeA.services.vaultService.queryBy&lt;SchedulingContract.ScheduledCheckState&gt;(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED))</ID>
    <ID>MaxLineLength:TestClock.kt$TestClock$ @Synchronized fun setTo(newInstant: Instant)</ID>
    <ID>MaxLineLength:TestCommonUtils.kt$inline fun &lt;reified TYPE : Throwable&gt; AbstractThrowableAssert&lt;*, *&gt;.isInstanceOf(): AbstractThrowableAssert&lt;*, *&gt;</ID>
    <ID>MaxLineLength:TestCommsFlow.kt$TestCommsFlowInitiator$tx.addOutputState(CommsTestState(responses, serviceHub.myInfo.legalIdentities.first()), CommsTestContract::class.java.name)</ID>
    <ID>MaxLineLength:TestConstants.kt$ fun dummyCommand(vararg signers: PublicKey = arrayOf(generateKeyPair().public))</ID>
    <ID>MaxLineLength:TestCordapp.kt$TestCordapp</ID>
    <ID>MaxLineLength:TestCordapp.kt$TestCordapp.Companion$ @JvmStatic fun findCordapp(scanPackage: String): TestCordapp</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl : TestCordappInternal</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$"${jars.map { it.toFile().absolutePath }}. Specify a package name which is unique to the CorDapp."</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$0</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$else -&gt; throw IllegalArgumentException("There is more than one CorDapp containing the package $scanPackage on the classpath " + "${jars.map { it.toFile().absolutePath }}. Specify a package name which is unique to the CorDapp.")</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal : TestCordapp</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal.Companion$cordappsWithoutMeta.forEach { require(it.value.size == 1) { "Conflicting CorDapps specified: ${it.value}" } }</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal.Companion$val allCordapps = nodeSpecificCordapps + generalCordapps.filter { it.withOnlyJarContents() !in nodeSpecificCordappsWithoutMeta }</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal.Companion${ // Ignore if the node already has the same CorDapp jar. This can happen if the node is being restarted. }</ID>
    <ID>MaxLineLength:TestDSL.kt$AttachmentResolutionException : FlowException</ID>
    <ID>MaxLineLength:TestDSL.kt$DoubleSpentInputs : FlowException</ID>
    <ID>MaxLineLength:TestDSL.kt$TestLedgerDSLInterpreter$( transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TestTransactionDSLInterpreter.() -&gt; Unit )</ID>
    <ID>MaxLineLength:TestDSL.kt$TestLedgerDSLInterpreter$throw IllegalStateException("A transaction-DSL block that is part of a test ledger must return a valid transaction.", e)</ID>
    <ID>MaxLineLength:TestDSL.kt$TestLedgerDSLInterpreter$val transactionsUnverified: List&lt;WireTransaction&gt; get() = nonVerifiedTransactionWithLocations.values.map { it.transaction }</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage, attachmentId, signers))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage, attachmentId, signers, jarManifestAttributes))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$override</ID>
    <ID>MaxLineLength:TestDSL.kt$net.corda.testing.dsl.TestDSL.kt</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext : CloseableResource</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun afterClass(teardownSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun afterTest(teardownSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun beforeClass(setupSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun beforeTest(setupSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun initialize(groupName: String)</ID>
    <ID>MaxLineLength:TestDoorman.kt$TestDoorman : ExternalResource</ID>
    <ID>MaxLineLength:TestHelpers.kt$TestHelpers$assertEquals("01:25:54.083", Duration.ofHours(1).plusMinutes(25).plusSeconds(54).plusMillis(83).toHumanReadable())</ID>
    <ID>MaxLineLength:TestHelpers.kt$TestHelpers$assertEquals("5d 10:41:22.485", Duration.ofDays(5).plusHours(10).plusMinutes(41).plusSeconds(22).plusMillis(485).plusNanos(723743).toHumanReadable())</ID>
    <ID>MaxLineLength:TestKeyManagerFactoryWrapper.kt$TestKeyManagerFactoryWrapper$AMQPConfigurationImpl : AMQPConfiguration</ID>
    <ID>MaxLineLength:TestKeyManagerFactoryWrapper.kt$TestKeyManagerFactoryWrapper$val amqpConfig = AMQPConfigurationImpl(config.p2pSslOptions.keyStore.get(true), config.p2pSslOptions.trustStore.get(true), MAX_MESSAGE_SIZE)</ID>
    <ID>MaxLineLength:TestKeyManagerFactoryWrapper.kt$TestKeyManagerFactoryWrapper$val signingCertificateStore = CertificateStoreStubs.Signing.withCertificatesDirectory(temporaryFolder.root.toPath())</ID>
    <ID>MaxLineLength:TestKeyManagerFactoryWrapper.kt$TestKeyManagerFactoryWrapper$val sslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(temporaryFolder.root.toPath(), keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$SystemPropertySetter : Closeable</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$assertEquals(listOf("-s", "-p", defaultJmeterPropertiesFile, "-q", expectedServerPropsFile.toString()), result.jmeterArgs)</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$cmdLine.serverRmiMappings = createFileInTmpFolder("server-rmi.config", "${InetAddress.getLocalHost().hostName}:10101")</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$testForException("Enabling ssh tunneling requires providing rmi mappings via -XserverRmiMappings") { Launcher.prepareJMeterArguments(cmdLine) }</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$testForException("System property jmeter.home must be set when running without capsule") { Launcher.prepareJMeterPropsGradle(cli) }</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$testForException("System property search_paths_file must be set when running without capsule") { Launcher.prepareJMeterPropsGradle(cli) }</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$testForException("To choose jmeter.properties, use the -XjmeterProperties flag, not -p for JMeter arguments") { Launcher.prepareJMeterArguments(cmdLine) }</ID>
    <ID>MaxLineLength:TestLauncherHelpers.kt$TestLauncherHelpers$val args = arrayOf("-Xssh", "server1", "server2", "-XadditionalSearchPaths", "bar.jar", "--", "-P", "proxy")</ID>
    <ID>MaxLineLength:TestNoSecurityDataVendingFlow.kt$TestNoSecurityDataVendingFlow : DataVendingFlow</ID>
    <ID>MaxLineLength:TestNoSecurityDataVendingFlow.kt$TestNoSecurityDataVendingFlow$@Suspendable override</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$fun addServiceIdentity(name: CordaX500Name, nodeKeyPair: KeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME)): Pair&lt;PartyAndCertificate, PrivateKey&gt;</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$listOf(NetworkHostAndPort("my.${identitiesAndPrivateKeys[0].first.party.name.organisation.replace(' ', '-')}.com", 1234))</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$fun createNodeInfoAndSigned(vararg names: CordaX500Name, serial: Long = 1, platformVersion: Int = 1): NodeInfoAndSigned</ID>
    <ID>MaxLineLength:TestNotaryFlow.kt$TestNotaryFlow$issueBuilder.addOutputState(NotaryTestState(notary.name.toString(), myIdentity), NotaryTestContract::class.java.name)</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$assertTrue(pendingStatesAfterClean.isEmpty(), "Expected all pending states to be cleared, got ${pendingStatesAfterClean.size}")</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$assertTrue(successStates.size &gt; 1, "Expecting at least 2 successful checks by now, got ${successStates.size}")</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$assertTrue(successStates.size &gt; 7, "Expecting at least 8 successful checks by now, got ${successStates.size}")</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$extraCordappPackagesToScan = listOf("net.corda.notaryhealthcheck.contract", "net.corda.notaryhealthcheck.cordapp")</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$extraCordappPackagesToScan = listOf("net.corda.notaryhealthcheck.contract", "net.corda.notaryhealthcheck.cordapp", "net.corda.notary.raft")</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$notarySpecs = listOf(NotarySpec(DUMMY_NOTARY_NAME, validating = validating, cluster = DummyClusterSpec(3)))</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$val failStates = nodeA.rpc.vaultQueryBy(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), contractStateType = FailedCheckState::class.java, paging = PageSpecification(1, 100), sorting = Sort(columns = emptyList())).states</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$val pendingStates = nodeA.rpc.vaultQueryBy(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), contractStateType = ScheduledCheckState::class.java, paging = PageSpecification(1, 100), sorting = Sort(columns = emptyList())).states</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$val pendingStatesAfterClean = nodeA.rpc.vaultQueryBy(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), contractStateType = ScheduledCheckState::class.java, paging = PageSpecification(1, 100), sorting = Sort(columns = emptyList())).states</ID>
    <ID>MaxLineLength:TestNotaryTypes.kt$TestNotaryTypes$val successStates = nodeA.rpc.vaultQueryBy(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), contractStateType = SuccessfulCheckState::class.java, paging = PageSpecification(1, 100), sorting = Sort(columns = emptyList())).states</ID>
    <ID>MaxLineLength:TestResponseFlowInIsolation.kt$TestResponseFlowInIsolation$private val network: MockNetwork = MockNetwork(MockNetworkParameters(cordappsForAllNodes = cordappsForPackages("com.template")))</ID>
    <ID>MaxLineLength:TestResponseFlowInIsolation.kt$TestResponseFlowInIsolation$val initiatedResponderFlowFuture = b.registerInitiatedFlow(BadInitiator::class.java, Responder::class.java).toFuture()</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertEquals(1, pendingChecks.states.size, "Expected exactly 1 pending (scheduled check), got ${pendingChecks.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertEquals(1, scheduledStates.states.size, "Expected exactly 1 pending (scheduled check), got ${scheduledStates.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(abandonedStates.states.isEmpty(), "Not expecting any abandoned checks, got ${abandonedStates.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(abandonedStates.states.isNotEmpty(), "Expected at least 1 abandoned check by now, got ${abandonedStates.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(failedStates.states.size &gt; 1, "Expected at least 2 failed checks by now, got ${failedStates.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(pendingChecksAfterCleanUp.states.isEmpty(), "Expected all pending checks to be removed, got ${pendingChecksAfterCleanUp.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(startedChecks.states.size &gt; 1, "Expected at least 2 started/running checks by now, got ${startedChecks.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(successfulChecks.states.isEmpty(), "Not expecting any successful checks, got ${successfulChecks.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$assertTrue(successfulChecks.states.size &gt; 1, "Expected at least 2 successful checks by now, got ${successfulChecks.states.size}")</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$cordappsForAllNodes = listOf(findCordapp("net.corda.notaryhealthcheck.contract"), findCordapp("net.corda.notaryhealthcheck.cordapp"))</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$nodeA.services.vaultService.queryBy&lt;SchedulingContract.ScheduledCheckState&gt;(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED))</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target, emptyList(), Instant.now().plusSeconds(1), Instant.MIN, 1, 2, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target, emptyList(), Instant.now().plusSeconds(1), Instant.MIN, 2, 5, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$nodeA.startFlow(InstallCheckScheduleStateFlow(listOf(nodeA.info.legalIdentities.first()), target, emptyList(), Instant.now().plusSeconds(1), lastSuccessTime, 2, 5, UniqueIdentifier(null)))</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$val pendingChecks = nodeA.services.vaultService.queryBy&lt;SchedulingContract.ScheduledCheckState&gt;(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED))</ID>
    <ID>MaxLineLength:TestScheduleCheckFlow.kt$TestScheduleCheckFlow$val successfulChecks = nodeA.services.vaultService.queryBy&lt;SchedulingContract.SuccessfulCheckState&gt;() val pendingChecks = nodeA.services.vaultService.queryBy&lt;SchedulingContract.ScheduledCheckState&gt;(criteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED)) assertTrue(successfulChecks.states.size &gt; 1, "Expected at least 2 successful checks by now, got ${successfulChecks.states.size}") // sort all successful states, get the second to last one and take it's finish time - that will be the last recorded success. The last one will be // handled the next time the scheduled state is run as it was started in the last run and finished after scheduling // the current pending state. val lastSuccessTime = successfulChecks.states.map { it.state.data.finishTime }.sorted().dropLast(1).last() assertEquals(1, pendingChecks.states.size, "Expected exactly 1 pending (scheduled check), got ${pendingChecks.states.size}") assertEquals(lastSuccessTime, pendingChecks.states.first().state.data.lastSuccessTime)</ID>
    <ID>MaxLineLength:TestTrustManagerFactoryWrapper.kt$TestTrustManagerFactoryWrapper$val signingCertificateStore = CertificateStoreStubs.Signing.withCertificatesDirectory(temporaryFolder.root.toPath())</ID>
    <ID>MaxLineLength:TestTrustManagerFactoryWrapper.kt$TestTrustManagerFactoryWrapper$val sslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(temporaryFolder.root.toPath(), keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:TestTrustManagerFactoryWrapper.kt$TestTrustManagerFactoryWrapper$wrapped.init(initialiseTrustStoreAndEnableCrlChecking(config.p2pSslOptions.trustStore.get(), RevocationConfigImpl(RevocationConfig.Mode.HARD_FAIL)))</ID>
    <ID>MaxLineLength:TestUtils.kt$@Deprecated("Returned port is not guaranteed to be free when used, which can result in flaky tests. Instead use a port " + "range that's unlikely to be used by the rest of the system, such as PortAllocation.Incremental(10000).")</ID>
    <ID>MaxLineLength:TestUtils.kt$TestIdentity$@JvmOverloads</ID>
    <ID>MaxLineLength:TestUtils.kt$TestIdentity.Companion$ @JvmStatic @JvmOverloads fun fresh(organisation: String, signatureScheme: SignatureScheme = Crypto.DEFAULT_SIGNATURE_SCHEME): TestIdentity</ID>
    <ID>MaxLineLength:TestUtils.kt$internal fun &lt;VALUE&gt; extractValueWithErrors(errors: Set&lt;Configuration.Validation.Error&gt;)</ID>
    <ID>MaxLineLength:TestUtils.kt$net.corda.testing.core.TestUtils.kt</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory : BindableNamedCacheFactorySingletonSerializeAsToken</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy : InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy$internal</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.Companion$return Proxy.newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.Companion$val handler = ThreadContextAdjustingRpcOpsProxy.ThreadContextAdjustingInvocationHandler(delegate, classLoader)</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.ThreadContextAdjustingInvocationHandler$private</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer : Proxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer$override fun fromProxy(proxy: StackTraceElementProxy): StackTraceElement</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer$override fun toProxy(obj: StackTraceElement): StackTraceElementProxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer.StackTraceElementProxy$@KeepForDJVM data</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer : Proxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$if (this.javaClass.name != proxy.exceptionClass) this.originalExceptionClassName = proxy.exceptionClass</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$logger.warn("Unexpected exception de-serializing throwable: ${proxy.exceptionClass}. Converting to CordaRuntimeException.", e)</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(StackTraceElementSerializer(factory))</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer$return ThrowableProxy(obj.javaClass.name, message, stackTraceToInclude, obj.cause, obj.suppressed, extraProperties)</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer${ try { // TODO: This will need reworking when we have multiple class loaders val clazz = Class.forName(proxy.exceptionClass, false, factory.classloader) // If it is CordaException or CordaRuntimeException, we can seek any constructor and then set the properties // Otherwise we just make a CordaRuntimeException if (CordaThrowable::class.java.isAssignableFrom(clazz) &amp;&amp; Throwable::class.java.isAssignableFrom(clazz)) { val typeInformation = factory.getTypeInformation(clazz) val constructor = typeInformation.constructor val params = constructor.parameters.map { parameter -&gt; proxy.additionalProperties[parameter.name] ?: proxy.additionalProperties[parameter.name.capitalize()] } val throwable = constructor.observedMethod.newInstance(*params.toTypedArray()) (throwable as CordaThrowable).apply { if (this.javaClass.name != proxy.exceptionClass) this.originalExceptionClassName = proxy.exceptionClass this.setMessage(proxy.message) this.setCause(proxy.cause) this.addSuppressed(proxy.suppressed) } return (throwable as Throwable).apply { this.stackTrace = proxy.stackTrace } } } catch (e: Exception) { logger.warn("Unexpected exception de-serializing throwable: ${proxy.exceptionClass}. Converting to CordaRuntimeException.", e) } // If the criteria are not met or we experience an exception constructing the exception, we fall back to our own unchecked exception. return CordaRuntimeException(proxy.exceptionClass, null, null).apply { this.setMessage(proxy.message) this.setCause(proxy.cause) this.stackTrace = proxy.stackTrace this.addSuppressed(proxy.suppressed) } }</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun fromOnly(fromTime: Instant): TimeWindow</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun fromStartAndDuration(fromTime: Instant, duration: Duration): TimeWindow</ID>
    <ID>MaxLineLength:TimeWindow.kt$TimeWindow.Companion$ @JvmStatic fun untilOnly(untilTime: Instant): TimeWindow</ID>
    <ID>MaxLineLength:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests$assertEquals(stepsCount, flowHandle.stepsTreeFeed!!.snapshot.size, "Expected progress tracker to return the last step")</ID>
    <ID>MaxLineLength:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests$assertThat(setOf(doneIndexStepFromSnapshot, doneIndexFromUpdates)).contains(doneIndex).withFailMessage("Expected the last step to be reached")</ID>
    <ID>MaxLineLength:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests$val nodeAHandle = startNode(providedName = ALICE_NAME, rpcUsers = listOf(user), customOverrides = configOverrides).getOrThrow()</ID>
    <ID>MaxLineLength:TimedFlowMultiThreadedSMMTests.kt$TimedFlowMultiThreadedSMMTests$val user = User("test", "pwd", setOf(Permissions.startFlow&lt;TimedInitiatorFlow&gt;(), Permissions.startFlow&lt;SuperFlow&gt;()))</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTestRule$cordappsForAllNodes = listOf(cordappForClasses(TimedFlowTests.TestNotaryService::class.java), DUMMY_CONTRACTS_CORDAPP)</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTestRule$val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false))))</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTestRule${ val replicaIds = (0 until clusterSize) val serviceLegalName = CordaX500Name("Custom Notary", "Zurich", "CH") val notaryIdentity = DevIdentityGenerator.generateDistributedNotaryCompositeIdentity( replicaIds.map { mockNet.baseDirectory(mockNet.nextNodeId + it) }, serviceLegalName) val networkParameters = NetworkParametersCopier(testNetworkParameters(listOf(NotaryInfo(notaryIdentity, false)))) val notaryConfig = mock&lt;NotaryConfig&gt; { whenever(it.serviceLegalName).thenReturn(serviceLegalName) whenever(it.validating).thenReturn(false) whenever(it.className).thenReturn(TimedFlowTests.TestNotaryService::class.java.name) } val notaryNodes = (0 until clusterSize).map { mockNet.createUnstartedNode(InternalMockNodeParameters(configOverrides = { doReturn(notaryConfig).whenever(it).notary })) } val aliceNode = mockNet.createUnstartedNode( InternalMockNodeParameters( legalName = CordaX500Name("Alice", "AliceCorp", "GB"), configOverrides = { conf: NodeConfiguration -&gt; val retryConfig = FlowTimeoutConfiguration(1.seconds, 3, 1.0) doReturn(retryConfig).whenever(conf).flowTimeout } ) ) val patientNode = mockNet.createUnstartedNode( InternalMockNodeParameters( legalName = CordaX500Name("Bob", "BobCorp", "GB"), configOverrides = { conf: NodeConfiguration -&gt; val retryConfig = FlowTimeoutConfiguration(10.seconds, 3, 1.0) doReturn(retryConfig).whenever(conf).flowTimeout } ) ) // MockNetwork doesn't support notary clusters, so we create all the nodes we need unstarted, and then install the // network-parameters in their directories before they're started. val nodes = (notaryNodes + aliceNode + patientNode).map { node -&gt; networkParameters.install(mockNet.baseDirectory(node.id)) node.start() } return Triple(notaryIdentity, nodes[nodes.lastIndex - 1], nodes.last()) }</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$TestNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$private</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.Companion$/** The notary nodes don't run any consensus protocol, so 2 nodes are sufficient for the purpose of this test. */ private val globalRule = TimedFlowTestRule(2)</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService$@Suspendable override</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:TimedFlowUtils.kt$ internal fun FlowLogic&lt;*&gt;.isEnabledTimedFlow(): Boolean</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$logger.info("Testing: ServerAlgo: $serverAlgo, ClientAlgo: $clientAlgo, Suites: ${cipherSuites.toList()}, Should fail: $shouldFail")</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$val clientKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/bridge_$clientAlgo.jks", "bridgepass", "bridgepass")</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$val clientParams = SSLParameters(cipherSuites, arrayOf("TLSv1.2")) clientParams.endpointIdentificationAlgorithm = null // Reconfirm default no server name indication, use our own validator. sslParameters = clientParams useClientMode = true // We need to specify this explicitly because by default the client binds to 'localhost' and we want it to bind // to whatever &lt;hostname&gt; resolves to(as that's what the server binds to). In particular on Debian &lt;hostname&gt; // resolves to 127.0.1.1 instead of the external address of the interface, so the ssl handshake fails. bind(InetSocketAddress(InetAddress.getLocalHost(), 0))</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$val serverKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/float_$serverAlgo.jks", "floatpass", "floatpass")</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$val trustStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/trust.jks", "trustpass", "trustpass")</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest.Companion$arrayOf("ec", "ec", CIPHER_SUITES_ALL, false)</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest.Companion$arrayOf("ec", "ec", CIPHER_SUITES_JUST_EC, false)</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest.Companion$arrayOf("ec", "ec", CIPHER_SUITES_JUST_RSA, true)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$logger.info("Testing: ServerAlgo: $serverAlgo, ClientAlgo: $clientAlgo, Suites: $cipherSuites, Server protocols: $serverProtocols, Client protocols: $clientProtocols, Should fail: $shouldFail")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val clientKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/bridge_$clientAlgo.jks", "bridgepass", "bridgepass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val clientParams = SSLParameters(cipherSuites.algos, clientProtocols.versions) clientParams.endpointIdentificationAlgorithm = null // Reconfirm default no server name indication, use our own validator. // SNI Client setup clientParams.serverNames = listOf(SNIHostName(sniServerName)) sslParameters = clientParams useClientMode = true // We need to specify this explicitly because by default the client binds to 'localhost' and we want it to bind // to whatever &lt;hostname&gt; resolves to(as that's what the server binds to). In particular on Debian &lt;hostname&gt; // resolves to 127.0.1.1 instead of the external address of the interface, so the ssl handshake fails. bind(InetSocketAddress(InetAddress.getLocalHost(), 0))</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val serverKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/float_$serverAlgo.jks", "floatpass", "floatpass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val trustStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/trust.jks", "trustpass", "trustpass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$@Parameterized.Parameters(name = "ServerAlgo: {0}, ClientAlgo: {1}, CipherSuites: {2}, Should fail: {3}, ServerProtocols: {4}, ClientProtocols: {5}")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.BOTH, Companion.TlsProtocols.BOTH)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.BOTH, Companion.TlsProtocols.ONE_2)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.ONE_2, Companion.TlsProtocols.BOTH)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.ONE_3, Companion.TlsProtocols.ONE_3)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, true, Companion.TlsProtocols.ONE_3, Companion.TlsProtocols.ONE_2)</ID>
    <ID>MaxLineLength:ToggleField.kt$InheritableThreadLocalToggleField$private val isAGlobalThreadBeingCreated: (Array&lt;StackTraceElement&gt;) -&gt; Boolean</ID>
    <ID>MaxLineLength:ToggleField.kt$InheritableThreadLocalToggleField.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:ToggleField.kt$ThreadLeakException : RuntimeException</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$// If ThreadLeakException is seen in practice, these warnings form a trail of where the holder has been: verify(log).warn(argThat { contains(leakedThreadName) &amp;&amp; contains("hello") }) val newThreadName = fork { Thread.currentThread().name }.getOrThrow() val future = fork(field::get) assertThatThrownBy { future.getOrThrow() } .isInstanceOf(ThreadLeakException::class.java) .hasMessageContaining(newThreadName) .hasMessageContaining("hello") fork { verifyNoMoreInteractions(log) withSingleThreadExecutor { verify(log).warn(argThat { contains(newThreadName) &amp;&amp; contains("hello") }) } }.getOrThrow()</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$isAGlobalThreadBeingCreated || (e.className == companionName &amp;&amp; e.methodName == "globalThreadCreationMethod")</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$listOf(SimpleToggleField&lt;String&gt;("simple"), ThreadLocalToggleField&lt;String&gt;("local"), inheritableThreadLocalToggleField())</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$private</ID>
    <ID>MaxLineLength:ToolConfig.kt$"--mode=Sign expects --sourcePath={path to blob to sign}, --signatureOutputPath={path to result signature} and --publicKeyOutputPath={path to output public key}."</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$Action.PersistCheckpoint(context.id, newCheckpoint, isCheckpointUpdate = currentState.isAnyCheckpointPersisted)</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$Action.RemoveFlow(context.id, FlowRemovalReason.OrderlyFinish(event.returnValue), currentState)</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$Action.SendExisting(state.peerParty, message, SenderDeduplicationId(deduplicationId, currentState.senderUUID))</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$freshErrorTransition(IllegalStateException("Tried to initiate in a flow not annotated with @${InitiatingFlow::class.java.simpleName}"))</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$is Event.DeliverSessionMessage -&gt; DeliverSessionMessageTransition(context, startingState, event).transition()</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$val newSessions = checkpoint.sessions + (sourceSessionId to SessionState.Uninitiated(event.destination, initiatingSubFlow, sourceSessionId, context.secureRandom.nextLong()))</ID>
    <ID>MaxLineLength:Trace.kt$Trace.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(invocationId: InvocationId = InvocationId.newInstance(), sessionId: SessionId = SessionId(invocationId.value, invocationId.timestamp))</ID>
    <ID>MaxLineLength:Trace.kt$Trace.InvocationId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:Trace.kt$Trace.SessionId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.Companion$@Synchronized private</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.Companion$return if (config != null &amp;&amp; config.enabled) TracingCacheWrapper(cache, getCollector(config.targetDir, traceName, config.converter)) else cache</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.Companion$return if (config != null &amp;&amp; config.enabled) TracingLoadingCacheWrapper(cache, getCollector(config.targetDir, traceName, config.converter)) else cache</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.TraceCollector$Thread.sleep(100)</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.TraceCollector$var firstRun = true // make sure the loop runs at least once (in case of very short lived process where the thread might be started after shutdown is initiated.</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.TracingCacheWrapper$private open</ID>
    <ID>MaxLineLength:TracingCacheWrapper.kt$CacheTracing.TracingLoadingCacheWrapper$private</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$EventSinkDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$EventStreamDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObjectPropertyDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListReadOnlyDelegate&lt;M : Any, out T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObserverDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$SubjectDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$WritableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TraderDemoClientApi.kt$TraderDemoClientApi$println("Sale completed - we have a happy customer!\n\nFinal transaction is:\n\n${Emoji.renderIfSupported(stx.tx)}")</ID>
    <ID>MaxLineLength:TraderDemoClientApi.kt$TraderDemoClientApi$val otherParty = rpc.wellKnownPartyFromX500Name(buyerName) ?: throw IllegalStateException("Don't know $buyerName")</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$TraderDemoClientApi(bank.rpc).runIssuer(amount = 100.DOLLARS, buyerName = DUMMY_BANK_A_NAME, sellerName = DUMMY_BANK_B_NAME)</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$clientBank.runIssuer(amount = 100.DOLLARS, buyerName = nodeA.services.myInfo.singleIdentity().name, sellerName = nodeB.services.myInfo.singleIdentity().name)</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$val buyer2 = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to buyer.p2pAddress.toString())).getOrThrow()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @BelongsToContract, and does not have an enclosing class which implements Contract. Either annotate </ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @Throws(MissingContractAttachments::class) fun toWireTransaction(services: ServicesForResolution): WireTransaction</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ Please contact the developer of the CorDapp and install the latest version, as this approach might be insecure.</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ fun setTimeWindow(time: Instant, timeTolerance: Duration)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectAttachmentConstraint( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, attachmentToUse: ContractAttachment, services: ServicesForResolution): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectContractAttachmentsAndOutputStateConstraints( services: ServicesForResolution, @Suppress("UNUSED_PARAMETER") serializationContext: SerializationContext? ): Pair&lt;Collection&lt;SecureHash&gt;, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$(allContractAttachments + attachments).toSortedSet().toList()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$?:</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$@CordaInternal internal</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$@Throws(AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$checkNotNull(notary) { "Need to specify a notary for the state, or set a default one on TransactionBuilder initialisation" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if (attachment == null || attachment !is ContractAttachment || !isUploaderTrusted(attachment.uploader)) { // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$inputStates != null -&gt; attachmentConstraintsTransition(inputStates.groupBy { it.constraint }.keys, attachmentToUse, services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$internal</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is CommandData -&gt; throw IllegalArgumentException("You passed an instance of CommandData, but that lacks the pubkey. You need to wrap it in a Command object first.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is ContractState -&gt; throw UnsupportedOperationException("Removed as of V1: please use a StateAndContract instead")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log.warnOnce("Signature constraints not available on network requiring a minimum platform version of 4. Current is: ${services.networkParameters.minimumPlatformVersion}.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private fun useWhitelistedByZoneAttachmentConstraint(contractClassName: ContractClassName, networkParameters: NetworkParameters)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(explicitAttachmentContracts.isEmpty() || explicitAttachmentContracts.groupBy { (ctr, _) -&gt; ctr }.all { (_, groups) -&gt; groups.size == 1 }) { "Multiple attachments set for the same contract." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$rootError is ClassNotFoundException -&gt; addMissingAttachment((rootError.message ?: throw e).replace(".", "/"), services, e)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$useWhitelistedByZoneAttachmentConstraint(contractClassName, services.networkParameters) -&gt; WhitelistedByZoneAttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val (allContractAttachments: Collection&lt;SecureHash&gt;, resolvedOutputs: List&lt;TransactionState&lt;ContractState&gt;&gt;) = selectContractAttachmentsAndOutputStateConstraints(services, serializationContext)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachment = services.attachments.openAttachment((state.constraint as HashAttachmentConstraint).attachmentId)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachmentToUse = services.attachments.openAttachment(selectedAttachmentId)?.let { it as ContractAttachment } ?: throw IllegalArgumentException("Contract attachment $selectedAttachmentId for $contractClassName is missing.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachments: Collection&lt;AttachmentId&gt; = contractAttachmentsAndResolvedOutputStates.map { it.first } + refStateContractAttachments</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val contractAttachmentsAndResolvedOutputStates: List&lt;Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;&gt; = allContracts.toSet() .map { ctr -&gt; handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val defaultOutputConstraint = selectAttachmentConstraint(contractClassName, inputStates, attachmentToUse, services)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val inputContractGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = inputsWithTransactionState.map { it.state } .groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val outputContractGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = outputs.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val referenceStateGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = referencesWithTransactionState.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedOutputStatesInTheOriginalOrder: List&lt;TransactionState&lt;ContractState&gt;&gt; = outputStates().map { os -&gt; resolvedStates.find { rs -&gt; rs.data == os.data &amp;&amp; rs.encumbrance == os.encumbrance }!! }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedStates: List&lt;TransactionState&lt;ContractState&gt;&gt; = contractAttachmentsAndResolvedOutputStates.mapNotNull { it.second } .flatten()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$when { // Sanity check. constraints.isEmpty() -&gt; throw IllegalArgumentException("Cannot transition from no constraints.") // Fail when combining the insecure AlwaysAcceptAttachmentConstraint with something else. constraints.size &gt; 1 &amp;&amp; constraints.any { it is AlwaysAcceptAttachmentConstraint } -&gt; throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.") // Multiple states with Hash constraints with different hashes. This should not happen as we checked already. constraints.size &gt; 1 &amp;&amp; constraints.all { it is HashAttachmentConstraint } -&gt; throw IllegalArgumentException("Cannot mix HashConstraints with different hashes in the same transaction.") // The HashAttachmentConstraint is the strongest constraint, so it wins when mixed with anything. As long as the actual constraints pass. // Migration from HashAttachmentConstraint to SignatureAttachmentConstraint is handled in [TransactionBuilder.handleContract] // If we have reached this point, then no migration is possible and the existing HashAttachmentConstraint must be used constraints.any { it is HashAttachmentConstraint } -&gt; constraints.find { it is HashAttachmentConstraint }!! // TODO, we don't currently support mixing signature constraints with different signers. This will change once we introduce third party signers. constraints.count { it is SignatureAttachmentConstraint } &gt; 1 -&gt; throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.") // This ensures a smooth migration from a Whitelist Constraint to a Signature Constraint constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse) // This condition is hit when the current node has not installed the latest signed version but has already received states that have been migrated constraints.any { it is SignatureAttachmentConstraint } &amp;&amp; !attachmentToUse.isSigned -&gt; throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.") // When all input states have the same constraint. constraints.size == 1 -&gt; constraints.single() else -&gt; throw IllegalArgumentException("Unexpected constraints $constraints.") }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val inputsAndOutputs = (inputStates ?: emptyList()) + (outputStates ?: emptyList()) fun selectAttachment() = getInstalledContractAttachmentId( contractClassName, inputsAndOutputs.filterNot { it.constraint in automaticConstraints }, services ) /* This block handles the very specific code path where a [HashAttachmentConstraint] can migrate to a [SignatureAttachmentConstraint]. If all the criteria is met, this function will return early as the rest of the logic is no longer required. This can only happen in a private network where all nodes have started with a system parameter that disables the hash constraint check. */ if (canMigrateFromHashToSignatureConstraint(inputStates, outputStates, services)) { val attachmentId = selectAttachment() val attachment = services.attachments.openAttachment(attachmentId) require(attachment != null) { "Contract attachment $attachmentId for $contractClassName is missing." } if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates } } // Determine if there are any HashConstraints that pin the version of a contract. If there are, check if we trust them. val hashAttachments = inputsAndOutputs .filter { it.constraint is HashAttachmentConstraint } .map { state -&gt; val attachment = services.attachments.openAttachment((state.constraint as HashAttachmentConstraint).attachmentId) if (attachment == null || attachment !is ContractAttachment || !isUploaderTrusted(attachment.uploader)) { // This should never happen because these are input states that should have been validated already. throw MissingContractAttachments(listOf(state)) } attachment }.toSet() // Check that states with the HashConstraint don't conflict between themselves or with an explicitly set attachment. require(hashAttachments.size &lt;= 1) { "Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code." } if (explicitContractAttachment != null &amp;&amp; hashAttachments.singleOrNull() != null) { require(explicitContractAttachment == (hashAttachments.single() as ContractAttachment).attachment.id) { "An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state." } } // This will contain the hash of the JAR that *has* to be used by this Transaction, because it is explicit. Or null if none. val forcedAttachmentId = explicitContractAttachment ?: hashAttachments.singleOrNull()?.id // This will contain the hash of the JAR that will be used by this Transaction. val selectedAttachmentId = forcedAttachmentId ?: selectAttachment() val attachmentToUse = services.attachments.openAttachment(selectedAttachmentId)?.let { it as ContractAttachment } ?: throw IllegalArgumentException("Contract attachment $selectedAttachmentId for $contractClassName is missing.") // For Exit transactions (no output states) there is no need to resolve the output constraints. if (outputStates == null) { return Pair(selectedAttachmentId, null) } // If there are no automatic constraints, there is nothing to resolve. if (outputStates.none { it.constraint in automaticConstraints }) { return Pair(selectedAttachmentId, outputStates) } // The final step is to resolve AutomaticPlaceholderConstraint. val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader) // When automaticConstraintPropagation is disabled for a contract, output states must an explicit Constraint. require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." } // This is the logic to determine the constraint which will replace the AutomaticPlaceholderConstraint. val defaultOutputConstraint = selectAttachmentConstraint(contractClassName, inputStates, attachmentToUse, services) // Sanity check that the selected attachment actually passes. val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations) require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" } val resolvedOutputStates = outputStates.map { val outputConstraint = it.constraint if (outputConstraint in automaticConstraints) { it.copy(constraint = defaultOutputConstraint) } else { // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it } } return Pair(selectedAttachmentId, resolvedOutputStates) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint // If there were states transitioned already used in the current transaction use that signature constraint, otherwise create a new one. return when { signatureConstraint != null -&gt; signatureConstraint else -&gt; makeSignatureAttachmentConstraint(attachmentToUse.signerKeys) } }</ID>
    <ID>MaxLineLength:TransactionBuilderTest.kt$TransactionBuilderTest$assertThat(wtx.outputs).containsOnly(outputState.copy(constraint = HashAttachmentConstraint(contractAttachmentId)))</ID>
    <ID>MaxLineLength:TransactionBuilderTest.kt$TransactionBuilderTest$private</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$ fun input(stateLabel: String)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$ fun reference(stateLabel: String)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$fun attachment(contractClassName: ContractClassName, attachmentId: AttachmentId)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$fun attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String,String&gt; = emptyMap())</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL&lt;out T : TransactionDSLInterpreter&gt; : TransactionDSLInterpreter</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String,String&gt;)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 2, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 2, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 2 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 3 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]")</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 3 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 2 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]")</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock A", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock A", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock B", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock B", encumbrance = 4, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock C", encumbrance = 5, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by 5pm time-lock", encumbrance = 1, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by itself", encumbrance = 0, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 0", encumbrance = 0, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 1", encumbrance = 1, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 2", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 3 again", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(Cash.PROGRAM_ID, "state encumbered by state 3", encumbrance = 3, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(TEST_TIMELOCK_ID, "state encumbered by state 2 which does not exist", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests${ // Single encumbrance with different notaries. assertFailsWith&lt;TransactionVerificationException.TransactionNotaryMismatchEncumbranceException&gt; { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } // More complex encumbrance (full cycle of size 4) where one of the encumbered states is assigned to a different notary. // 0 -&gt; 1, 1 -&gt; 3, 3 -&gt; 2, 2 -&gt; 0 // We expect that state at index 3 cannot be encumbered with the state at index 2, due to mismatched notaries. assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 3 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 2 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]") // Two different encumbrance chains, where only one fails due to mismatched notary. // 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2 where encumbered states with indices 2 and 3, respectively, are assigned // to different notaries. assertThatExceptionOfType(TransactionVerificationException.TransactionNotaryMismatchEncumbranceException::class.java) .isThrownBy { TransactionBuilder() .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 1, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 0, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY, 3, AutomaticPlaceholderConstraint) .addOutputState(stateWithNewOwner, Cash.PROGRAM_ID, DUMMY_NOTARY2, 2, AutomaticPlaceholderConstraint) .addCommand(Cash.Commands.Issue(), MEGA_CORP.owningKey) .toLedgerTransaction(ledgerServices) .verify() } .withMessageContaining("index 2 is assigned to notary [O=Notary Service, L=Zurich, C=CH], while its encumbrance with " + "index 3 is assigned to notary [O=Notary Service2, L=Zurich, C=CH]") }</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests.Companion$val DUMMY_NOTARY2 = TestIdentity(DUMMY_NOTARY_NAME.copy(organisation = "${DUMMY_NOTARY_NAME.organisation}2"), 30).party</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$output(PROGRAM_ID, "c1", State(1000.POUNDS `issued by` DUMMY_CASH_ISSUER, AnonymousParty(MEGA_CORP_PUBKEY)))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$output(PROGRAM_ID, "c2", State(2000.POUNDS `issued by` DUMMY_CASH_ISSUER, AnonymousParty(MEGA_CORP_PUBKEY)))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$output(PROGRAM_ID, "c3", State(3000.POUNDS `issued by` DUMMY_CASH_ISSUER, AnonymousParty(MINI_CORP_PUBKEY)))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$private val DUMMY_CASH_ISSUER_IDENTITY = getTestPartyAndCertificate(Party(CordaX500Name("Snake Oil Issuer", "London", "GB"), DUMMY_CASH_ISSUER_KEY.public))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$val contractAttachment = MockContractAttachment(interpreter.services.cordappProvider.getContractAttachmentID(PROGRAM_ID)!!, PROGRAM_ID)</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$Query</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$val unvisitedInputTxs: Map&lt;SecureHash, SignedTransaction&gt; = inputsLeadingToUnvisitedTx.map { it.txhash }.toHashSet().mapNotNull { transactions.getTransaction(it) }.associateBy { it.id }</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$val unvisitedInputTxsWithInputIndex: Iterable&lt;Pair&lt;SignedTransaction, Int&gt;&gt; = inputsLeadingToUnvisitedTx.filter { it.txhash in unvisitedInputTxs.keys }.map { Pair(unvisitedInputTxs[it.txhash]!!, it.index) }</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$GraphTransactionStorage : MockTransactionStorage</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$val search = TransactionGraphSearch(storage, listOf(storage.inputTx.tx), TransactionGraphSearch.Query(DummyContract.Commands.Create::class.java))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$inputState = StateAndRef(TransactionState(TestCash.State(depositRef, 100.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), fakeStateRef)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$tx = TransactionBuilder(DUMMY_NOTARY).withItems(inputState, outputState, changeState, Command(TestCash.Commands.Move(), arrayListOf(MEGA_CORP.owningKey)))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val changeState = TransactionState(TestCash.State(depositRef, 400.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val fakeTx = megaCorpServices.signInitialTransaction(TransactionBuilder(DUMMY_NOTARY).withItems(outputState, Command(TestCash.Commands.Issue(), arrayListOf(MEGA_CORP.owningKey))))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val megaCorpServices = object : MockServices(listOf("net.corda.coretests.serialization"), MEGA_CORP.name, mock(), testNetworkParameters(notaries = listOf(NotaryInfo(DUMMY_NOTARY, true))), MEGA_CORP_KEY) { //override mock implementation with a real one override fun loadContractAttachment(stateRef: StateRef): Attachment = servicesForResolution.loadContractAttachment(stateRef) }</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val notaryServices = MockServices(listOf("net.corda.coretests.serialization"), DUMMY_NOTARY.name, rigorousMock(), DUMMY_NOTARY_KEY)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val outputState = TransactionState(TestCash.State(depositRef, 600.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val signatures = listOf(TransactionSignature(ByteArray(1), MEGA_CORP_KEY.public, SignatureMetadata(1, Crypto.findSignatureScheme(MEGA_CORP_KEY.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests.TestCash.State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature : DigitalSignature</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$ @Throws(InvalidKeyException::class, SignatureException::class) fun verify(txId: SecureHash)</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$/** * Construct a [TransactionSignature] with [partialMerkleTree] set to null. * This is the recommended constructor when signing over a single transaction. * */ constructor(bytes: ByteArray, by: PublicKey, signatureMetadata: SignatureMetadata) : this(bytes, by, signatureMetadata, null)</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val signableData = SignableData(testBytes.sha256(), SignatureMetadata(1, Crypto.findSignatureScheme(keyPair.public).schemeNumberID))</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val signableData = SignableData(txId, SignatureMetadata(3, Crypto.findSignatureScheme(keyPair.public).schemeNumberID))</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val txSignatureWithFullTree = TransactionSignature(txSignature.bytes, txSignature.by, txSignature.signatureMetadata, pmtFull)</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest$val txSignatureWithTree = TransactionSignature(txSignature.bytes, txSignature.by, txSignature.signatureMetadata, pmt)</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest${ val keyPair = Crypto.deriveKeyPairFromEntropy(Crypto.EDDSA_ED25519_SHA512, BigInteger.valueOf(1234567890L)) val txId = "aTransaction".toByteArray().sha256() // One-tx signature. val txSignature = signOneTx(txId, keyPair) // partialMerkleTree should be null. assertNull(txSignature.partialMerkleTree) // Verify the corresponding txId with every possible way. assertTrue(Crypto.doVerify(txId, txSignature)) assertTrue(txSignature.verify(txId)) assertTrue(Crypto.isValid(txId, txSignature)) assertTrue(txSignature.isValid(txId)) // We signed the txId itself, not its hash (because it was a signature over one tx only and no partial tree has been received). assertFailsWith&lt;SignatureException&gt; { Crypto.doVerify(txId.sha256(), txSignature) } }</ID>
    <ID>MaxLineLength:TransactionSignatureTest.kt$TransactionSignatureTest${ val txId = "aTransaction".toByteArray().sha256() // One-tx signature. val txSignature = try { signOneTx(txId, keyPair) } catch (e: Throwable) { e.cause?.printStackTrace() throw e } // partialMerkleTree should be null. assertNull(txSignature.partialMerkleTree) // Verify the corresponding txId with every possible way. assertTrue(Crypto.doVerify(txId, txSignature)) assertTrue(txSignature.verify(txId)) assertTrue(Crypto.isValid(txId, txSignature)) assertTrue(txSignature.isValid(txId)) // We signed the txId itself, not its hash (because it was a signature over one tx only and no partial tree has been received). assertFailsWith&lt;SignatureException&gt; { Crypto.doVerify(txId.sha256(), txSignature) } }</ID>
    <ID>MaxLineLength:TransactionState.kt$TransactionState$ @BelongsToContract, and does not have an enclosing class which implements Contract. Either annotate </ID>
    <ID>MaxLineLength:TransactionState.kt$TransactionState$/** * All contract states may be _encumbered_ by up to one other state. * * The encumbrance state, if present, forces additional controls over the encumbered state, since the platform checks * that the encumbrance state is present as an input in the same transaction that consumes the encumbered state, and * the contract code and rules of the encumbrance state will also be verified during the execution of the transaction. * For example, a cash contract state could be encumbered with a time-lock contract state; the cash state is then only * processable in a transaction that verifies that the time specified in the encumbrance time-lock has passed. * * The encumbered state refers to another by index, and the referred encumbrance state * is an output state in a particular position on the same transaction that created the encumbered state. An alternative * implementation would be encumbering by reference to a [StateRef], which would allow the specification of encumbrance * by a state created in a prior transaction. * * Note that an encumbered state that is being consumed must have its encumbrance consumed in the same transaction, * otherwise the transaction is not valid. */ val encumbrance: Int? = null</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_CASH_ISSUER_KEY).verifySignaturesExcept(DUMMY_KEY_1.public) }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_1).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_1, ak).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_2).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;TransactionVerificationException.NotaryChangeInWrongTransactionType&gt; { buildTransaction().verify() }</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$keySigs + DUMMY_NOTARY_KEY.sign(SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(DUMMY_NOTARY_KEY.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$makeSigned(wtx, DUMMY_KEY_1, ak).verifySignaturesExcept(compKey, DUMMY_KEY_2.public)</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val baseOutState = TransactionState(DummyContract.SingleOwnerState(0, ALICE), DummyContract.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val keySigs = keys.map { it.sign(SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(it.public).schemeNumberID))) }</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val outputState = TransactionState(DummyContract.SingleOwnerState(0, ALICE), DummyContract.PROGRAM_ID, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>MaxLineLength:TransactionUtils.kt$"Invalid Transaction. Sizes of CommandData (${commandDataList.size}) and Signers (${signersList.size}) do not match"</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ContractUpgradeTransactionBuilder$val components = listOf(inputs, notary, legacyContractAttachmentId, upgradedContractClassName, upgradedContractAttachmentId, networkParametersHash).map { it.serialize() }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$SerializedStateAndRef$@KeepForDJVM data</ID>
    <ID>MaxLineLength:TransactionUtils.kt$check(leafIndices.max()!! &lt; signersList.size) { "Invalid Transaction. A command with no corresponding signer detected" }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (attachments.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.ATTACHMENTS_GROUP.ordinal, attachments.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.COMMANDS_GROUP.ordinal, commands.map { it.value }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.SIGNERS_GROUP.ordinal, commands.map { it.signers }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (inputs.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.INPUTS_GROUP.ordinal, inputs.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (networkParametersHash != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.PARAMETERS_GROUP.ordinal, listOf(networkParametersHash.serialize())))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (notary != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.NOTARY_GROUP.ordinal, listOf(notary).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (outputs.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.OUTPUTS_GROUP.ordinal, outputs.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (references.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.REFERENCES_GROUP.ordinal, references.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (timeWindow != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.TIMEWINDOW_GROUP.ordinal, listOf(timeWindow).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash")</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val commandDataList: List&lt;CommandData&gt; = deserialiseComponentGroup(componentGroups, CommandData::class, ComponentGroupEnum.COMMANDS_GROUP, forceDeserialize)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val componentHashes = group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val signersList: List&lt;List&lt;PublicKey&gt;&gt; = uncheckedCast(deserialiseComponentGroup(componentGroups, List::class, ComponentGroupEnum.SIGNERS_GROUP, forceDeserialize))</ID>
    <ID>MaxLineLength:TransactionUtils.kt${ // Transactions created on Corda 3.x or below do not contain network parameters, // so no checking is done until the minimum platform version is at least 4. if (networkParametersHash == null) { if (serviceHub.networkParameters.minimumPlatformVersion &lt; 4) return else throw IllegalArgumentException("Transaction for notarisation doesn't contain network parameters hash.") } else { serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash") } // TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay. // We will never end up in perfect synchronization with all the nodes. However, network parameters update process // lets us predict what is the reasonable time window for changing parameters on most of the nodes. // For now we don't check whether the attached network parameters match the current ones. }</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionResolutionException$@KeepForDJVM open</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConflictingAttachmentsRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConstraintPropagationRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ContractCreationError : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ContractRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$Direction</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$InvalidAttachmentException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$InvalidNotaryChange : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$MissingAttachmentRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$MissingNetworkParametersException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$NotaryChangeInWrongTransactionType : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$OverlappingAttachmentsException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$PackageOwnershipException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$SignersMissing : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionContractConflictException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionNetworkParameterOrderingException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionNotaryMismatchEncumbranceException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$UntrustedAttachmentsException : CordaException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException${ /** * Indicates that one of the [Contract.verify] methods selected by the contract constraints and attachments * rejected the transaction by throwing an exception. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractRejection internal constructor(txId: SecureHash, val contractClass: String, cause: Throwable?, message: String) : TransactionVerificationException(txId, "Contract verification failed: $message, contract: $contractClass", cause) { internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "") } /** * This exception happens when a transaction was not built correctly. * When a contract is not annotated with [NoConstraintPropagation], then the platform ensures that the constraints of output states transition correctly from input states. * * @property txId The transaction. * @property contractClass The fully qualified class name of the failing contract. * @property inputConstraint The constraint of the input state. * @property outputConstraint The constraint of the outputs state. */ @KeepForDJVM class ConstraintPropagationRejection(txId: SecureHash, val contractClass: String, inputConstraint: AttachmentConstraint, outputConstraint: AttachmentConstraint) : TransactionVerificationException(txId, "Contract constraints for $contractClass are not propagated correctly. The outputConstraint: $outputConstraint is not a valid transition from the input constraint: $inputConstraint.", null) /** * The transaction attachment that contains the [contractClass] class didn't meet the constraints specified by * the [TransactionState.constraint] object. This usually implies a version mismatch of some kind. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractConstraintRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed for $contractClass", null) /** * A state requested a contract class via its [TransactionState.contract] field that didn't appear in any attached * JAR at all. This usually implies the attachments were forgotten or a version mismatch. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class MissingAttachmentRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed, could not find attachment for: $contractClass", null) /** * Indicates this transaction violates the "no overlap" rule: two attachments are trying to provide the same file * path. Whereas Java classpaths would normally allow that with the first class taking precedence, this is not * allowed in transactions for security reasons. This usually indicates that two separate apps share a dependency, * in which case you could try 'shading the fat jars' to rename classes of dependencies. Or you could manually * attach dependency JARs when building the transaction. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ConflictingAttachmentsRejection(txId: SecureHash, val contractClass: String) : TransactionVerificationException(txId, "Contract constraints failed for: $contractClass, because multiple attachments providing this contract were attached.", null) /** * Indicates that the same attachment has been added multiple times to a transaction. */ @KeepForDJVM class DuplicateAttachmentsRejection(txId: SecureHash, val attachmentId: Attachment) : TransactionVerificationException(txId, "The attachment: $attachmentId was added multiple times.", null) /** * A [Contract] class named by a state could not be constructed. Most likely you do not have a no-argument * constructor, or the class doesn't subclass [Contract]. * * @property contractClass The fully qualified class name of the failing contract. */ @KeepForDJVM class ContractCreationError internal constructor(txId: SecureHash, val contractClass: String, cause: Throwable?, message: String) : TransactionVerificationException(txId, "Contract verification failed: $message, could not create contract class: $contractClass", cause) { internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "") } /** * An output state has a notary that doesn't match the transaction's notary field. It must! * * @property txNotary the [Party] specified by the transaction header. * @property outputNotary the [Party] specified by the errant state. */ @KeepForDJVM class NotaryChangeInWrongTransactionType(txId: SecureHash, val txNotary: Party, val outputNotary: Party) : TransactionVerificationException(txId, "Found unexpected notary change in transaction. Tx notary: $txNotary, found: $outputNotary", null) /** * If a state is encumbered (the [TransactionState.encumbrance] field is set) then its encumbrance must be used * as an input to any transaction that uses it. In this way states can be tied together in chains, thus composing * logic. Note that encumbrances aren't fully supported by all aspects of the platform at this time so if you use * them, you may find transactions created by the platform don't always respect the encumbrance rule. * * @property missing the index of the state missing the encumbrance. * @property inOut whether the issue exists in the input list or output list. */ @KeepForDJVM class TransactionMissingEncumbranceException(txId: SecureHash, val missing: Int, val inOut: Direction) : TransactionVerificationException(txId, "Missing required encumbrance $missing in $inOut", null) /** * If two or more states refer to another state (as their encumbrance), then the bi-directionality property cannot * be satisfied. */ @KeepForDJVM class TransactionDuplicateEncumbranceException(txId: SecureHash, index: Int) : TransactionVerificationException(txId, "The bi-directionality property of encumbered output states " + "is not satisfied. Index $index is referenced more than once", null) /** * An encumbered state should also be referenced as the encumbrance of another state in order to satisfy the * bi-directionality property (a full cycle should be present). */ @KeepForDJVM class TransactionNonMatchingEncumbranceException(txId: SecureHash, nonMatching: Collection&lt;Int&gt;) : TransactionVerificationException(txId, "The bi-directionality property of encumbered output states " + "is not satisfied. Encumbered states should also be referenced as an encumbrance of another state to form " + "a full cycle. Offending indices $nonMatching", null) /** * All encumbered states should be assigned to the same notary. This is due to the fact that multi-notary * transactions are not supported and thus two encumbered states with different notaries cannot be consumed * in the same transaction. */ @KeepForDJVM class TransactionNotaryMismatchEncumbranceException(txId: SecureHash, encumberedIndex: Int, encumbranceIndex: Int, encumberedNotary: Party, encumbranceNotary: Party) : TransactionVerificationException(txId, "Encumbered output states assigned to different notaries found. " + "Output state with index $encumberedIndex is assigned to notary [$encumberedNotary], while its encumbrance with index $encumbranceIndex is assigned to notary [$encumbranceNotary]", null) /** * If a state is identified as belonging to a contract, either because the state class is defined as an inner class * of the contract class or because the state class is annotated with [BelongsToContract], then it must not be * bundled in a [TransactionState] with a different contract. * * @param state The [TransactionState] whose bundled state and contract are in conflict. * @param requiredContractClassName The class name of the contract to which the state belongs. */ @KeepForDJVM class TransactionContractConflictException(txId: SecureHash, state: TransactionState&lt;ContractState&gt;, requiredContractClassName: String) : TransactionVerificationException(txId, """ State of class ${state.data::class.java.typeName} belongs to contract $requiredContractClassName, but is bundled in TransactionState with ${state.contract}. For details see: https://docs.corda.net/api-contract-constraints.html#contract-state-agreement """.trimIndent().replace('\n', ' '), null) // TODO: add reference to documentation @KeepForDJVM class TransactionRequiredContractUnspecifiedException(txId: SecureHash, state: TransactionState&lt;ContractState&gt;) : TransactionVerificationException(txId, """ State of class ${state.data::class.java.typeName} does not have a specified owning contract. Add the @BelongsToContract annotation to this class to ensure that it can only be bundled in a TransactionState with the correct contract. For details see: https://docs.corda.net/api-contract-constraints.html#contract-state-agreement """.trimIndent(), null) /** * If the network parameters associated with an input or reference state in a transaction are more recent than the network parameters of the new transaction itself. */ @KeepForDJVM class TransactionNetworkParameterOrderingException(txId: SecureHash, inputStateRef: StateRef, txnNetworkParameters: NetworkParameters, inputNetworkParameters: NetworkParameters) : TransactionVerificationException(txId, "The network parameters epoch (${txnNetworkParameters.epoch}) of this transaction " + "is older than the epoch (${inputNetworkParameters.epoch}) of input state: $inputStateRef", null) /** * Thrown when the network parameters with hash: missingNetworkParametersHash is not available at this node. Usually all the parameters * that are in the resolution chain for transaction with txId should be fetched from peer via [FetchParametersFlow] or from network map. * * @param txId Id of the transaction that has missing parameters hash in the resolution chain * @param missingNetworkParametersHash Missing hash of the network parameters associated to this transaction */ @KeepForDJVM class MissingNetworkParametersException(txId: SecureHash, missingNetworkParametersHash: SecureHash) : TransactionVerificationException(txId, "Couldn't find network parameters with hash: $missingNetworkParametersHash related to this transaction: $txId", null) /** Whether the inputs or outputs list contains an encumbrance issue, see [TransactionMissingEncumbranceException]. */ @CordaSerializable @KeepForDJVM enum class Direction { /** Issue in the inputs list. */ INPUT, /** Issue in the outputs list. */ OUTPUT } // We could revisit and throw this more appropriate type in a future release that uses targetVersion to // avoid the compatibility break, because IllegalStateException isn't ideal for this. Or we could use this // as a cause. /** @suppress This class is not used: duplicate inputs throw a [IllegalStateException] instead. */ @Deprecated("This class is not used: duplicate inputs throw a [IllegalStateException] instead.") @DeleteForDJVM class DuplicateInputStates(txId: SecureHash, val duplicates: NonEmptySet&lt;StateRef&gt;) : TransactionVerificationException(txId, "Duplicate inputs: ${duplicates.joinToString()}", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class MoreThanOneNotary(txId: SecureHash) : TransactionVerificationException(txId, "More than one notary", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class SignersMissing(txId: SecureHash, val missing: List&lt;PublicKey&gt;) : TransactionVerificationException(txId, "Signers missing: ${missing.joinToString()}", null) /** @suppress This class is obsolete and nothing has ever used it. */ @Deprecated("This class is obsolete and nothing has ever used it.") @DeleteForDJVM class InvalidNotaryChange(txId: SecureHash) : TransactionVerificationException(txId, "Detected a notary change. Outputs must use the same notary as inputs", null) /** * Thrown when multiple attachments provide the same file when building the AttachmentsClassloader for a transaction. */ @KeepForDJVM class OverlappingAttachmentsException(txId: SecureHash, val path: String) : TransactionVerificationException(txId, "Multiple attachments define a file at $path.", null) /** * Thrown to indicate that a contract attachment is not signed by the network-wide package owner. Please note that * the [txId] will always be [SecureHash.zeroHash] because package ownership is an error with a particular attachment, * and because attachment classloaders are reused this is independent of any particular transaction. */ class PackageOwnershipException(txId: SecureHash, @Suppress("unused") val attachmentHash: AttachmentId, @Suppress("unused") val invalidClassName: String, val packageName: String) : TransactionVerificationException(txId, """The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters""".trimIndent(), null) class InvalidAttachmentException(txId: SecureHash, @Suppress("unused") val attachmentHash: AttachmentId) : TransactionVerificationException(txId, "The attachment $attachmentHash is not a valid ZIP or JAR file.".trimIndent(), null) // TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized. /** Thrown during classloading upon encountering an untrusted attachment (eg. not in the [TRUSTED_UPLOADERS] list) */ @KeepForDJVM class UntrustedAttachmentsException(val txId: SecureHash, val ids: List&lt;SecureHash&gt;) : CordaException("Attempting to load untrusted transaction attachments: $ids. " + "At this time these are not loadable because the DJVM sandbox has not yet been integrated. " + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") /* If you add a new class extending [TransactionVerificationException], please add a test in `TransactionVerificationExceptionSerializationTests` proving that it can actually be serialised. As a rule, exceptions intended to be serialised _must_ have a corresponding readable property for every named constructor parameter - so make your constructor parameters `val`s even if nothing other than the serializer is ever going to read them. */ }</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractCreationError$internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractRejection$internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$ Please check the source of this attachment and if it is malicious contact your zone operator to report this incident.</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$"""The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters"""</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNonMatchingEncumbranceException$"is not satisfied. Encumbered states should also be referenced as an encumbrance of another state to form "</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionNotaryMismatchEncumbranceException$"Output state with index $encumberedIndex is assigned to notary [$encumberedNotary], while its encumbrance with index $encumbranceIndex is assigned to notary [$encumbranceNotary]"</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$ Add the @BelongsToContract annotation to this class to ensure that it can only be bundled in a TransactionState</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.UntrustedAttachmentsException$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$net.corda.core.contracts.TransactionVerificationException.kt</ID>
    <ID>MaxLineLength:TransactionVerificationExceptionSerialisationTests.kt$TransactionVerificationExceptionSerialisationTests$val exception = TransactionVerificationException.NotaryChangeInWrongTransactionType(txid, dummyBankA, dummyNotary)</ID>
    <ID>MaxLineLength:TransactionVerificationRequest.kt$TransactionVerificationRequest$@Suppress("MemberVisibilityCanBePrivate") //TODO the use of deprecated toLedgerTransaction need to be revisited as resolveContractAttachment requires attachments of the transactions which created input states... //TODO ...to check contract version non downgrade rule, curretly dummy Attachment if not fund is used which sets contract version to '1' @CordaSerializable</ID>
    <ID>MaxLineLength:TransactionVerificationRequest.kt$TransactionVerificationRequest$attachments .mapNotNull { it as? MockContractAttachment } .associateBy(Attachment::id) { ContractAttachment(it, it.contract, uploader = DEPLOYED_CORDAPP_UPLOADER) }</ID>
    <ID>MaxLineLength:TransactionVerifierService.kt$TransactionVerifierService$ fun verify(transaction: LedgerTransaction): CordaFuture&lt;*&gt;</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ State of class </ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun validateStatesAgainstContract()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraints(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$?:</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$checkMinimumPlatformVersion(ltx.networkParameters?.minimumPlatformVersion ?: 1, 4, "Signature constraints")</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$contractAttachmentsPerContract .groupBy { it.first } // Group by contract. .filter { (_, attachments) -&gt; attachments.size &gt; 1 }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (contractWithMultipleAttachments != null) throw TransactionVerificationException.ConflictingAttachmentsRejection(ltx.id, contractWithMultipleAttachments)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (ltx.attachments.size != ltx.attachments.toSet().size) throw TransactionVerificationException.DuplicateAttachmentsRejection(ltx.id, ltx.attachments.groupBy { it }.filterValues { it.size &gt; 1 }.keys.first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (result.keys != contractClasses) throw TransactionVerificationException.MissingAttachmentRejection(ltx.id, contractClasses.minus(result.keys).first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$throw TransactionVerificationException.NotaryChangeInWrongTransactionType(ltx.id, ltx.notary, it.notary)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$throw TransactionVerificationException.TransactionNonMatchingEncumbranceException(ltx.id, symmetricDifference)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val constraintAttachment = AttachmentWithContext(contractAttachment, contract, ltx.networkParameters!!.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val inputConstraints = (inputContractGroups[contractClassName] ?: emptyList()).map { it.state.constraint }.toSet()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val outputConstraints = (outputContractGroups[contractClassName] ?: emptyList()).map { it.constraint }.toSet()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ // checkNoNotaryChange and checkEncumbrancesValid are called here, and not in the c'tor, as they need access to the "outputs" // list, the contents of which need to be deserialized under the correct classloader. checkNoNotaryChange() checkEncumbrancesValid() // The following checks ensure the integrity of the current transaction and also of the future chain. // See: https://docs.corda.net/head/api-contract-constraints.html // A transaction contains both the data and the code that must be executed to validate the transition of the data. // Transactions can be created by malicious adversaries, who can try to use code that allows them to create transactions that appear valid but are not. // 1. Check that there is one and only one attachment for each relevant contract. val contractAttachmentsByContract = getUniqueContractAttachmentsByContract() // 2. Check that the attachments satisfy the constraints of the states. (The contract verification code is correct.) verifyConstraints(contractAttachmentsByContract) // 3. Check that the actual state constraints are correct. This is necessary because transactions can be built by potentially malicious nodes // who can create output states with a weaker constraint which can be exploited in a future transaction. verifyConstraintsValidity(contractAttachmentsByContract) // 4. Check that the [TransactionState] objects are correctly formed. validateStatesAgainstContract() // 5. Final step is to run the contract code. After the first 4 steps we are now sure that we are running the correct code. verifyContracts() }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ if (!contractClassName.contractHasAutomaticConstraintPropagation(transactionClassLoader)) { contractClassName.warnContractWithoutConstraintPropagation() continue } val contractAttachment = contractAttachmentsByContract[contractClassName]!! // Verify that the constraints of output states have at least the same level of restriction as the constraints of the // corresponding input states. val inputConstraints = (inputContractGroups[contractClassName] ?: emptyList()).map { it.state.constraint }.toSet() val outputConstraints = (outputContractGroups[contractClassName] ?: emptyList()).map { it.constraint }.toSet() outputConstraints.forEach { outputConstraint -&gt; inputConstraints.forEach { inputConstraint -&gt; if (!(outputConstraint.canBeTransitionedFrom(inputConstraint, contractAttachment))) { throw TransactionVerificationException.ConstraintPropagationRejection( ltx.id, contractClassName, inputConstraint, outputConstraint) } } } }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$ private fun calculateTotalEquiv(myIdentity: Party?, reportingCurrencyExchange: Pair&lt;Currency, (Amount&lt;Currency&gt;) -&gt; Amount&lt;Currency&gt;&gt;, inputs: List&lt;ContractState&gt;, outputs: List&lt;ContractState&gt;): AmountDiff&lt;Currency&gt;</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$"Input Party" to { tx, s -&gt; tx.inputParties.any { it.any { it.value?.name?.organisation?.contains(s, true) == true } } }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$"Output Party" to { tx, s -&gt; tx.outputParties.any { it.any { it.value?.name?.organisation?.contains(s, true) == true } } }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$// Column stays the same size, but we don't violate column restricted resize policy for the whole table view. // It removes that irritating column at the end of table that does nothing. minWidth = 26.0 maxWidth = 26.0</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$Inputs</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$Outputs</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$Transaction</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private fun ObservableList&lt;StateAndRef&lt;ContractState&gt;&gt;.getParties()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private fun ObservableList&lt;StateAndRef&lt;ContractState&gt;&gt;.toText()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$val commands = if (it.transaction.coreTransaction is WireTransaction) it.transaction.tx.commands else emptyList()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$copyableLabel(party.map { "${signature.toStringShort()} (${it?.let { PartyNameFormatter.short.format(it.name) } ?: "Anonymous"})" })</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$label</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$val issuer: AbstractParty = anonymousIssuer.owningKey.toKnownParty().value ?: anonymousIssuer</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.TransactionWidget$private val partiallyResolvedTransactions by observableListReadOnly(TransactionDataModel::partiallyResolvedTransactions)</ID>
    <ID>MaxLineLength:TransactionViewer.kt$outputs.mapNotNull { it as? Cash.State } .filter { it.amount.token.issuer.party.owningKey.toKnownParty().value == myIdentity &amp;&amp; it.owner.owningKey.toKnownParty().value != myIdentity }</ID>
    <ID>MaxLineLength:TransactionWithSignatures.kt$TransactionWithSignatures${ val sigKeys = sigs.map { it.by }.toSet() // TODO Problem is that we can get single PublicKey wrapped as CompositeKey in allowedToBeMissing/mustSign // equals on CompositeKey won't catch this case (do we want to single PublicKey be equal to the same key wrapped in CompositeKey with threshold 1?) return requiredSigningKeys.filter { !it.isFulfilledBy(sigKeys) }.toSet() }</ID>
    <ID>MaxLineLength:TransformsSchema.kt$TransformsAnnotationProcessor</ID>
    <ID>MaxLineLength:TransformsSchema.kt$TransformsAnnotationProcessor$private</ID>
    <ID>MaxLineLength:TransitionBuilder.kt$CannotFindSessionException : IllegalStateException</ID>
    <ID>MaxLineLength:TransitionExecutor.kt$TransitionExecutor$ fun forceRemoveFlow(id: StateMachineRunId)</ID>
    <ID>MaxLineLength:TransitionExecutorImpl.kt$TransitionExecutorImpl$detailedLogger.warn("PropagateError(flowId=$currentFlowId;action=$action;exception=${exception.message})")</ID>
    <ID>MaxLineLength:TransitionExecutorImpl.kt$TransitionExecutorImpl$log.warn("Error while executing $action during transition to errored state, aborting transition", exception)</ID>
    <ID>MaxLineLength:TransitionExecutorImpl.kt$TransitionExecutorImpl${ // If we errored while transitioning to an error state then we cannot record the additional // error as that may result in an infinite loop, e.g. error propagation fails -&gt; record error -&gt; propagate fails again. // Instead we just keep around the old error state and wait for a new schedule, perhaps // triggered from a flow hospital log.warn("Error while executing $action during transition to errored state, aborting transition", exception) return Pair(FlowContinuation.Abort, previousState.copy(isFlowResumed = false)) }</ID>
    <ID>MaxLineLength:TrustManagerFactoryWrapper.kt$LoggingTrustManagerFactorySpiWrapper$return if (factorySpi is LoggingTrustManagerFactorySpiWrapper) trustManagers else trustManagers.filterIsInstance(X509ExtendedTrustManager::class.java).map { LoggingTrustManagerWrapper(it) }.toTypedArray()</ID>
    <ID>MaxLineLength:TrustManagerFactoryWrapper.kt$LoggingTrustManagerFactorySpiWrapper$val engineGetTrustManagersMethod = TrustManagerFactorySpi::class.java.getDeclaredMethod("engineGetTrustManagers")</ID>
    <ID>MaxLineLength:TrustManagerFactoryWrapper.kt$LoggingTrustManagerFactorySpiWrapper$val engineInitMethod = TrustManagerFactorySpi::class.java.getDeclaredMethod("engineInit", ManagerFactoryParameters::class.java)</ID>
    <ID>MaxLineLength:TrustManagerFactoryWrapper.kt$LoggingTrustManagerFactoryWrapper : TrustManagerFactory</ID>
    <ID>MaxLineLength:Try.kt$Try$ fun doOnFailure(action: Consumer&lt;Throwable&gt;): Try&lt;A&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try$ fun doOnSuccess(action: Consumer&lt;in A&gt;): Try&lt;A&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try$ inline fun &lt;B&gt; flatMap(function: (A) -&gt; Try&lt;B&gt;): Try&lt;B&gt;</ID>
    <ID>MaxLineLength:Try.kt$Try.Companion$ @JvmStatic inline fun &lt;T&gt; on(body: () -&gt; T): Try&lt;T&gt;</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$ActivateFloat : TunnelControlMessage</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$CrlRequest$internal</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$CrlResponse$internal</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$FloatHealthyAck$internal</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$HealthCheckFloat$internal</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$SigningRequest$internal</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$SigningResponse$internal</ID>
    <ID>MaxLineLength:TunnelControlMessages.kt$private val requestCounter = AtomicLong(System.currentTimeMillis()) // Initialise once with current ms value to avoid clash from previous start-ups</ID>
    <ID>MaxLineLength:TunnelControlTest.kt$TunnelControlTest$val bridgeProxiedReceiverService = TunnelingBridgeReceiverService(bridgeConfig, maxMessageSize, bridgeAuditService, haService, tunnelingSigningService, signingService, filterService)</ID>
    <ID>MaxLineLength:TunnelControlTest.kt$TunnelControlTest$val controlLinkSSLConfiguration = bridgeConfig.bridgeInnerConfig?.tunnelSSLConfiguration ?: bridgeConfig.publicSSLConfiguration</ID>
    <ID>MaxLineLength:TunnelControlTest.kt$TunnelControlTest$val signingService = CryptoServiceSigningService(bridgeConfig.p2pTlsSigningCryptoServiceConfig, DUMMY_BANK_A_NAME, bridgeConfig.publicSSLConfiguration, bridgeConfig.sslHandshakeTimeout, name = "P2P")</ID>
    <ID>MaxLineLength:TunnelControlTest.kt$TunnelControlTest$val tunnelingSigningService = CryptoServiceSigningService(bridgeConfig.tunnelingCryptoServiceConfig, DUMMY_BANK_A_NAME, controlLinkSSLConfiguration, name = "Tunnel")</ID>
    <ID>MaxLineLength:TunnelControlTest.kt$TunnelControlTest.TestBridgeAMQPListenerService$override</ID>
    <ID>MaxLineLength:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService : ExternalCrlSourceServiceLifecycleSupport</ID>
    <ID>MaxLineLength:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService$Caffeine.newBuilder() .maximumSize(java.lang.Long.getLong("net.corda.bridge.services.receiver.crl.cacheSize", 100)) .expireAfterWrite(java.lang.Long.getLong("net.corda.bridge.services.receiver.crl.expireMinutes", 60), TimeUnit.MINUTES)</ID>
    <ID>MaxLineLength:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService$RequestResponseServiceHelper(amqpControl, floatClientName, sourceLink, sourceLegalName, auditService, log, stateHelper, FloatControlTopics.FLOAT_CRL_TOPIC, CrlResponse::class, responseTimeout)</ID>
    <ID>MaxLineLength:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService$private</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$auditService.packetDropEvent(receivedMessage, "Invalid float inbound topic received ${receivedMessage.topic}!!", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$auditService.packetDropEvent(receivedMessage, "Unable to decode Float Control message", RoutingDirection.INBOUND)</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$connectSubscriber = controlClient.onConnection.subscribe(::onConnectToControl) { log.error("Connection event error", it) }</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$log.info("For CRL retrieval via tunnel will be using the following ProxyConfig: ${conf.outboundConfig?.proxyConfig}. If this is unwanted, please use 'useProxyForCrls = false' to override.")</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$log.info("Not using ProxyConfig for CRL retrieval via tunnel. If this is unwanted, please use 'useProxyForCrls = true' to override.")</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$log.info("Received CRL request '${request.requestId}' for certificate with X.500 name: '${certificate.subjectX500Principal}'")</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private val stateHelper: ServiceStateHelper = ServiceStateHelper(log)</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$private val statusFollower = ServiceStateCombiner(listOf(auditService, haService, filterService, tunnelingSigningService, signingService))</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$receiveSubscriber = controlClient.onReceive.subscribe(::onFloatMessage) { log.error("Receive event error", it) }</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$val activateMessage = ActivateFloat(signingService.certificates(), trustStoreBytes.toByteArray(), trustStore.password.toCharArray(), maximumMessageSize)</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$val amqpActivateMessage = amqpControlClient!!.createMessage(activateMessage.serialize(context = SerializationDefaults.P2P_CONTEXT).bytes, FLOAT_CONTROL_TOPIC, expectedCertificateSubject.toString(), emptyMap())</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$val amqpCrlResponse = amqpControlClient!!.createMessage(response.serialize(context = SerializationDefaults.P2P_CONTEXT).bytes, FloatControlTopics.FLOAT_CRL_TOPIC, expectedCertificateSubject.toString(), emptyMap())</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$val amqpDeactivateMessage = amqpControlClient!!.createMessage(DeactivateFloat.serialize(context = SerializationDefaults.P2P_CONTEXT).bytes, FLOAT_CONTROL_TOPIC, expectedCertificateSubject.toString(), emptyMap())</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$val amqpSigningResponse = amqpControlClient!!.createMessage(response.serialize(context = SerializationDefaults.P2P_CONTEXT).bytes, FloatControlTopics.FLOAT_SIGNING_TOPIC, expectedCertificateSubject.toString(), emptyMap())</ID>
    <ID>MaxLineLength:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$val response = SigningResponse(request.requestId, signingService.sign(request.alias, request.sigAlgo, request.data))</ID>
    <ID>MaxLineLength:TutorialContract.kt$CommercialPaper$"output states are issued by a command signer" using (output.issuance.party.owningKey in command.signers)</ID>
    <ID>MaxLineLength:TutorialContract.kt$CommercialPaper$"the transaction is signed by the owner of the CP" using (input.owner.owningKey in command.signers)</ID>
    <ID>MaxLineLength:TutorialContract.kt$CommercialPaper$return TransactionBuilder(notary = notary).withItems(stateAndContract, Command(Commands.Issue(), issuance.party.owningKey))</ID>
    <ID>MaxLineLength:TutorialContract.kt$State$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:TutorialFlowStateMachines.kt$TwoPartyTradeFlow.Seller$override val progressTracker: ProgressTracker = TwoPartyTradeFlow.Seller.tracker()</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$override</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$return Triple(ptx, arrayListOf(deal.participants.single { it is Party &amp;&amp; serviceHub.myInfo.isLegalIdentity(it) }.owningKey), emptyList())</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Handshake$@CordaSerializable data</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary$abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$@Suspendable protected abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownMe == ourIdentity){"Well known party for handshake identity ${it.secondaryIdentity} does not match ourIdentity"}</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownOtherParty == otherSideSession.counterparty){"Well known party for handshake identity ${it.primaryIdentity} does not match counterparty"}</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$serviceHub.signInitialTransaction(utx, additionalSigningPubKeys).withAdditionalSignatures(additionalSignatures)</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val ptxSignedByOtherSide = ptx + subFlow(CollectSignatureFlow(ptx, otherSideSession, otherSideSession.counterparty.owningKey))</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val sessionsForOtherSigners = excludeNotary(groupPublicKeysByWellKnownParty(serviceHub, ptxSignedByOtherSide.getMissingSigners()), ptxSignedByOtherSide).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val stx = subFlow(CollectSignaturesFlow(ptxSignedByOtherSide, sessionsForOtherSigners, additionalSigningPubKeys))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow${ // TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this // and [AbstractStateReplacementFlow]. class UnacceptablePriceException(givenPrice: Amount&lt;Currency&gt;) : FlowException("Unacceptable price: $givenPrice") class AssetMismatchException(val expectedTypeName: String, val typeName: String) : FlowException() { override fun toString() = "The submitted asset didn't match the expected type: $expectedTypeName vs $typeName" } /** * This object is serialised to the network and is the first flow message the seller sends to the buyer. * * @param payToIdentity anonymous identity of the seller, for payment to be sent to. */ @CordaSerializable data class SellerTradeInfo( val price: Amount&lt;Currency&gt;, val payToIdentity: PartyAndCertificate ) open class Seller(private val otherSideSession: FlowSession, private val assetToSell: StateAndRef&lt;OwnableState&gt;, private val price: Amount&lt;Currency&gt;, private val myParty: PartyAndCertificate, // TODO Left because in tests it's used to pass anonymous party. override val progressTracker: ProgressTracker = Seller.tracker()) : FlowLogic&lt;SignedTransaction&gt;() { companion object { object AWAITING_PROPOSAL : ProgressTracker.Step("Awaiting transaction proposal") // DOCSTART 3 object VERIFYING_AND_SIGNING : ProgressTracker.Step("Verifying and signing transaction proposal") { override fun childProgressTracker() = SignTransactionFlow.tracker() } // DOCEND 3 fun tracker() = ProgressTracker(AWAITING_PROPOSAL, VERIFYING_AND_SIGNING) } // DOCSTART 4 @Suspendable override fun call(): SignedTransaction { progressTracker.currentStep = AWAITING_PROPOSAL // Make the first message we'll send to kick off the flow. val hello = SellerTradeInfo(price, myParty) // What we get back from the other side is a transaction that *might* be valid and acceptable to us, // but we must check it out thoroughly before we sign! // SendTransactionFlow allows seller to access our data to resolve the transaction. subFlow(SendStateAndRefFlow(otherSideSession, listOf(assetToSell))) otherSideSession.send(hello) // Verify and sign the transaction. progressTracker.currentStep = VERIFYING_AND_SIGNING // DOCSTART 07 // Sync identities to ensure we know all of the identities involved in the transaction we're about to // be asked to sign subFlow(IdentitySyncFlow.Receive(otherSideSession)) // DOCEND 07 // DOCSTART 5 val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } } val txId = subFlow(signTransactionFlow).id // DOCEND 5 return subFlow(ReceiveFinalityFlow(otherSideSession, expectedTxId = txId)) } // DOCEND 4 // Following comment moved here so that it doesn't appear in the docsite: // There are all sorts of funny games a malicious secondary might play with it sends maybeSTX, // we should fix them: // // - This tx may attempt to send some assets we aren't intending to sell to the secondary, if // we're reusing keys! So don't reuse keys! // - This tx may include output states that impose odd conditions on the movement of the cash, // once we implement state pairing. // // but the goal of this code is not to be fully secure (yet), but rather, just to find good ways to // express flow state machines on top of the messaging layer. } open class Buyer(private val sellerSession: FlowSession, private val notary: Party, private val acceptablePrice: Amount&lt;Currency&gt;, private val typeToBuy: Class&lt;out OwnableState&gt;, private val anonymous: Boolean) : FlowLogic&lt;SignedTransaction&gt;() { constructor(otherSideSession: FlowSession, notary: Party, acceptablePrice: Amount&lt;Currency&gt;, typeToBuy: Class&lt;out OwnableState&gt;) : this(otherSideSession, notary, acceptablePrice, typeToBuy, true) // DOCSTART 2 object RECEIVING : ProgressTracker.Step("Waiting for seller trading info") object VERIFYING : ProgressTracker.Step("Verifying seller assets") object SIGNING : ProgressTracker.Step("Generating and signing transaction proposal") object COLLECTING_SIGNATURES : ProgressTracker.Step("Collecting signatures from other parties") { override fun childProgressTracker() = CollectSignaturesFlow.tracker() } object RECORDING : ProgressTracker.Step("Recording completed transaction") { // TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733. // override fun childProgressTracker() = FinalityFlow.tracker() } override val progressTracker = ProgressTracker(RECEIVING, VERIFYING, SIGNING, COLLECTING_SIGNATURES, RECORDING) // DOCEND 2 // DOCSTART 1 @Suspendable override fun call(): SignedTransaction { // Wait for a trade request to come in from the other party. progressTracker.currentStep = RECEIVING val (assetForSale, tradeRequest) = receiveAndValidateTradeRequest() // Create the identity we'll be paying to, and send the counterparty proof we own the identity val buyerAnonymousIdentity = if (anonymous) serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false) else ourIdentityAndCert // Put together a proposed transaction that performs the trade, and sign it. progressTracker.currentStep = SIGNING val (ptx, cashSigningPubKeys) = assembleSharedTX(assetForSale, tradeRequest, buyerAnonymousIdentity) // DOCSTART 6 // Now sign the transaction with whatever keys we need to move the cash. val partSignedTx = serviceHub.signInitialTransaction(ptx, cashSigningPubKeys) // Sync up confidential identities in the transaction with our counterparty subFlow(IdentitySyncFlow.Send(sellerSession, ptx.toWireTransaction(serviceHub))) // Send the signed transaction to the seller, who must then sign it themselves and commit // it to the ledger by sending it to the notary. progressTracker.currentStep = COLLECTING_SIGNATURES val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey)) val twiceSignedTx = partSignedTx + sellerSignature // DOCEND 6 // Notarise and record the transaction. progressTracker.currentStep = RECORDING return subFlow(FinalityFlow(twiceSignedTx, sellerSession)) } @Suspendable private fun receiveAndValidateTradeRequest(): Pair&lt;StateAndRef&lt;OwnableState&gt;, SellerTradeInfo&gt; { val assetForSale = subFlow(ReceiveStateAndRefFlow&lt;OwnableState&gt;(sellerSession)).single() return assetForSale to sellerSession.receive&lt;SellerTradeInfo&gt;().unwrap { progressTracker.currentStep = VERIFYING // What is the seller trying to sell us? val asset = assetForSale.state.data val assetTypeName = asset.javaClass.name // The asset must either be owned by the well known identity of the counterparty, or we must be able to // prove the owner is a confidential identity of the counterparty. val assetForSaleIdentity = serviceHub.identityService.wellKnownPartyFromAnonymous(asset.owner) require(assetForSaleIdentity == sellerSession.counterparty){"Well known identity lookup returned identity that does not match counterparty"} // Register the identity we're about to send payment to. This shouldn't be the same as the asset owner // identity, so that anonymity is enforced. val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" } if (it.price &gt; acceptablePrice) throw UnacceptablePriceException(it.price) if (!typeToBuy.isInstance(asset)) throw AssetMismatchException(typeToBuy.name, assetTypeName) it } } @Suspendable private fun assembleSharedTX(assetForSale: StateAndRef&lt;OwnableState&gt;, tradeRequest: SellerTradeInfo, buyerAnonymousIdentity: PartyAndCertificate): SharedTx { val ptx = TransactionBuilder(notary) // Add input and output states for the movement of cash, by using the Cash contract to generate the states val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party) // Add inputs/outputs/a command for the movement of the asset. tx.addInputState(assetForSale) val (command, state) = assetForSale.state.data.withNewOwner(buyerAnonymousIdentity.party) tx.addOutputState(state, assetForSale.state.contract, assetForSale.state.notary) tx.addCommand(command, assetForSale.state.data.owner.owningKey) // We set the transaction's time-window: it may be that none of the contracts need this! // But it can't hurt to have one. val currentTime = serviceHub.clock.instant() tx.setTimeWindow(currentTime, 30.seconds) return SharedTx(tx, cashSigningPubKeys) } // DOCEND 1 data class SharedTx(val tx: TransactionBuilder, val cashSigningPubKeys: List&lt;PublicKey&gt;) } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow${ // TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this // and [AbstractStateReplacementFlow]. class UnacceptablePriceException(givenPrice: Amount&lt;Currency&gt;) : FlowException("Unacceptable price: $givenPrice") class AssetMismatchException(val expectedTypeName: String, val typeName: String) : FlowException() { override fun toString() = "The submitted asset didn't match the expected type: $expectedTypeName vs $typeName" } /** * This object is serialised to the network and is the first flow message the seller sends to the buyer. * * @param payToIdentity anonymous identity of the seller, for payment to be sent to. */ @CordaSerializable data class SellerTradeInfo( val price: Amount&lt;Currency&gt;, val payToIdentity: PartyAndCertificate ) open class Seller(private val otherSideSession: FlowSession, private val assetToSell: StateAndRef&lt;OwnableState&gt;, private val price: Amount&lt;Currency&gt;, private val myParty: PartyAndCertificate, // TODO Left because in tests it's used to pass anonymous party. override val progressTracker: ProgressTracker = Seller.tracker()) : FlowLogic&lt;SignedTransaction&gt;() { companion object { object AWAITING_PROPOSAL : ProgressTracker.Step("Awaiting transaction proposal") // DOCSTART 3 object VERIFYING_AND_SIGNING : ProgressTracker.Step("Verifying and signing transaction proposal") { override fun childProgressTracker() = SignTransactionFlow.tracker() } // DOCEND 3 fun tracker() = ProgressTracker(AWAITING_PROPOSAL, VERIFYING_AND_SIGNING) } // DOCSTART 4 @Suspendable override fun call(): SignedTransaction { progressTracker.currentStep = AWAITING_PROPOSAL // Make the first message we'll send to kick off the flow. val hello = SellerTradeInfo(price, myParty) // What we get back from the other side is a transaction that *might* be valid and acceptable to us, // but we must check it out thoroughly before we sign! // SendTransactionFlow allows seller to access our data to resolve the transaction. subFlow(SendStateAndRefFlow(otherSideSession, listOf(assetToSell))) otherSideSession.send(hello) // Verify and sign the transaction. progressTracker.currentStep = VERIFYING_AND_SIGNING // Sync identities to ensure we know all of the identities involved in the transaction we're about to // be asked to sign subFlow(IdentitySyncFlow.Receive(otherSideSession)) // DOCSTART 5 val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = stx.tx.inputs.map { serviceHub.loadState(it).data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } } val txId = subFlow(signTransactionFlow).id // DOCEND 5 return subFlow(ReceiveFinalityFlow(otherSideSession, expectedTxId = txId)) } // DOCEND 4 // Following comment moved here so that it doesn't appear in the docsite: // There are all sorts of funny games a malicious secondary might play with it sends maybeSTX, // we should fix them: // // - This tx may attempt to send some assets we aren't intending to sell to the secondary, if // we're reusing keys! So don't reuse keys! // - This tx may include output states that impose odd conditions on the movement of the cash, // once we implement state pairing. // // but the goal of this code is not to be fully secure (yet), but rather, just to find good ways to // express flow state machines on top of the messaging layer. } open class Buyer(private val sellerSession: FlowSession, private val notary: Party, private val acceptablePrice: Amount&lt;Currency&gt;, private val typeToBuy: Class&lt;out OwnableState&gt;, private val anonymous: Boolean) : FlowLogic&lt;SignedTransaction&gt;() { constructor(otherSideSession: FlowSession, notary: Party, acceptablePrice: Amount&lt;Currency&gt;, typeToBuy: Class&lt;out OwnableState&gt;) : this(otherSideSession, notary, acceptablePrice, typeToBuy, true) // DOCSTART 2 object RECEIVING : ProgressTracker.Step("Waiting for seller trading info") object VERIFYING : ProgressTracker.Step("Verifying seller assets") object SIGNING : ProgressTracker.Step("Generating and signing transaction proposal") object COLLECTING_SIGNATURES : ProgressTracker.Step("Collecting signatures from other parties") { override fun childProgressTracker() = CollectSignaturesFlow.tracker() } object RECORDING : ProgressTracker.Step("Recording completed transaction") { // TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733. // override fun childProgressTracker() = FinalityFlow.tracker() } override val progressTracker = ProgressTracker(RECEIVING, VERIFYING, SIGNING, COLLECTING_SIGNATURES, RECORDING) // DOCEND 2 // DOCSTART 1 @Suspendable override fun call(): SignedTransaction { // Wait for a trade request to come in from the other party. progressTracker.currentStep = RECEIVING val (assetForSale, tradeRequest) = receiveAndValidateTradeRequest() // Create the identity we'll be paying to, and send the counterparty proof we own the identity val buyerAnonymousIdentity = if (anonymous) serviceHub.keyManagementService.freshKeyAndCert(ourIdentityAndCert, false) else ourIdentityAndCert // Put together a proposed transaction that performs the trade, and sign it. progressTracker.currentStep = SIGNING val (ptx, cashSigningPubKeys) = assembleSharedTX(assetForSale, tradeRequest, buyerAnonymousIdentity) // Now sign the transaction with whatever keys we need to move the cash. val partSignedTx = serviceHub.signInitialTransaction(ptx, cashSigningPubKeys) // Sync up confidential identities in the transaction with our counterparty subFlow(IdentitySyncFlow.Send(sellerSession, ptx.toWireTransaction(serviceHub))) // Send the signed transaction to the seller, who must then sign it themselves and commit // it to the ledger by sending it to the notary. progressTracker.currentStep = COLLECTING_SIGNATURES val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey)) val twiceSignedTx = partSignedTx + sellerSignature // Notarise and record the transaction. progressTracker.currentStep = RECORDING return subFlow(FinalityFlow(twiceSignedTx, sellerSession)) } @Suspendable private fun receiveAndValidateTradeRequest(): Pair&lt;StateAndRef&lt;OwnableState&gt;, SellerTradeInfo&gt; { val assetForSale = subFlow(ReceiveStateAndRefFlow&lt;OwnableState&gt;(sellerSession)).single() return assetForSale to sellerSession.receive&lt;SellerTradeInfo&gt;().unwrap { progressTracker.currentStep = VERIFYING // What is the seller trying to sell us? val asset = assetForSale.state.data val assetTypeName = asset.javaClass.name // The asset must either be owned by the well known identity of the counterparty, or we must be able to // prove the owner is a confidential identity of the counterparty. val assetForSaleIdentity = serviceHub.identityService.wellKnownPartyFromAnonymous(asset.owner) require(assetForSaleIdentity == sellerSession.counterparty) // Register the identity we're about to send payment to. This shouldn't be the same as the asset owner // identity, so that anonymity is enforced. val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" } if (it.price &gt; acceptablePrice) throw UnacceptablePriceException(it.price) if (!typeToBuy.isInstance(asset)) throw AssetMismatchException(typeToBuy.name, assetTypeName) it } } @Suspendable private fun assembleSharedTX(assetForSale: StateAndRef&lt;OwnableState&gt;, tradeRequest: SellerTradeInfo, buyerAnonymousIdentity: PartyAndCertificate): SharedTx { val ptx = TransactionBuilder(notary) // Add input and output states for the movement of cash, by using the Cash contract to generate the states val (tx, cashSigningPubKeys) = Cash.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party) // Add inputs/outputs/a command for the movement of the asset. tx.addInputState(assetForSale) val (command, state) = assetForSale.state.data.withNewOwner(buyerAnonymousIdentity.party) tx.addOutputState(state, assetForSale.state.contract, assetForSale.state.notary) tx.addCommand(command, assetForSale.state.data.owner.owningKey) // We set the transaction's time-window: it may be that none of the contracts need this! // But it can't hurt to have one. val currentTime = serviceHub.clock.instant() tx.setTimeWindow(currentTime, 30.seconds) return SharedTx(tx, cashSigningPubKeys) } // DOCEND 1 data class SharedTx(val tx: TransactionBuilder, val cashSigningPubKeys: List&lt;PublicKey&gt;) } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$@Suspendable private</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$constructor(otherSideSession: FlowSession, notary: Party, acceptablePrice: Amount&lt;Currency&gt;, typeToBuy: Class&lt;out OwnableState&gt;) : this(otherSideSession, notary, acceptablePrice, typeToBuy, true)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(assetForSaleIdentity == sellerSession.counterparty){"Well known identity lookup returned identity that does not match counterparty"}</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val (tx, cashSigningPubKeys) = Cash.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val sellerSignature = subFlow(CollectSignatureFlow(partSignedTx, sellerSession, sellerSession.counterparty.owningKey))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val wellKnownPayToIdentity = serviceHub.identityService.verifyAndRegisterIdentity(it.payToIdentity) ?: it.payToIdentity</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$override val progressTracker: ProgressTracker = Seller.tracker()</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$private val myParty: PartyAndCertificate</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller$val signTransactionFlow = object : SignTransactionFlow(otherSideSession, VERIFYING_AND_SIGNING.childProgressTracker()) { override fun checkTransaction(stx: SignedTransaction) { // Verify that we know who all the participants in the transaction are val states: Iterable&lt;ContractState&gt; = stx.tx.inputs.map { serviceHub.loadState(it).data } + stx.tx.outputs.map { it.data } states.forEach { state -&gt; state.participants.forEach { anon -&gt; require(serviceHub.identityService.wellKnownPartyFromAnonymous(anon) != null) { "Transaction state $state involves unknown participant $anon" } } } if (stx.tx.outputStates.sumCashBy(myParty.party).withoutIssuer() != price) throw FlowException("Transaction is not sending us the right amount of cash") } }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.&lt;no name provided&gt;$val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.&lt;no name provided&gt;$val states: Iterable&lt;ContractState&gt; = stx.tx.inputs.map { serviceHub.loadState(it).data } + stx.tx.outputs.map { it.data }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( // Buyer Bob is told about Alice's commercial paper, but doesn't know it .. expect(TxRecord.Get(alicesFakePaper[0].id)), // He asks and gets the tx, validates it, sees it's a self issue with no dependencies, stores. expect(TxRecord.Add(alicesSignedTxns.values.first())), // Alice gets Bob's proposed transaction and doesn't know his two cash states. She asks, Bob answers. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), // Alice notices that Bob's cash txns depend on a third tx she also doesn't know. She asks, Bob answers. expect(TxRecord.Get(bobsFakeCash[0].id)) )</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( // Seller Alice sends her seller info to Bob, who wants to check the asset for sale. // He requests, Alice looks up in her DB to send the tx to Bob expect(TxRecord.Get(alicesFakePaper[0].id)), // Seller Alice gets a proposed tx which depends on Bob's two cash txns and her own tx. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)), // Alice notices that Bob's cash txns depend on a third tx she also doesn't know. expect(TxRecord.Get(bobsFakeCash[0].id)), // Bob answers with the transactions that are now all verifiable, as Alice bottomed out. // Bob's transactions are valid, so she commits to the database //expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[0].id]!!)), //TODO investigate missing event after introduction of signature constraints non-downgrade rule expect(TxRecord.Get(bobsFakeCash[0].id)), // Verify expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[2].id]!!)), expect(TxRecord.Get(bobsFakeCash[0].id)), // Verify expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[1].id]!!)), // Now she verifies the transaction is contract-valid (not signature valid) which means // looking up the states again. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)), // Alice needs to look up the input states to find out which Notary they point to expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)) )</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// Insert a prospectus type attachment into the commercial paper transaction. val stream = ByteArrayOutputStream() JarOutputStream(stream).use { it.putNextEntry(ZipEntry("Prospectus.txt")) it.write("Our commercial paper is top notch stuff".toByteArray()) it.closeEntry() } val attachmentID = aliceNode.database.transaction { attachment(stream.toByteArray().inputStream()) } val bobsKey = bobNode.services.keyManagementService.keys.single() val bobsFakeCash = bobNode.database.transaction { fillUpForBuyer(false, issuer, AnonymousParty(bobsKey), notary) }.second insertFakeTransactions(bobsFakeCash, bobNode, bob, notaryNode, bankNode) val alicesFakePaper = aliceNode.database.transaction { fillUpForSeller(false, issuer, alice, 1200.DOLLARS `issued by` bank.ref(0), attachmentID, notary).second } insertFakeTransactions(alicesFakePaper, aliceNode, alice, notaryNode, bankNode) val aliceTxStream = aliceNode.services.validatedTransactions.track().updates val aliceTxMappings = with(aliceNode) { database.transaction { services.stateMachineRecordedTransactionMapping.track().updates } } val aliceSmId = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerId mockNet.runNetwork() // We need to declare this here, if we do it inside [expectEvents] kotlin throws an internal compiler error(!). val aliceTxExpectations = sequence( expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[0].id) }, expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[2].id) }, expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[1].id) } ) aliceTxStream.expectEvents { aliceTxExpectations } val aliceMappingExpectations = sequence( expect&lt;StateMachineTransactionMapping&gt; { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[0].id) }, expect { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[2].id) }, expect { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[1].id) } ) aliceTxMappings.expectEvents { aliceMappingExpectations }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// Insert a prospectus type attachment into the commercial paper transaction. val stream = ByteArrayOutputStream() JarOutputStream(stream).use { it.putNextEntry(ZipEntry("Prospectus.txt")) it.write("Our commercial paper is top notch stuff".toByteArray()) it.closeEntry() } val attachmentID = aliceNode.database.transaction { attachment(stream.toByteArray().inputStream()) } val bobsKey = bobNode.services.keyManagementService.keys.single() val bobsFakeCash = bobNode.database.transaction { fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bobsKey), notary, bobNode, bob, notaryNode, bankNode) }.second val alicesFakePaper = aliceNode.database.transaction { fillUpForSeller(false, issuer, alice, 1200.DOLLARS `issued by` bank.ref(0), attachmentID, notary).second } insertFakeTransactions(alicesFakePaper, aliceNode, alice, notaryNode, bankNode) val aliceTxStream = aliceNode.services.validatedTransactions.track().updates val aliceTxMappings = with(aliceNode) { database.transaction { services.stateMachineRecordedTransactionMapping.track().updates } } val aliceSmId = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerId mockNet.runNetwork() // We need to declare this here, if we do it inside [expectEvents] kotlin throws an internal compiler error(!). val aliceTxExpectations = sequence( expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[0].id) }, expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[2].id) }, expect { tx: SignedTransaction -&gt; require(tx.id == bobsFakeCash[1].id) } ) aliceTxStream.expectEvents { aliceTxExpectations } val aliceMappingExpectations = sequence( expect&lt;StateMachineTransactionMapping&gt; { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[0].id) }, expect&lt;StateMachineTransactionMapping&gt; { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[2].id) }, expect { (stateMachineRunId, transactionId) -&gt; require(stateMachineRunId == aliceSmId) require(transactionId == bobsFakeCash[1].id) } ) aliceTxMappings.expectEvents { aliceMappingExpectations }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$SignableData(id, SignatureMetadata(1, Crypto.findSignatureScheme(notaryParty.owningKey).schemeNumberID))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, cashIssuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$bobNode.services.fillWithSomeTestCash(2000.DOLLARS, bankNode.services, outputNotary = notary, issuedBy = cashIssuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$bobNode.services.fillWithSomeTestCash(2000.DOLLARS, bankNode.services, outputNotary = notary, issuedBy = issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(bobError, issuer, bob, notary, bobNode, bob, notaryNode, bankNode).second</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bob.owningKey), notary, bobNode, bob, notaryNode, bankNode)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bobsKey), notary, bobNode, bob, notaryNode, bankNode)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "bob cash 1", notary = notary, contractState = 800.DOLLARS.CASH issuedBy issuer ownedBy owner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "bob cash 2", notary = notary, contractState = 300.DOLLARS.CASH issuedBy issuer ownedBy owner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "elbonian money 1", notary = notary, contractState = 800.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "elbonian money 2", notary = notary, contractState = 1000.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, notary = notary, contractState = 700.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$private</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val (bobStateMachine, aliceResult) = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef())</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val aliceFuture = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerResult</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val aliceNode = mockNet.createPartyNode(ALICE_NAME) var bobNode = mockNet.createPartyNode(BOB_NAME) val bankNode = mockNet.createPartyNode(BOC_NAME) aliceNode.internals.disableDBCloseOnStop() bobNode.internals.disableDBCloseOnStop() val bobAddr = bobNode.network.myAddress mockNet.runNetwork() // Clear network map registration messages val alice = aliceNode.info.singleIdentity() val bank = bankNode.info.singleIdentity() val bob = bobNode.info.singleIdentity() val issuer = bank.ref(1, 2, 3) bobNode.database.transaction { VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, issuer) } val alicesFakePaper = aliceNode.database.transaction { fillUpForSeller(false, issuer, alice, 1200.DOLLARS `issued by` bank.ref(0), null, notary).second } insertFakeTransactions(alicesFakePaper, aliceNode, alice, notaryNode, bankNode) val aliceFuture = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerResult // Everything is on this thread so we can now step through the flow one step at a time. // Seller Alice already sent a message to Buyer Bob. Pump once: bobNode.pumpReceive() // Bob sends a couple of queries for the dependencies back to Alice. Alice reponds. aliceNode.pumpReceive() bobNode.pumpReceive() aliceNode.pumpReceive() bobNode.pumpReceive() aliceNode.pumpReceive() bobNode.pumpReceive() // OK, now Bob has sent the partial transaction back to Alice and is waiting for Alice's signature. bobNode.database.transaction { assertThat(bobNode.internals.checkpointStorage.checkpoints()).hasSize(1) } val storage = bobNode.services.validatedTransactions val bobTransactionsBeforeCrash = bobNode.database.transaction { (storage as DBTransactionStorage).transactions } assertThat(bobTransactionsBeforeCrash).isNotEmpty // .. and let's imagine that Bob's computer has a power cut. He now has nothing now beyond what was on disk. bobNode.dispose() // Alice doesn't know that and carries on: she wants to know about the cash transactions he's trying to use. // She will wait around until Bob comes back. assertThat(aliceNode.pumpReceive()).isNotNull() // FIXME: Knowledge of confidential identities is lost on node shutdown, so Bob's node now refuses to sign the // transaction because it has no idea who the parties are. // ... bring the node back up ... the act of constructing the SMM will re-register the message handlers // that Bob was waiting on before the reboot occurred. bobNode = mockNet.createNode(InternalMockNodeParameters(bobAddr.id, BOB_NAME)) // Find the future representing the result of this state machine again. val bobFuture = bobNode.smm.findStateMachines(BuyerAcceptor::class.java).single().second // And off we go again. mockNet.runNetwork() // Bob is now finished and has the same transaction as Alice. assertThat(bobFuture.getOrThrow()).isEqualTo(aliceFuture.getOrThrow()) assertThat(bobNode.smm.findStateMachines(Buyer::class.java)).isEmpty() bobNode.database.transaction { assertThat(bobNode.internals.checkpointStorage.checkpoints()).isEmpty() } aliceNode.database.transaction { assertThat(aliceNode.internals.checkpointStorage.checkpoints()).isEmpty() } bobNode.database.transaction { val restoredBobTransactions = bobTransactionsBeforeCrash.filter { bobNode.services.validatedTransactions.getTransaction(it.id) != null } assertThat(restoredBobTransactions).containsAll(bobTransactionsBeforeCrash) } aliceNode.internals.manuallyCloseDB() bobNode.internals.manuallyCloseDB()</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$val aliceNode = mockNet.createPartyNode(ALICE_NAME) var bobNode = mockNet.createPartyNode(BOB_NAME) val bankNode = mockNet.createPartyNode(BOC_NAME) aliceNode.internals.disableDBCloseOnStop() bobNode.internals.disableDBCloseOnStop() val bobAddr = bobNode.network.myAddress mockNet.runNetwork() // Clear network map registration messages val alice = aliceNode.info.singleIdentity() val bank = bankNode.info.singleIdentity() val bob = bobNode.info.singleIdentity() val issuer = bank.ref(1, 2, 3) bobNode.database.transaction { bobNode.services.fillWithSomeTestCash(2000.DOLLARS, bankNode.services, outputNotary = notary, issuedBy = issuer) } val alicesFakePaper = aliceNode.database.transaction { fillUpForSeller(false, issuer, alice, 1200.DOLLARS `issued by` bank.ref(0), null, notary).second } insertFakeTransactions(alicesFakePaper, aliceNode, alice, notaryNode, bankNode) val aliceFuture = runBuyerAndSeller(notary, bob, aliceNode, bobNode, "alice's paper".outputStateAndRef()).sellerResult // Everything is on this thread so we can now step through the flow one step at a time. // Seller Alice already sent a message to Buyer Bob. Pump once: bobNode.pumpReceive() // Bob sends a couple of queries for the dependencies back to Alice. Alice reponds. aliceNode.pumpReceive() bobNode.pumpReceive() aliceNode.pumpReceive() bobNode.pumpReceive() aliceNode.pumpReceive() bobNode.pumpReceive() // OK, now Bob has sent the partial transaction back to Alice and is waiting for Alice's signature. bobNode.database.transaction { assertThat(bobNode.internals.checkpointStorage.checkpoints()).hasSize(1) } val storage = bobNode.services.validatedTransactions val bobTransactionsBeforeCrash = bobNode.database.transaction { (storage as DBTransactionStorage).transactions } assertThat(bobTransactionsBeforeCrash).isNotEmpty // .. and let's imagine that Bob's computer has a power cut. He now has nothing now beyond what was on disk. bobNode.dispose() // Alice doesn't know that and carries on: she wants to know about the cash transactions he's trying to use. // She will wait around until Bob comes back. assertThat(aliceNode.pumpReceive()).isNotNull() // FIXME: Knowledge of confidential identities is lost on node shutdown, so Bob's node now refuses to sign the // transaction because it has no idea who the parties are. // ... bring the node back up ... the act of constructing the SMM will re-register the message handlers // that Bob was waiting on before the reboot occurred. bobNode = mockNet.createNode(InternalMockNodeParameters(bobAddr.id, BOB_NAME)) // Find the future representing the result of this state machine again. val bobFuture = bobNode.smm.findStateMachines(BuyerAcceptor::class.java).single().second // And off we go again. mockNet.runNetwork() // Bob is now finished and has the same transaction as Alice. assertThat(bobFuture.getOrThrow()).isEqualTo(aliceFuture.getOrThrow()) assertThat(bobNode.smm.findStateMachines(Buyer::class.java)).isEmpty() bobNode.database.transaction { assertThat(bobNode.internals.checkpointStorage.checkpoints()).isEmpty() } aliceNode.database.transaction { assertThat(aliceNode.internals.checkpointStorage.checkpoints()).isEmpty() } bobNode.database.transaction { val restoredBobTransactions = bobTransactionsBeforeCrash.filter { bobNode.services.validatedTransactions.getTransaction(it.id) != null } assertThat(restoredBobTransactions).containsAll(bobTransactionsBeforeCrash) } aliceNode.internals.manuallyCloseDB() bobNode.internals.manuallyCloseDB()</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests.&lt;no name provided&gt;$return RecordingTransactionStorage(database, super.makeTransactionStorage(transactionCacheSizeBytes))</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests.BuyerAcceptor$require(serviceHub.networkMapCache.isNotary(it.notaryIdentity)) { "${it.notaryIdentity} is not a notary" }</ID>
    <ID>MaxLineLength:TypeIdentifier.kt$TypeIdentifier.Companion$ fun forGenericType(type: Type, resolutionContext: Type = type): TypeIdentifier</ID>
    <ID>MaxLineLength:TypeIdentifier.kt$TypeIdentifier.Companion$is GenericArrayType -&gt; ArrayOf(forGenericType(type.genericComponentType.resolveAgainst(resolutionContext)))</ID>
    <ID>MaxLineLength:TypeIdentifier.kt$TypeIdentifier.Parameterised$data</ID>
    <ID>MaxLineLength:TypeLoader.kt$ClassCarpentingTypeLoader : TypeLoader</ID>
    <ID>MaxLineLength:TypeLoader.kt$TypeLoader$ fun load(remoteTypeInformation: Collection&lt;RemoteTypeInformation&gt;, context: SerializationContext): Map&lt;TypeIdentifier, Type&gt;</ID>
    <ID>MaxLineLength:TypeModellingFingerPrinter.kt$FingerPrintingState$writer.writeAlreadySeen()</ID>
    <ID>MaxLineLength:TypeParameterUtils.kt$private</ID>
    <ID>MaxLineLength:TypeParameterUtils.kt${ if (declaredClass == actualClass) { return null } if (actualClass.typeParameters.isEmpty()) { return actualClass } // The actual class can never have type variables resolved, due to the JVM's use of type erasure, so let's try and resolve them // Search for declared type in the inheritance hierarchy and then see if that fills in all the variables val implementationChain: List&lt;Type&gt; = findPathToDeclared(actualClass, declaredType)?.toList() ?: throw AMQPNotSerializableException( declaredType, "No inheritance path between actual $actualClass and declared $declaredType.") val start = implementationChain.last() val rest = implementationChain.dropLast(1).drop(1) val resolver = rest.reversed().fold(TypeResolver().where(start, declaredType)) { resolved, chainEntry -&gt; val newResolved = resolved.resolveType(chainEntry) TypeResolver().where(chainEntry, newResolved) } // The end type is a special case as it is a Class, so we need to fake up a ParameterizedType for it to get the TypeResolver to do anything. val endType = actualClass.asParameterizedType() return resolver.resolveType(endType) }</ID>
    <ID>MaxLineLength:TypesafeCordappConfigTests.kt$TypesafeCordappConfigTests$val config = ConfigFactory.parseString("string=string\nint=1\nfloat=1.0\ndouble=1.0\nnumber=2\ndouble=1.01\nbool=false")</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract.State$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Currency&gt;&gt;, newOwner: AbstractParty): FungibleAsset&lt;Currency&gt;</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract.State$return UniqueDummyFungibleStateSchema.UniquePersistentDummyFungibleState(currency = amount.token.product.currencyCode)</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleStateSchema : MappedSchema</ID>
    <ID>MaxLineLength:UniqueDummyLinearContract.kt$UniqueDummyLinearStateSchema : MappedSchema</ID>
    <ID>MaxLineLength:UniqueIdentifier.kt$UniqueIdentifier$@CordaSerializable @KeepForDJVM data</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$JPAUniquenessProviderFactory$database = configureDatabase(MockServices.makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null }, NodeSchemaService(extraSchemas = setOf(JPANotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$JPAUniquenessProviderWithUnspentStateCacheFactory$database = configureDatabase(MockServices.makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null }, NodeSchemaService(extraSchemas = setOf(JPANotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$MySQLUniquenessProviderFactory$private</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$RaftUniquenessProviderFactory$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$StandaloneJPAUniquenessProviderFactory$val standaloneJPANotaryConfig = StandaloneJPANotaryConfig(dataSourceProperties, standaloneJPANotaryDatabaseConfig)</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$StandaloneJPAUniquenessProviderFactory$val standaloneJPANotaryDatabaseConfig = StandaloneJPANotaryDatabaseConfig(initialiseSchema = SchemaInitializationType.UPDATE_H2_ONLY)</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$private val requestSignature = NotarisationRequestSignature(DigitalSignature.WithKey(NullKeys.NullPublicKey, ByteArray(32)), 0)</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature, invalidTimeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature, timeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, invalidTimeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, references = emptyList()).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), txID, identity, requestSignature, invalidTimeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState1), firstTxId, identity, requestSignature, invalidTimeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState1), firstTxId, identity, requestSignature, timeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(referenceState), firstTxId, identity, requestSignature, references = emptyList()) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, invalidTimeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState), secondTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState1), firstTxId, identity, requestSignature, timeWindow).get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(referenceState), SecureHash.randomSHA256(), identity, requestSignature, timeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result3 = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$"action must have a time-window" using (tx.timeWindow != null) // "action must be authorized" by (cmd.signers.any { action.actors.any { party -&gt; party.owningKey == it } }) // todo perhaps merge these two requirements? "condition must be met" using evalBoolean(tx, action.condition)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$"the transaction is signed by all liable parties" using (liableParties(outState.details).all { it in cmd.signers })</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$Action(arr.name, replaceFixing(tx, arr.condition, fixings, unusedFixings), replaceFixing(tx, arr.arrangement, fixings, unusedFixings))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$if (dt != null &amp;&amp; fixings.containsKey(FixOf(perceivable.source, dt.toLocalDate(), perceivable.tenor))) { unusedFixings.remove(FixOf(perceivable.source, dt.toLocalDate(), perceivable.tenor)) uncheckedCast(Const(fixings[FixOf(perceivable.source, dt.toLocalDate(), perceivable.tenor)]!!)) } else perceivable</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arr.actions.map { Action(it.name, it.condition, replaceFixing(tx, it.arrangement, fixings, unusedFixings)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, it.condition, removeNext(it.arrangement)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, it.condition, replaceNext(it.arrangement, nextReplacement)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, replaceStartEnd(it.condition, start, end), replaceStartEnd(it.arrangement, start, end)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Interest -&gt; uncheckedCast(Interest(replaceStartEnd(p.amount, start, end), p.dayCountConvention, replaceStartEnd(p.interest, start, end), replaceStartEnd(p.start, start, end), replaceStartEnd(p.end, start, end)))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Obligation -&gt; Obligation(replaceFixing(tx, arr.amount, fixings, unusedFixings), arr.currency, arr.from, arr.to)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Obligation -&gt; Obligation(replaceStartEnd(arrangement.amount, start, end), arrangement.currency, arrangement.from, arrangement.to)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableAnd -&gt; uncheckedCast(replaceStartEnd(p.left, start, end) and replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOperation</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOperation -&gt; PerceivableOperation(replaceStartEnd(p.left, start, end), p.op, replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOr -&gt; uncheckedCast(replaceStartEnd(p.left, start, end) or replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is RollOut -&gt; RollOut(arr.startDate, arr.endDate, arr.frequency, replaceFixing(tx, arr.template, fixings, unusedFixings))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$val action = actions[value.name] ?: throw IllegalArgumentException("Failed requirement: action must be defined")</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$val schedule = BusinessCalendar.createGenericSchedule(start, rollOut.frequency, noOfAdditionalPeriods = 1, endDate = end)</ID>
    <ID>MaxLineLength:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$database = configureDatabase(MockServices.makeTestDataSourceProperties(), DatabaseConfig(runMigration = true), { null }, { null }, NodeSchemaService(extraSchemas = setOf(JPANotarySchemaV1)))</ID>
    <ID>MaxLineLength:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$private</ID>
    <ID>MaxLineLength:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$private val requestSignature = NotarisationRequestSignature(DigitalSignature.WithKey(NullKeys.NullPublicKey, ByteArray(32)), 0)</ID>
    <ID>MaxLineLength:UnspentStatesCacheTests.kt$UnspentStatesCacheTests$val result3 = provider!!.commit(secondInputs, secondTxId, identity, requestSignature, references = referenceStates).get()</ID>
    <ID>MaxLineLength:UnspentStatesCacheTests.kt$UnspentStatesCacheTests${ val referenceStates = listOf(generateStateRef()) val inputs = listOf(generateStateRef()) val secondTxId = SecureHash.randomSHA256() val unspentStatesCache = UnspentStatesCacheFactory().create() provider = createJPAUniquenessProvider(Clock.systemUTC(), unspentStatesCache) //Input states and reference states are not marked as unspent, either before or after the transaction is committed assertFalse(unspentStatesCache.isAllUnspent(inputs)) assertFalse(unspentStatesCache.isAllUnspent(referenceStates)) val result = provider!!.commit(inputs, txID, identity, requestSignature, references = referenceStates).get() assertEquals(UniquenessProvider.Result.Success, result) assertFalse(unspentStatesCache.isAllUnspent(inputs)) assertFalse(unspentStatesCache.isAllUnspent(referenceStates)) // Idempotency: can re-notarise successfully. val result2 = provider!!.commit(inputs, txID, identity, requestSignature, references = referenceStates).get() assertEquals(UniquenessProvider.Result.Success, result2) //Input states using the first txId are marked as unspent, while reference states are unaffected //Note that if we created reference states using the first txId, they would be marked as unspent val secondInputs = listOf(StateRef(txID, 0)) assertTrue(unspentStatesCache.isAllUnspent(secondInputs)) val result3 = provider!!.commit(secondInputs, secondTxId, identity, requestSignature, references = referenceStates).get() assertEquals(UniquenessProvider.Result.Success, result3) assertFalse(unspentStatesCache.isAllUnspent(secondInputs)) }</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$Action.PersistCheckpoint(context.id, currentState.checkpoint, isCheckpointUpdate = currentState.isAnyCheckpointPersisted)</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$SenderDeduplicationId(DeduplicationId.createForNormal(currentState.checkpoint, 0, initiatedState), currentState.senderUUID)</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$deduplicationSeed = "D-${initiatingMessage.initiatorSessionId.toLong}-${initiatingMessage.initiationEntropy}"</ID>
    <ID>MaxLineLength:Util.kt$arrangement.actions.fold(ImmutableSet.builder&lt;Party&gt;(), { builder, k -&gt; builder.addAll(involvedPartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.actions.fold(ImmutableSet.builder&lt;PublicKey&gt;(), { builder, k -&gt; builder.addAll(liablePartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.arrangements.fold(ImmutableSet.builder&lt;Party&gt;(), { builder, k -&gt; builder.addAll(involvedPartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.arrangements.fold(ImmutableSet.builder&lt;PublicKey&gt;(), { builder, k -&gt; builder.addAll(liablePartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$is PerceivableAnd -&gt; Sets.union( signingParties( perceivable.left ), signingParties(perceivable.right) ).immutableCopy()</ID>
    <ID>MaxLineLength:Util.kt$is PerceivableOr -&gt; Sets.union( signingParties( perceivable.left ), signingParties(perceivable.right) ).immutableCopy()</ID>
    <ID>MaxLineLength:Util.kt$net.corda.finance.contracts.universal.Util.kt</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;SNAPSHOT, ELEMENT&gt; DataFeed&lt;SNAPSHOT, ELEMENT&gt;.doOnError(action: (Throwable) -&gt; Unit): DataFeed&lt;SNAPSHOT, ELEMENT&gt;</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;SNAPSHOT, ELEMENT&gt; DataFeed&lt;SNAPSHOT, ELEMENT&gt;.mapErrors(transform: (Throwable) -&gt; Throwable): DataFeed&lt;SNAPSHOT, ELEMENT&gt;</ID>
    <ID>MaxLineLength:Utils.kt$ fun &lt;T&gt; Observable&lt;T&gt;.notUsed()</ID>
    <ID>MaxLineLength:Utils.kt$ fun TransactionBuilder.addAttachmentOnce(att: SecureHash?): TransactionBuilder</ID>
    <ID>MaxLineLength:Utils.kt$@Suppress("UNCHECKED_CAST") inline</ID>
    <ID>MaxLineLength:Utils.kt$StateRefHere</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; Configuration.Property.Definition.Single&lt;TYPE&gt;.listOrEmpty(): Configuration.Property.Definition&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; PropertyDelegate.Single&lt;TYPE&gt;.listOrEmpty(): PropertyDelegate&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.RequiredList&lt;TYPE&gt;.mapValid(noinline convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.mapValid(noinline convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;reified ENUM : Enum&lt;ENUM&gt;, VALUE : Any&gt; Configuration.Specification&lt;VALUE&gt;.enum(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;reified NESTED : Any&gt; Configuration.Specification&lt;*&gt;.nested(specification: Configuration.Specification&lt;NESTED&gt;, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;NESTED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$internal fun Config.serialize(options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true).setJson(true)): String</ID>
    <ID>MaxLineLength:Utils.kt$internal fun ConfigValue.serialize(options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true).setJson(true)): String</ID>
    <ID>MaxLineLength:Utils.kt$return requireNotNull(getDeclaredAnnotation(A::class.java)) { "$name needs to be annotated with ${A::class.java.name}" }</ID>
    <ID>MaxLineLength:Utils.kt$return results.states.firstOrNull() ?: throw IllegalArgumentException("State (type=${T::class}) corresponding to the reference $ref not found (or is spent).")</ID>
    <ID>MaxLineLength:UtilsTest.kt$UtilsTest$rawConfiguration += "key1.key2" to configObject("key3" to "value2", "key4" to configObject("key5" to -2.0, "key6" to false))</ID>
    <ID>MaxLineLength:UtilsTest.kt$UtilsTest$rawConfiguration += "key7" to listOf("Hey!", true, 17, 0.0, configObject("key8" to listOf(-12.0, "HH", false), "key9" to "blah"))</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService$cryptoServerProvider.loginSign(credentials.username, credentials.keyFile.toFile().absolutePath, String(credentials.password))</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService$getPublicKey(alias) ?: throw CryptoServiceException("Key generation for alias $alias succeeded, but key could not be accessed afterwards.")</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService$override</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService$private</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService.&lt;no name provided&gt;$private val publicKey: PublicKey = getPublicKey(alias) ?: throw CryptoServiceException("No key found for alias $alias", isRecoverable = false)</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService.Companion$( // KeepSessionAlive=1 doesn't prevent from session expiry after 5 min of inactivity when using remote connection to HSM. // As a workaround, we use HSM cluster with two identical nodes to handle network re-connections automatically. "${config.port}@${config.host} ${config.port}@${config.host}", config.connectionTimeout, config.timeout, if (config.keepSessionAlive) 1 else 0, config.keyGroup, config.keySpecifier )</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService.Companion$is ConfigException, is UnknownConfigurationKeysException -&gt; throw Exception("Error in ${configFile.toFile().absolutePath} : ${e.message}")</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService.Companion$return fromConfig(config) { UtimacoCredentials(config.username, config.password.toByteArray(), config.keyFile) }</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService.Companion$throw ConnectException("${CryptoServerAPI.CryptoServerException.getErrorMessage(e.ErrorCode, null)}: " + HsmErrors.errors[e.ErrorCode])</ID>
    <ID>MaxLineLength:UtimacoCryptoService.kt$UtimacoCryptoService.Companion${ // This error is reported when it's not possible to connect to any CryptoServer in a cluster mode. // In non-cluster mode ConnectException is thrown instead. // To let CryptoServiceSigningService start when connection to HSM cannot be temporarily established, // the error needs to be converted to IOException which has a special handling inside CryptoServiceSigningService. throw ConnectException("${CryptoServerAPI.CryptoServerException.getErrorMessage(e.ErrorCode, null)}: " + HsmErrors.errors[e.ErrorCode]) }</ID>
    <ID>MaxLineLength:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest$assertFailsWith&lt;UtimacoCryptoService.UtimacoHSMException&gt; { cryptoService.generateKeyPair("foo", cryptoService.defaultIdentitySignatureScheme()) }</ID>
    <ID>MaxLineLength:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest$assertFailsWith&lt;UtimacoCryptoService.UtimacoHSMException&gt; { cryptoService.generateKeyPair(alias, Crypto.ECDSA_SECP256R1_SHA256) }</ID>
    <ID>MaxLineLength:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest$override fun getSupportedSchemes(): List&lt;SignatureScheme&gt;</ID>
    <ID>MaxLineLength:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest$val cryptoService = UtimacoCryptoService.fromConfig(conf) { UtimacoCryptoService.UtimacoCredentials(username, pw, keyFile) }</ID>
    <ID>MaxLineLength:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest$val cryptoService = UtimacoCryptoService.fromConfig(config) { UtimacoCryptoService.UtimacoCredentials("INTEGRATION_TEST", pw.toByteArray()) }</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val additionalNodeInfoPollingFrequencyMsec by long().optional().withDefaultValue(Defaults.additionalNodeInfoPollingFrequencyMsec)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val additionalP2PAddresses by string().mapValid(::toNetworkHostAndPort).list().optional().withDefaultValue(Defaults.additionalP2PAddresses)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val blacklistedAttachmentSigningKeys by string().list().optional().withDefaultValue(Defaults.blacklistedAttachmentSigningKeys)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val certificateChainCheckPolicies by nested(CertChainPolicyConfigSpec).list().optional().withDefaultValue(Defaults.certificateChainCheckPolicies)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val cordappSignerKeyFingerprintBlacklist by string().list().optional().withDefaultValue(Defaults.cordappSignerKeyFingerprintBlacklist)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val extraNetworkMapKeys by string().mapValid(::toUUID).list().optional().withDefaultValue(Defaults.extraNetworkMapKeys)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val flowMonitorSuspensionLoggingThresholdMillis by duration().optional().withDefaultValue(Defaults.flowMonitorSuspensionLoggingThresholdMillis)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$return result.mapValid { conf -&gt; Valid.withResult(conf as NodeConfiguration, conf.validate().map(::toError).toSet()) }</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$val messagingServerExternal = config[messagingServerExternal] ?: Defaults.messagingServerExternal(config[messagingServerAddress])</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$private fun toError(validationErrorMessage: String): Configuration.Validation.Error</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$internal</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$return cmdLineOptions.parseConfiguration(rawConfig).doIfValid { logRawConfig(rawConfig) }.doOnErrors(::logConfigurationErrors).optional?.let { ExitCodes.SUCCESS } ?: ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$val rawConfig = cmdLineOptions.rawConfiguration().doOnErrors(cmdLineOptions::logRawConfigurationErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$internal fun logRawConfig(config: Config)</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$logger.error(errors.joinToString(System.lineSeparator(), "Error(s) while parsing node configuration:${System.lineSeparator()}") { error -&gt; "\t- ${error.description()}" })</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$private val configRenderingOptions = ConfigRenderOptions.defaults().setFormatted(true).setComments(false).setOriginComments(false)</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED&gt; map(convert: (TARGET) -&gt; MAPPED): Validated&lt;MAPPED, ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED&gt; mapValid(convert: (TARGET) -&gt; Validated&lt;MAPPED, ERROR&gt;): Validated&lt;MAPPED, ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED_ERROR&gt; mapErrors(convertError: (ERROR) -&gt; MAPPED_ERROR): Validated&lt;TARGET, MAPPED_ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun value(exceptionOnErrors: (Set&lt;ERROR&gt;) -&gt; Exception = { errors -&gt; IllegalStateException(errors.joinToString(System.lineSeparator())) }): TARGET</ID>
    <ID>MaxLineLength:Validated.kt$Validated$/** * Returns the underlying value as optional, with a null result instead of an exception if validation rules were violated. */ val optional: TARGET? get() = if (isValid) value() else null</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Companion$ fun &lt;T, E&gt; withResult(target: T, errors: Set&lt;E&gt;): Validated&lt;T, E&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Result$Unsuccessful&lt;TARGET, ERROR&gt; : ResultValidated</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Result.Successful$override</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Result.Unsuccessful$override</ID>
    <ID>MaxLineLength:ValidatingNotaryFlow.kt$ValidatingNotaryFlow : NotaryServiceFlow</ID>
    <ID>MaxLineLength:ValidatingNotaryFlow.kt$ValidatingNotaryFlow$open</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(alice.owningKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$assertThat(notaryError.cause).hasMessageContaining("Transaction for notarisation doesn't contain network parameters hash.")</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$private</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests$val modifiedSignature = NotarisationRequestSignature(randomKeyPair.sign(bytesToSign), aliceNode.services.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests.&lt;no name provided&gt;$val alteredMessage = InMemoryMessage(message.topic, OpaqueBytes(alteredMessageData.serialize().bytes), message.uniqueMessageId)</ID>
    <ID>MaxLineLength:Validator.kt$Validator$ fun validate(target: TARGET, options: OPTIONS): Validated&lt;TARGET, ERROR&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$CommodityState$override</ID>
    <ID>MaxLineLength:VaultFiller.kt$CommodityState$override fun withNewOwner(newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ // TODO: need to make all FungibleAsset commands (issue, move, exit) generic fun fillWithSomeTestCommodity(amount: Amount&lt;Commodity&gt;, issuerServices: ServiceHub, issuedBy: PartyAndReference): Vault&lt;CommodityState&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ fun fillWithSomeTestCash(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT): Vault&lt;Cash.State&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ fun generateCommoditiesIssue(tx: TransactionBuilder, amount: Amount&lt;Issued&lt;Commodity&gt;&gt;, owner: AbstractParty, notary: Party)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$addOutputState(DummyDealContract.State(ref = "test ref", participants = participants.plus(me)), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$addOutputState(DummyDealContract.State(ref = it, participants = participantsToUse), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$cash.generateIssue(issuance, Amount(pennies, Issued(issuedBy, howMuch.token)), owner ?: services.myInfo.singleIdentity(), altNotary)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$fun evolveLinearState(linearState: StateAndRef&lt;LinearState&gt;): StateAndRef&lt;LinearState&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$val amounts = calculateRandomlySizedAmounts(howMuch, atLeastThisManyStates, atMostThisManyStates, rng ?: rngFactory())</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(issuerKey.public).schemeNumberID)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller.Companion${ val numSlots = min + Math.floor(rng.nextDouble() * (max - min)).toInt() val baseSize = howMuch.quantity / numSlots check(baseSize &gt; 0) { baseSize } val amounts = LongArray(numSlots) { baseSize } var distanceFromGoal = 0L // If we want 10 slots then max adjust is 0.1, so even if all random numbers come out to the largest downward // adjustment possible, the last slot ends at zero. With 20 slots, max adjust is 0.05 etc. val maxAdjust = 1.0 / numSlots for (i in amounts.indices) { if (i != amounts.lastIndex) { val adjustBy = rng.nextDouble() * maxAdjust - (maxAdjust / 2) val adjustment = (1 + adjustBy) val adjustTo = (amounts[i] * adjustment).toLong() amounts[i] = adjustTo distanceFromGoal += baseSize - adjustTo } else { amounts[i] += distanceFromGoal } } // The desired amount may not have divided equally to start with, so adjust the first value to make up. amounts[0] += howMuch.quantity - amounts.sum() return amounts }</ID>
    <ID>MaxLineLength:VaultFlowTest.kt$VaultFlowTest.Initiator$addOutputState(UniqueDummyLinearContract.State(participants, "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultFlowTest.kt$VaultFlowTest.Initiator$val stx = serviceHub.signInitialTransaction(TransactionBuilder(serviceHub.networkMapCache.notaryIdentities.first()).apply { addOutputState(UniqueDummyLinearContract.State(participants, "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID) addOutputState(DummyDealContract.State(participants, "linear id"), DUMMY_DEAL_PROGRAM_ID) addCommand(DummyCommandData, listOf(ourIdentity.owningKey)) })</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$(notaryServices.myInfo.legalIdentitiesAndCerts + BOC_IDENTITY + CASH_NOTARY_IDENTITY + MINI_CORP_IDENTITY + MEGA_CORP_IDENTITY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$notaryServices = MockServices(cordappPackages, dummyNotary, mock(), dummyCashIssuer.keyPair, BOC_KEY, MEGA_CORP_KEY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { ContractState::class.java.isAssignableFrom(it.state.data::class.java) }.size == 20) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { DealState::class.java.isAssignableFrom(it.state.data::class.java) }.size == 10) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { DummyDealContract.State::class.java.isAssignableFrom(it.state.data::class.java) }.size == 10) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$/** * Query result returns a [Vault.Page] which contains: * 1) actual states as a list of [StateAndRef] * 2) state reference and associated vault metadata as a list of [Vault.StateMetadata] * 3) [PageSpecification] used to delimit the size of items returned in the result set (defaults to [DEFAULT_PAGE_SIZE]) * 4) Total number of items available (to aid further pagination if required) */ val states = result.states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$// Beware: do not use `MyContractClass::class.qualifiedName` as this returns a fully qualified name using "dot" notation for enclosed class val MYCONTRACT_ID = "net.corda.node.services.vault.VaultQueryTestsBase\$MyContractClass"</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Suppress("EXPECTED_CONDITION") val pagingSpec = PageSpecification(DEFAULT_PAGE_NUM, @Suppress("INTEGER_OVERFLOW") Integer.MAX_VALUE + 1) // overflow = -2147483648</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator NOT LIKE does not return results containing the same characters as the case insensitive string`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator case insensitive NOT IN does not return results containing the same characters as the case insensitive strings`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator case insensitive NOT_EQUAL does not return results containing the same characters as the case insensitive string`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$CashSchemaV1.PersistentCashState::pennies</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$CommercialPaperUtils.generateIssue(issuance, faceValue, TEST_TX_TIME + 30.days, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$CommercialPaperUtils.generateIssue(issuance, faceValue2, TEST_TX_TIME + 30.days, DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$MyState : BaseState</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$QueryCriteria.TimeInstantType.CONSUMED</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.ASC -&gt; assertThat(allStates.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.ASC -&gt; assertThat(allStates.sortedBy { it.state.data.linearNumber }.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.DESC -&gt; assertThat(allStates.sortedByDescending { it.ref.txhash }.sortedByDescending { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.DESC -&gt; assertThat(allStates.sortedByDescending { it.state.data.linearNumber }.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(constraintResults.states.map { it.state.constraint }).containsAll(listOf(constraintHash, constraintSignature, constraintSignatureCompositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(constraintResults4.states.map { it.state.constraint }).containsAll(listOf(constraintSignature, constraintSignatureCompositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(enrichedResults.map { it.state.constraint }).containsAll(listOf(constraintSignature, alwaysAcceptConstraint))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(fungibleStateCountUnconsumed.toInt()).isEqualTo(10 - cashUpdates.consumed.size + cashUpdates.produced.size)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(metadata.last().contractStateClassName).isEqualTo("net.corda.finance.contracts.asset.Cash\$State")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(results.states).hasSize(1)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(results.states).hasSize(2)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$groupByColumns = listOf(SampleCashSchemaV2.PersistentCashState::currency, SampleCashSchemaV2.PersistentCashState::stateRef)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(10.DOLLARS, 25.POUNDS, 50.POUNDS, 100.SWISS_FRANCS).zip(listOf(3, 1, 1, 3))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(100.DOLLARS, 200.DOLLARS, 300.DOLLARS, 400.POUNDS, 500.SWISS_FRANCS).zip(1..5)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(100.DOLLARS, 200.DOLLARS, 300.POUNDS, 400.POUNDS, 500.SWISS_FRANCS, 600.SWISS_FRANCS).zip(1..6)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(UUID.randomUUID()))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val allStates = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, criteria = criteria).states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val alwaysAcceptConstraint = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AlwaysAcceptAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val avg = builder { CashSchemaV1.PersistentCashState::pennies.avg(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val baseCriteria = VaultQueryCriteria(constraints = setOf(Vault.ConstraintInfo(AlwaysAcceptAttachmentConstraint)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val ccyIndex = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val ccyIndex = builder { CommercialPaperSchemaV1.PersistentCommercialPaperState::currency.equal(USD.currencyCode) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val chfCashIssuerName = CordaX500Name(organisation = "Swiss Francs Cash Issuer", locality = "Zurich", country = "CH")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val compositeKey = CompositeKey.Builder().addKeys(alice.publicKey, bob.publicKey, charlie.publicKey, bankOfCorda.publicKey, bigCorp.publicKey, megaCorp.publicKey, miniCorp.publicKey, cashNotary.publicKey, dummyNotary.publicKey, dummyCashIssuer.publicKey).build()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintCriteria1 = VaultQueryCriteria(constraints = setOf(Vault.ConstraintInfo(AlwaysAcceptAttachmentConstraint)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintCriteria3 = VaultQueryCriteria(constraints = setOf(Vault.ConstraintInfo(constraintSignatureCompositeKey)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintSignature = linearStateSignature.states.first().state.constraint as SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintSignatureCompositeKey = linearStateSignatureCompositeKey.states.first().state.constraint as SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId1)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaByLockIds = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId1, lockId2)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaExclusive = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaLockedOnly = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaMissingLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_AND_SPECIFIED))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaUnlockedAndByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(lockId2)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val database = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(runMigration = true), identitySvc::wellKnownPartyFromX500Name, identitySvc::wellKnownPartyFromAnonymous)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val dealStateCountConsumed = vaultService.queryBy&lt;DealState&gt;(countCriteriaConsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val dealStateCountUnconsumed = vaultService.queryBy&lt;DealState&gt;(countCriteriaUnconsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val externalIds = listOf(linearState1.states.first().state.data.linearId.externalId!!, linearState3.states.first().state.data.linearId.externalId!!)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val faceValueIndex = CommercialPaperSchemaV1.PersistentCommercialPaperState::faceValue.greaterThanOrEqual(10000L)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val fungibleAssetStateCriteria = FungibleAssetQueryCriteria(participants = listOf(services.myInfo.singleIdentity()))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val fungibleStateCountConsumed = vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;(countCriteriaConsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val fungibleStateCountUnconsumed = vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;(countCriteriaUnconsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val gbpCashIssuerName = CordaX500Name(organisation = "British Pounds Cash Issuer", locality = "London", country = "GB")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val issuedStates = vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER).states.toList()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearIds = listOf(linearState1.states.first().state.data.linearId, linearState3.states.first().state.data.linearId)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearState2 = vaultFiller.evolveLinearState(linearState) // consume current and produce new state reference</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearState3 = vaultFiller.evolveLinearState(linearState2) // consume current and produce new state reference</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCountConsumed = vaultService.queryBy&lt;LinearState&gt;(countCriteriaConsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCountUnconsumed = vaultService.queryBy&lt;LinearState&gt;(countCriteriaUnconsumed).otherResults.single() as Long</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(linearId = listOf(linearId), status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(linearId = txns.states.map { it.state.data.linearId }, status = Vault.StateStatus.CONSUMED)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(uuid = linearStates.map { it.state.data.linearId.id }, status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateHash = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint) // defaults to the HashConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateHash = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint) // defaults to the hash constraint.</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateSignature = vaultFiller.fillWithSomeTestLinearStates(1, constraint = SignatureAttachmentConstraint(alice.publicKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateSignatureCompositeKey = vaultFiller.fillWithSomeTestLinearStates(1, constraint = SignatureAttachmentConstraint(compositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStates = vaultFiller.fillWithSomeTestLinearStates(2, "TEST") // create 2 states with same externalId</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val logicalExpression = builder { CashSchemaV1.PersistentCashState::pennies.`in`(listOf(10000L, 20000L), false) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val logicalExpression = builder { CashSchemaV1.PersistentCashState::pennies.notIn(listOf(10000L, 20000L), false) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val maturityIndex = CommercialPaperSchemaV1.PersistentCommercialPaperState::maturity.greaterThanOrEqual(TEST_TX_TIME + 30.days)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val max = builder { CashSchemaV1.PersistentCashState::pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val max = builder { CashSchemaV1.PersistentCashState::pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val min = builder { CashSchemaV1.PersistentCashState::pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val min = builder { CashSchemaV1.PersistentCashState::pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val newAllStates = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, criteria = criteria).states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val page = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, paging = paging, criteria = criteria)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val result = vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(status = Vault.StateStatus.ALL), sorting = sorting)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = services.vaultService.queryBy&lt;FungibleAsset&lt;*&gt;&gt;(baseCriteria and enrichedCriteria, sorter).states</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = vaultService.queryBy&lt;Cash.State&gt;(criteria, Sort(setOf(Sort.SortColumn(sortAttribute, Sort.Direction.ASC))))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = vaultService.queryBy&lt;DummyLinearContract.State&gt;(criteria, Sort(setOf(Sort.SortColumn(sortAttribute, Sort.Direction.ASC))))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val resultsComposite = vaultService.queryBy&lt;ContractState&gt;(linearStateCriteria.or(fungibleAssetStateCriteria))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val resultsCompositeAnd = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.and(linearStateCriteria))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val resultsCompositeOr = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.or(linearStateCriteria))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(issuerKey.public).schemeNumberID)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val signedStatesExitingTx = services.signInitialTransaction(statesExitingTx).withAdditionalSignature(issuerKey, signatureMetadata)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortAttribute = SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "linearNumber")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortAttribute = SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "stateRef")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortCol1 = Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.CONTRACT_STATE_TYPE), Sort.Direction.DESC)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortCol2 = Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.STATE_STATUS), Sort.Direction.ASC)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sortCol3 = Sort.SortColumn(SortAttribute.Standard(Sort.VaultStateAttribute.CONSUMED_TIME), Sort.Direction.DESC)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "linearString"), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Standard(Sort.LinearStateAttribute.EXTERNAL_ID), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Standard(Sort.LinearStateAttribute.UUID), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val statesExitingTx = TransactionBuilder(notary.party).withItems(*states.toList().toTypedArray()).addCommand(dummyCommand())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val usdCashIssuerName = CordaX500Name(organisation = "US Dollars Cash Issuer", locality = "New York", country = "US")</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val utx = TransactionBuilder(notary = notaryServices.myInfo.singleIdentity()).withItems(stateAndContract).withItems(dummyCommand())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCash(100.DOLLARS, notaryServices, 1, BOC.ref(0), MINI_CORP)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCash(100.DOLLARS, notaryServices, 1, DUMMY_CASH_ISSUER, services.myInfo.singleIdentity())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCommodity(Amount(100, Commodity.getInstance("FCOJ")!!), notaryServices, DUMMY_OBLIGATION_ISSUER.ref(1))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, "TEST1") vaultFiller.fillWithSomeTestDeals(listOf("123")) vaultFiller.fillWithSomeTestCash(100.DOLLARS, notaryServices, 1, DUMMY_CASH_ISSUER, services.myInfo.singleIdentity()) vaultFiller.fillWithSomeTestCommodity(Amount(100, Commodity.getInstance("FCOJ")!!), notaryServices, DUMMY_OBLIGATION_ISSUER.ref(1)) vaultFiller.fillWithDummyState() // all contract states query val results = vaultService.queryBy&lt;ContractState&gt;() assertThat(results.states).hasSize(5) // linear states only query val linearStateCriteria = LinearStateQueryCriteria() val resultsLSC = vaultService.queryBy&lt;ContractState&gt;(linearStateCriteria) assertThat(resultsLSC.states).hasSize(2) // fungible asset states only query val fungibleAssetStateCriteria = FungibleAssetQueryCriteria() val resultsFASC = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria) assertThat(resultsFASC.states).hasSize(2) // composite OR query for both linear and fungible asset states (eg. all states in either Fungible and Linear states tables) val resultsCompositeOr = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.or(linearStateCriteria)) assertThat(resultsCompositeOr.states).hasSize(4) // composite AND query for both linear and fungible asset states (eg. all states in both Fungible and Linear states tables) val resultsCompositeAnd = vaultService.queryBy&lt;ContractState&gt;(fungibleAssetStateCriteria.and(linearStateCriteria)) assertThat(resultsCompositeAnd.states).hasSize(0)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, constraint = AlwaysAcceptAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestLinearStates(1, constraint = WhitelistedByZoneAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER, charlie.party, statesToRecord = StatesToRecord.ALL_VISIBLE)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER, statesToRecord = StatesToRecord.ALL_VISIBLE)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultService.softLockReserve(UUID.randomUUID(), NonEmptySet.of(issuedStates[1].ref, issuedStates[2].ref, issuedStates[3].ref))</ID>
    <ID>MaxLineLength:VaultRestartTest.kt$VaultRestartTest$val node = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to "localhost:30000")).getOrThrow()</ID>
    <ID>MaxLineLength:VaultRestartTest.kt$VaultRestartTest$val restartedNode = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to "localhost:30000")).getOrThrow()</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.PersistentStateRefAndKey$@Embeddable @Immutable data</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultLinearStates$@Table(name = "vault_linear_states", indexes = [Index(name = "external_id_index", columnList = "external_id"), Index(name = "uuid_index", columnList = "uuid")])</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultStates$@Table(name = "vault_states", indexes = [Index(name = "state_status_idx", columnList = "state_status"), Index(name = "lock_id_idx", columnList = "lock_id, state_status")])</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultTxnNote$@Table(name = "vault_transaction_notes", indexes = [Index(name = "seq_no_index", columnList = "seq_no"), Index(name = "transaction_id_index", columnList = "transaction_id")])</ID>
    <ID>MaxLineLength:VaultService.kt$StatesNotAvailableException : FlowException</ID>
    <ID>MaxLineLength:VaultService.kt$Vault$Update&lt;U : ContractState&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Companion$@Deprecated("No longer used. The vault does not emit empty updates") val NoNotaryUpdate = Vault.Update(emptySet(), emptySet(), type = Vault.UpdateType.NOTARY_CHANGE, references = emptySet())</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, null)</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, relevancyStatus, ConstraintInfo(AlwaysAcceptAttachmentConstraint))</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$ operator fun plus(rhs: Update&lt;U&gt;): Update&lt;U&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$/** * Specifies the type of update, currently supported types are general and, contract upgrade and notary change. * Notary change transactions only modify the notary field on states, and potentially need to be handled * differently. */ val type: UpdateType = UpdateType.GENERAL</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$inline</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references)</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update${ require(rhs.type == type) { "Cannot combine updates of different types" } val combinedConsumed = consumed + (rhs.consumed - produced) // The ordering below matters to preserve ordering of consumed/produced Sets when they are insertion order dependent implementations. val combinedProduced = produced.filter { it !in rhs.consumed }.toSet() + rhs.produced return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references) }</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$ @Suspendable @Throws(StatesNotAvailableException::class) fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending(lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt;): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$/** * Prefer the use of [updates] unless you know why you want to use this instead. * * Get a synchronous [Observable] of updates. When observations are pushed to the Observer, the [Vault] will already * incorporate the update, and the database transaction associated with the update will still be open and current. * If for some reason the processing crosses outside of the database transaction (for example, the update is pushed * outside the current JVM or across to another [Thread], which is executing in a different database transaction), * then the [Vault] may not incorporate the update due to racing with committing the current database transaction. */ val rawUpdates: Observable&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$doneFuture(Vault.Update(consumed = setOf(snapshot.single()), produced = emptySet(), references = emptySet()))</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$inline</ID>
    <ID>MaxLineLength:VaultServiceInternal.kt$VaultServiceInternal$ fun notify(statesToRecord: StatesToRecord, tx: CoreTransaction)</ID>
    <ID>MaxLineLength:VaultServiceInternal.kt$VaultServiceInternal$ fun notifyAll(statesToRecord: StatesToRecord, txns: Iterable&lt;CoreTransaction&gt;, previouslySeenTxns: Iterable&lt;CoreTransaction&gt; = emptyList())</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair$internals.disableDBCloseOnStop() // Otherwise the in-memory database may disappear (taking the checkpoint with it) while we reboot the client.</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair$server.registerCoreFlowFactory(AbstractClientLogic::class.java, ServerLogic::class.java, { ServerLogic(it, serverRunning) }, false)</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair.ServerLogic$private</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest$ClientLogic : AbstractClientLogic</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest$private</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest${ assertEquals(emptyList(), fsm.resultFuture.getOrThrow()) // In this case we don't want softLockRelease called so that we avoid its expensive query, even after restore from checkpoint. }</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.&lt;no name provided&gt;.&lt;no name provided&gt;$mockVault.softLockRelease(lockId, stateRefs)</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.ClientLogic$return serviceHub.vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(LOCKED_ONLY))).states.map { it.state.data }</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.FungibleAssetImpl$@BelongsToContract(ContractImpl::class) private</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.FungibleAssetImpl$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Unit&gt;&gt;, newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultMigrationSchema</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator : Iterator</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$// The rest of this class is an attempt at multithreading that was ultimately scuppered by liquibase not providing a connection pool. // This may be useful as a starting point for improving performance of the migration, so is left here. To start using it, remove the // serialization environment changes in the execute function in the migration, and change forEach -&gt; parallelForEach. private val pool = ForkJoinPool.commonPool()</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$criteriaBuilder</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$logger.debug("Loaded page $pageNumber of ${(numStates - 1 / pageNumber.toLong()) + 1}. Current page has ${result.size} vault states")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$private</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator${ endTransaction() transaction = database.newTransaction() val query = createVaultStatesQuery(VaultSchemaV1.VaultStates::class.java) { it } // The above query excludes states that have entries in the state party table. As the iteration proceeds, each state has entries // added to this table. The result is that when the next page is retrieved, any results that were in the previous page are not in // the query at all! As such, the next set of states that need processing start at the first result. query.firstResult = 0 query.maxResults = pageSize pageNumber++ val result = query.resultList logger.debug("Loaded page $pageNumber of ${(numStates - 1 / pageNumber.toLong()) + 1}. Current page has ${result.size} vault states") return result }</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion$effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion.AMQPInspectorSerializationScheme$override</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion.AMQPInspectorSerializationScheme$override fun rpcClientSerializerFactory(context: SerializationContext)</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion.AMQPInspectorSerializationScheme$override fun rpcServerSerializerFactory(context: SerializationContext)</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$return listOf(VaultPageTask(database, page.subList(0, pageSize / 2), block), VaultPageTask(database, page.subList(pageSize / 2, pageSize), block))</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$logger</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$logger.info("Finished performing vault state data migration for ${persistentStates.numStates - statesSkipped} states")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$throw VaultStateMigrationException("Cannot add state parties for state ${stateAndRef.ref} as state class is not on the " + "classpath and participants cannot be synthesised")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$throw VaultStateMigrationException("Cannot migrate vault states as liquibase failed to provide a suitable database connection")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$throw VaultStateMigrationException("Failed to migrate $statesSkipped states in the vault. Check the logs for details of the " + "error for each state.")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration$val myKeys = identityService.stripNotOurKeys(stateAndRef.state.data.participants.map { participant -&gt; participant.owningKey }).toSet()</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration${ // This should only happen if there was no attachment that could be used to deserialise the output states, and the state was // serialised such that the participants list cannot be accessed (participants is calculated and not marked as a // SerializableCalculatedProperty. throw VaultStateMigrationException("Cannot add state parties for state ${stateAndRef.ref} as state class is not on the " + "classpath and participants cannot be synthesised") }</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateMigration${ val stateAndRef = getStateAndRef(it) addStateParties(session, stateAndRef) // Can get away without checking for AbstractMethodErrors here as these will have already occurred when trying to add // state parties. val myKeys = identityService.stripNotOurKeys(stateAndRef.state.data.participants.map { participant -&gt; participant.owningKey }).toSet() if (!NodeVaultService.isRelevant(stateAndRef.state.data, myKeys)) { it.relevancyStatus = Vault.RelevancyStatus.NOT_RELEVANT } }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$OnLedgerAsset.generateIssue(txBuilder, TransactionState(CommodityState(amount, owner), Obligation.PROGRAM_ID, dummyNotary.party), Obligation.Commands.Issue())</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$cordaDB = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), notaryServices.identityService::wellKnownPartyFromX500Name, notaryServices.identityService::wellKnownPartyFromAnonymous)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$createCommodityTransaction(Amount(it.toLong(), Issued(bankOfCorda.ref(2), Commodity.getInstance("FCOJ")!!)), owner)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$createVaultStatesFromNotaryChangeTransaction(notaryTx, cashTx.coreTransaction.outputs + cashTx2.coreTransaction.outputs)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$criteriaQuery.where(criteriaBuilder.equal(queryRootStates.get&lt;Vault.RelevancyStatus&gt;("relevancyStatus"), relevancyStatus))</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$private</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val notaryTx = createNotaryChangeTransaction(listOf(StateRef(cashTx.id, 0), StateRef(cashTx2.id, 0)), SecureHash.allOnesHash)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val persistentIDs = certs.map { PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.toStringShort(), it.certPath.encoded) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val persistentName = PersistentIdentityService.PersistentPartyToPublicKeyHash(name.toString(), certs.first().owningKey.toStringShort())</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val signableData = SignableData(notaryTx.id, SignatureMetadata(3, Crypto.findSignatureScheme(notaryKey).schemeNumberID))</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ // Liquibase automatically closes the database connection when doing an actual migration. This test ensures the custom migration // leaves it open. addCashStates(12, ALICE) val migration = VaultStateMigration() migration.execute(liquibaseDB) assertFalse(cordaDB.dataSource.connection.isClosed) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ // This test is a little bit of a hack - it checks that these states are migrated correctly by looking at params in the database, // but these will not be there for V3 nodes. Handling for this must be tested manually. val cashTx = createCashTransaction(Cash(), 5.DOLLARS, BOB) val cashTx2 = createCashTransaction(Cash(), 10.DOLLARS, BOB) val notaryTx = createNotaryChangeTransaction(listOf(StateRef(cashTx.id, 0), StateRef(cashTx2.id, 0)), SecureHash.allOnesHash) createVaultStatesFromTransaction(cashTx, stateStatus = Vault.StateStatus.CONSUMED) createVaultStatesFromTransaction(cashTx2, stateStatus = Vault.StateStatus.CONSUMED) createVaultStatesFromNotaryChangeTransaction(notaryTx, cashTx.coreTransaction.outputs + cashTx2.coreTransaction.outputs) storeTransaction(cashTx) storeTransaction(cashTx2) storeTransaction(notaryTx) val migration = VaultStateMigration() migration.execute(liquibaseDB) assertEquals(2, getStatePartyCount()) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ val cashStatesToAdd = 1000 val linearStatesToAdd = 0 val commodityStatesToAdd = 0 val stateMultiplier = 10 cordaDB = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), notaryServices.identityService::wellKnownPartyFromX500Name, notaryServices.identityService::wellKnownPartyFromAnonymous) // Starting the database this way runs the migration under test. This is fine for the unit tests (as the changelog table is ignored), // but when starting an actual node using these databases the migration will be skipped, as it has an entry in the changelog table. // This must therefore be removed. cordaDB.dataSource.connection.createStatement().use { it.execute("DELETE FROM DATABASECHANGELOG WHERE FILENAME IN ('migration/vault-schema.changelog-v9.xml')") } for (i in 1..stateMultiplier) { addCashStates(cashStatesToAdd, BOB) addLinearStates(linearStatesToAdd, listOf(BOB, ALICE)) addCommodityStates(commodityStatesToAdd, BOB) } saveOurKeys(listOf(bob.keyPair)) saveAllIdentities(listOf(BOB_IDENTITY, ALICE_IDENTITY, BOC_IDENTITY, dummyNotary.identity)) cordaDB.close() }</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$@Test fun `something plus consume states 0 and 1, and produce state 4, is something without state 0 and 1 outputs and only state 4 output`()</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef0 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef0)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef1 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef1)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef2 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef2)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef3 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef3)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef4 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef4)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$val expected = Vault.Update&lt;ContractState&gt;(setOf(stateAndRef2, stateAndRef3), setOf(stateAndRef0, stateAndRef1, stateAndRef4))</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$val notaryChangeUpdate = Vault.Update&lt;ContractState&gt;(setOf(stateAndRef2, stateAndRef3), setOf(stateAndRef0, stateAndRef1), type = Vault.UpdateType.NOTARY_CHANGE)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$Cash().generateIssue(usefulBuilder, 100.DOLLARS `issued by` MEGA_CORP.ref(1), AnonymousParty(freshKey), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$CashUtils.generateSpend(services, spendTXBuilder, 80.DOLLARS, services.myInfo.legalIdentitiesAndCerts.single(), BOB)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$CashUtils.generateSpend(services, txn1Builder, 60.DOLLARS, services.myInfo.legalIdentitiesAndCerts.single(), BOB)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$CashUtils.generateSpend(services, txn2Builder, 80.DOLLARS, services.myInfo.legalIdentitiesAndCerts.single(), BOB)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$TransactionBuilder(notary = DUMMY_NOTARY) .addOutputState(DummyLinearContract.State(linearId = linearId, participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyDealContract.State(ref = "999", participants = listOf(freshIdentity)), DUMMY_DEAL_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyLinearContract.State(linearId = linearId, participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyLinearContract.State(participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$services.validatedTransactions.getTransaction(deals.first().ref.txhash)?.apply { notaryServices.recordTransactions(this) }</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$services.validatedTransactions.getTransaction(linearStates.first().ref.txhash)?.apply { notaryServices.recordTransactions(this) }</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val consumedStates = vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(status = Vault.StateStatus.CONSUMED)).states</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val consumedStates1 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val consumedStates2 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 10, MEGA_CORP.ref(1), AnonymousParty(freshKey))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 3, DUMMY_CASH_ISSUER, AnonymousParty(freshKey))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest.Companion$"net.corda.testing.contracts"</ID>
    <ID>MaxLineLength:VersionExtractor.kt$VersionExtractor.Spec$override fun parseValid(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:VersionExtractor.kt$VersionExtractor.Spec$private</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject("version" to null), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject("version" to versionValue), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject(), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionInfo.kt$VersionInfo$/** * Platform version of the node which is an integer value which increments on any release where any of the public * API of the entire Corda platform changes. This includes messaging, serialisation, node APIs, etc. */ val platformVersion: Int</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:${principalAddressValue.port}", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV1 = configObject("configuration.metadata.version" to 1, "principalHost" to principalAddressValue.host, "principalPort" to principalAddressValue.port, "adminHost" to adminAddressValue.host, "adminPort" to adminAddressValue.port).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV2 = configObject("configuration.metadata.version" to 2, "configuration.value.addresses" to addressesValue).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV2 = configObject("configuration.value.addresses" to addressesValue).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val parseConfiguration = VersionedSpecificationRegistry.mapping(extractVersion, 1 to RpcSettingsSpec.V1, 2 to RpcSettingsSpec.V2)</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val rpcSettingsFromVersion1Conf = parseConfiguration.invoke(configurationV1).mapValid { it.parse(configurationV1) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val rpcSettingsFromVersion2Conf = parseConfiguration.invoke(configurationV2).mapValid { it.parse(configurationV2) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec$return Validated.invalid(Configuration.Validation.Error.BadValue.of(host, Address::class.java.simpleName, "Value must be of format \"host(String):port(Int &gt; 0)\" e.g., \"127.0.0.1:8080\""))</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec.V2.AddressesSpec$override fun parseValid(configuration: Config, options: Configuration.Options)</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec.V2.AddressesSpec$return Address.validFromRawValue(rawValue) { error -&gt; Configuration.Validation.Error.BadValue.of(error) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$private fun Configuration.Version.Extractor.parseRequired(config: Config, options: Configuration.Options = Configuration.Options.defaults)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry$value?.let { valid(it) } ?: invalid&lt;Configuration.Specification&lt;VALUE&gt;, Configuration.Validation.Error&gt;(Configuration.Validation.Error.UnsupportedVersion.of(version))</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, vararg specifications: Pair&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: Configuration.Value.Parser&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: Configuration.Value.Parser&lt;Int&gt;, vararg specifications: Pair&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry&lt;VALUE&gt; : </ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-core", versionInfo.vendor, versionInfo.releaseVersion, "Copyright 2019 R3. Licensed use only")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary", versionInfo.vendor, versionInfo.releaseVersion, "Copyright 2019 R3. Licensed use only")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-bft-smart", versionInfo.vendor, versionInfo.releaseVersion, "Copyright 2019 R3. Licensed use only")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-mysql", versionInfo.vendor, versionInfo.releaseVersion, "Copyright 2019 R3. Licensed use only")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-raft", versionInfo.vendor, versionInfo.releaseVersion, "Copyright 2019 R3. Licensed use only")</ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-standalonejpa", versionInfo.vendor, versionInfo.releaseVersion, "Copyright 2019 R3. Licensed use only")</ID>
    <ID>MaxLineLength:Volume.kt$Volume$nodeInfoFile.readBytes().deserialize&lt;SignedNodeInfo&gt;().verified().let { NotaryInfo(it.legalIdentities.first(), validating) }</ID>
    <ID>MaxLineLength:Volume.kt$Volume$val validating = ConfigFactory.parseFile(configFile).getConfig("notary").getBooleanCaseInsensitive("validating")</ID>
    <ID>MaxLineLength:WebArgsParser.kt$ArgsParser$// The intent of allowing a command line configurable directory and config path is to allow deployment flexibility. // Other general configuration should live inside the config file unless we regularly need temporary overrides on the command line private val baseDirectoryArg = optionParser .accepts("base-directory", "The node working directory where all the files are kept") .withRequiredArg() .defaultsTo(".")</ID>
    <ID>MaxLineLength:WebArgsParser.kt$ArgsParser$private val logToConsoleArg = optionParser.accepts("log-to-console", "If set, prints logging to the console as well as to a file.")</ID>
    <ID>MaxLineLength:WebServerPluginRegistry.kt$WebServerPluginRegistry</ID>
    <ID>MaxLineLength:WebServerPluginRegistry.kt$WebServerPluginRegistry$/** * Map of static serving endpoints to the matching resource directory. All endpoints will be prefixed with "/web" and postfixed with "\*. * Resource directories can be either on disk directories (especially when debugging) in the form "a/b/c". Serving from a JAR can * be specified with: javaClass.getResource("&lt;folder-in-jar&gt;").toExternalForm() */ val staticServeDirs: Map&lt;String, String&gt; get() = emptyMap()</ID>
    <ID>MaxLineLength:WhitelistGenerator.kt$logger.info("Include contracts from $INCLUDE_WHITELIST_FILE_NAME: ${includeContracts.joinToString()} present in JARs: $optionalCordappJars.")</ID>
    <ID>MaxLineLength:WhitelistGenerator.kt$private fun readAllLines(path: Path) : List&lt;String&gt;</ID>
    <ID>MaxLineLength:WhitelistGeneratorTest.kt$WhitelistGeneratorTest$val newWhitelist = generateWhitelist(existingWhitelist, emptyList(), listOf(TestContractsJar(contractClassNames = emptyList())))</ID>
    <ID>MaxLineLength:WhitelistGeneratorTest.kt$WhitelistGeneratorTest$val whitelist = generateWhitelist(emptyMap(), emptyList(), listOf(TestContractsJar(contractClassNames = emptyList())))</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$( inputs: List&lt;StateRef&gt;, attachments: List&lt;SecureHash&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt = PrivacySalt() )</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * Builds whole Merkle tree for a transaction. * Briefly, each component group has its own sub Merkle tree and all of the roots of these trees are used as leaves * in a top level Merkle tree. * Note that ordering of elements inside a [ComponentGroup] matters when computing the Merkle root. * On the other hand, insertion group ordering does not affect the top level Merkle tree construction, as it is * actually an ordered Merkle tree, where its leaves are ordered based on the group ordinal in [ComponentGroupEnum]. * If any of the groups is an empty list or a null object, then [SecureHash.allOnesHash] is used as its hash. * Also, [privacySalt] is not a Merkle tree leaf, because it is already "inherently" included via the component nonces. */ val merkleTree: MerkleTree by lazy { MerkleTree.getMerkleTree(groupHashes) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * Calculate nonces for every transaction component, including new fields (due to backwards compatibility support) we cannot process. * Nonce are computed in the following way: * nonce1 = H(salt || path_for_1st_component) * nonce2 = H(salt || path_for_2nd_component) * etc. * Thus, all of the nonces are "independent" in the sense that knowing one or some of them, you can learn * nothing about the rest. */ internal val availableComponentNonces: Map&lt;Int, List&lt;SecureHash&gt;&gt; by lazy { componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap() }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$/** * The leaves (group hashes) of the top level Merkle tree. * If a group's Merkle root is allOnesHash, it is a flag that denotes this group is empty (if list) or null (if single object) * in the wire transaction. */ internal val groupHashes: List&lt;SecureHash&gt; by lazy { val listOfLeaves = mutableListOf&lt;SecureHash&gt;() // Even if empty and not used, we should at least send oneHashes for each known // or received but unknown (thus, bigger than known ordinal) component groups. for (i in 0..componentGroups.map { it.groupIndex }.max()!!) { val root = groupsMerkleRoots[i] ?: SecureHash.allOnesHash listOfLeaves.add(root) } listOfLeaves }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$// This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$ReplaceWith("WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$SerializedStateAndRef(resolveStateRefAsSerialized(ref) ?: throw TransactionResolutionException(ref.txhash), ref)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$check(componentGroups.map { it.groupIndex }.toSet().size == componentGroups.size) { "Duplicated component groups detected" }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$check(inputs.isNotEmpty() || outputs.isNotEmpty()) { "A transaction must contain at least one input or output state" }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$checkTransactionSize(ltx, resolvedNetworkParameters.maxTransactionSize, serializedResolvedInputs, serializedResolvedReferences)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(availableComponentNonces[it.groupIndex]!![internalIndex], internalIt) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$isAttachmentTrusted = { (services as? ServiceHubCoreInternal)?.attachmentTrustCalculator?.calculate(it) ?: true }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedAttachments = attachments.lazyMapped { att, _ -&gt; resolveAttachment(att) ?: throw AttachmentResolutionException(att) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedNetworkParameters = resolveParameters(networkParametersHash) ?: throw TransactionResolutionException.UnknownParametersException(id, networkParametersHash!!)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction${ var remainingTransactionSize = maxTransactionSize fun minus(size: Int) { require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." } remainingTransactionSize -= size } // This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int { return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0 } // Check attachments size first as they are most likely to go over the limit. With ContractAttachment instances // it's likely that the same underlying Attachment CorDapp will occur more than once so we dedup on the attachment id. ltx.attachments.distinctBy { it.id }.forEach { minus(it.size) } minus(resolvedSerializedInputs.sumBy { it.serializedState.size }) minus(resolvedSerializedReferences.sumBy { it.serializedState.size }) // For Commands and outputs we can use the component groups as they are already serialized. minus(componentGroupSize(COMMANDS_GROUP)) minus(componentGroupSize(OUTPUTS_GROUP)) }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$?:</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$else -&gt; throw UnsupportedOperationException("Attempting to resolve input ${stateRef.index} of a ${coreTransaction.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$is ContractUpgradeWireTransaction -&gt; coreTransaction.resolveOutputComponent(services, stateRef, params)</ID>
    <ID>MaxLineLength:WithContracts.kt$WithContracts$//region Operations fun TestStartedNode.signDummyContract(owner: PartyAndReference, magicNumber: Int = 0, vararg others: PartyAndReference)</ID>
    <ID>MaxLineLength:WithFinality.kt$WithFinality$//region Operations fun TestStartedNode.finalise(stx: SignedTransaction, vararg recipients: Party): FlowStateMachine&lt;SignedTransaction&gt;</ID>
    <ID>MaxLineLength:WithReferencedStatesFlow.kt$WithReferencedStatesFlow&lt;T : Any&gt; : FlowLogic</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow : FlowLogic</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Completed command requires the counterparty as signer" using (command.signers.contains(before.counterparty.owningKey))</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Completed command requires the source Party as signer" using (command.signers.contains(before.source.owningKey))</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Issue requires the source Party as signer" using (command.signers.contains(issued.source.owningKey))</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Output must be a final state" using (after.state in setOf(WorkflowState.APPROVED, WorkflowState.REJECTED))</ID>
    <ID>MaxLineLength:WritablePublicKeyToOwningIdentityCache.kt$WritablePublicKeyToOwningIdentityCache : PublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:X500Utils.kt$ fun X500Principal.toAttributesMap(supportedAttributes: Set&lt;ASN1ObjectIdentifier&gt; = emptySet()): Map&lt;ASN1ObjectIdentifier, String&gt;</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore$val certArray = requireNotNull(internal.getCertificateChain(alias)) { "No certificate chain under the alias $alias" }</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore.Companion$val internal: KeyStore = if (createNew) loadOrCreateKeyStore(keyStoreFile, storePassword) else loadKeyStore(keyStoreFile, storePassword)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$private</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(tlsCert, nodeCaCert, intermediateCa.certificate, rootCa.certificate), keyPassword)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$val (keystore, trustStore) = makeKeyStores(X500Name("CN=Bank A TLS, UID=, E=me@email.com, C=GB"), nameConstraints)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$val (keystore, trustStore) = makeKeyStores(X500Name("O=Bank A, UID=, E=me@email.com, C=GB"), nameConstraints)</ID>
    <ID>MaxLineLength:X509Utilities.kt$CertificateType$enum</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ @JvmStatic fun createCertificate(certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null): X509Certificate</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ @JvmStatic fun saveCertificateAsPEMFile(certificate: X509Certificate, file: Path)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ fun createCertificateSigningRequest(subject: X500Principal, email: String, publicKey: PublicKey, contentSigner: ContentSigner, certRole: CertRole = CertRole.NODE_CA): PKCS10CertificationRequest</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ fun getCertificateValidityWindow(before: Duration, after: Duration, parent: X509Certificate? = null): Pair&lt;Date, Date&gt;</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$// Note that this default value only applies to BCCryptoService. Other implementations of CryptoService may have to use different // schemes (for instance `UtimacoCryptoService.DEFAULT_IDENTITY_SIGNATURE_SCHEME`). val DEFAULT_IDENTITY_SIGNATURE_SCHEME = Crypto.EDDSA_ED25519_SHA512</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo)) .addExtension(Extension.basicConstraints, true, BasicConstraints(certificateType.isCA)) .addExtension(Extension.keyUsage, false, certificateType.keyUsage) .addExtension(Extension.extendedKeyUsage, false, keyPurposes) .addExtension(Extension.authorityKeyIdentifier, false, JcaX509ExtensionUtils().createAuthorityKeyIdentifier(issuerPublicKey))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$fun createCertificateSigningRequest(subject: X500Principal, email: String, keyPair: KeyPair, certRole: CertRole = CertRole.NODE_CA): PKCS10CertificationRequest</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$require(isSignatureValid(JcaContentVerifierProviderBuilder().build(issuerKeyPair.public))){"Invalid signature"}</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val builder = JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo)) .addExtension(Extension.basicConstraints, true, BasicConstraints(certificateType.isCA)) .addExtension(Extension.keyUsage, false, certificateType.keyUsage) .addExtension(Extension.extendedKeyUsage, false, keyPurposes) .addExtension(Extension.authorityKeyIdentifier, false, JcaX509ExtensionUtils().createAuthorityKeyIdentifier(issuerPublicKey))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val builder = createPartialCertificate(certificateType, issuer, issuerPublicKey, subject, subjectPublicKey, validityWindow, nameConstraints, crlDistPoint, crlIssuer)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, crlDistPoint)))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val signer = ContentSignerBuilder.build(signatureScheme, keyPair.private, Crypto.findProvider(signatureScheme.providerName))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities${ val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, crlDistPoint))) val crlIssuerGeneralNames = crlIssuer?.let { GeneralNames(GeneralName(crlIssuer)) } // The second argument is flag that allows you to define what reason of certificate revocation is served by this distribution point see [ReasonFlags]. // The idea is that you have different revocation per revocation reason. Since we won't go into such a granularity, we can skip that parameter. // The third argument allows you to specify the name of the CRL issuer, it needs to be consistent with the crl (IssuingDistributionPoint) extension and the idp argument. // If idp == true, set it, if idp == false, leave it null as done here. val distPoint = DistributionPoint(distPointName, null, crlIssuerGeneralNames) builder.addExtension(Extension.cRLDistributionPoints, false, CRLDistPoint(arrayOf(distPoint))) }</ID>
    <ID>MaxLineLength:X509Utilities.kt$val Certificate.x509: X509Certificate get() = requireNotNull(this as? X509Certificate) { "Not an X.509 certificate: $this" }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$Crypto.supportedSignatureSchemes().filter { it != COMPOSITE_KEY }.forEach { serializeDeserializeX509CertPath(it) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$NettyTestClient(sslClientContext, InetAddress.getLocalHost().canonicalHostName, server.port, clientHandler)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$assertFalse { keyUsage.hasUsages(5) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$assertTrue { Crypto.isValid(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME, serverCert.publicKey, signature, testData) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$childSubject: X500Principal = X500Principal("CN=Test Child Cert,O=R3 Ltd,L=London,C=GB")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$clientParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$p2pSslConfig.keyStore.get(createNew = true).also { it.registerDevP2pCertificates(MEGA_CORP.name, rootCa.certificate, intermediateCa, nodeCa) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$private</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$serverParams.endpointIdentificationAlgorithm = null</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$signingCertStore.get(createNew = true).also { it.installDevNodeCaCertPath(MEGA_CORP.name, rootCa.certificate, intermediateCa, nodeCa) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (_, caCert, childKeyPair, childCert) = genCaAndChildKeysCertsAndSubjects(signatureSchemeRoot, signatureSchemeChild)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (serverCert, serverKeyPair) = serverKeyStore.getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, certStore.entryPassword)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (sslCert) = sslKeyStoreReloaded.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_TLS, sslKeyStoreReloaded.entryPassword) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caCert = X509Utilities.createSelfSignedCACertificate(X500Principal("CN=Test CA Cert,O=R3 Ltd,L=London,C=GB"), caKey)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caCert = X509Utilities.createSelfSignedCACertificate(X500Principal("CN=Test Cert,O=R3 Ltd,L=London,C=GB"), caKey)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caSubjectKeyIdentifier = SubjectKeyIdentifier.getInstance(caCert.toBc().getExtension(Extension.subjectKeyIdentifier).parsedValue)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val certCaAuthorityKeyIdentifier = AuthorityKeyIdentifier.getInstance(getExtension(Extension.authorityKeyIdentifier).parsedValue)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val certificate = X509Utilities.createCertificate(CertificateType.TLS, rootCACert, rootCAKey, BOB_NAME.x500Principal, BOB.publicKey)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val childCert = X509Utilities.createCertificate(CertificateType.TLS, caCert, caKeyPair, childSubject, childKeyPair.public)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val expected = X509Utilities.createSelfSignedCACertificate(ALICE.name.x500Principal, generateKeyPair(signatureScheme))</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val p2pSslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val serverSocket = serverSocketFactory.createServerSocket(0) as SSLServerSocket // use 0 to get first free socket</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val signingCertStore = CertificateStoreStubs.Signing.withCertificatesDirectory(certificatesDirectory, "serverstorepass")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val sslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(tempFolder.root.toPath(), keyStorePassword = "serverstorepass")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$// We ensure that all of the algorithms are both used (at least once) as first and second in the following [Pair]s. // We also add [DEFAULT_TLS_SIGNATURE_SCHEME] and [DEFAULT_IDENTITY_SIGNATURE_SCHEME] combinations for consistency. val certChainSchemeCombinations = listOf( Pair(DEFAULT_TLS_SIGNATURE_SCHEME, DEFAULT_TLS_SIGNATURE_SCHEME), Pair(DEFAULT_IDENTITY_SIGNATURE_SCHEME, DEFAULT_IDENTITY_SIGNATURE_SCHEME), Pair(DEFAULT_TLS_SIGNATURE_SCHEME, DEFAULT_IDENTITY_SIGNATURE_SCHEME), Pair(ECDSA_SECP256R1_SHA256, SPHINCS256_SHA256), Pair(ECDSA_SECP256K1_SHA256, RSA_SHA256), Pair(EDDSA_ED25519_SHA512, ECDSA_SECP256K1_SHA256), Pair(RSA_SHA256, EDDSA_ED25519_SHA512), Pair(SPHINCS256_SHA256, ECDSA_SECP256R1_SHA256) )</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$Triple(ECDSA_SECP256K1_SHA256,java.security.interfaces.ECPrivateKey::class.java, org.bouncycastle.jce.interfaces.ECPrivateKey::class.java)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$Triple(ECDSA_SECP256R1_SHA256,java.security.interfaces.ECPrivateKey::class.java, org.bouncycastle.jce.interfaces.ECPrivateKey::class.java)</ID>
    <ID>MaxLineLength:YearMonthSerializer.kt$YearMonthSerializer : Proxy</ID>
    <ID>MaxLineLength:YearSerializer.kt$YearSerializer : Proxy</ID>
    <ID>MaxLineLength:ZkClient.kt$ZkClient : ZkLeader</ID>
    <ID>MaxLineLength:ZkClientTest.kt$ZkClientTests$alice -&gt; client.addLeadershipListener(SyncHelperListener(client.nodeId, leaderCount, failures, aliceLeaderGain))</ID>
    <ID>MaxLineLength:ZkClientTest.kt$ZkClientTests$bob.addLeadershipListener(SyncHelperListener(client.nodeId, leaderCount, failures, bobLeaderGain))</ID>
    <ID>MaxLineLength:ZkClientTest.kt$ZkClientTests$chip -&gt; client.addLeadershipListener(SyncHelperListener(client.nodeId, leaderCount, failures, chipLeaderGain))</ID>
    <ID>MaxLineLength:ZkClientTest.kt$ZkClientTests$chip.addLeadershipListener(SyncHelperListener(client.nodeId, leaderCount, failures, chipLeaderGain))</ID>
    <ID>MaxLineLength:ZkClientTest.kt$ZkClientTests$client.addLeadershipListener(SyncHelperListener(client.nodeId, leaderCount, failures, aliceLeaderGain))</ID>
    <ID>MaxLineLength:ZkClientTest.kt$ZkClientTests$val bob = ZkClient(zkServer.connectString, ZKPaths.makePath(ELECTION_PATH, "test7"), "BOB", 50) // Use numbers that check for numeric sorting</ID>
    <ID>MaxLineLength:ZkLeader.kt$ZkLeader$ fun close()</ID>
    <ID>MaxLineLength:ZoneIdSerializer.kt$ZoneIdSerializer : Proxy</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer : Proxy</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer$override fun fromProxy(proxy: ZonedDateTimeProxy): ZonedDateTime</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer$override fun toProxy(obj: ZonedDateTime): ZonedDateTimeProxy</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer$override val additionalSerializers: Iterable&lt;CustomSerializer&lt;out Any&gt;&gt; = listOf(LocalDateTimeSerializer(factory), ZoneIdSerializer(factory))</ID>
    <ID>MaxLineLength:ZonedDateTimeSerializer.kt$ZonedDateTimeSerializer.Companion$val ofLenient: Method = ZonedDateTime::class.java.getDeclaredMethod("ofLenient", LocalDateTime::class.java, ZoneOffset::class.java, ZoneId::class.java)</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$fun createContractCreationError(txId: SecureHash, contractClass: String, cause: Throwable)</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$fun createContractRejection(txId: SecureHash, contract: Contract, cause: Throwable)</ID>
    <ID>MaxLineLength:main.kt$At this point the tester should issue a Ctrl-C command. No new flows will be submitted and a 60 second grace period is given for the flows to halt.</ID>
    <ID>MaxLineLength:main.kt$System.`in`.read()</ID>
    <ID>ModifierOrder:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashFlow$@Suspendable abstract protected</ID>
    <ID>ModifierOrder:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashFlow$abstract protected</ID>
    <ID>ModifierOrder:AbstractConfidentialCashFlow.kt$AbstractConfidentialAwareCashResponderFlow$@Suspendable abstract protected</ID>
    <ID>ModifierOrder:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected</ID>
    <ID>ModifierOrder:StateMachineViewer.kt$StateMachineViewer.StateMachineWidget$inner private</ID>
    <ID>NestedBlockDepth:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>NestedBlockDepth:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>NestedBlockDepth:AbstractNode.kt$AbstractNode$private fun registerCordappFlows()</ID>
    <ID>NestedBlockDepth:AggregatedList.kt$AggregatedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out E&gt;)</ID>
    <ID>NestedBlockDepth:AllButBlacklisted.kt$AllButBlacklisted$ override fun hasListed(type: Class&lt;*&gt;): Boolean</ID>
    <ID>NestedBlockDepth:Amount.kt$Amount.Companion$ @JvmStatic fun parseCurrency(input: String): Amount&lt;Currency&gt;</ID>
    <ID>NestedBlockDepth:AttachmentDemo.kt$@Suppress("DEPRECATION") // DOCSTART 1 fun recipient(rpc: CordaRPCOps, webPort: Int)</ID>
    <ID>NestedBlockDepth:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>NestedBlockDepth:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>NestedBlockDepth:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>NestedBlockDepth:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>NestedBlockDepth:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>NestedBlockDepth:ConcatenatedList.kt$ConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>NestedBlockDepth:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>NestedBlockDepth:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>NestedBlockDepth:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>NestedBlockDepth:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$override fun runProgram(): Int</ID>
    <ID>NestedBlockDepth:DbScriptRunner.kt$ListPopulator$override fun populate(connection: Connection)</ID>
    <ID>NestedBlockDepth:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>NestedBlockDepth:ExternalSourceRevocationChecker.kt$ExternalSourceRevocationChecker$ @Throws(CertPathValidatorException::class) private fun checkApprovedCRLs(cert: X509Certificate, approvedCRLs: Set&lt;X509CRL&gt;)</ID>
    <ID>NestedBlockDepth:FetchDataFlow.kt$FetchAttachmentsFlow$override fun maybeWriteToDisk(downloaded: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>NestedBlockDepth:Hooker.kt$Hooker$private fun createHooks(hookContainer: Any): Hooks</ID>
    <ID>NestedBlockDepth:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>NestedBlockDepth:InteractiveShell.kt$InteractiveShell$@JvmStatic fun gracefulShutdown(userSessionOut: RenderPrintWriter, cordaRPCOps: CordaRPCOps)</ID>
    <ID>NestedBlockDepth:InternalUtils.kt$ inline fun &lt;T&gt; Iterable&lt;T&gt;.noneOrSingle(predicate: (T) -&gt; Boolean): T?</ID>
    <ID>NestedBlockDepth:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.addManifest(fileName: String, vararg entries: Pair&lt;Attributes.Name, String&gt;)</ID>
    <ID>NestedBlockDepth:LogProcessor.kt$LogProcessor$fun findSessions(): LogProcessor</ID>
    <ID>NestedBlockDepth:Main.kt$Node$fun avalancheLoop()</ID>
    <ID>NestedBlockDepth:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$ private fun &lt;T&gt; runWithRetry(operation: DBOperation&lt;T&gt;): T</ID>
    <ID>NestedBlockDepth:NetworkBootstrapper.kt$CopyCordapps$protected fun List&lt;Path&gt;.copy(nodeDirs: List&lt;Path&gt;)</ID>
    <ID>NestedBlockDepth:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>NestedBlockDepth:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>NestedBlockDepth:Node.kt$Node$ private fun tryDetectIfNotPublicHost(host: String): String?</ID>
    <ID>NestedBlockDepth:Node.kt$Node$override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters)</ID>
    <ID>NestedBlockDepth:Node.kt$Node$private fun startLocalRpcBroker(securityManager: RPCSecurityManager, sslOptions: MutualSslConfiguration): BrokerAddresses?</ID>
    <ID>NestedBlockDepth:NodeVaultService.kt$NodeVaultService$private fun recordUpdate(update: Vault.Update&lt;ContractState&gt;, previouslySeen: Boolean): Vault.Update&lt;ContractState&gt;</ID>
    <ID>NestedBlockDepth:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$override fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>NestedBlockDepth:NotaryRegistrationTool.kt$NotaryRegistrationTool$// Make sure the nodes don't have conflicting crypto service configurations private fun validateNodeHsmConfigs(configFiles: List&lt;Path&gt;)</ID>
    <ID>NestedBlockDepth:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>NestedBlockDepth:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun openProfile(): List&lt;InstallConfig&gt;?</ID>
    <ID>NestedBlockDepth:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun saveProfile(): Boolean</ID>
    <ID>NestedBlockDepth:QuasarInstrumentationHook.kt$PackageTree$ fun toGlobs(excludeTree: PackageTree): List&lt;Glob&gt;</ID>
    <ID>NestedBlockDepth:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>NestedBlockDepth:RegistrationTool.kt$RegistrationTool$// Make sure the nodes don't have conflicting crypto service configurations private fun validateNodeHsmConfigs(configFiles: List&lt;Path&gt;)</ID>
    <ID>NestedBlockDepth:ShutdownManager.kt$ShutdownManager$fun shutdown()</ID>
    <ID>NestedBlockDepth:SpringDriver.kt$SpringBootDriverDSL$private fun queryWebserver(handle: NodeHandle, process: Process, checkUrl: String): WebserverHandle</ID>
    <ID>NestedBlockDepth:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendToSessionsTransition(sourceSessionIdToMessage: Map&lt;SessionId, SerializedBytes&lt;Any&gt;&gt;)</ID>
    <ID>NestedBlockDepth:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>NestedBlockDepth:ThrowableSerializer.kt$ThrowableSerializer$override fun fromProxy(proxy: ThrowableProxy): Throwable</ID>
    <ID>NestedBlockDepth:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>NestedBlockDepth:main.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>NewLineAtEndOfFile:AMQPBridgeManager.kt$net.corda.nodeapi.internal.bridging.AMQPBridgeManager.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPBridgeTest.kt$net.corda.node.amqp.AMQPBridgeTest.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPChannelHandler.kt$net.corda.nodeapi.internal.protonwrapper.netty.AMQPChannelHandler.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPClient.kt$net.corda.nodeapi.internal.protonwrapper.netty.AMQPClient.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPExceptions.kt$net.corda.serialization.internal.amqp.AMQPExceptions.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPFirewallSerializationScheme.kt$net.corda.bridge.internal.AMQPFirewallSerializationScheme.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPListenerTest.kt$net.corda.bridge.services.AMQPListenerTest.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPPrimitiveSerializer.kt$net.corda.serialization.internal.amqp.AMQPPrimitiveSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPRemoteTypeModel.kt$net.corda.serialization.internal.amqp.AMQPRemoteTypeModel.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPRemoteTypeModelTests.kt$net.corda.serialization.internal.amqp.AMQPRemoteTypeModelTests.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPSerializerFactories.kt$net.corda.serialization.internal.amqp.AMQPSerializerFactories.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPServer.kt$net.corda.nodeapi.internal.protonwrapper.netty.AMQPServer.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPSigningService.kt$net.corda.bridge.services.receiver.AMQPSigningService.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPTestSerialiationScheme.kt$net.corda.node.internal.serialization.testutils.AMQPTestSerialiationScheme.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPTypeIdentifierParser.kt$net.corda.serialization.internal.amqp.AMQPTypeIdentifierParser.kt</ID>
    <ID>NewLineAtEndOfFile:AMQPTypeIdentifierParserTests.kt$net.corda.serialization.internal.amqp.AMQPTypeIdentifierParserTests.kt</ID>
    <ID>NewLineAtEndOfFile:ANSIProgressRenderer.kt$net.corda.tools.shell.utlities.ANSIProgressRenderer.kt</ID>
    <ID>NewLineAtEndOfFile:ANSIProgressRendererTest.kt$net.corda.tools.shell.utilities.ANSIProgressRendererTest.kt</ID>
    <ID>NewLineAtEndOfFile:APIServer.kt$net.corda.webserver.api.APIServer.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractCashFlow.kt$com.r3.corda.enterprise.perftestcordapp.flows.AbstractCashFlow.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractCashFlow.kt$net.corda.finance.flows.AbstractCashFlow.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractCashSelection.kt$com.r3.corda.enterprise.perftestcordapp.contracts.asset.cash.selection.AbstractCashSelection.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractConfidentialCashFlow.kt$com.r3.corda.enterprise.perftestcordapp.flows.AbstractConfidentialCashFlow.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractNodeRegistrationTest.kt$net.corda.node.services.keys.cryptoservice.AbstractNodeRegistrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractParty.kt$net.corda.core.identity.AbstractParty.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractPartyDescriptor.kt$net.corda.node.services.persistence.AbstractPartyDescriptor.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractScenarioRunner.kt$net.corda.haTesting.AbstractScenarioRunner.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractWrappedKeysTest.kt$net.corda.node.services.keys.cryptoservice.AbstractWrappedKeysTest.kt</ID>
    <ID>NewLineAtEndOfFile:AbstractZkLatch.kt$net.corda.flowworker.zookeeper.AbstractZkLatch.kt</ID>
    <ID>NewLineAtEndOfFile:Address.kt$net.corda.common.configuration.parsing.internal.Address.kt</ID>
    <ID>NewLineAtEndOfFile:AddressBindingException.kt$net.corda.core.internal.errors.AddressBindingException.kt</ID>
    <ID>NewLineAtEndOfFile:AddressBindingFailureTests.kt$net.corda.node.AddressBindingFailureTests.kt</ID>
    <ID>NewLineAtEndOfFile:AddressUtils.kt$net.corda.node.utilities.AddressUtils.kt</ID>
    <ID>NewLineAtEndOfFile:Addresses.kt$net.corda.common.configuration.parsing.internal.Addresses.kt</ID>
    <ID>NewLineAtEndOfFile:AdvancedExceptionDialog.kt$net.corda.explorer.ui.AdvancedExceptionDialog.kt</ID>
    <ID>NewLineAtEndOfFile:AliasProvidingKeyMangerWrapper.kt$net.corda.nodeapi.internal.protonwrapper.netty.AliasProvidingKeyMangerWrapper.kt</ID>
    <ID>NewLineAtEndOfFile:AllExceptionMapper.kt$net.corda.webserver.internal.AllExceptionMapper.kt</ID>
    <ID>NewLineAtEndOfFile:AllowAllRevocationChecker.kt$net.corda.nodeapi.internal.protonwrapper.netty.AllowAllRevocationChecker.kt</ID>
    <ID>NewLineAtEndOfFile:AmountTest.kt$net.corda.client.jackson.AmountTest.kt</ID>
    <ID>NewLineAtEndOfFile:AmountTests.kt$net.corda.coretests.contracts.AmountTests.kt</ID>
    <ID>NewLineAtEndOfFile:AnonymousParty.kt$net.corda.core.identity.AnonymousParty.kt</ID>
    <ID>NewLineAtEndOfFile:AnotherDummyContract.kt$net.corda.isolated.contracts.AnotherDummyContract.kt</ID>
    <ID>NewLineAtEndOfFile:AppendOnlyPersistentMapNonConcurrentTest.kt$net.corda.node.services.persistence.AppendOnlyPersistentMapNonConcurrentTest.kt</ID>
    <ID>NewLineAtEndOfFile:AppendOnlyPersistentMapTest.kt$net.corda.node.services.persistence.AppendOnlyPersistentMapTest.kt</ID>
    <ID>NewLineAtEndOfFile:ApplicationMessage.kt$net.corda.nodeapi.internal.protonwrapper.messages.ApplicationMessage.kt</ID>
    <ID>NewLineAtEndOfFile:Arrangement.kt$net.corda.finance.contracts.universal.Arrangement.kt</ID>
    <ID>NewLineAtEndOfFile:ArtemisBroker.kt$net.corda.node.internal.artemis.ArtemisBroker.kt</ID>
    <ID>NewLineAtEndOfFile:ArtemisConfigurationToolTest.kt$com.r3.ha.utilities.ArtemisConfigurationToolTest.kt</ID>
    <ID>NewLineAtEndOfFile:ArtemisConnectionTest.kt$net.corda.bridge.services.ArtemisConnectionTest.kt</ID>
    <ID>NewLineAtEndOfFile:ArtemisRpcTests.kt$net.corda.node.services.rpc.ArtemisRpcTests.kt</ID>
    <ID>NewLineAtEndOfFile:ArtemisTcpTransport.kt$net.corda.nodeapi.internal.ArtemisTcpTransport.kt</ID>
    <ID>NewLineAtEndOfFile:ArtemisUtils.kt$net.corda.bridge.ArtemisUtils.kt</ID>
    <ID>NewLineAtEndOfFile:AssertingTestDatabaseContext.kt$net.corda.testing.internal.db.AssertingTestDatabaseContext.kt</ID>
    <ID>NewLineAtEndOfFile:AsyncLoggingTest.kt$net.corda.node.utilities.logging.AsyncLoggingTest.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentStorageInternal.kt$net.corda.node.services.persistence.AttachmentStorageInternal.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentTest.kt$net.corda.deterministic.contracts.AttachmentTest.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentTrustCalculator.kt$net.corda.core.internal.AttachmentTrustCalculator.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentTrustCalculatorTest.kt$net.corda.node.services.attachments.AttachmentTrustCalculatorTest.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentTrustTable.kt$net.corda.tools.shell.AttachmentTrustTable.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentVersionNumberMigration.kt$net.corda.nodeapi.internal.persistence.AttachmentVersionNumberMigration.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentWithContext.kt$net.corda.core.internal.AttachmentWithContext.kt</ID>
    <ID>NewLineAtEndOfFile:AttachmentsClassLoader.kt$net.corda.core.serialization.internal.AttachmentsClassLoader.kt</ID>
    <ID>NewLineAtEndOfFile:AuthDBTests.kt$net.corda.node.AuthDBTests.kt</ID>
    <ID>NewLineAtEndOfFile:AuthenticatedRpcOpsProxy.kt$net.corda.node.internal.rpc.proxies.AuthenticatedRpcOpsProxy.kt</ID>
    <ID>NewLineAtEndOfFile:AuthorizingSubject.kt$net.corda.node.internal.security.AuthorizingSubject.kt</ID>
    <ID>NewLineAtEndOfFile:AzureBackend.kt$net.corda.networkbuilder.backends.AzureBackend.kt</ID>
    <ID>NewLineAtEndOfFile:AzureContainerPusher.kt$net.corda.networkbuilder.containers.push.azure.AzureContainerPusher.kt</ID>
    <ID>NewLineAtEndOfFile:AzureInstantiator.kt$net.corda.networkbuilder.containers.instance.azure.AzureInstantiator.kt</ID>
    <ID>NewLineAtEndOfFile:AzureKeyVaultCryptoService.kt$net.corda.nodeapi.internal.cryptoservice.azure.AzureKeyVaultCryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:AzureKeyVaultCryptoServiceTest.kt$net.corda.node.services.keys.cryptoservice.azure.AzureKeyVaultCryptoServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:AzureKeyVaultCryptoServiceTest.kt$net.corda.nodeapi.internal.cryptoservice.azure.AzureKeyVaultCryptoServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:AzureRegistryLocator.kt$net.corda.networkbuilder.containers.push.azure.AzureRegistryLocator.kt</ID>
    <ID>NewLineAtEndOfFile:AzureSmbVolume.kt$net.corda.networkbuilder.volumes.azure.AzureSmbVolume.kt</ID>
    <ID>NewLineAtEndOfFile:Backend.kt$net.corda.networkbuilder.backends.Backend.kt</ID>
    <ID>NewLineAtEndOfFile:BankOfCordaWebApi.kt$net.corda.bank.api.BankOfCordaWebApi.kt</ID>
    <ID>NewLineAtEndOfFile:BaseFlowSampler.kt$com.r3.corda.jmeter.BaseFlowSampler.kt</ID>
    <ID>NewLineAtEndOfFile:BaseTransaction.kt$net.corda.core.transactions.BaseTransaction.kt</ID>
    <ID>NewLineAtEndOfFile:BaseTransactions.kt$net.corda.core.transactions.BaseTransactions.kt</ID>
    <ID>NewLineAtEndOfFile:BigDecimalSerializer.kt$net.corda.serialization.internal.amqp.custom.BigDecimalSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:BigIntegerSerializer.kt$net.corda.serialization.internal.amqp.custom.BigIntegerSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:BitSetSerializer.kt$net.corda.serialization.internal.amqp.custom.BitSetSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:BootstrapperView.kt$net.corda.networkbuilder.gui.BootstrapperView.kt</ID>
    <ID>NewLineAtEndOfFile:BouncyCastleWrappedKeysTest.kt$net.corda.node.services.keys.cryptoservice.bouncycastle.BouncyCastleWrappedKeysTest.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeAMQPListenerService.kt$net.corda.bridge.services.api.BridgeAMQPListenerService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeAMQPListenerServiceImpl.kt$net.corda.bridge.services.receiver.BridgeAMQPListenerServiceImpl.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeArtemisConnectionService.kt$net.corda.bridge.services.api.BridgeArtemisConnectionService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeArtemisConnectionServiceImpl.kt$net.corda.bridge.services.artemis.BridgeArtemisConnectionServiceImpl.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeConfigHelper.kt$net.corda.bridge.services.config.BridgeConfigHelper.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeControlListener.kt$net.corda.nodeapi.internal.bridging.BridgeControlListener.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeControlMessages.kt$net.corda.nodeapi.internal.bridging.BridgeControlMessages.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeDriver.kt$net.corda.bridge.BridgeDriver.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeHSMTest.kt$net.corda.bridge.BridgeHSMTest.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeIntegrationDiffSslTest.kt$net.corda.bridge.BridgeIntegrationDiffSslTest.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeIntegrationTest.kt$net.corda.bridge.BridgeIntegrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeManager.kt$net.corda.nodeapi.internal.bridging.BridgeManager.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeMasterService.kt$net.corda.bridge.services.api.BridgeMasterService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeMetricsService.kt$net.corda.nodeapi.internal.bridging.BridgeMetricsService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeReceiverService.kt$net.corda.bridge.services.api.BridgeReceiverService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeRestartTest.kt$net.corda.bridge.BridgeRestartTest.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeSSLKeyTool.kt$com.r3.ha.utilities.BridgeSSLKeyTool.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeSenderService.kt$net.corda.bridge.services.api.BridgeSenderService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeSmokeTest.kt$net.corda.bridge.smoketest.BridgeSmokeTest.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeSupervisorService.kt$net.corda.bridge.services.api.BridgeSupervisorService.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeSupervisorServiceImpl.kt$net.corda.bridge.services.supervisors.BridgeSupervisorServiceImpl.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeTestHelper.kt$net.corda.bridge.BridgeTestHelper.kt</ID>
    <ID>NewLineAtEndOfFile:BridgeToolTest.kt$com.r3.ha.utilities.BridgeToolTest.kt</ID>
    <ID>NewLineAtEndOfFile:BrokerJaasLoginModule.kt$net.corda.node.internal.artemis.BrokerJaasLoginModule.kt</ID>
    <ID>NewLineAtEndOfFile:BrokerRpcSslOptions.kt$net.corda.nodeapi.BrokerRpcSslOptions.kt</ID>
    <ID>NewLineAtEndOfFile:BuiltNode.kt$net.corda.networkbuilder.nodes.BuiltNode.kt</ID>
    <ID>NewLineAtEndOfFile:BullyLeader.kt$net.corda.nodeapi.internal.bully.BullyLeader.kt</ID>
    <ID>NewLineAtEndOfFile:BullyLeaderTest.kt$net.corda.nodeapi.internal.bully.BullyLeaderTest.kt</ID>
    <ID>NewLineAtEndOfFile:CacheTracingConfig.kt$net.corda.node.utilities.profiling.CacheTracingConfig.kt</ID>
    <ID>NewLineAtEndOfFile:CacheTracingTest.kt$net.corda.core.internal.profiling.CacheTracingTest.kt</ID>
    <ID>NewLineAtEndOfFile:CaffeineStatsCounter.kt$net.corda.node.utilities.CaffeineStatsCounter.kt</ID>
    <ID>NewLineAtEndOfFile:CarpenterExceptionTests.kt$net.corda.serialization.internal.carpenter.CarpenterExceptionTests.kt</ID>
    <ID>NewLineAtEndOfFile:CarpentryDependencyGraph.kt$net.corda.serialization.internal.model.CarpentryDependencyGraph.kt</ID>
    <ID>NewLineAtEndOfFile:CashIssueAndPaymentFlow.kt$com.r3.corda.enterprise.perftestcordapp.flows.CashIssueAndPaymentFlow.kt</ID>
    <ID>NewLineAtEndOfFile:CashIssueAndPaymentNoSelection.kt$com.r3.corda.enterprise.perftestcordapp.flows.CashIssueAndPaymentNoSelection.kt</ID>
    <ID>NewLineAtEndOfFile:CashScenarioRunner.kt$net.corda.haTesting.CashScenarioRunner.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionH2Impl.kt$com.r3.corda.enterprise.perftestcordapp.contracts.asset.cash.selection.CashSelectionH2Impl.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionH2Impl.kt$net.corda.finance.workflows.asset.selection.CashSelectionH2Impl.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionH2ImplTest.kt$net.corda.finance.workflows.asset.selection.CashSelectionH2ImplTest.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionH2Test.kt$com.r3.corda.enterprise.perftestcordapp.contracts.asset.CashSelectionH2Test.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionMySQLImpl.kt$com.r3.corda.enterprise.perftestcordapp.contracts.asset.cash.selection.CashSelectionMySQLImpl.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionOracleImpl.kt$net.corda.finance.workflows.asset.selection.CashSelectionOracleImpl.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionSQLServerImpl.kt$.CashSelectionSQLServerImpl.kt</ID>
    <ID>NewLineAtEndOfFile:CashSelectionSQLServerImpl.kt$com.r3.corda.enterprise.perftestcordapp.contracts.asset.cash.selection.CashSelectionSQLServerImpl.kt</ID>
    <ID>NewLineAtEndOfFile:CertHoldingKeyManagerFactoryWrapper.kt$net.corda.nodeapi.internal.protonwrapper.netty.CertHoldingKeyManagerFactoryWrapper.kt</ID>
    <ID>NewLineAtEndOfFile:CertPathSerializer.kt$net.corda.serialization.internal.amqp.custom.CertPathSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:CertificateChainCheckPolicy.kt$net.corda.node.internal.artemis.CertificateChainCheckPolicy.kt</ID>
    <ID>NewLineAtEndOfFile:CertificateRevocationListNodeTests.kt$net.corda.node.amqp.CertificateRevocationListNodeTests.kt</ID>
    <ID>NewLineAtEndOfFile:CertificateRevocationRequest.kt$net.corda.nodeapi.internal.network.CertificateRevocationRequest.kt</ID>
    <ID>NewLineAtEndOfFile:CertificateStore.kt$net.corda.nodeapi.internal.config.CertificateStore.kt</ID>
    <ID>NewLineAtEndOfFile:CertificateStoreStubs.kt$net.corda.testing.internal.stubs.CertificateStoreStubs.kt</ID>
    <ID>NewLineAtEndOfFile:CertificatesUtils.kt$net.corda.node.utilities.CertificatesUtils.kt</ID>
    <ID>NewLineAtEndOfFile:CheatingSecurityProvider.kt$net.corda.deterministic.CheatingSecurityProvider.kt</ID>
    <ID>NewLineAtEndOfFile:CheckpointDumperTest.kt$net.corda.node.services.rpc.CheckpointDumperTest.kt</ID>
    <ID>NewLineAtEndOfFile:CheckpointSerializationAPI.kt$net.corda.core.serialization.internal.CheckpointSerializationAPI.kt</ID>
    <ID>NewLineAtEndOfFile:CheckpointSerializationScheme.kt$net.corda.serialization.internal.CheckpointSerializationScheme.kt</ID>
    <ID>NewLineAtEndOfFile:CheckpointStorage.kt$net.corda.node.services.api.CheckpointStorage.kt</ID>
    <ID>NewLineAtEndOfFile:ChosenList.kt$net.corda.client.jfx.utils.ChosenList.kt</ID>
    <ID>NewLineAtEndOfFile:CityDatabaseTest.kt$net.corda.worldmap.CityDatabaseTest.kt</ID>
    <ID>NewLineAtEndOfFile:ClassCarpenterWhitelistTest.kt$net.corda.serialization.internal.carpenter.ClassCarpenterWhitelistTest.kt</ID>
    <ID>NewLineAtEndOfFile:ClassCarpentingTypeLoaderTests.kt$net.corda.serialization.internal.model.ClassCarpentingTypeLoaderTests.kt</ID>
    <ID>NewLineAtEndOfFile:ClassLoadingUtils.kt$net.corda.core.internal.ClassLoadingUtils.kt</ID>
    <ID>NewLineAtEndOfFile:ClassLoadingUtilsTest.kt$net.corda.core.internal.ClassLoadingUtilsTest.kt</ID>
    <ID>NewLineAtEndOfFile:ClassSerializer.kt$net.corda.serialization.internal.amqp.custom.ClassSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:ClearNetworkCacheCli.kt$net.corda.node.internal.subcommands.ClearNetworkCacheCli.kt</ID>
    <ID>NewLineAtEndOfFile:CliBackwardsCompatibleTest.kt$net.corda.testing.CliBackwardsCompatibleTest.kt</ID>
    <ID>NewLineAtEndOfFile:CliParser.kt$net.corda.notaryhealthcheck.client.CliParser.kt</ID>
    <ID>NewLineAtEndOfFile:ClientCacheFactory.kt$net.corda.client.rpc.internal.ClientCacheFactory.kt</ID>
    <ID>NewLineAtEndOfFile:ClientRelevantError.kt$net.corda.core.ClientRelevantError.kt</ID>
    <ID>NewLineAtEndOfFile:ClientRpcExample.kt$net.corda.docs.kotlin.ClientRpcExample.kt</ID>
    <ID>NewLineAtEndOfFile:ClientRpcSslOptions.kt$net.corda.core.messaging.ClientRpcSslOptions.kt</ID>
    <ID>NewLineAtEndOfFile:ClientRpcTutorial.kt$net.corda.docs.kotlin.ClientRpcTutorial.kt</ID>
    <ID>NewLineAtEndOfFile:ClientSessionUtils.kt$net.corda.nodeapi.internal.ClientSessionUtils.kt</ID>
    <ID>NewLineAtEndOfFile:CollectionSerializer.kt$net.corda.serialization.internal.amqp.CollectionSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:CommandLineCompatibilityCheckerTest.kt$net.corda.testing.CommandLineCompatibilityCheckerTest.kt</ID>
    <ID>NewLineAtEndOfFile:CommandLineCompatibilityUtils.kt$net.corda.testing.CommandLineCompatibilityUtils.kt</ID>
    <ID>NewLineAtEndOfFile:CommandsSerializationTests.kt$net.corda.coretests.serialization.CommandsSerializationTests.kt</ID>
    <ID>NewLineAtEndOfFile:CommercialPaper.kt$com.r3.corda.enterprise.perftestcordapp.contracts.CommercialPaper.kt</ID>
    <ID>NewLineAtEndOfFile:CommonSchema.kt$net.corda.core.schemas.CommonSchema.kt</ID>
    <ID>NewLineAtEndOfFile:CompatibilityTest.kt$net.corda.finance.flows.CompatibilityTest.kt</ID>
    <ID>NewLineAtEndOfFile:ComposableTypePropertySerializer.kt$net.corda.serialization.internal.amqp.ComposableTypePropertySerializer.kt</ID>
    <ID>NewLineAtEndOfFile:CompositeSignature.kt$net.corda.core.crypto.CompositeSignature.kt</ID>
    <ID>NewLineAtEndOfFile:Config.kt$net.corda.notaryhealthcheck.client.Config.kt</ID>
    <ID>NewLineAtEndOfFile:ConfigExporter.kt$net.corda.core.ConfigExporter.kt</ID>
    <ID>NewLineAtEndOfFile:ConfigObfuscator.kt$net.corda.common.configuration.parsing.internal.ConfigObfuscator.kt</ID>
    <ID>NewLineAtEndOfFile:ConfigObfuscatorTest.kt$net.corda.common.configuration.parsing.internal.ConfigObfuscatorTest.kt</ID>
    <ID>NewLineAtEndOfFile:ConfigParsingTest.kt$net.corda.nodeapi.internal.config.ConfigParsingTest.kt</ID>
    <ID>NewLineAtEndOfFile:ConfigSections.kt$net.corda.node.services.config.schema.v1.ConfigSections.kt</ID>
    <ID>NewLineAtEndOfFile:ConfigTest.kt$net.corda.bridge.ConfigTest.kt</ID>
    <ID>NewLineAtEndOfFile:Configuration.kt$net.corda.common.configuration.parsing.internal.Configuration.kt</ID>
    <ID>NewLineAtEndOfFile:ConnectionChange.kt$net.corda.nodeapi.internal.protonwrapper.netty.ConnectionChange.kt</ID>
    <ID>NewLineAtEndOfFile:ConnectionStateMachine.kt$net.corda.nodeapi.internal.protonwrapper.engine.ConnectionStateMachine.kt</ID>
    <ID>NewLineAtEndOfFile:Console.kt$net.corda.healthsurvey.cli.Console.kt</ID>
    <ID>NewLineAtEndOfFile:Constants.kt$net.corda.common.logging.Constants.kt</ID>
    <ID>NewLineAtEndOfFile:Constants.kt$net.corda.networkbuilder.Constants.kt</ID>
    <ID>NewLineAtEndOfFile:ConstructorForDeserialization.kt$net.corda.core.serialization.ConstructorForDeserialization.kt</ID>
    <ID>NewLineAtEndOfFile:ContainerPusher.kt$net.corda.networkbuilder.containers.push.ContainerPusher.kt</ID>
    <ID>NewLineAtEndOfFile:Context.kt$net.corda.networkbuilder.context.Context.kt</ID>
    <ID>NewLineAtEndOfFile:ContextualLoggingUtils.kt$net.corda.node.services.logging.ContextualLoggingUtils.kt</ID>
    <ID>NewLineAtEndOfFile:ContractAttachmentSerializer.kt$net.corda.serialization.internal.amqp.custom.ContractAttachmentSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:ContractHierarchyTest.kt$net.corda.coretests.contracts.ContractHierarchyTest.kt</ID>
    <ID>NewLineAtEndOfFile:ContractJarTestUtils.kt$net.corda.testing.core.internal.ContractJarTestUtils.kt</ID>
    <ID>NewLineAtEndOfFile:ContractUpgradeTransactions.kt$net.corda.core.transactions.ContractUpgradeTransactions.kt</ID>
    <ID>NewLineAtEndOfFile:ContractUpgradeUtils.kt$net.corda.core.internal.ContractUpgradeUtils.kt</ID>
    <ID>NewLineAtEndOfFile:Converters.kt$net.corda.webserver.converters.Converters.kt</ID>
    <ID>NewLineAtEndOfFile:CopiedNode.kt$net.corda.networkbuilder.nodes.CopiedNode.kt</ID>
    <ID>NewLineAtEndOfFile:CopiedNotary.kt$net.corda.networkbuilder.notaries.CopiedNotary.kt</ID>
    <ID>NewLineAtEndOfFile:CorDappSerializerTests.kt$net.corda.serialization.internal.amqp.CorDappSerializerTests.kt</ID>
    <ID>NewLineAtEndOfFile:CordaAuthenticationPlugin.kt$net.corda.tools.shell.CordaAuthenticationPlugin.kt</ID>
    <ID>NewLineAtEndOfFile:CordaClassResolverTests.kt$net.corda.serialization.internal.CordaClassResolverTests.kt</ID>
    <ID>NewLineAtEndOfFile:CordaClosureSerializer.kt$net.corda.node.serialization.kryo.CordaClosureSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:CordaException.kt$net.corda.core.CordaException.kt</ID>
    <ID>NewLineAtEndOfFile:CordaExceptionTest.kt$net.corda.deterministic.CordaExceptionTest.kt</ID>
    <ID>NewLineAtEndOfFile:CordaFlowToolWindow.kt$net.corda.ideaplugin.toolwindow.CordaFlowToolWindow.kt</ID>
    <ID>NewLineAtEndOfFile:CordaInternal.kt$net.corda.core.CordaInternal.kt</ID>
    <ID>NewLineAtEndOfFile:CordaPersistenceTest.kt$net.corda.nodeapi.internal.CordaPersistenceTest.kt</ID>
    <ID>NewLineAtEndOfFile:CordaRPCClient.kt$net.corda.client.rpc.CordaRPCClient.kt</ID>
    <ID>NewLineAtEndOfFile:CordaRPCClientReconnectionTest.kt$net.corda.client.rpcreconnect.CordaRPCClientReconnectionTest.kt</ID>
    <ID>NewLineAtEndOfFile:CordaRPCProxyClient.kt$net.corda.behave.service.proxy.CordaRPCProxyClient.kt</ID>
    <ID>NewLineAtEndOfFile:CordaRpcWorkerOps.kt$net.corda.rpcWorker.CordaRpcWorkerOps.kt</ID>
    <ID>NewLineAtEndOfFile:CordaSSHAuthInfo.kt$net.corda.tools.shell.CordaSSHAuthInfo.kt</ID>
    <ID>NewLineAtEndOfFile:CordaSdkVersionComboBox.kt$net.corda.ideaplugin.module.CordaSdkVersionComboBox.kt</ID>
    <ID>NewLineAtEndOfFile:CordaServiceFlowTests.kt$net.corda.node.services.CordaServiceFlowTests.kt</ID>
    <ID>NewLineAtEndOfFile:CordaServiceTest.kt$net.corda.node.internal.CordaServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:CordaVersion.kt$net.corda.common.logging.CordaVersion.kt</ID>
    <ID>NewLineAtEndOfFile:CordaVersionProvider.kt$net.corda.cliutils.CordaVersionProvider.kt</ID>
    <ID>NewLineAtEndOfFile:CordaViewModel.kt$net.corda.explorer.model.CordaViewModel.kt</ID>
    <ID>NewLineAtEndOfFile:CordaX500Name.kt$net.corda.core.identity.CordaX500Name.kt</ID>
    <ID>NewLineAtEndOfFile:CordappConfig.kt$net.corda.core.cordapp.CordappConfig.kt</ID>
    <ID>NewLineAtEndOfFile:CordappConfigFileProviderTests.kt$net.corda.node.internal.cordapp.CordappConfigFileProviderTests.kt</ID>
    <ID>NewLineAtEndOfFile:CordappConfigProvider.kt$net.corda.node.internal.cordapp.CordappConfigProvider.kt</ID>
    <ID>NewLineAtEndOfFile:CordappInfo.kt$net.corda.core.cordapp.CordappInfo.kt</ID>
    <ID>NewLineAtEndOfFile:CordappLoader.kt$net.corda.nodeapi.internal.cordapp.CordappLoader.kt</ID>
    <ID>NewLineAtEndOfFile:CordappProvider.kt$net.corda.core.cordapp.CordappProvider.kt</ID>
    <ID>NewLineAtEndOfFile:CordappResolver.kt$net.corda.core.internal.cordapp.CordappResolver.kt</ID>
    <ID>NewLineAtEndOfFile:CreateMigrationSqlForCordappsCli.kt$com.r3.corda.dbmigration.CreateMigrationSqlForCordappsCli.kt</ID>
    <ID>NewLineAtEndOfFile:CrlFetcher.kt$net.corda.bridge.services.crl.CrlFetcher.kt</ID>
    <ID>NewLineAtEndOfFile:CrlFetcherTest.kt$net.corda.bridge.services.crl.CrlFetcherTest.kt</ID>
    <ID>NewLineAtEndOfFile:CrlServer.kt$net.corda.nodeapi.internal.amqp.crl.CrlServer.kt</ID>
    <ID>NewLineAtEndOfFile:CryptoService.kt$net.corda.nodeapi.internal.cryptoservice.CryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:CryptoServiceFactory.kt$net.corda.nodeapi.internal.cryptoservice.CryptoServiceFactory.kt</ID>
    <ID>NewLineAtEndOfFile:CryptoServiceSigningService.kt$net.corda.nodeapi.internal.cryptoservice.CryptoServiceSigningService.kt</ID>
    <ID>NewLineAtEndOfFile:CryptoServiceSigningServiceUnitTest.kt$net.corda.bridge.services.receiver.CryptoServiceSigningServiceUnitTest.kt</ID>
    <ID>NewLineAtEndOfFile:CryptoServiceSpec.kt$net.corda.nodeapi.internal.cryptoservice.CryptoServiceSpec.kt</ID>
    <ID>NewLineAtEndOfFile:CryptoUtils.kt$net.corda.core.crypto.CryptoUtils.kt</ID>
    <ID>NewLineAtEndOfFile:CurrenciesTests.kt$net.corda.finance.CurrenciesTests.kt</ID>
    <ID>NewLineAtEndOfFile:CurrencyParameterSensitivitiesSerializer.kt$net.corda.vega.plugin.customserializers.CurrencyParameterSensitivitiesSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:CustomSerializerRegistryTests.kt$net.corda.serialization.internal.amqp.CustomSerializerRegistryTests.kt</ID>
    <ID>NewLineAtEndOfFile:CustomTypeJsonParsingTests.kt$net.corda.tools.shell.CustomTypeJsonParsingTests.kt</ID>
    <ID>NewLineAtEndOfFile:DBRunnerExtension.kt$net.corda.testing.internal.db.DBRunnerExtension.kt</ID>
    <ID>NewLineAtEndOfFile:Dashboard.kt$net.corda.explorer.views.Dashboard.kt</ID>
    <ID>NewLineAtEndOfFile:DataSourceFactory.kt$net.corda.node.internal.DataSourceFactory.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseConstants.kt$net.corda.testing.database.DatabaseConstants.kt</ID>
    <ID>NewLineAtEndOfFile:DatabaseTestContainers.kt$net.corda.notary.standalonejpa.DatabaseTestContainers.kt</ID>
    <ID>NewLineAtEndOfFile:DbExceptionHandler.kt$net.corda.node.internal.DbExceptionHandler.kt</ID>
    <ID>NewLineAtEndOfFile:DbManagerConfiguration.kt$com.r3.corda.dbmigration.DbManagerConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:DbManagerOptions.kt$com.r3.corda.dbmigration.DbManagerOptions.kt</ID>
    <ID>NewLineAtEndOfFile:DbSchemaInitialisationTest.kt$net.corda.node.persistence.DbSchemaInitialisationTest.kt</ID>
    <ID>NewLineAtEndOfFile:DbTransactionsResolver.kt$net.corda.node.services.DbTransactionsResolver.kt</ID>
    <ID>NewLineAtEndOfFile:DbTransactionsResolverTopologicalSortTest.kt$net.corda.node.services.transactions.DbTransactionsResolverTopologicalSortTest.kt</ID>
    <ID>NewLineAtEndOfFile:DeduplicationId.kt$net.corda.node.services.statemachine.DeduplicationId.kt</ID>
    <ID>NewLineAtEndOfFile:DefaultCacheProvider.kt$net.corda.serialization.internal.model.DefaultCacheProvider.kt</ID>
    <ID>NewLineAtEndOfFile:DefaultKryoCustomizer.kt$net.corda.node.serialization.kryo.DefaultKryoCustomizer.kt</ID>
    <ID>NewLineAtEndOfFile:DelegatedKeystoreProvider.kt$net.corda.nodeapi.internal.provider.DelegatedKeystoreProvider.kt</ID>
    <ID>NewLineAtEndOfFile:DelegatedKeystoreProviderTest.kt$net.corda.nodeapi.internal.provider.DelegatedKeystoreProviderTest.kt</ID>
    <ID>NewLineAtEndOfFile:DelegatedSignatureProvider.kt$net.corda.nodeapi.internal.provider.DelegatedSignatureProvider.kt</ID>
    <ID>NewLineAtEndOfFile:DelegatedSigningService.kt$net.corda.nodeapi.internal.provider.DelegatedSigningService.kt</ID>
    <ID>NewLineAtEndOfFile:DemoBenchNodeInfoFilesCopier.kt$net.corda.demobench.model.DemoBenchNodeInfoFilesCopier.kt</ID>
    <ID>NewLineAtEndOfFile:DescriptorBasedSerializerRegistry.kt$net.corda.serialization.internal.amqp.DescriptorBasedSerializerRegistry.kt</ID>
    <ID>NewLineAtEndOfFile:DeserializeNeedingCarpentrySimpleTypesTest.kt$net.corda.serialization.internal.amqp.DeserializeNeedingCarpentrySimpleTypesTest.kt</ID>
    <ID>NewLineAtEndOfFile:DeserializeQueryableStateTest.kt$net.corda.serialization.internal.amqp.DeserializeQueryableStateTest.kt</ID>
    <ID>NewLineAtEndOfFile:DigitalSignatureWithCert.kt$net.corda.core.internal.DigitalSignatureWithCert.kt</ID>
    <ID>NewLineAtEndOfFile:DirectBridgeSenderService.kt$net.corda.bridge.services.sender.DirectBridgeSenderService.kt</ID>
    <ID>NewLineAtEndOfFile:DistributedServiceTests.kt$net.corda.node.services.distributed.DistributedServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:DoNotImplement.kt$net.corda.core.DoNotImplement.kt</ID>
    <ID>NewLineAtEndOfFile:DockerBackend.kt$net.corda.networkbuilder.backends.DockerBackend.kt</ID>
    <ID>NewLineAtEndOfFile:DockerInstantiator.kt$net.corda.networkbuilder.containers.instance.docker.DockerInstantiator.kt</ID>
    <ID>NewLineAtEndOfFile:DockerUtils.kt$net.corda.networkbuilder.docker.DockerUtils.kt</ID>
    <ID>NewLineAtEndOfFile:Driver.kt$net.corda.testing.driver.Driver.kt</ID>
    <ID>NewLineAtEndOfFile:DryRunCli.kt$com.r3.corda.dbmigration.DryRunCli.kt</ID>
    <ID>NewLineAtEndOfFile:DualNodeBaseFlowSampler.kt$com.r3.corda.jmeter.DualNodeBaseFlowSampler.kt</ID>
    <ID>NewLineAtEndOfFile:DummyClusterSpec.kt$net.corda.testing.node.internal.DummyClusterSpec.kt</ID>
    <ID>NewLineAtEndOfFile:DummyIssueAndMove.kt$net.corda.notarydemo.flows.DummyIssueAndMove.kt</ID>
    <ID>NewLineAtEndOfFile:DummyLinearContract.kt$net.corda.testing.internal.vault.DummyLinearContract.kt</ID>
    <ID>NewLineAtEndOfFile:DurationHelper.kt$net.corda.notaryhealthcheck.utils.DurationHelper.kt</ID>
    <ID>NewLineAtEndOfFile:DurationSerializer.kt$net.corda.serialization.internal.amqp.custom.DurationSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:EfficiencyKnownUnspentCachingDriver.kt$net.corda.notarydemo.flows.EfficiencyKnownUnspentCachingDriver.kt</ID>
    <ID>NewLineAtEndOfFile:EmptyFlow.kt$com.r3.corda.enterprise.perftestcordapp.flows.EmptyFlow.kt</ID>
    <ID>NewLineAtEndOfFile:EnterpriseCashSelectionSQLServerImpl.kt$net.corda.finance.workflows.asset.selection.EnterpriseCashSelectionSQLServerImpl.kt</ID>
    <ID>NewLineAtEndOfFile:EnterpriseFlowLogicRefFactory.kt$net.corda.node.services.statemachine.EnterpriseFlowLogicRefFactory.kt</ID>
    <ID>NewLineAtEndOfFile:EnterpriseNamedCacheFactory.kt$net.corda.node.utilities.EnterpriseNamedCacheFactory.kt</ID>
    <ID>NewLineAtEndOfFile:EnterpriseNodeTest.kt$net.corda.node.internal.EnterpriseNodeTest.kt</ID>
    <ID>NewLineAtEndOfFile:EnumClassTests.kt$net.corda.serialization.internal.carpenter.EnumClassTests.kt</ID>
    <ID>NewLineAtEndOfFile:EnumSerializer.kt$net.corda.serialization.internal.amqp.EnumSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:EnumSetSerializer.kt$net.corda.serialization.internal.amqp.custom.EnumSetSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:EnumTests.kt$net.corda.serialization.internal.amqp.EnumTests.kt</ID>
    <ID>NewLineAtEndOfFile:EnumTransformationTests.kt$net.corda.serialization.internal.amqp.EnumTransformationTests.kt</ID>
    <ID>NewLineAtEndOfFile:EnumTransforms.kt$net.corda.serialization.internal.model.EnumTransforms.kt</ID>
    <ID>NewLineAtEndOfFile:ErrorCodeLoggingTests.kt$net.corda.node.logging.ErrorCodeLoggingTests.kt</ID>
    <ID>NewLineAtEndOfFile:ErrorCodeRewritePolicy.kt$net.corda.common.logging.ErrorCodeRewritePolicy.kt</ID>
    <ID>NewLineAtEndOfFile:ErrorMessagesTests.kt$net.corda.serialization.internal.amqp.ErrorMessagesTests.kt</ID>
    <ID>NewLineAtEndOfFile:EventProcessor.kt$net.corda.nodeapi.internal.protonwrapper.engine.EventProcessor.kt</ID>
    <ID>NewLineAtEndOfFile:Eventually.kt$net.corda.testing.common.internal.Eventually.kt</ID>
    <ID>NewLineAtEndOfFile:EvolutionSerializerFactory.kt$net.corda.serialization.internal.amqp.EvolutionSerializerFactory.kt</ID>
    <ID>NewLineAtEndOfFile:EvolutionSerializerFactoryTests.kt$net.corda.serialization.internal.amqp.EvolutionSerializerFactoryTests.kt</ID>
    <ID>NewLineAtEndOfFile:ExampleConfigTest.kt$net.corda.docs.ExampleConfigTest.kt</ID>
    <ID>NewLineAtEndOfFile:Examples.kt$net.corda.finance.contracts.universal.Examples.kt</ID>
    <ID>NewLineAtEndOfFile:ExceptionsErrorCodeFunctions.kt$net.corda.common.logging.ExceptionsErrorCodeFunctions.kt</ID>
    <ID>NewLineAtEndOfFile:ExceptionsSerializationTest.kt$net.corda.node.services.statemachine.ExceptionsSerializationTest.kt</ID>
    <ID>NewLineAtEndOfFile:ExchangeRateModelTest.kt$net.corda.client.jfx.model.ExchangeRateModelTest.kt</ID>
    <ID>NewLineAtEndOfFile:ExecuteMigrationsCli.kt$com.r3.corda.dbmigration.ExecuteMigrationsCli.kt</ID>
    <ID>NewLineAtEndOfFile:ExitCodes.kt$net.corda.cliutils.ExitCodes.kt</ID>
    <ID>NewLineAtEndOfFile:Explorer.kt$net.corda.demobench.explorer.Explorer.kt</ID>
    <ID>NewLineAtEndOfFile:ExposeJpaToFlowsTests.kt$net.corda.node.services.persistence.ExposeJpaToFlowsTests.kt</ID>
    <ID>NewLineAtEndOfFile:ExternalCrlSource.kt$net.corda.nodeapi.internal.protonwrapper.netty.ExternalCrlSource.kt</ID>
    <ID>NewLineAtEndOfFile:ExternalIdMappingTest.kt$net.corda.node.services.vault.ExternalIdMappingTest.kt</ID>
    <ID>NewLineAtEndOfFile:ExternalMasterElectionService.kt$net.corda.bridge.services.ha.ExternalMasterElectionService.kt</ID>
    <ID>NewLineAtEndOfFile:ExternalSourceRevocationChecker.kt$net.corda.nodeapi.internal.protonwrapper.netty.revocation.ExternalSourceRevocationChecker.kt</ID>
    <ID>NewLineAtEndOfFile:FXFwdTimeOption.kt$net.corda.finance.contracts.universal.FXFwdTimeOption.kt</ID>
    <ID>NewLineAtEndOfFile:FetchDataFlow.kt$net.corda.core.internal.FetchDataFlow.kt</ID>
    <ID>NewLineAtEndOfFile:FileUtils.kt$net.corda.healthsurvey.FileUtils.kt</ID>
    <ID>NewLineAtEndOfFile:FilterMyKeysTests.kt$net.corda.node.services.keys.FilterMyKeysTests.kt</ID>
    <ID>NewLineAtEndOfFile:FilterServiceTest.kt$net.corda.bridge.services.FilterServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:FingerPrinterTesting.kt$net.corda.serialization.internal.amqp.FingerPrinterTesting.kt</ID>
    <ID>NewLineAtEndOfFile:FirewallAuditService.kt$net.corda.bridge.services.api.FirewallAuditService.kt</ID>
    <ID>NewLineAtEndOfFile:FirewallCmdLineOptions.kt$net.corda.bridge.FirewallCmdLineOptions.kt</ID>
    <ID>NewLineAtEndOfFile:FirewallInstance.kt$net.corda.bridge.internal.FirewallInstance.kt</ID>
    <ID>NewLineAtEndOfFile:FirewallStartup.kt$net.corda.bridge.internal.FirewallStartup.kt</ID>
    <ID>NewLineAtEndOfFile:FirewallVersionInfo.kt$net.corda.bridge.FirewallVersionInfo.kt</ID>
    <ID>NewLineAtEndOfFile:FloatControlListenerService.kt$net.corda.bridge.services.receiver.FloatControlListenerService.kt</ID>
    <ID>NewLineAtEndOfFile:FloatControlService.kt$net.corda.bridge.services.api.FloatControlService.kt</ID>
    <ID>NewLineAtEndOfFile:FloatSupervisorService.kt$net.corda.bridge.services.api.FloatSupervisorService.kt</ID>
    <ID>NewLineAtEndOfFile:FloatSupervisorServiceImpl.kt$net.corda.bridge.services.supervisors.FloatSupervisorServiceImpl.kt</ID>
    <ID>NewLineAtEndOfFile:FlowHandle.kt$net.corda.core.messaging.FlowHandle.kt</ID>
    <ID>NewLineAtEndOfFile:FlowHospitalTest.kt$net.corda.node.services.statemachine.FlowHospitalTest.kt</ID>
    <ID>NewLineAtEndOfFile:FlowInitiator.kt$net.corda.core.flows.FlowInitiator.kt</ID>
    <ID>NewLineAtEndOfFile:FlowLogicRef.kt$net.corda.core.flows.FlowLogicRef.kt</ID>
    <ID>NewLineAtEndOfFile:FlowMatchers.kt$net.corda.testing.internal.matchers.flow.FlowMatchers.kt</ID>
    <ID>NewLineAtEndOfFile:FlowMonitor.kt$net.corda.node.services.statemachine.FlowMonitor.kt</ID>
    <ID>NewLineAtEndOfFile:FlowNameFormatter.kt$net.corda.explorer.formatters.FlowNameFormatter.kt</ID>
    <ID>NewLineAtEndOfFile:FlowOverrideTests.kt$net.corda.node.flows.FlowOverrideTests.kt</ID>
    <ID>NewLineAtEndOfFile:FlowRegistrationTest.kt$net.corda.node.internal.FlowRegistrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:FlowRetryTest.kt$net.corda.node.flows.FlowRetryTest.kt</ID>
    <ID>NewLineAtEndOfFile:FlowRunner.kt$net.corda.tools.testing.pinger.FlowRunner.kt</ID>
    <ID>NewLineAtEndOfFile:FlowSnapshotTreeDataManager.kt$net.corda.ideaplugin.toolwindow.FlowSnapshotTreeDataManager.kt</ID>
    <ID>NewLineAtEndOfFile:FlowStackSnapshot.kt$net.corda.core.flows.FlowStackSnapshot.kt</ID>
    <ID>NewLineAtEndOfFile:FlowStateMachineComparator.kt$net.corda.node.services.statemachine.FlowStateMachineComparator.kt</ID>
    <ID>NewLineAtEndOfFile:FlowStateMachineComparatorTest.kt$net.corda.node.services.statemachine.FlowStateMachineComparatorTest.kt</ID>
    <ID>NewLineAtEndOfFile:FlowTestsUtils.kt$net.corda.testing.flows.FlowTestsUtils.kt</ID>
    <ID>NewLineAtEndOfFile:FlowTimeoutException.kt$net.corda.node.services.statemachine.FlowTimeoutException.kt</ID>
    <ID>NewLineAtEndOfFile:FlowTreeDataManager.kt$net.corda.ideaplugin.toolwindow.FlowTreeDataManager.kt</ID>
    <ID>NewLineAtEndOfFile:FlowVersioningTest.kt$net.corda.node.services.statemachine.FlowVersioningTest.kt</ID>
    <ID>NewLineAtEndOfFile:FlowWorker.kt$net.corda.flowworker.FlowWorker.kt</ID>
    <ID>NewLineAtEndOfFile:FlowWorkerPartitioner.kt$net.corda.flowworker.zookeeper.FlowWorkerPartitioner.kt</ID>
    <ID>NewLineAtEndOfFile:FlowWorkerZkClient.kt$net.corda.flowworker.zookeeper.FlowWorkerZkClient.kt</ID>
    <ID>NewLineAtEndOfFile:FlowWorkerZkClientTest.kt$net.corda.flowworker.zookeeper.FlowWorkerZkClientTest.kt</ID>
    <ID>NewLineAtEndOfFile:FlowsExecutionModeRpcTest.kt$net.corda.client.rpc.FlowsExecutionModeRpcTest.kt</ID>
    <ID>NewLineAtEndOfFile:ForwardingArtemisMessageClient.kt$net.corda.bridge.services.artemis.ForwardingArtemisMessageClient.kt</ID>
    <ID>NewLineAtEndOfFile:FoundNode.kt$net.corda.networkbuilder.nodes.FoundNode.kt</ID>
    <ID>NewLineAtEndOfFile:FutureMatchers.kt$net.corda.testing.internal.matchers.future.FutureMatchers.kt</ID>
    <ID>NewLineAtEndOfFile:FutureXCryptoServiceTest.kt$net.corda.nodeapi.internal.cryptoservice.futurex.FutureXCryptoServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:FutureXNodeRegistrationTest.kt$net.corda.node.services.keys.cryptoservice.futurex.FutureXNodeRegistrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:GemaltoLunaCryptoService.kt$net.corda.nodeapi.internal.cryptoservice.gemalto.GemaltoLunaCryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:GenerateHelpers.kt$net.corda.loadtest.tests.GenerateHelpers.kt</ID>
    <ID>NewLineAtEndOfFile:GenerateNodeInfoCli.kt$net.corda.node.internal.subcommands.GenerateNodeInfoCli.kt</ID>
    <ID>NewLineAtEndOfFile:Generator.kt$net.corda.client.mock.Generator.kt</ID>
    <ID>NewLineAtEndOfFile:Generator.kt$net.corda.notarytest.Generator.kt</ID>
    <ID>NewLineAtEndOfFile:GetStringConfigFlow.kt$net.corda.configsample.GetStringConfigFlow.kt</ID>
    <ID>NewLineAtEndOfFile:GroupAMoreTests.kt$net.corda.testing.internal.db.GroupAMoreTests.kt</ID>
    <ID>NewLineAtEndOfFile:GroupATests.kt$net.corda.testing.internal.db.GroupATests.kt</ID>
    <ID>NewLineAtEndOfFile:GroupBTests.kt$net.corda.testing.internal.db.GroupBTests.kt</ID>
    <ID>NewLineAtEndOfFile:GuiUtilitiesKtTest.kt$net.corda.explorer.views.GuiUtilitiesKtTest.kt</ID>
    <ID>NewLineAtEndOfFile:H2SecurityTests.kt$net.corda.node.persistence.H2SecurityTests.kt</ID>
    <ID>NewLineAtEndOfFile:HABrokerFailoverTest.kt$net.corda.bridge.HABrokerFailoverTest.kt</ID>
    <ID>NewLineAtEndOfFile:HealthCheckFlow.kt$net.corda.notaryhealthcheck.cordapp.HealthCheckFlow.kt</ID>
    <ID>NewLineAtEndOfFile:HibernateColumnConverterTests.kt$net.corda.node.services.persistence.HibernateColumnConverterTests.kt</ID>
    <ID>NewLineAtEndOfFile:HibernateEntityManagerFactoryProvider.kt$net.corda.notary.standalonejpa.HibernateEntityManagerFactoryProvider.kt</ID>
    <ID>NewLineAtEndOfFile:HibernateQueryCriteriaParser.kt$net.corda.node.services.vault.HibernateQueryCriteriaParser.kt</ID>
    <ID>NewLineAtEndOfFile:HibernateStatistics.kt$net.corda.nodeapi.internal.persistence.HibernateStatistics.kt</ID>
    <ID>NewLineAtEndOfFile:IOUContract.kt$net.corda.docs.kotlin.tutorial.twoparty.IOUContract.kt</ID>
    <ID>NewLineAtEndOfFile:IOUState.kt$net.corda.docs.kotlin.tutorial.twoparty.IOUState.kt</ID>
    <ID>NewLineAtEndOfFile:Id.kt$net.corda.core.utilities.Id.kt</ID>
    <ID>NewLineAtEndOfFile:IdempotentFlow.kt$net.corda.core.internal.IdempotentFlow.kt</ID>
    <ID>NewLineAtEndOfFile:IdempotentFlowTests.kt$net.corda.node.services.statemachine.IdempotentFlowTests.kt</ID>
    <ID>NewLineAtEndOfFile:IdenticonRenderer.kt$net.corda.explorer.identicon.IdenticonRenderer.kt</ID>
    <ID>NewLineAtEndOfFile:IdentitySyncFlowTests.kt$net.corda.confidential.IdentitySyncFlowTests.kt</ID>
    <ID>NewLineAtEndOfFile:IdentityUtils.kt$net.corda.core.identity.IdentityUtils.kt</ID>
    <ID>NewLineAtEndOfFile:InProcessBridgeReceiverService.kt$net.corda.bridge.services.receiver.InProcessBridgeReceiverService.kt</ID>
    <ID>NewLineAtEndOfFile:IncomingMessageFilterService.kt$net.corda.bridge.services.api.IncomingMessageFilterService.kt</ID>
    <ID>NewLineAtEndOfFile:InfrequentlyMutatedCache.kt$net.corda.node.utilities.InfrequentlyMutatedCache.kt</ID>
    <ID>NewLineAtEndOfFile:InfrequentlyMutatedCacheTest.kt$net.corda.node.utilities.InfrequentlyMutatedCacheTest.kt</ID>
    <ID>NewLineAtEndOfFile:InitiatedBy.kt$net.corda.core.flows.InitiatedBy.kt</ID>
    <ID>NewLineAtEndOfFile:InputStreamSerializer.kt$net.corda.serialization.internal.amqp.custom.InputStreamSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:InstallCheckScheduleStateFlow.kt$net.corda.notaryhealthcheck.cordapp.InstallCheckScheduleStateFlow.kt</ID>
    <ID>NewLineAtEndOfFile:InstallShellExtensionsParser.kt$net.corda.cliutils.InstallShellExtensionsParser.kt</ID>
    <ID>NewLineAtEndOfFile:InstanceInfo.kt$net.corda.networkbuilder.containers.instance.InstanceInfo.kt</ID>
    <ID>NewLineAtEndOfFile:Instances.kt$net.corda.core.crypto.internal.Instances.kt</ID>
    <ID>NewLineAtEndOfFile:InstantSerializer.kt$net.corda.serialization.internal.amqp.custom.InstantSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:Instantiator.kt$net.corda.networkbuilder.containers.instance.Instantiator.kt</ID>
    <ID>NewLineAtEndOfFile:InstrumentationTest.kt$net.corda.instrumentation.byteman.InstrumentationTest.kt</ID>
    <ID>NewLineAtEndOfFile:InterestRatesSwapDemoAPI.kt$net.corda.irs.web.api.InterestRatesSwapDemoAPI.kt</ID>
    <ID>NewLineAtEndOfFile:InternalAccessTestHelpers.kt$net.corda.serialization.internal.InternalAccessTestHelpers.kt</ID>
    <ID>NewLineAtEndOfFile:InternalCordaRPCOps.kt$net.corda.core.internal.messaging.InternalCordaRPCOps.kt</ID>
    <ID>NewLineAtEndOfFile:InternalKeystoreGenerator.kt$com.r3.ha.utilities.InternalKeystoreGenerator.kt</ID>
    <ID>NewLineAtEndOfFile:InternalMockAttachmentStorage.kt$net.corda.testing.internal.services.InternalMockAttachmentStorage.kt</ID>
    <ID>NewLineAtEndOfFile:InternalMockNetworkConfigOverrides.kt$net.corda.testing.node.internal.InternalMockNetworkConfigOverrides.kt</ID>
    <ID>NewLineAtEndOfFile:InternalTestConstants.kt$net.corda.testing.internal.InternalTestConstants.kt</ID>
    <ID>NewLineAtEndOfFile:InternalTestUtils.kt$net.corda.testing.internal.InternalTestUtils.kt</ID>
    <ID>NewLineAtEndOfFile:InvocationContext.kt$net.corda.core.context.InvocationContext.kt</ID>
    <ID>NewLineAtEndOfFile:InvocationHandlerTemplate.kt$net.corda.node.internal.InvocationHandlerTemplate.kt</ID>
    <ID>NewLineAtEndOfFile:IssueCash.kt$net.corda.bank.IssueCash.kt</ID>
    <ID>NewLineAtEndOfFile:IssueCashLoggingTests.kt$net.corda.node.logging.IssueCashLoggingTests.kt</ID>
    <ID>NewLineAtEndOfFile:JCACryptoService.kt$net.corda.nodeapi.internal.cryptoservice.JCACryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:JPALoadTestFlow.kt$net.corda.notarytest.flows.JPALoadTestFlow.kt</ID>
    <ID>NewLineAtEndOfFile:JPANotaryEntities.kt$net.corda.notary.standalonejpa.JPANotaryEntities.kt</ID>
    <ID>NewLineAtEndOfFile:JVMAgentRegistry.kt$net.corda.node.utilities.JVMAgentRegistry.kt</ID>
    <ID>NewLineAtEndOfFile:JarSignatureCollector.kt$net.corda.core.internal.JarSignatureCollector.kt</ID>
    <ID>NewLineAtEndOfFile:JvmStatsHelper.kt$net.corda.core.internal.utilities.JvmStatsHelper.kt</ID>
    <ID>NewLineAtEndOfFile:JvmStatsHelperTest.kt$net.corda.core.internal.utilities.JvmStatsHelperTest.kt</ID>
    <ID>NewLineAtEndOfFile:KMSUtilsTests.kt$net.corda.node.services.keys.KMSUtilsTests.kt</ID>
    <ID>NewLineAtEndOfFile:KeepForDJVM.kt$net.corda.core.KeepForDJVM.kt</ID>
    <ID>NewLineAtEndOfFile:KeyManagementService.kt$net.corda.core.node.services.KeyManagementService.kt</ID>
    <ID>NewLineAtEndOfFile:KeyOwningIdentity.kt$net.corda.nodeapi.internal.KeyOwningIdentity.kt</ID>
    <ID>NewLineAtEndOfFile:KeyStoreConfigHelpers.kt$net.corda.nodeapi.internal.KeyStoreConfigHelpers.kt</ID>
    <ID>NewLineAtEndOfFile:KeyStoreGenerator.kt$net.corda.deterministic.data.KeyStoreGenerator.kt</ID>
    <ID>NewLineAtEndOfFile:KotlinUtilsTest.kt$net.corda.coretests.utilities.KotlinUtilsTest.kt</ID>
    <ID>NewLineAtEndOfFile:LargeTransactionsTest.kt$net.corda.node.services.statemachine.LargeTransactionsTest.kt</ID>
    <ID>NewLineAtEndOfFile:Launcher.kt$net.corda.launcher.Launcher.kt</ID>
    <ID>NewLineAtEndOfFile:LauncherCommandLine.kt$com.r3.corda.jmeter.LauncherCommandLine.kt</ID>
    <ID>NewLineAtEndOfFile:LazyPool.kt$net.corda.core.internal.LazyPool.kt</ID>
    <ID>NewLineAtEndOfFile:LazyStickyPool.kt$net.corda.core.internal.LazyStickyPool.kt</ID>
    <ID>NewLineAtEndOfFile:LedgerTransactionQueryTests.kt$net.corda.coretests.transactions.LedgerTransactionQueryTests.kt</ID>
    <ID>NewLineAtEndOfFile:LegacyConfigurations.kt$net.corda.bridge.services.config.internal.LegacyConfigurations.kt</ID>
    <ID>NewLineAtEndOfFile:LegalNameValidator.kt$net.corda.core.internal.LegalNameValidator.kt</ID>
    <ID>NewLineAtEndOfFile:LegalNameValidatorTest.kt$net.corda.core.internal.LegalNameValidatorTest.kt</ID>
    <ID>NewLineAtEndOfFile:LifeCycle.kt$net.corda.core.internal.LifeCycle.kt</ID>
    <ID>NewLineAtEndOfFile:LifecycleSupport.kt$net.corda.node.internal.LifecycleSupport.kt</ID>
    <ID>NewLineAtEndOfFile:LinearStateScenarioRunner.kt$net.corda.haTesting.LinearStateScenarioRunner.kt</ID>
    <ID>NewLineAtEndOfFile:LoadGeneratorClient.kt$net.corda.tools.benchmark.LoadGeneratorClient.kt</ID>
    <ID>NewLineAtEndOfFile:LocalDateSerializer.kt$net.corda.serialization.internal.amqp.custom.LocalDateSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:LocalDateTimeSerializer.kt$net.corda.serialization.internal.amqp.custom.LocalDateTimeSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:LocalPropertyInformation.kt$net.corda.serialization.internal.model.LocalPropertyInformation.kt</ID>
    <ID>NewLineAtEndOfFile:LocalTimeSerializer.kt$net.corda.serialization.internal.amqp.custom.LocalTimeSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:LocalTypeInformationBuilder.kt$net.corda.serialization.internal.model.LocalTypeInformationBuilder.kt</ID>
    <ID>NewLineAtEndOfFile:LocalTypeModelTests.kt$net.corda.serialization.internal.model.LocalTypeModelTests.kt</ID>
    <ID>NewLineAtEndOfFile:LocalVolume.kt$net.corda.networkbuilder.volumes.docker.LocalVolume.kt</ID>
    <ID>NewLineAtEndOfFile:LogProcessor.kt$com.r3.corda.tracelog.LogProcessor.kt</ID>
    <ID>NewLineAtEndOfFile:LoggingFirewallAuditService.kt$net.corda.bridge.services.audit.LoggingFirewallAuditService.kt</ID>
    <ID>NewLineAtEndOfFile:LoggingFirewallAuditServiceTest.kt$net.corda.bridge.services.audit.LoggingFirewallAuditServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:LoopbackBridgeTest.kt$net.corda.bridge.LoopbackBridgeTest.kt</ID>
    <ID>NewLineAtEndOfFile:LoopbackBridgeTest.kt$net.corda.node.amqp.LoopbackBridgeTest.kt</ID>
    <ID>NewLineAtEndOfFile:MQSecurityTest.kt$net.corda.services.messaging.MQSecurityTest.kt</ID>
    <ID>NewLineAtEndOfFile:Main.kt$com.r3.ha.notaryregistration.Main.kt</ID>
    <ID>NewLineAtEndOfFile:Main.kt$com.r3.ha.utilities.Main.kt</ID>
    <ID>NewLineAtEndOfFile:Main.kt$net.corda.haTesting.Main.kt</ID>
    <ID>NewLineAtEndOfFile:Main.kt$net.corda.notaryhealthcheck.client.Main.kt</ID>
    <ID>NewLineAtEndOfFile:Main.kt$net.corda.notarytest.Main.kt</ID>
    <ID>NewLineAtEndOfFile:MainView.kt$net.corda.explorer.views.MainView.kt</ID>
    <ID>NewLineAtEndOfFile:MappedSchemasCrossReferenceDetectionTests.kt$net.corda.coretests.schemas.MappedSchemasCrossReferenceDetectionTests.kt</ID>
    <ID>NewLineAtEndOfFile:MatcherTests.kt$net.corda.testing.internal.MatcherTests.kt</ID>
    <ID>NewLineAtEndOfFile:Matchers.kt$net.corda.testing.internal.matchers.Matchers.kt</ID>
    <ID>NewLineAtEndOfFile:MemUtils.kt$net.corda.flowworker.MemUtils.kt</ID>
    <ID>NewLineAtEndOfFile:MerkleTransaction.kt$net.corda.core.transactions.MerkleTransaction.kt</ID>
    <ID>NewLineAtEndOfFile:MerkleTree.kt$net.corda.core.crypto.MerkleTree.kt</ID>
    <ID>NewLineAtEndOfFile:MerkleTreeTest.kt$net.corda.deterministic.crypto.MerkleTreeTest.kt</ID>
    <ID>NewLineAtEndOfFile:MessageState.kt$net.corda.testMessage.MessageState.kt</ID>
    <ID>NewLineAtEndOfFile:MessageStatus.kt$net.corda.nodeapi.internal.protonwrapper.messages.MessageStatus.kt</ID>
    <ID>NewLineAtEndOfFile:MetricInterceptor.kt$net.corda.node.services.statemachine.interceptors.MetricInterceptor.kt</ID>
    <ID>NewLineAtEndOfFile:Metrics.kt$net.corda.notaryhealthcheck.cordapp.Metrics.kt</ID>
    <ID>NewLineAtEndOfFile:MigrationExporter.kt$net.corda.node.services.persistence.MigrationExporter.kt</ID>
    <ID>NewLineAtEndOfFile:MigrationNamedCacheFactory.kt$net.corda.node.migration.MigrationNamedCacheFactory.kt</ID>
    <ID>NewLineAtEndOfFile:MigrationServicesForResolution.kt$net.corda.node.migration.MigrationServicesForResolution.kt</ID>
    <ID>NewLineAtEndOfFile:MissingAttachmentsException.kt$net.corda.core.serialization.MissingAttachmentsException.kt</ID>
    <ID>NewLineAtEndOfFile:MockAttachmentStorage.kt$net.corda.testing.services.MockAttachmentStorage.kt</ID>
    <ID>NewLineAtEndOfFile:MockContractAttachment.kt$net.corda.deterministic.verifier.MockContractAttachment.kt</ID>
    <ID>NewLineAtEndOfFile:MockCordappConfigProvider.kt$net.corda.testing.internal.MockCordappConfigProvider.kt</ID>
    <ID>NewLineAtEndOfFile:MockCryptoService.kt$net.corda.testing.node.internal.MockCryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:MockKeyManagementService.kt$net.corda.testing.node.internal.MockKeyManagementService.kt</ID>
    <ID>NewLineAtEndOfFile:MockNetworkTest.kt$net.corda.testing.node.MockNetworkTest.kt</ID>
    <ID>NewLineAtEndOfFile:MockPublicKeyToOwningIdentityCache.kt$net.corda.testing.node.internal.MockPublicKeyToOwningIdentityCache.kt</ID>
    <ID>NewLineAtEndOfFile:MockServices.kt$net.corda.testing.node.MockServices.kt</ID>
    <ID>NewLineAtEndOfFile:MockTransactionStorage.kt$net.corda.testing.node.internal.MockTransactionStorage.kt</ID>
    <ID>NewLineAtEndOfFile:ModeSelectingChannel.kt$net.corda.nodeapi.internal.protonwrapper.netty.ModeSelectingChannel.kt</ID>
    <ID>NewLineAtEndOfFile:ModelsUtils.kt$net.corda.client.jfx.model.ModelsUtils.kt</ID>
    <ID>NewLineAtEndOfFile:MonthDaySerializer.kt$net.corda.serialization.internal.amqp.custom.MonthDaySerializer.kt</ID>
    <ID>NewLineAtEndOfFile:MultiThreadedStateMachineExecutor.kt$net.corda.node.services.statemachine.MultiThreadedStateMachineExecutor.kt</ID>
    <ID>NewLineAtEndOfFile:MySQLLoadTestFlow.kt$net.corda.notarytest.flows.MySQLLoadTestFlow.kt</ID>
    <ID>NewLineAtEndOfFile:NamedCacheTest.kt$net.corda.core.internal.NamedCacheTest.kt</ID>
    <ID>NewLineAtEndOfFile:NettyEngineBasedTlsAuthenticationTests.kt$net.corda.node.utilities.NettyEngineBasedTlsAuthenticationTests.kt</ID>
    <ID>NewLineAtEndOfFile:NettyServerEventLogger.kt$net.corda.nodeapi.internal.protonwrapper.netty.NettyServerEventLogger.kt</ID>
    <ID>NewLineAtEndOfFile:NettyTestClient.kt$net.corda.testing.internal.NettyTestClient.kt</ID>
    <ID>NewLineAtEndOfFile:NettyTestHandler.kt$net.corda.testing.internal.NettyTestHandler.kt</ID>
    <ID>NewLineAtEndOfFile:NettyTestServer.kt$net.corda.testing.internal.NettyTestServer.kt</ID>
    <ID>NewLineAtEndOfFile:NettyWritable.kt$net.corda.nodeapi.internal.protonwrapper.engine.NettyWritable.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkBootstrapper.kt$net.corda.nodeapi.internal.network.NetworkBootstrapper.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkBootstrapperBackwardsCompatibilityTest.kt$net.corda.bootstrapper.NetworkBootstrapperBackwardsCompatibilityTest.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkBootstrapperRunnerTests.kt$net.corda.bootstrapper.NetworkBootstrapperRunnerTests.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkMap.kt$net.corda.nodeapi.internal.network.NetworkMap.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkMapHttpProxyTest.kt$net.corda.node.services.network.NetworkMapHttpProxyTest.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkMapServer.kt$net.corda.testing.node.internal.network.NetworkMapServer.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkMapSocksProxyTest.kt$net.corda.node.services.network.NetworkMapSocksProxyTest.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkMapUpdater.kt$net.corda.node.services.network.NetworkMapUpdater.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkParameterOverridesSpec.kt$net.corda.nodeapi.internal.network.NetworkParameterOverridesSpec.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkParametersReaderTest.kt$net.corda.node.services.network.NetworkParametersReaderTest.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkParametersResolutionTest.kt$net.corda.coretests.internal.NetworkParametersResolutionTest.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkProxy.kt$net.corda.node.utilities.NetworkProxy.kt</ID>
    <ID>NewLineAtEndOfFile:NetworkProxyTests.kt$net.corda.node.utilities.NetworkProxyTests.kt</ID>
    <ID>NewLineAtEndOfFile:NoOpTestDatabaseContext.kt$net.corda.testing.internal.db.NoOpTestDatabaseContext.kt</ID>
    <ID>NewLineAtEndOfFile:NodeAdder.kt$net.corda.networkbuilder.nodes.NodeAdder.kt</ID>
    <ID>NewLineAtEndOfFile:NodeAttachmentService.kt$net.corda.node.services.persistence.NodeAttachmentService.kt</ID>
    <ID>NewLineAtEndOfFile:NodeAttachmentTrustCalculator.kt$net.corda.node.services.attachments.NodeAttachmentTrustCalculator.kt</ID>
    <ID>NewLineAtEndOfFile:NodeBuildProperties.kt$net.corda.node.utilities.NodeBuildProperties.kt</ID>
    <ID>NewLineAtEndOfFile:NodeConfiguration.kt$net.corda.node.services.config.NodeConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:NodeConfigurationImpl.kt$net.corda.node.services.config.NodeConfigurationImpl.kt</ID>
    <ID>NewLineAtEndOfFile:NodeConnection.kt$net.corda.loadtest.NodeConnection.kt</ID>
    <ID>NewLineAtEndOfFile:NodeCopier.kt$net.corda.networkbuilder.nodes.NodeCopier.kt</ID>
    <ID>NewLineAtEndOfFile:NodeDiagnosticInfo.kt$net.corda.core.node.NodeDiagnosticInfo.kt</ID>
    <ID>NewLineAtEndOfFile:NodeFinder.kt$net.corda.networkbuilder.nodes.NodeFinder.kt</ID>
    <ID>NewLineAtEndOfFile:NodeFlowManagerTest.kt$net.corda.node.internal.NodeFlowManagerTest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeHandleTests.kt$net.corda.node.services.rpc.NodeHandleTests.kt</ID>
    <ID>NewLineAtEndOfFile:NodeInfoFilesCopierTest.kt$net.corda.nodeapi.internal.network.NodeInfoFilesCopierTest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeInstance.kt$net.corda.networkbuilder.nodes.NodeInstance.kt</ID>
    <ID>NewLineAtEndOfFile:NodeInstanceRequest.kt$net.corda.networkbuilder.nodes.NodeInstanceRequest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeInstantiator.kt$net.corda.networkbuilder.nodes.NodeInstantiator.kt</ID>
    <ID>NewLineAtEndOfFile:NodeJanitor.kt$net.corda.node.utilities.NodeJanitor.kt</ID>
    <ID>NewLineAtEndOfFile:NodeMonitorModel.kt$net.corda.client.jfx.model.NodeMonitorModel.kt</ID>
    <ID>NewLineAtEndOfFile:NodeNamedCache.kt$net.corda.node.utilities.NodeNamedCache.kt</ID>
    <ID>NewLineAtEndOfFile:NodePerformanceTests.kt$com.r3.corda.enterprise.perftestcordapp.NodePerformanceTests.kt</ID>
    <ID>NewLineAtEndOfFile:NodePropertiesStore.kt$net.corda.node.services.api.NodePropertiesStore.kt</ID>
    <ID>NewLineAtEndOfFile:NodePusher.kt$net.corda.networkbuilder.nodes.NodePusher.kt</ID>
    <ID>NewLineAtEndOfFile:NodeRPCTests.kt$net.corda.node.NodeRPCTests.kt</ID>
    <ID>NewLineAtEndOfFile:NodeRpcOptions.kt$net.corda.node.services.config.rpc.NodeRpcOptions.kt</ID>
    <ID>NewLineAtEndOfFile:NodeRpcSettings.kt$net.corda.demobench.model.NodeRpcSettings.kt</ID>
    <ID>NewLineAtEndOfFile:NodeStartupCliTest.kt$net.corda.node.internal.NodeStartupCliTest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeStartupCompatibilityTest.kt$net.corda.node.internal.NodeStartupCompatibilityTest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeStartupForWrappedKeysTest.kt$net.corda.node.services.keys.cryptoservice.NodeStartupForWrappedKeysTest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeStartupTest.kt$net.corda.node.internal.NodeStartupTest.kt</ID>
    <ID>NewLineAtEndOfFile:NodeStatePersistenceTests.kt$net.corda.node.persistence.NodeStatePersistenceTests.kt</ID>
    <ID>NewLineAtEndOfFile:NodeUniqueIdProvider.kt$net.corda.node.internal.NodeUniqueIdProvider.kt</ID>
    <ID>NewLineAtEndOfFile:NodeVaultServiceTest.kt$net.corda.node.services.vault.NodeVaultServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:NonInvalidatingCache.kt$net.corda.node.utilities.NonInvalidatingCache.kt</ID>
    <ID>NewLineAtEndOfFile:NonInvalidatingUnboundCache.kt$net.corda.node.utilities.NonInvalidatingUnboundCache.kt</ID>
    <ID>NewLineAtEndOfFile:NotSerializableExceptions.kt$net.corda.serialization.internal.NotSerializableExceptions.kt</ID>
    <ID>NewLineAtEndOfFile:Notarise.kt$net.corda.notarydemo.client.Notarise.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryChangeTests.kt$net.corda.node.services.NotaryChangeTests.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryCopier.kt$net.corda.networkbuilder.notaries.NotaryCopier.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryEntities.kt$net.corda.notary.experimental.NotaryEntities.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryExceptionSerializationTest.kt$net.corda.coretests.serialization.NotaryExceptionSerializationTest.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryFunctionalSamplers.kt$com.r3.corda.jmeter.NotaryFunctionalSamplers.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryLoader.kt$net.corda.node.utilities.NotaryLoader.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryRegistrationTool.kt$com.r3.ha.notaryregistration.NotaryRegistrationTool.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryService.kt$net.corda.core.internal.notary.NotaryService.kt</ID>
    <ID>NewLineAtEndOfFile:NotarySpec.kt$net.corda.testing.node.NotarySpec.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryTestContracts.kt$net.corda.verification.NotaryTestContracts.kt</ID>
    <ID>NewLineAtEndOfFile:NotaryWhitelistTests.kt$net.corda.node.services.transactions.NotaryWhitelistTests.kt</ID>
    <ID>NewLineAtEndOfFile:NullKeys.kt$net.corda.core.crypto.NullKeys.kt</ID>
    <ID>NewLineAtEndOfFile:ObjectBuilder.kt$net.corda.serialization.internal.amqp.ObjectBuilder.kt</ID>
    <ID>NewLineAtEndOfFile:ObjectDiffer.kt$net.corda.node.utilities.ObjectDiffer.kt</ID>
    <ID>NewLineAtEndOfFile:ObjectSerializer.kt$net.corda.serialization.internal.amqp.ObjectSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:ObligationUtils.kt$net.corda.finance.workflows.asset.ObligationUtils.kt</ID>
    <ID>NewLineAtEndOfFile:ObservableContextInterface.kt$net.corda.node.services.rpc.ObservableContextInterface.kt</ID>
    <ID>NewLineAtEndOfFile:ObservablesTests.kt$net.corda.node.utilities.ObservablesTests.kt</ID>
    <ID>NewLineAtEndOfFile:OffsetDateTimeSerializer.kt$net.corda.serialization.internal.amqp.custom.OffsetDateTimeSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:OffsetTimeSerializer.kt$net.corda.serialization.internal.amqp.custom.OffsetTimeSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:OpaqueBytesSubSequenceSerializer.kt$net.corda.serialization.internal.amqp.custom.OpaqueBytesSubSequenceSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:OptionalSerializationTests.kt$net.corda.serialization.internal.amqp.OptionalSerializationTests.kt</ID>
    <ID>NewLineAtEndOfFile:OptionalSerializer.kt$net.corda.serialization.internal.amqp.custom.OptionalSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:OracleNodeTearOffTests.kt$net.corda.irs.api.OracleNodeTearOffTests.kt</ID>
    <ID>NewLineAtEndOfFile:OverridePKSerializerTest.kt$net.corda.serialization.internal.amqp.OverridePKSerializerTest.kt</ID>
    <ID>NewLineAtEndOfFile:P2PFlowsDrainingModeTest.kt$net.corda.node.modes.draining.P2PFlowsDrainingModeTest.kt</ID>
    <ID>NewLineAtEndOfFile:P2PMQSecurityTest.kt$net.corda.services.messaging.P2PMQSecurityTest.kt</ID>
    <ID>NewLineAtEndOfFile:P2PMessageDeduplicatorTest.kt$net.corda.node.services.messaging.P2PMessageDeduplicatorTest.kt</ID>
    <ID>NewLineAtEndOfFile:PackageOwnershipVerificationTests.kt$net.corda.coretests.contracts.PackageOwnershipVerificationTests.kt</ID>
    <ID>NewLineAtEndOfFile:PartyTest.kt$net.corda.coretests.indentity.PartyTest.kt</ID>
    <ID>NewLineAtEndOfFile:Password.kt$net.corda.node.internal.security.Password.kt</ID>
    <ID>NewLineAtEndOfFile:PasswordTest.kt$net.corda.node.internal.security.PasswordTest.kt</ID>
    <ID>NewLineAtEndOfFile:PathUtilsTest.kt$net.corda.core.internal.PathUtilsTest.kt</ID>
    <ID>NewLineAtEndOfFile:PeriodSerializer.kt$net.corda.serialization.internal.amqp.custom.PeriodSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:PermissionException.kt$net.corda.client.rpc.PermissionException.kt</ID>
    <ID>NewLineAtEndOfFile:Permissions.kt$net.corda.node.services.Permissions.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentIdentityMigration.kt$net.corda.node.migration.PersistentIdentityMigration.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentIdentityMigrationNewTable.kt$net.corda.node.migration.PersistentIdentityMigrationNewTable.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentIdentityMigrationNewTableTest.kt$net.corda.node.migration.PersistentIdentityMigrationNewTableTest.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentIdentityService.kt$net.corda.node.services.identity.PersistentIdentityService.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentIdentityServiceTests.kt$net.corda.node.services.identity.PersistentIdentityServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentMapTests.kt$net.corda.node.utilities.PersistentMapTests.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentScheduledFlowRepository.kt$net.corda.node.services.events.PersistentScheduledFlowRepository.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentScheduledFlowRepositoryTest.kt$net.corda.node.services.events.PersistentScheduledFlowRepositoryTest.kt</ID>
    <ID>NewLineAtEndOfFile:PersistentStateServiceTests.kt$net.corda.node.services.schema.PersistentStateServiceTests.kt</ID>
    <ID>NewLineAtEndOfFile:PingPongFlow.kt$net.corda.bridge.PingPongFlow.kt</ID>
    <ID>NewLineAtEndOfFile:PortAllocationTest.kt$net.corda.testing.driver.PortAllocationTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrimusXCryptoService.kt$net.corda.nodeapi.internal.cryptoservice.securosys.PrimusXCryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:PrimusXCryptoServiceTest.kt$net.corda.nodeapi.internal.cryptoservice.securosys.PrimusXCryptoServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrimusXNodeRegistrationTest.kt$net.corda.node.services.keys.cryptoservice.securosys.PrimusXNodeRegistrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrimusXWrappedKeysTest.kt$net.corda.node.services.keys.cryptoservice.securosys.PrimusXWrappedKeysTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrioritizedLeaderLatch.kt$net.corda.nodeapi.internal.zookeeper.PrioritizedLeaderLatch.kt</ID>
    <ID>NewLineAtEndOfFile:PrioritizedLeaderLatchTest.kt$net.corda.nodeapi.internal.zookeeper.PrioritizedLeaderLatchTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrivacySaltTest.kt$net.corda.core.contracts.PrivacySaltTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrivacySaltTest.kt$net.corda.deterministic.contracts.PrivacySaltTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrivateKeySerializationTest.kt$net.corda.serialization.internal.PrivateKeySerializationTest.kt</ID>
    <ID>NewLineAtEndOfFile:PrivateKeySerializer.kt$net.corda.serialization.internal.amqp.custom.PrivateKeySerializer.kt</ID>
    <ID>NewLineAtEndOfFile:PrivatePropertyTests.kt$net.corda.serialization.internal.amqp.PrivatePropertyTests.kt</ID>
    <ID>NewLineAtEndOfFile:ProcessUtilities.kt$net.corda.testing.node.internal.ProcessUtilities.kt</ID>
    <ID>NewLineAtEndOfFile:ProcessUtilitiesTests.kt$net.corda.testing.node.internal.ProcessUtilitiesTests.kt</ID>
    <ID>NewLineAtEndOfFile:Program.kt$net.corda.healthsurvey.Program.kt</ID>
    <ID>NewLineAtEndOfFile:ProgressTracker.kt$net.corda.core.internal.ProgressTracker.kt</ID>
    <ID>NewLineAtEndOfFile:Properties.kt$net.corda.common.configuration.parsing.internal.Properties.kt</ID>
    <ID>NewLineAtEndOfFile:PropertyTest.kt$net.corda.common.configuration.parsing.internal.PropertyTest.kt</ID>
    <ID>NewLineAtEndOfFile:PropertyValidationTest.kt$net.corda.common.configuration.parsing.internal.PropertyValidationTest.kt</ID>
    <ID>NewLineAtEndOfFile:ProxyUtils.kt$net.corda.nodeapi.internal.proxy.ProxyUtils.kt</ID>
    <ID>NewLineAtEndOfFile:PublicKeyHashToExternalId.kt$net.corda.node.services.persistence.PublicKeyHashToExternalId.kt</ID>
    <ID>NewLineAtEndOfFile:PublicKeySerializer.kt$net.corda.serialization.internal.amqp.custom.PublicKeySerializer.kt</ID>
    <ID>NewLineAtEndOfFile:PublicKeyToOwningIdentityCache.kt$net.corda.nodeapi.internal.PublicKeyToOwningIdentityCache.kt</ID>
    <ID>NewLineAtEndOfFile:PublicKeyToOwningIdentityCacheImpl.kt$net.corda.node.services.persistence.PublicKeyToOwningIdentityCacheImpl.kt</ID>
    <ID>NewLineAtEndOfFile:PublicKeyToOwningIdentityCacheImplTest.kt$net.corda.node.services.persistence.PublicKeyToOwningIdentityCacheImplTest.kt</ID>
    <ID>NewLineAtEndOfFile:PublicKeyToTextConverter.kt$net.corda.node.services.persistence.PublicKeyToTextConverter.kt</ID>
    <ID>NewLineAtEndOfFile:PushedNode.kt$net.corda.networkbuilder.nodes.PushedNode.kt</ID>
    <ID>NewLineAtEndOfFile:QueryCriteriaUtils.kt$net.corda.core.node.services.vault.QueryCriteriaUtils.kt</ID>
    <ID>NewLineAtEndOfFile:RPCApi.kt$net.corda.nodeapi.RPCApi.kt</ID>
    <ID>NewLineAtEndOfFile:RPCConcurrencyTests.kt$net.corda.client.rpc.RPCConcurrencyTests.kt</ID>
    <ID>NewLineAtEndOfFile:RPCConnection.kt$net.corda.client.rpc.RPCConnection.kt</ID>
    <ID>NewLineAtEndOfFile:RPCException.kt$net.corda.client.rpc.RPCException.kt</ID>
    <ID>NewLineAtEndOfFile:RPCMQSecurityTest.kt$net.corda.services.messaging.RPCMQSecurityTest.kt</ID>
    <ID>NewLineAtEndOfFile:RPCOps.kt$net.corda.core.messaging.RPCOps.kt</ID>
    <ID>NewLineAtEndOfFile:RPCOpsRouting.kt$net.corda.node.services.rpc.RPCOpsRouting.kt</ID>
    <ID>NewLineAtEndOfFile:RPCProxyServer.kt$net.corda.behave.service.proxy.RPCProxyServer.kt</ID>
    <ID>NewLineAtEndOfFile:RPCProxyServerTest.kt$net.corda.behave.service.proxy.RPCProxyServerTest.kt</ID>
    <ID>NewLineAtEndOfFile:RPCProxyWebServiceTest.kt$net.corda.behave.service.proxy.RPCProxyWebServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:RPCReturnsObservables.kt$net.corda.core.messaging.RPCReturnsObservables.kt</ID>
    <ID>NewLineAtEndOfFile:RPCSecurityManagerImpl.kt$net.corda.node.internal.security.RPCSecurityManagerImpl.kt</ID>
    <ID>NewLineAtEndOfFile:RPCSecurityManagerTest.kt$net.corda.node.services.RPCSecurityManagerTest.kt</ID>
    <ID>NewLineAtEndOfFile:RPCStabilityTests.kt$net.corda.client.rpc.RPCStabilityTests.kt</ID>
    <ID>NewLineAtEndOfFile:RaftConfig.kt$net.corda.notary.experimental.raft.RaftConfig.kt</ID>
    <ID>NewLineAtEndOfFile:RaftTransactionCommitLog.kt$net.corda.notary.experimental.raft.RaftTransactionCommitLog.kt</ID>
    <ID>NewLineAtEndOfFile:RaftTransactionCommitLogTests.kt$net.corda.notary.experimental.raft.RaftTransactionCommitLogTests.kt</ID>
    <ID>NewLineAtEndOfFile:RandomFailingProxy.kt$net.corda.node.services.rpc.RandomFailingProxy.kt</ID>
    <ID>NewLineAtEndOfFile:ReactiveArtemisConsumer.kt$net.corda.node.internal.artemis.ReactiveArtemisConsumer.kt</ID>
    <ID>NewLineAtEndOfFile:ReceiveAllFlowTests.kt$net.corda.coretests.flows.ReceiveAllFlowTests.kt</ID>
    <ID>NewLineAtEndOfFile:ReceivedMessage.kt$net.corda.nodeapi.internal.protonwrapper.messages.ReceivedMessage.kt</ID>
    <ID>NewLineAtEndOfFile:ReceivedMessageImpl.kt$net.corda.nodeapi.internal.protonwrapper.messages.impl.ReceivedMessageImpl.kt</ID>
    <ID>NewLineAtEndOfFile:ReconnectingObservable.kt$net.corda.client.rpc.internal.ReconnectingObservable.kt</ID>
    <ID>NewLineAtEndOfFile:ReferenceInputStateTests.kt$net.corda.coretests.transactions.ReferenceInputStateTests.kt</ID>
    <ID>NewLineAtEndOfFile:RegistrationServer.kt$com.r3.ha.utilities.RegistrationServer.kt</ID>
    <ID>NewLineAtEndOfFile:RegistrationTool.kt$com.r3.ha.utilities.RegistrationTool.kt</ID>
    <ID>NewLineAtEndOfFile:RegistrationToolTest.kt$com.r3.ha.utilities.RegistrationToolTest.kt</ID>
    <ID>NewLineAtEndOfFile:ReleaseLockCli.kt$com.r3.corda.dbmigration.ReleaseLockCli.kt</ID>
    <ID>NewLineAtEndOfFile:RemoteSerializerFactory.kt$net.corda.serialization.internal.amqp.RemoteSerializerFactory.kt</ID>
    <ID>NewLineAtEndOfFile:RemoteTypeCarpenter.kt$net.corda.serialization.internal.model.RemoteTypeCarpenter.kt</ID>
    <ID>NewLineAtEndOfFile:RepeatingBytesInputStream.kt$net.corda.client.rpc.RepeatingBytesInputStream.kt</ID>
    <ID>NewLineAtEndOfFile:Report.kt$net.corda.healthsurvey.output.Report.kt</ID>
    <ID>NewLineAtEndOfFile:RequestResponseServiceHelper.kt$net.corda.bridge.services.receiver.RequestResponseServiceHelper.kt</ID>
    <ID>NewLineAtEndOfFile:RequiresDb.kt$net.corda.testing.internal.db.RequiresDb.kt</ID>
    <ID>NewLineAtEndOfFile:ResolveStatePointersTest.kt$net.corda.node.services.transactions.ResolveStatePointersTest.kt</ID>
    <ID>NewLineAtEndOfFile:RestrictedEntityManager.kt$net.corda.nodeapi.internal.persistence.RestrictedEntityManager.kt</ID>
    <ID>NewLineAtEndOfFile:RevocationConfig.kt$net.corda.nodeapi.internal.protonwrapper.netty.RevocationConfig.kt</ID>
    <ID>NewLineAtEndOfFile:RolesAdderOnLogin.kt$net.corda.node.services.rpc.RolesAdderOnLogin.kt</ID>
    <ID>NewLineAtEndOfFile:RpcBrokerConfiguration.kt$net.corda.node.services.rpc.RpcBrokerConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:RpcClientCordaFutureSerializer.kt$net.corda.client.rpc.internal.serialization.amqp.RpcClientCordaFutureSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:RpcClientObservableDeSerializer.kt$net.corda.client.rpc.internal.serialization.amqp.RpcClientObservableDeSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:RpcExceptions.kt$net.corda.nodeapi.exceptions.RpcExceptions.kt</ID>
    <ID>NewLineAtEndOfFile:RpcFlowWorkerDriver.kt$net.corda.rpcWorker.RpcFlowWorkerDriver.kt</ID>
    <ID>NewLineAtEndOfFile:RpcHelper.kt$net.corda.haTesting.RpcHelper.kt</ID>
    <ID>NewLineAtEndOfFile:RpcHelpers.kt$net.corda.nodeapi.internal.RpcHelpers.kt</ID>
    <ID>NewLineAtEndOfFile:RpcInfo.kt$net.corda.RpcInfo.kt</ID>
    <ID>NewLineAtEndOfFile:RpcMatchers.kt$net.corda.testing.internal.matchers.rpc.RpcMatchers.kt</ID>
    <ID>NewLineAtEndOfFile:RpcServerObservableSerializer.kt$net.corda.node.serialization.amqp.RpcServerObservableSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:RpcServerObservableSerializerTests.kt$net.corda.node.internal.serialization.RpcServerObservableSerializerTests.kt</ID>
    <ID>NewLineAtEndOfFile:RpcSslTest.kt$net.corda.node.services.rpc.RpcSslTest.kt</ID>
    <ID>NewLineAtEndOfFile:RpcWorker.kt$net.corda.rpcWorker.RpcWorker.kt</ID>
    <ID>NewLineAtEndOfFile:RpcWorkerMultiIdentityTest.kt$net.corda.rpcWorker.RpcWorkerMultiIdentityTest.kt</ID>
    <ID>NewLineAtEndOfFile:RpcWorkerPaidTest.kt$net.corda.rpcWorker.RpcWorkerPaidTest.kt</ID>
    <ID>NewLineAtEndOfFile:RpcWorkerStartStopTest.kt$net.corda.rpcWorker.RpcWorkerStartStopTest.kt</ID>
    <ID>NewLineAtEndOfFile:RpcWorkerTest.kt$net.corda.rpcWorker.RpcWorkerTest.kt</ID>
    <ID>NewLineAtEndOfFile:RxNotificationSerializer.kt$net.corda.serialization.internal.amqp.custom.RxNotificationSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:SNIBridgeTest.kt$net.corda.bridge.SNIBridgeTest.kt</ID>
    <ID>NewLineAtEndOfFile:SSHDConfiguration.kt$net.corda.tools.shell.SSHDConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:SSLHelperTest.kt$net.corda.nodeapi.internal.protonwrapper.netty.SSLHelperTest.kt</ID>
    <ID>NewLineAtEndOfFile:Samplers.kt$com.r3.corda.jmeter.Samplers.kt</ID>
    <ID>NewLineAtEndOfFile:SchedulableFlow.kt$net.corda.core.flows.SchedulableFlow.kt</ID>
    <ID>NewLineAtEndOfFile:ScheduledCheckFlow.kt$net.corda.notaryhealthcheck.cordapp.ScheduledCheckFlow.kt</ID>
    <ID>NewLineAtEndOfFile:SchedulerService.kt$net.corda.node.services.api.SchedulerService.kt</ID>
    <ID>NewLineAtEndOfFile:SchedulingContract.kt$net.corda.notaryhealthcheck.cordapp.SchedulingContract.kt</ID>
    <ID>NewLineAtEndOfFile:Schema.kt$net.corda.common.configuration.parsing.internal.Schema.kt</ID>
    <ID>NewLineAtEndOfFile:Schema.kt$net.corda.notary.experimental.bftsmart.Schema.kt</ID>
    <ID>NewLineAtEndOfFile:Schema.kt$net.corda.notary.experimental.raft.Schema.kt</ID>
    <ID>NewLineAtEndOfFile:SchemaMigrationTest.kt$net.corda.nodeapi.internal.persistence.SchemaMigrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:SchemaTest.kt$net.corda.common.configuration.parsing.internal.SchemaTest.kt</ID>
    <ID>NewLineAtEndOfFile:SearchField.kt$net.corda.explorer.views.SearchField.kt</ID>
    <ID>NewLineAtEndOfFile:SecureArtemisConfiguration.kt$net.corda.node.internal.artemis.SecureArtemisConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:SecureHashTest.kt$net.corda.deterministic.crypto.SecureHashTest.kt</ID>
    <ID>NewLineAtEndOfFile:SecureRandomTest.kt$net.corda.deterministic.crypto.SecureRandomTest.kt</ID>
    <ID>NewLineAtEndOfFile:SendableMessage.kt$net.corda.nodeapi.internal.protonwrapper.messages.SendableMessage.kt</ID>
    <ID>NewLineAtEndOfFile:SendableMessageImpl.kt$net.corda.nodeapi.internal.protonwrapper.messages.impl.SendableMessageImpl.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationAnnotations.kt$net.corda.core.serialization.SerializationAnnotations.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationPropertyOrdering.kt$net.corda.serialization.internal.amqp.SerializationPropertyOrdering.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationSchemaTests.kt$net.corda.serialization.internal.amqp.SerializationSchemaTests.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationSupport.kt$net.corda.tools.shell.SerializationSupport.kt</ID>
    <ID>NewLineAtEndOfFile:SerializationWhitelist.kt$net.corda.core.serialization.SerializationWhitelist.kt</ID>
    <ID>NewLineAtEndOfFile:SerializeAsTokenContextImpl.kt$net.corda.serialization.internal.SerializeAsTokenContextImpl.kt</ID>
    <ID>NewLineAtEndOfFile:SerializeAsTokenSerializer.kt$net.corda.node.serialization.kryo.SerializeAsTokenSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:SerializerFactory.kt$net.corda.serialization.internal.amqp.SerializerFactory.kt</ID>
    <ID>NewLineAtEndOfFile:SerializerFactoryBuilder.kt$net.corda.serialization.internal.amqp.SerializerFactoryBuilder.kt</ID>
    <ID>NewLineAtEndOfFile:ServiceHubCoreInternal.kt$net.corda.core.internal.ServiceHubCoreInternal.kt</ID>
    <ID>NewLineAtEndOfFile:ServiceLifecycleSupport.kt$net.corda.nodeapi.internal.lifecycle.ServiceLifecycleSupport.kt</ID>
    <ID>NewLineAtEndOfFile:ServiceStateHelper.kt$net.corda.nodeapi.internal.lifecycle.ServiceStateHelper.kt</ID>
    <ID>NewLineAtEndOfFile:ServiceStateTest.kt$net.corda.bridge.ServiceStateTest.kt</ID>
    <ID>NewLineAtEndOfFile:Settings.kt$net.corda.explorer.views.Settings.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsModel.kt$net.corda.explorer.model.SettingsModel.kt</ID>
    <ID>NewLineAtEndOfFile:SettingsModelTest.kt$net.corda.explorer.model.SettingsModelTest.kt</ID>
    <ID>NewLineAtEndOfFile:SharedMemoryIncremental.kt$net.corda.testing.driver.internal.SharedMemoryIncremental.kt</ID>
    <ID>NewLineAtEndOfFile:ShutdownManager.kt$net.corda.testing.node.internal.ShutdownManager.kt</ID>
    <ID>NewLineAtEndOfFile:SignatureConstraintMigrationFromHashConstraintsTests.kt$net.corda.contracts.SignatureConstraintMigrationFromHashConstraintsTests.kt</ID>
    <ID>NewLineAtEndOfFile:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$net.corda.contracts.SignatureConstraintMigrationFromWhitelistConstraintTests.kt</ID>
    <ID>NewLineAtEndOfFile:SignatureConstraintVersioningTests.kt$net.corda.contracts.SignatureConstraintVersioningTests.kt</ID>
    <ID>NewLineAtEndOfFile:SimpleMessageFilterService.kt$net.corda.bridge.services.filter.SimpleMessageFilterService.kt</ID>
    <ID>NewLineAtEndOfFile:SimpleStringSerializer.kt$net.corda.serialization.internal.amqp.custom.SimpleStringSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:SingleInstanceMasterService.kt$net.corda.bridge.services.ha.SingleInstanceMasterService.kt</ID>
    <ID>NewLineAtEndOfFile:SingletonSerializer.kt$net.corda.serialization.internal.amqp.SingletonSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:Specification.kt$net.corda.common.configuration.parsing.internal.Specification.kt</ID>
    <ID>NewLineAtEndOfFile:SpecificationTest.kt$net.corda.common.configuration.parsing.internal.SpecificationTest.kt</ID>
    <ID>NewLineAtEndOfFile:Ssh.kt$com.r3.corda.jmeter.Ssh.kt</ID>
    <ID>NewLineAtEndOfFile:SslConfiguration.kt$net.corda.nodeapi.internal.config.SslConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:StaffedFlowHospital.kt$net.corda.node.services.statemachine.StaffedFlowHospital.kt</ID>
    <ID>NewLineAtEndOfFile:StandaloneJPANotaryService.kt$net.corda.notary.standalonejpa.StandaloneJPANotaryService.kt</ID>
    <ID>NewLineAtEndOfFile:StandaloneJPAUniquenessProviderTests.kt$net.corda.notary.standalonejpa.StandaloneJPAUniquenessProviderTests.kt</ID>
    <ID>NewLineAtEndOfFile:StandaloneShellArgsParserTest.kt$net.corda.tools.shell.StandaloneShellArgsParserTest.kt</ID>
    <ID>NewLineAtEndOfFile:StandardConfigValueParsers.kt$net.corda.node.services.config.schema.parsers.StandardConfigValueParsers.kt</ID>
    <ID>NewLineAtEndOfFile:StartLocalPerfCorDapp.kt$com.r3.corda.jmeter.StartLocalPerfCorDapp.kt</ID>
    <ID>NewLineAtEndOfFile:StartableByRPC.kt$net.corda.core.flows.StartableByRPC.kt</ID>
    <ID>NewLineAtEndOfFile:StartableByService.kt$net.corda.core.flows.StartableByService.kt</ID>
    <ID>NewLineAtEndOfFile:StateHandlingFlows.kt$net.corda.notaryhealthcheck.cordapp.StateHandlingFlows.kt</ID>
    <ID>NewLineAtEndOfFile:StateMachineRunId.kt$net.corda.core.flows.StateMachineRunId.kt</ID>
    <ID>NewLineAtEndOfFile:StateMachineRunIdTest.kt$net.corda.client.jackson.StateMachineRunIdTest.kt</ID>
    <ID>NewLineAtEndOfFile:StateMachineState.kt$net.corda.node.services.statemachine.StateMachineState.kt</ID>
    <ID>NewLineAtEndOfFile:StatePointer.kt$net.corda.core.contracts.StatePointer.kt</ID>
    <ID>NewLineAtEndOfFile:StatePointerSearch.kt$net.corda.core.internal.StatePointerSearch.kt</ID>
    <ID>NewLineAtEndOfFile:StatePointerSearchTests.kt$net.corda.core.internal.StatePointerSearchTests.kt</ID>
    <ID>NewLineAtEndOfFile:StaticInitialisationOfSerializedObjectTest.kt$net.corda.serialization.internal.amqp.StaticInitialisationOfSerializedObjectTest.kt</ID>
    <ID>NewLineAtEndOfFile:StatusTransitions.kt$io.cryptoblk.core.StatusTransitions.kt</ID>
    <ID>NewLineAtEndOfFile:StatusTransitionsTest.kt$io.cryptoblk.core.StatusTransitionsTest.kt</ID>
    <ID>NewLineAtEndOfFile:StreamTests.kt$net.corda.serialization.internal.amqp.StreamTests.kt</ID>
    <ID>NewLineAtEndOfFile:StringBufferSerializer.kt$net.corda.serialization.internal.amqp.custom.StringBufferSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:StructuresTests.kt$net.corda.core.contracts.StructuresTests.kt</ID>
    <ID>NewLineAtEndOfFile:SwapIdentitiesFlow.kt$net.corda.confidential.SwapIdentitiesFlow.kt</ID>
    <ID>NewLineAtEndOfFile:SystematicTerminationTest.kt$net.corda.instrumentation.byteman.SystematicTerminationTest.kt</ID>
    <ID>NewLineAtEndOfFile:TLSAuthenticationTests.kt$net.corda.node.utilities.TLSAuthenticationTests.kt</ID>
    <ID>NewLineAtEndOfFile:TLSSigningService.kt$net.corda.nodeapi.internal.cryptoservice.TLSSigningService.kt</ID>
    <ID>NewLineAtEndOfFile:TagExtractor.kt$com.r3.corda.tracelog.TagExtractor.kt</ID>
    <ID>NewLineAtEndOfFile:TargetVersionDependentRules.kt$net.corda.core.internal.rules.TargetVersionDependentRules.kt</ID>
    <ID>NewLineAtEndOfFile:TendermintAdapter.kt$net.corda.tools.benchmark.adapters.tendermint.TendermintAdapter.kt</ID>
    <ID>NewLineAtEndOfFile:TendermintClient.kt$net.corda.tools.benchmark.adapters.tendermint.TendermintClient.kt</ID>
    <ID>NewLineAtEndOfFile:TestAnnotations.kt$net.corda.testing.internal.db.TestAnnotations.kt</ID>
    <ID>NewLineAtEndOfFile:TestAuditService.kt$net.corda.bridge.services.TestAuditService.kt</ID>
    <ID>NewLineAtEndOfFile:TestCheckScheduleManagementFlow.kt$net.corda.notaryhealthcheck.cordapp.TestCheckScheduleManagementFlow.kt</ID>
    <ID>NewLineAtEndOfFile:TestCommandLine.kt$com.r3.corda.jmeter.TestCommandLine.kt</ID>
    <ID>NewLineAtEndOfFile:TestCommsFlowInitiatorTest.kt$net.corda.configsample.TestCommsFlowInitiatorTest.kt</ID>
    <ID>NewLineAtEndOfFile:TestConfig.kt$net.corda.notaryhealthcheck.client.TestConfig.kt</ID>
    <ID>NewLineAtEndOfFile:TestDatabaseContext.kt$net.corda.testing.internal.db.TestDatabaseContext.kt</ID>
    <ID>NewLineAtEndOfFile:TestHelpers.kt$net.corda.notaryhealthcheck.utils.TestHelpers.kt</ID>
    <ID>NewLineAtEndOfFile:TestKeyManagerFactoryWrapper.kt$net.corda.nodeapi.internal.protonwrapper.netty.TestKeyManagerFactoryWrapper.kt</ID>
    <ID>NewLineAtEndOfFile:TestNettyTestInfra.kt$net.corda.testing.internal.TestNettyTestInfra.kt</ID>
    <ID>NewLineAtEndOfFile:TestNoSecurityDataVendingFlow.kt$net.corda.coretests.flows.TestNoSecurityDataVendingFlow.kt</ID>
    <ID>NewLineAtEndOfFile:TestObservableContext.kt$net.corda.node.internal.serialization.testutils.TestObservableContext.kt</ID>
    <ID>NewLineAtEndOfFile:TestScheduleCheckFlow.kt$net.corda.notaryhealthcheck.cordapp.TestScheduleCheckFlow.kt</ID>
    <ID>NewLineAtEndOfFile:TestSerializationContext.kt$net.corda.serialization.internal.amqp.testutils.TestSerializationContext.kt</ID>
    <ID>NewLineAtEndOfFile:TestServiceBase.kt$net.corda.bridge.services.TestServiceBase.kt</ID>
    <ID>NewLineAtEndOfFile:TestTrustManagerFactoryWrapper.kt$net.corda.nodeapi.internal.protonwrapper.netty.TestTrustManagerFactoryWrapper.kt</ID>
    <ID>NewLineAtEndOfFile:TestUtils.kt$net.corda.common.configuration.parsing.internal.TestUtils.kt</ID>
    <ID>NewLineAtEndOfFile:TestingNamedCacheFactory.kt$net.corda.testing.internal.TestingNamedCacheFactory.kt</ID>
    <ID>NewLineAtEndOfFile:Tests.kt$com.r3.corda.tracelog.Tests.kt</ID>
    <ID>NewLineAtEndOfFile:ThreadContextAdjustingRpcOpsProxy.kt$net.corda.node.internal.rpc.proxies.ThreadContextAdjustingRpcOpsProxy.kt</ID>
    <ID>NewLineAtEndOfFile:ThreadContextAdjustingRpcOpsProxyTest.kt$net.corda.node.internal.rpc.proxies.ThreadContextAdjustingRpcOpsProxyTest.kt</ID>
    <ID>NewLineAtEndOfFile:TimeWindow.kt$net.corda.core.contracts.TimeWindow.kt</ID>
    <ID>NewLineAtEndOfFile:TimedFlowUtils.kt$net.corda.node.utilities.TimedFlowUtils.kt</ID>
    <ID>NewLineAtEndOfFile:TimingUtils.kt$net.corda.core.internal.utilities.TimingUtils.kt</ID>
    <ID>NewLineAtEndOfFile:TlsDiffAlgorithmsTest.kt$net.corda.nodeapi.internal.crypto.TlsDiffAlgorithmsTest.kt</ID>
    <ID>NewLineAtEndOfFile:TlsDiffProtocolsTest.kt$net.corda.nodeapi.internal.crypto.TlsDiffProtocolsTest.kt</ID>
    <ID>NewLineAtEndOfFile:ToggleField.kt$net.corda.core.internal.ToggleField.kt</ID>
    <ID>NewLineAtEndOfFile:TopLevelTransition.kt$net.corda.node.services.statemachine.transitions.TopLevelTransition.kt</ID>
    <ID>NewLineAtEndOfFile:Trace.kt$net.corda.core.context.Trace.kt</ID>
    <ID>NewLineAtEndOfFile:TracingCacheWrapper.kt$net.corda.core.internal.profiling.TracingCacheWrapper.kt</ID>
    <ID>NewLineAtEndOfFile:Trackable.kt$net.corda.healthsurvey.tracking.Trackable.kt</ID>
    <ID>NewLineAtEndOfFile:TrackedDelegate.kt$net.corda.client.jfx.model.TrackedDelegate.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionCallbackTest.kt$net.corda.node.services.persistence.TransactionCallbackTest.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionGenerator.kt$net.corda.deterministic.data.TransactionGenerator.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionStorage.kt$net.corda.core.node.services.TransactionStorage.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionVerificationExceptionSerialisationTests.kt$net.corda.coretests.contracts.TransactionVerificationExceptionSerialisationTests.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionVerifierService.kt$net.corda.core.node.services.TransactionVerifierService.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionWithSignatures.kt$net.corda.core.transactions.TransactionWithSignatures.kt</ID>
    <ID>NewLineAtEndOfFile:TransactionWithSignaturesTest.kt$net.corda.deterministic.transactions.TransactionWithSignaturesTest.kt</ID>
    <ID>NewLineAtEndOfFile:TrustManagerFactoryWrapper.kt$net.corda.nodeapi.internal.protonwrapper.netty.TrustManagerFactoryWrapper.kt</ID>
    <ID>NewLineAtEndOfFile:TunnelControlMessages.kt$net.corda.bridge.services.receiver.TunnelControlMessages.kt</ID>
    <ID>NewLineAtEndOfFile:TunnelControlTest.kt$net.corda.bridge.services.TunnelControlTest.kt</ID>
    <ID>NewLineAtEndOfFile:TunnelExternalCrlSourceService.kt$net.corda.bridge.services.receiver.TunnelExternalCrlSourceService.kt</ID>
    <ID>NewLineAtEndOfFile:TunnelingBridgeReceiverService.kt$net.corda.bridge.services.receiver.TunnelingBridgeReceiverService.kt</ID>
    <ID>NewLineAtEndOfFile:TutorialContract.kt$net.corda.docs.kotlin.tutorial.contract.TutorialContract.kt</ID>
    <ID>NewLineAtEndOfFile:TutorialFlowStateMachines.kt$net.corda.docs.kotlin.tutorial.flowstatemachines.TutorialFlowStateMachines.kt</ID>
    <ID>NewLineAtEndOfFile:TypeIdentifier.kt$net.corda.serialization.internal.model.TypeIdentifier.kt</ID>
    <ID>NewLineAtEndOfFile:TypeIdentifierTests.kt$net.corda.serialization.internal.model.TypeIdentifierTests.kt</ID>
    <ID>NewLineAtEndOfFile:TypeModellingFingerPrinterTests.kt$net.corda.serialization.internal.amqp.TypeModellingFingerPrinterTests.kt</ID>
    <ID>NewLineAtEndOfFile:TypeNotationGenerator.kt$net.corda.serialization.internal.amqp.TypeNotationGenerator.kt</ID>
    <ID>NewLineAtEndOfFile:TypesafeCordappConfig.kt$net.corda.node.internal.cordapp.TypesafeCordappConfig.kt</ID>
    <ID>NewLineAtEndOfFile:TypesafeCordappConfigTests.kt$net.corda.node.internal.cordapp.TypesafeCordappConfigTests.kt</ID>
    <ID>NewLineAtEndOfFile:UniqueDummyFungibleContract.kt$net.corda.testing.internal.vault.UniqueDummyFungibleContract.kt</ID>
    <ID>NewLineAtEndOfFile:UniqueDummyLinearContract.kt$net.corda.testing.internal.vault.UniqueDummyLinearContract.kt</ID>
    <ID>NewLineAtEndOfFile:UniqueIdentifier.kt$net.corda.core.contracts.UniqueIdentifier.kt</ID>
    <ID>NewLineAtEndOfFile:UniqueIdentifierTest.kt$net.corda.deterministic.contracts.UniqueIdentifierTest.kt</ID>
    <ID>NewLineAtEndOfFile:UniquenessProviderTests.kt$net.corda.node.services.transactions.UniquenessProviderTests.kt</ID>
    <ID>NewLineAtEndOfFile:UnspentStatesCache.kt$net.corda.node.services.transactions.UnspentStatesCache.kt</ID>
    <ID>NewLineAtEndOfFile:UnspentStatesCacheTests.kt$net.corda.node.services.transactions.UnspentStatesCacheTests.kt</ID>
    <ID>NewLineAtEndOfFile:UpdateBusinessDayFlow.kt$net.corda.irs.flows.UpdateBusinessDayFlow.kt</ID>
    <ID>NewLineAtEndOfFile:User.kt$net.corda.testing.node.User.kt</ID>
    <ID>NewLineAtEndOfFile:Utils.kt$io.cryptoblk.core.Utils.kt</ID>
    <ID>NewLineAtEndOfFile:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>NewLineAtEndOfFile:Utils.kt$net.corda.node.internal.classloading.Utils.kt</ID>
    <ID>NewLineAtEndOfFile:Utils.kt$net.corda.node.services.keys.cryptoservice.utimaco.Utils.kt</ID>
    <ID>NewLineAtEndOfFile:UtilsTest.kt$net.corda.common.configuration.parsing.internal.UtilsTest.kt</ID>
    <ID>NewLineAtEndOfFile:UtimacoCryptoService.kt$net.corda.nodeapi.internal.cryptoservice.utimaco.UtimacoCryptoService.kt</ID>
    <ID>NewLineAtEndOfFile:UtimacoCryptoServiceIntegrationTest.kt$net.corda.node.services.keys.cryptoservice.utimaco.UtimacoCryptoServiceIntegrationTest.kt</ID>
    <ID>NewLineAtEndOfFile:UtimacoCryptoServiceTest.kt$net.corda.nodeapi.internal.cryptoservice.utimaco.UtimacoCryptoServiceTest.kt</ID>
    <ID>NewLineAtEndOfFile:UuidGenerator.kt$net.corda.core.utilities.UuidGenerator.kt</ID>
    <ID>NewLineAtEndOfFile:V1NodeConfigurationSpec.kt$net.corda.node.services.config.schema.v1.V1NodeConfigurationSpec.kt</ID>
    <ID>NewLineAtEndOfFile:Validated.kt$net.corda.common.validation.internal.Validated.kt</ID>
    <ID>NewLineAtEndOfFile:Validator.kt$net.corda.common.validation.internal.Validator.kt</ID>
    <ID>NewLineAtEndOfFile:VaultEnumTypesTest.kt$net.corda.core.node.services.VaultEnumTypesTest.kt</ID>
    <ID>NewLineAtEndOfFile:VaultService.kt$net.corda.core.node.services.VaultService.kt</ID>
    <ID>NewLineAtEndOfFile:VaultStateMigration.kt$net.corda.node.migration.VaultStateMigration.kt</ID>
    <ID>NewLineAtEndOfFile:VersionExtractor.kt$net.corda.common.configuration.parsing.internal.versioned.VersionExtractor.kt</ID>
    <ID>NewLineAtEndOfFile:VersionExtractorTest.kt$net.corda.common.configuration.parsing.internal.versioned.VersionExtractorTest.kt</ID>
    <ID>NewLineAtEndOfFile:VersionInfo.kt$net.corda.node.VersionInfo.kt</ID>
    <ID>NewLineAtEndOfFile:VersionedParsingExampleTest.kt$net.corda.common.configuration.parsing.internal.versioned.VersionedParsingExampleTest.kt</ID>
    <ID>NewLineAtEndOfFile:VersionedSpecificationRegistry.kt$net.corda.common.configuration.parsing.internal.versioned.VersionedSpecificationRegistry.kt</ID>
    <ID>NewLineAtEndOfFile:VirtualCordapps.kt$net.corda.node.internal.cordapp.VirtualCordapps.kt</ID>
    <ID>NewLineAtEndOfFile:Volume.kt$net.corda.networkbuilder.volumes.Volume.kt</ID>
    <ID>NewLineAtEndOfFile:WebServer.kt$net.corda.webserver.WebServer.kt</ID>
    <ID>NewLineAtEndOfFile:WebServerPluginRegistry.kt$net.corda.webserver.services.WebServerPluginRegistry.kt</ID>
    <ID>NewLineAtEndOfFile:Whitelist.kt$com.r3.corda.enterprise.perftestcordapp.Whitelist.kt</ID>
    <ID>NewLineAtEndOfFile:WhitelistBasedTypeModelConfiguration.kt$net.corda.serialization.internal.amqp.WhitelistBasedTypeModelConfiguration.kt</ID>
    <ID>NewLineAtEndOfFile:WithContracts.kt$net.corda.coretests.flows.WithContracts.kt</ID>
    <ID>NewLineAtEndOfFile:WithMockNet.kt$net.corda.coretests.flows.WithMockNet.kt</ID>
    <ID>NewLineAtEndOfFile:WritablePublicKeyToOwningIdentityCache.kt$net.corda.node.services.persistence.WritablePublicKeyToOwningIdentityCache.kt</ID>
    <ID>NewLineAtEndOfFile:X509EdDSAEngineTest.kt$net.corda.core.internal.X509EdDSAEngineTest.kt</ID>
    <ID>NewLineAtEndOfFile:YearMonthSerializer.kt$net.corda.serialization.internal.amqp.custom.YearMonthSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:YearSerializer.kt$net.corda.serialization.internal.amqp.custom.YearSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:ZkClient.kt$net.corda.nodeapi.internal.zookeeper.ZkClient.kt</ID>
    <ID>NewLineAtEndOfFile:ZkClientTest.kt$net.corda.nodeapi.internal.zookeeper.ZkClientTest.kt</ID>
    <ID>NewLineAtEndOfFile:ZkLeader.kt$net.corda.nodeapi.internal.zookeeper.ZkLeader.kt</ID>
    <ID>NewLineAtEndOfFile:ZoneIdSerializer.kt$net.corda.serialization.internal.amqp.custom.ZoneIdSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:ZonedDateTimeSerializer.kt$net.corda.serialization.internal.amqp.custom.ZonedDateTimeSerializer.kt</ID>
    <ID>NewLineAtEndOfFile:errorAndTerminate.kt$net.corda.node.utilities.errorAndTerminate.kt</ID>
    <ID>NewLineAtEndOfFile:internalAccessTestHelpers.kt$net.corda.core.internal.internalAccessTestHelpers.kt</ID>
    <ID>NewLineAtEndOfFile:main.kt$net.corda.tools.testing.pinger.main.kt</ID>
    <ID>PackageNaming:AbstractScenarioRunner.kt$package net.corda.haTesting</ID>
    <ID>PackageNaming:CashScenarioRunner.kt$package net.corda.haTesting</ID>
    <ID>PackageNaming:CordaRpcWorkerOps.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:LinearStateScenarioRunner.kt$package net.corda.haTesting</ID>
    <ID>PackageNaming:Main.kt$package net.corda.haTesting</ID>
    <ID>PackageNaming:MessageState.kt$package net.corda.testMessage</ID>
    <ID>PackageNaming:RpcFlowWorkerDriver.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:RpcHelper.kt$package net.corda.haTesting</ID>
    <ID>PackageNaming:RpcWorker.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:RpcWorkerMultiIdentityTest.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:RpcWorkerPaidTest.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:RpcWorkerServiceHub.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:RpcWorkerStartStopTest.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:RpcWorkerTest.kt$package net.corda.rpcWorker</ID>
    <ID>PackageNaming:ScheduledState.kt$package net.corda.testMessage</ID>
    <ID>ReturnCount:AMQPChannelHandler.kt$AMQPChannelHandler$private fun handleSuccessfulHandshake(ctx: ChannelHandlerContext)</ID>
    <ID>ReturnCount:AbstractPartyDescriptor.kt$AbstractPartyDescriptor$override fun &lt;X : Any&gt; unwrap(value: AbstractParty?, type: Class&lt;X&gt;, options: WrapperOptions): X?</ID>
    <ID>ReturnCount:AbstractPartyDescriptor.kt$AbstractPartyDescriptor$override fun &lt;X : Any&gt; wrap(value: X?, options: WrapperOptions): AbstractParty?</ID>
    <ID>ReturnCount:Address.kt$Address.Companion$fun &lt;ERROR&gt; validFromRawValue(rawValue: String, mapError: (String) -&gt; ERROR): Validated&lt;Address, ERROR&gt;</ID>
    <ID>ReturnCount:Amount.kt$Amount.Companion$ @JvmStatic fun getDisplayTokenSize(token: Any): BigDecimal</ID>
    <ID>ReturnCount:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>ReturnCount:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun containsClasses(attachment: Attachment): Boolean</ID>
    <ID>ReturnCount:BackChainResolutionSampler.kt$BackChainResolutionSampler$override fun createFlowInvoke(rpcProxy: CordaRPCOps, testContext: JavaSamplerContext): BaseFlowSampler.FlowInvoke&lt;*&gt;</ID>
    <ID>ReturnCount:BankOfCordaWebApi.kt$BankOfCordaWebApi$ @POST @Path("issue-asset-request") @Consumes(MediaType.APPLICATION_JSON) fun issueAssetRequest(params: IssueRequestParams): Response</ID>
    <ID>ReturnCount:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>ReturnCount:BullyLeader.kt$BullyLeaderClient$private fun compareIds(nodeId1: String, priority1: Int, nodeId2: String, priority2: Int): Int</ID>
    <ID>ReturnCount:ByteArrays.kt$fun hexToBin(ch: Char): Int</ID>
    <ID>ReturnCount:ByteBufferStreams.kt$ByteBufferInputStream$@Throws(IOException::class) override fun read(b: ByteArray, offset: Int, length: Int): Int</ID>
    <ID>ReturnCount:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>ReturnCount:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>ReturnCount:CloseableTab.kt$CloseableTab$fun requestClose()</ID>
    <ID>ReturnCount:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin$override fun authenticate(username: String?, credential: String?): AuthInfo</ID>
    <ID>ReturnCount:CordaClassResolver.kt$CordaClassResolver$private fun checkClass(type: Class&lt;*&gt;): Registration?</ID>
    <ID>ReturnCount:CrlFetcher.kt$CrlFetcher$fun fetch(cert: X509Certificate): Set&lt;X509CRL&gt;</ID>
    <ID>ReturnCount:Crypto.kt$Crypto$// Custom key pair generator from an entropy required for various tests. It is similar to deriveKeyPairECDSA, // but the accepted range of the input entropy is more relaxed: // 2 &lt;= entropy &lt; N, where N is the order of base-point G. private fun deriveECDSAKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair</ID>
    <ID>ReturnCount:Crypto.kt$Crypto$// Given the domain parameters, this routine deterministically generates an ECDSA key pair // in accordance with X9.62 section 5.2.1 pages 26, 27. private fun deriveKeyPairECDSA(parameterSpec: ECParameterSpec, privateKey: PrivateKey, seed: ByteArray): KeyPair</ID>
    <ID>ReturnCount:DBCheckpointStorage.kt$DBCheckpointStorage$override fun getCheckpointCount(connection: Connection): Long</ID>
    <ID>ReturnCount:DBRunnerExtension.kt$DBRunnerExtension$private fun getDatabaseContext(context: ExtensionContext?): TestDatabaseContext?</ID>
    <ID>ReturnCount:Emoji.kt$Emoji$fun renderIfSupported(obj: Any): String</ID>
    <ID>ReturnCount:FirewallStartup.kt$FirewallStartup$ override fun runProgram(): Int</ID>
    <ID>ReturnCount:FloatControlListenerService.kt$FloatControlListenerService$private fun forwardReceivedMessage(message: ReceivedMessage)</ID>
    <ID>ReturnCount:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$private fun buildParams(constructor: KFunction&lt;FlowLogic&lt;*&gt;&gt;, args: Map&lt;String, Any?&gt;): HashMap&lt;KParameter, Any?&gt;?</ID>
    <ID>ReturnCount:FlowManager.kt$NodeFlowManager.FlowWeightComparator$override fun compare(o1: NodeFlowManager.RegisteredFlowContainer, o2: NodeFlowManager.RegisteredFlowContainer): Int</ID>
    <ID>ReturnCount:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>ReturnCount:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: CordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>ReturnCount:InteractiveShell.kt$InteractiveShell$private fun maybeFollow(response: Any?, printerFun: (Any?) -&gt; String, out: PrintWriter): CordaFuture&lt;Unit&gt;</ID>
    <ID>ReturnCount:InternalKeystoreGenerator.kt$AbstractInternalKeystoreGenerator$// When we move to Picocli 4.0 delete this and use @ArgGroup instead. fun errorInHSMOptions(hsmName: String?, hsmConfigFile: Path?, prefix: String): Boolean</ID>
    <ID>ReturnCount:Interpolators.kt$LinearInterpolator$override fun interpolate(x: Double): Double</ID>
    <ID>ReturnCount:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseCordappInfo(manifest: Manifest?, defaultName: String): Cordapp.Info</ID>
    <ID>ReturnCount:Launcher.kt$DbManagementTool$fun runLegacyCommands(): Int</ID>
    <ID>ReturnCount:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$override fun get(actualClass: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;</ID>
    <ID>ReturnCount:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>ReturnCount:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$ private fun buildNonAtomic(rawType: Class&lt;*&gt;, type: Type, typeIdentifier: TypeIdentifier, typeParameterInformation: List&lt;LocalTypeInformation&gt;): LocalTypeInformation</ID>
    <ID>ReturnCount:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun makeConstructorPairedProperty(constructorIndex: Int, descriptor: PropertyDescriptor, constructorInformation: LocalConstructorInformation): LocalPropertyInformation?</ID>
    <ID>ReturnCount:LogProcessor.kt$LogProcessor$private fun logStatement(line: String, tags: Map&lt;String, String&gt;, severity: String = "INFO")</ID>
    <ID>ReturnCount:LogProcessor.kt$LogProcessor$private fun startFlow(tags: Map&lt;String, String&gt;)</ID>
    <ID>ReturnCount:Main.kt$Node$fun isAccepted(tx: Transaction): Boolean</ID>
    <ID>ReturnCount:MockNodeMessagingService.kt$MockNodeMessagingService$ private fun getNextQueue(q: LinkedBlockingQueue&lt;InMemoryMessagingNetwork.MessageTransfer&gt;, block: Boolean): Pair&lt;InMemoryMessagingNetwork.MessageTransfer, List&lt;Handler&gt;&gt;?</ID>
    <ID>ReturnCount:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>ReturnCount:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun createFlowFromCheckpoint( id: StateMachineRunId, serializedCheckpoint: SerializedBytes&lt;Checkpoint&gt;, isAnyCheckpointPersisted: Boolean, isStartIdempotent: Boolean, initialDeduplicationHandler: DeduplicationHandler? ): Flow?</ID>
    <ID>ReturnCount:NettyTestHandler.kt$NettyTestHandler$fun waitForReadCalled(numberOfExpectedCalls: Int = 1): Boolean</ID>
    <ID>ReturnCount:NetworkMapHttpProxyTest.kt$AuthenticatedConnectHandler$override fun handleAuthentication(request: HttpServletRequest?, response: HttpServletResponse?, address: String?): Boolean</ID>
    <ID>ReturnCount:NetworkMapHttpProxyTest.kt$AuthenticatedHttpProxy$private fun validateProxyAuth(clientRequest: HttpServletRequest?, proxyResponse: HttpServletResponse?): Boolean</ID>
    <ID>ReturnCount:NetworkRegistrationHelper.kt$NodeRegistrationHelper$override fun validateAndGetTlsCrlIssuerCert(): X509Certificate?</ID>
    <ID>ReturnCount:NodeAttachmentTrustCalculator.kt$NodeAttachmentTrustCalculator$override fun calculate(attachment: Attachment): Boolean</ID>
    <ID>ReturnCount:NodeConfigurationImpl.kt$NodeConfigurationImpl$private fun validateDevModeOptions(): List&lt;String&gt;</ID>
    <ID>ReturnCount:NodeSchemaService.kt$NodeSchemaService$// Because schema is always one supported by the state, just delegate. override fun generateMappedObject(state: ContractState, schema: MappedSchema): PersistentState</ID>
    <ID>ReturnCount:NodeStartup.kt$NodeStartup$fun initialiseAndRun(cmdLineOptions: SharedNodeCmdLineOptions, afterNodeInitialisation: RunAfterNodeInitialisation, requireCertificates: Boolean = false): Int</ID>
    <ID>ReturnCount:NodeStartup.kt$NodeStartup$fun isNodeRunningAt(baseDirectory: Path): Boolean</ID>
    <ID>ReturnCount:NodeStartup.kt$NodeStartup$private fun canReadCertificatesDirectory(certDirectory: Path, devMode: Boolean): Boolean</ID>
    <ID>ReturnCount:NodeStartup.kt$fun CliWrapperBase.initLogging(baseDirectory: Path): Boolean</ID>
    <ID>ReturnCount:NodeVaultService.kt$NodeVaultService$@Suspendable @Throws(StatesNotAvailableException::class) override fun &lt;T : FungibleState&lt;*&gt;&gt; tryLockFungibleStatesForSpending( lockId: UUID, eligibleStatesQuery: QueryCriteria, amount: Amount&lt;*&gt;, contractStateType: Class&lt;out T&gt; ): List&lt;StateAndRef&lt;T&gt;&gt;</ID>
    <ID>ReturnCount:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>ReturnCount:PartialMerkleTree.kt$PartialMerkleTree$// Helper function to compute the path. False means go to the left and True to the right. // Because the path is updated recursively, the path is returned in reverse order. private fun leafIndexHelper(leaf: SecureHash, node: PartialTree, path: MutableList&lt;Boolean&gt;): Boolean</ID>
    <ID>ReturnCount:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$override fun getPartyInfo(party: Party): PartyInfo?</ID>
    <ID>ReturnCount:Program.kt$ConfigObfuscatorCli$override fun runProgram(): Int</ID>
    <ID>ReturnCount:Program.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>ReturnCount:Program.kt$private fun getUsernameAndPassword(): Pair&lt;String, String&gt;?</ID>
    <ID>ReturnCount:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ReturnCount:RPCSecurityManagerImpl.kt$RPCPermissionResolver$override fun resolvePermission(representation: String): Permission</ID>
    <ID>ReturnCount:RegistrationTool.kt$RegistrationTool$private fun makeBridgeCryptoService(bridgeConfig: Config, configDir: Path): CryptoService?</ID>
    <ID>ReturnCount:RigorousMock.kt$SpectatorDefaultAnswer$override fun answerImpl(invocation: InvocationOnMock): Any?</ID>
    <ID>ReturnCount:SNIKeyManager.kt$SNIKeyManager$private fun chooseServerAlias(keyType: String?, issuers: Array&lt;out Principal&gt;?, matcher: SNIMatcher?): String?</ID>
    <ID>ReturnCount:SerialFilter.kt$SerialFilter$internal fun applyPredicate(acceptClass: (Class&lt;*&gt;) -&gt; Boolean, serialClass: Class&lt;*&gt;?): Boolean</ID>
    <ID>ReturnCount:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>ReturnCount:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$override fun retryFlowFromSafePoint(currentState: StateMachineState)</ID>
    <ID>ReturnCount:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun createFlowFromCheckpoint( id: StateMachineRunId, serializedCheckpoint: SerializedBytes&lt;Checkpoint&gt;, isAnyCheckpointPersisted: Boolean, isStartIdempotent: Boolean, initialDeduplicationHandler: DeduplicationHandler? ): Flow?</ID>
    <ID>ReturnCount:SpecificationTest.kt$SpecificationTest$fun parseMax(elements: List&lt;Long&gt;): Valid&lt;Long&gt;</ID>
    <ID>ReturnCount:StandaloneShell.kt$StandaloneShell$override fun runProgram(): Int</ID>
    <ID>ReturnCount:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ReturnCount:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>ReturnCount:TransitionExecutorImpl.kt$TransitionExecutorImpl$@Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>ReturnCount:TypeParameterUtils.kt$ private fun inferTypeVariables(actualClass: Class&lt;*&gt;, declaredClass: Class&lt;*&gt;, declaredType: ParameterizedType): Type?</ID>
    <ID>ReturnCount:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>ReturnCount:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>SpreadOperator:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$(*it.whitelist.toTypedArray())</ID>
    <ID>SpreadOperator:AbstractNode.kt$FlowStarterImpl$(logicType, *args)</ID>
    <ID>SpreadOperator:AbstractParty.kt$AbstractParty$(*bytes)</ID>
    <ID>SpreadOperator:AbstractRPCTest.kt$AbstractRPCTest.Companion$(*modes)</ID>
    <ID>SpreadOperator:ArtemisMessagingClient.kt$ArtemisMessagingClient$(backupTransports.isNotEmpty(), *(listOf(tcpTransport) + backupTransports).toTypedArray())</ID>
    <ID>SpreadOperator:AssertingTestDatabaseContext.kt$AssertingTestDatabaseContext$(*expectedScripts)</ID>
    <ID>SpreadOperator:AttachmentDemo.kt$(*args)</ID>
    <ID>SpreadOperator:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$(*packages.toTypedArray())</ID>
    <ID>SpreadOperator:AuthenticatedRpcOpsProxy.kt$(methodName, *(args.map(Class&lt;*&gt;::getName).toTypedArray()))</ID>
    <ID>SpreadOperator:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$(logicType, *args)</ID>
    <ID>SpreadOperator:AzureInstantiator.kt$AzureInstantiator$(*portsToOpen.toIntArray())</ID>
    <ID>SpreadOperator:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$(0x30, b1.toByte(), 0x02, b2.toByte(), *r, 0x02, b3.toByte(), *s)</ID>
    <ID>SpreadOperator:BaseFlowSampler.kt$BaseFlowSampler$(flowInvoke.flowLogicClass, *(flowInvoke.args))</ID>
    <ID>SpreadOperator:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$(*tcpTransports.toTypedArray())</ID>
    <ID>SpreadOperator:BridgeConfigHelper.kt$(*pairs)</ID>
    <ID>SpreadOperator:BridgeDriver.kt$(bridgeCertPath, *nodeSSLKeystores)</ID>
    <ID>SpreadOperator:BridgeDriver.kt$(bridgeKeytool, "--base-directory", bridgeDir.toString(), "--bridge-keystore-password", bridgeKeystorePassword, "--node-keystores", *nodeKeystores.map { it.toString() }.toTypedArray(), "--node-keystore-passwords", nodeKeystorePassword)</ID>
    <ID>SpreadOperator:ByteArrays.kt$OpaqueBytes.Companion$(*b)</ID>
    <ID>SpreadOperator:CertificateStore.kt$CertificateStore$(*options)</ID>
    <ID>SpreadOperator:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$(*constructorParams)</ID>
    <ID>SpreadOperator:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$(*params)</ID>
    <ID>SpreadOperator:CollectSignaturesFlow.kt$CollectSignatureFlow$(*signingKeys)</ID>
    <ID>SpreadOperator:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$(*party)</ID>
    <ID>SpreadOperator:CompositeKey.kt$CompositeKey.Builder$(*keys.toTypedArray())</ID>
    <ID>SpreadOperator:ConfigOperatorTests.kt$ConfigOperatorTests$(*config)</ID>
    <ID>SpreadOperator:ConfigOperatorTests.kt$ConfigOperatorTests$(*overrides)</ID>
    <ID>SpreadOperator:ConfigParsingTest.kt$ConfigParsingTest$(*values)</ID>
    <ID>SpreadOperator:ConfigUtilities.kt$(*pairs)</ID>
    <ID>SpreadOperator:Configuration.kt$Configuration.Validation.Error$(*(containingPath.toList() + this.containingPath).toTypedArray())</ID>
    <ID>SpreadOperator:ContractJarTestUtils.kt$ContractJarTestUtils$(jarName, *contractNames.map{ "${it.replace(".", "/")}.class" }.toTypedArray())</ID>
    <ID>SpreadOperator:CordaCliWrapper.kt$(RunLast().useOut(System.out).useAnsi(defaultAnsiMode), DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE), *args)</ID>
    <ID>SpreadOperator:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$(logicType, context(), *args)</ID>
    <ID>SpreadOperator:CordaRPCProxyClient.kt$CordaRPCProxyClient$(flowName, *args)</ID>
    <ID>SpreadOperator:CordaSdkVersionComboBox.kt$CordaSdkVersionComboBox$(null, *sdkVersions)</ID>
    <ID>SpreadOperator:CordaX500Name.kt$CordaX500Name.Companion$(*Locale.getISOCountries(), unspecifiedCountry)</ID>
    <ID>SpreadOperator:CrlServer.kt$CrlServlet.Companion$(newNodeCert, INTERMEDIATE_CA.certificate, *nodeKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }.drop(2).toTypedArray())</ID>
    <ID>SpreadOperator:CrlServer.kt$CrlServlet.Companion$(newTlsCert, newNodeCert, INTERMEDIATE_CA.certificate, *sslKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) }.drop(3).toTypedArray())</ID>
    <ID>SpreadOperator:CustomCordapp.kt$CustomCordapp$(*classes.map { it.name }.toTypedArray())</ID>
    <ID>SpreadOperator:CustomCordapp.kt$CustomCordapp$(*packages.map { it.replace('.', '/') }.toTypedArray())</ID>
    <ID>SpreadOperator:DemoBench.kt$DemoBench.Companion$(DemoBench::class.java, *args)</ID>
    <ID>SpreadOperator:DevCertificatesTest.kt$DevCertificatesTest$(*oldX509Certificates)</ID>
    <ID>SpreadOperator:DockerInstantiator.kt$DockerInstantiator$(*it.toTypedArray())</ID>
    <ID>SpreadOperator:DriverDSLImpl.kt$DriverDSLImpl$( config, quasarJarPath, debugPort, bytemanJarPath, null, systemProperties, "512m", null, *extraCmdLineFlag )</ID>
    <ID>SpreadOperator:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$(flowInvoke.flowLogicClass, *(flowInvoke.args))</ID>
    <ID>SpreadOperator:DummyContract.kt$DummyContract.Companion$( /* INPUTS */ *priors.toTypedArray(), /* COMMAND */ Command(cmd, priorState.owner.owningKey), /* OUTPUT */ StateAndContract(state, PROGRAM_ID) )</ID>
    <ID>SpreadOperator:DummyContract.kt$DummyContract.Companion$(*items)</ID>
    <ID>SpreadOperator:DummyContractV2.kt$DummyContractV2.Companion$( /* INPUTS */ *priors.toTypedArray(), /* COMMAND */ Command(cmd, priorState.owners.map { it.owningKey }), /* OUTPUT */ StateAndContract(state, DummyContractV2.PROGRAM_ID) )</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*fields)</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*fields, cause.staticLocationBasedHash(hashedFields, visited + cause))</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*hashedFields.invoke(this))</ID>
    <ID>SpreadOperator:Expect.kt$(*Array(number) { expectation(it) })</ID>
    <ID>SpreadOperator:Expect.kt$(*expectations)</ID>
    <ID>SpreadOperator:Explorer.kt$ExplorerController$(explorerPath, *args)</ID>
    <ID>SpreadOperator:FlowFrameworkTests.kt$FlowFrameworkTests$(*expected)</ID>
    <ID>SpreadOperator:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$(*expected)</ID>
    <ID>SpreadOperator:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$(flowClass, *args)</ID>
    <ID>SpreadOperator:FlowOverrideTests.kt$FlowOverrideTests$(*nodeAClasses.toTypedArray())</ID>
    <ID>SpreadOperator:FlowOverrideTests.kt$FlowOverrideTests$(*nodeBClasses.toTypedArray())</ID>
    <ID>SpreadOperator:FlowTestsUtils.kt$(*allSessions)</ID>
    <ID>SpreadOperator:FlowTestsUtils.kt$(session, *sessions)</ID>
    <ID>SpreadOperator:FlowWorker.kt$FlowWorker$(startFlowMessage.logicType, *startFlowMessage.args)</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*ourInputStates.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*ourOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*theirInputStates.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*theirOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*leftPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*leftPredicates.toTypedArray(), *rightPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*rightPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$(*predicateSet.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$(*combinedPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$(*joinPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:IRSDemo.kt$(*args)</ID>
    <ID>SpreadOperator:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$(*commandAndArgs)</ID>
    <ID>SpreadOperator:InteractiveShell.kt$InteractiveShell$(clazz, *args)</ID>
    <ID>SpreadOperator:InteractiveShellTest.kt$InteractiveShellTest$(*args)</ID>
    <ID>SpreadOperator:InteractiveShellTest.kt$InteractiveShellTest$(*args.map { it!!::class.java }.toTypedArray())</ID>
    <ID>SpreadOperator:InternalUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:InvocationHandlerTemplate.kt$InvocationHandlerTemplate$(delegate, *args)</ID>
    <ID>SpreadOperator:IrsDemoWebApplication.kt$IrsDemoWebApplication.Companion$(IrsDemoWebApplication::class.java, *args)</ID>
    <ID>SpreadOperator:IssueCash.kt$IssueCash$(*args)</ID>
    <ID>SpreadOperator:JVMConfig.kt$JVMConfig$(jarPath, *args)</ID>
    <ID>SpreadOperator:JVMConfig.kt$JVMConfig$(javaPath.toString(), "-jar", jarPath.toString(), *args)</ID>
    <ID>SpreadOperator:JacksonSupportTest.kt$JacksonSupportTest$(*fieldNames)</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$((bin / command[0]).toString(), *command.sliceArray(1 until command.size))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "cvf", fileName) + contents))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "i", fileName)))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "uvf", fileName) + contents))</ID>
    <ID>SpreadOperator:Kryo.kt$ImmutableClassSerializer$(*args)</ID>
    <ID>SpreadOperator:Launcher.kt$Launcher.Companion$(cmdLine, *args)</ID>
    <ID>SpreadOperator:LogHelper.kt$LogHelper$(*classes.map { "+" + it.packageName }.toTypedArray())</ID>
    <ID>SpreadOperator:LogHelper.kt$LogHelper$(*classes.map { it.packageName }.toTypedArray())</ID>
    <ID>SpreadOperator:Main.kt$(*args)</ID>
    <ID>SpreadOperator:Main.kt$(BenchmarkTool(), System.err, *args)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( identityService, *arrayOf(initialIdentity.keyPair) + moreKeys, pkToIdCache = MockPublicKeyToOwningIdentityCache() )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, *moreIdentities )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, networkParameters, *moreIdentities )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(*listOf(firstIdentity, *moreIdentities).map { it.identity }.toTypedArray())</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(cordappPackages, TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(firstIdentity, *moreIdentities)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices.Companion$( identityService, *arrayOf(initialIdentity.keyPair) + moreKeys, pkToIdCache = MockPublicKeyToOwningIdentityCache() )</ID>
    <ID>SpreadOperator:NetworkBuilder.kt$(*this.toTypedArray())</ID>
    <ID>SpreadOperator:NetworkMapTest.kt$NetworkMapTest$(*nodes)</ID>
    <ID>SpreadOperator:NetworkMapUpdater.kt$NetworkMapUpdater$(*networkMapDownloadFutures)</ID>
    <ID>SpreadOperator:NetworkParametersCopier.kt$NetworkParametersCopier$(nodeDir / fileName, *copyOptions)</ID>
    <ID>SpreadOperator:NodeProcess.kt$NodeProcess.Factory$(javaPath.toString(), "-Dcapsule.log=verbose", "-jar", cordaJar.toString(), *extraJvmArgs)</ID>
    <ID>SpreadOperator:NodeRegistrationTest.kt$NodeRegistrationTest$( pollInterval = 1.seconds, hostAndPort = portAllocation.nextHostAndPort(), myHostNameValue = "localhost", additionalServices = *arrayOf(registrationHandler))</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(*commonPredicates)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(*commonPredicates, stateRefsPredicate)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(lockUpdateTime, lockIdPredicate, *commonPredicates)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(stateStatusPredication, lockIdPredicate, *commonPredicates)</ID>
    <ID>SpreadOperator:ObjectBuilder.kt$ConstructorCaller$(*parameters)</ID>
    <ID>SpreadOperator:ObligationUtils.kt$ObligationUtils$(*inputs)</ID>
    <ID>SpreadOperator:P2PMessagingClient.kt$P2PMessagingClient$(backupTransports.isNotEmpty(), *(listOf(tcpTransport) + backupTransports).toTypedArray())</ID>
    <ID>SpreadOperator:PathUtils.kt$(*options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(parent / fileName, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *attrs)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, BasicFileAttributes::class.java, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, bytes, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, lines, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, maxDepth, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, targetFile, *options)</ID>
    <ID>SpreadOperator:ProgressTracker.kt$ProgressTracker$(UNSTARTED, STARTING, *inputSteps, DONE)</ID>
    <ID>SpreadOperator:Properties.kt$FunctionalListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$ListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$StandardProperty$(*key.split(".").toTypedArray())</ID>
    <ID>SpreadOperator:PropertyValidationTest.kt$PropertyValidationTest$(*key.split(".").toTypedArray())</ID>
    <ID>SpreadOperator:PropertyValidationTest.kt$PropertyValidationTest$(*key.split(".").toTypedArray(), nestedKey)</ID>
    <ID>SpreadOperator:RPCClient.kt$RPCClient$(*haPoolTransportConfigurations.toTypedArray())</ID>
    <ID>SpreadOperator:RPCDriver.kt$RandomRpcUser.Companion$(handle.proxy, *arguments.toTypedArray())</ID>
    <ID>SpreadOperator:RPCOpsWithContext.kt$(cordaRPCOps, *(args ?: arrayOf()))</ID>
    <ID>SpreadOperator:RPCProxyWebService.kt$RPCProxyWebService$(flowClass, *flowArgs)</ID>
    <ID>SpreadOperator:RPCSecurityManagerTest.kt$RPCSecurityManagerTest$(request.first(), *args)</ID>
    <ID>SpreadOperator:RPCServer.kt$RPCServer$(opsRouting[targetLegalName], *arguments.toTypedArray())</ID>
    <ID>SpreadOperator:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$(queueName, *queueNames)</ID>
    <ID>SpreadOperator:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$(reconnectingRPCConnection.proxy, *(args ?: emptyArray()))</ID>
    <ID>SpreadOperator:RegistrationServer.kt$RegistrationServer$(10.seconds, hostAndPort, additionalServices = *arrayOf(SimpleDoormanService()))</ID>
    <ID>SpreadOperator:RegistrationTool.kt$RegistrationTool$(sslKeyTool, *toolArgs.toTypedArray())</ID>
    <ID>SpreadOperator:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$(rpcWorkerBroker.serverControl, rpcWorkerConfig, *rpcWorkerServiceHubs.toTypedArray())</ID>
    <ID>SpreadOperator:RpcWorker.kt$(main, *args)</ID>
    <ID>SpreadOperator:SSLHelper.kt$(*ArtemisTcpTransport.TLS_VERSIONS.toTypedArray())</ID>
    <ID>SpreadOperator:Samplers.kt$CashPaySampler$(flowInvoke.flowLogicClass, *(flowInvoke.args))</ID>
    <ID>SpreadOperator:Samplers.kt$TxResolutionSampler$(flowInvoke.flowLogicClass, *(flowInvoke.args))</ID>
    <ID>SpreadOperator:ServiceHub.kt$ServiceHub$(first, *remaining)</ID>
    <ID>SpreadOperator:StandaloneShell.kt$StandaloneShell$(format, *args)</ID>
    <ID>SpreadOperator:StringToMethodCallParser.kt$StringToMethodCallParser.ParsedMethodCall$(target, *args)</ID>
    <ID>SpreadOperator:TestCommandLine.kt$TestCommandLine$(cli, *args)</ID>
    <ID>SpreadOperator:TestDoorman.kt$TestDoorman$( pollInterval = 1.seconds, hostAndPort = portAllocation.nextHostAndPort(), myHostNameValue = "localhost", additionalServices = *arrayOf(registrationHandler))</ID>
    <ID>SpreadOperator:TestLauncherHelpers.kt$TestLauncherHelpers$(cli, *args)</ID>
    <ID>SpreadOperator:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$(*certs, intermediateAndRoot.first.certificate, intermediateAndRoot.second)</ID>
    <ID>SpreadOperator:TestUtils.kt$TestIdentity$(*bytes)</ID>
    <ID>SpreadOperator:ThrowableSerializer.kt$ThrowableSerializer$(*params.toTypedArray())</ID>
    <ID>SpreadOperator:ToolConfig.kt$ToolConfig$(*args)</ID>
    <ID>SpreadOperator:TraderDemo.kt$TraderDemo$(*args)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*keys)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*types)</ID>
    <ID>SpreadOperator:TransactionWithSignatures.kt$TransactionWithSignatures$(*allowedToBeMissing)</ID>
    <ID>SpreadOperator:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$(listOf(bc1), node, identity, notaryNode, *extraSigningNodes)</ID>
    <ID>SpreadOperator:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$(listOf(bc2), node, identity, notaryNode, *extraSigningNodes)</ID>
    <ID>SpreadOperator:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$(listOf(eb1), node, identity, notaryNode, *extraSigningNodes)</ID>
    <ID>SpreadOperator:VaultQueryTests.kt$VaultQueryTestRule$( cordappPackages, makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity), megaCorp, moreKeys = *arrayOf(DUMMY_NOTARY_KEY))</ID>
    <ID>SpreadOperator:VaultQueryTests.kt$VaultQueryTestsBase$(*states.toList().toTypedArray())</ID>
    <ID>SpreadOperator:VaultWithCashTest.kt$VaultWithCashTest$( cordappPackages, makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity), TestIdentity(MEGA_CORP.name, servicesKey), networkParameters, moreKeys = *arrayOf(dummyNotary.keyPair))</ID>
    <ID>SpreadOperator:WaitForStateConsumption.kt$WaitForStateConsumption$(*futures.toTypedArray())</ID>
    <ID>SpreadOperator:WebArgsParser.kt$ArgsParser$(*args)</ID>
    <ID>SpreadOperator:WebServer.kt$(*args)</ID>
    <ID>SpreadOperator:WithContracts.kt$WithContracts$( magicNumber, mockNet.defaultNotaryIdentity, owner, *others)</ID>
    <ID>SpreadOperator:WithContracts.kt$WithContracts$(owner, magicNumber, *others)</ID>
    <ID>SpreadOperator:X509Utilities.kt$X509Utilities$(*certificates)</ID>
    <ID>ThrowsCount:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>ThrowsCount:AbstractNode.kt$fun CordaPersistence.startHikariPool(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>ThrowsCount:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from // Artemis IO errors @Throws(IOException::class, AddressBindingException::class, KeyStoreException::class) private fun configureAndStartServer()</ID>
    <ID>ThrowsCount:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$fun parseConfigFile(configFile: Path): AzureKeyVaultConfig</ID>
    <ID>ThrowsCount:BrokerJaasLoginModule.kt$BaseBrokerJaasLoginModule$protected fun getUsernamePasswordAndCerts(): Triple&lt;String, String, Array&lt;X509Certificate&gt;?&gt;</ID>
    <ID>ThrowsCount:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>ThrowsCount:CheckpointVerifier.kt$CheckpointVerifier$// Throws exception when the flow is incompatible private fun checkFlowCompatible(subFlow: SubFlow, currentCordappsByHash: Map&lt;SecureHash.SHA256, Cordapp&gt;, platformVersion: Int)</ID>
    <ID>ThrowsCount:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>ThrowsCount:ConnectionManager.kt$ fun setupJSchWithSshAgent(): JSch</ID>
    <ID>ThrowsCount:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun resolve(services: ServicesForResolution, sigs: List&lt;TransactionSignature&gt;): ContractUpgradeLedgerTransaction</ID>
    <ID>ThrowsCount:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$private fun &lt;T&gt; startFlow(logicType: Class&lt;out FlowLogic&lt;T&gt;&gt;, args: Array&lt;out Any?&gt;): FlowStateMachine&lt;T&gt;</ID>
    <ID>ThrowsCount:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>ThrowsCount:DeserializationInput.kt$DeserializationInput$@Throws( AMQPNotSerializableException::class, AMQPNoTypeNotSerializableException::class) private fun &lt;R&gt; des(generator: () -&gt; R): R</ID>
    <ID>ThrowsCount:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>ThrowsCount:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>ThrowsCount:ExternalSourceRevocationChecker.kt$ExternalSourceRevocationChecker$ @Throws(CertPathValidatorException::class) private fun checkApprovedCRLs(cert: X509Certificate, approvedCRLs: Set&lt;X509CRL&gt;)</ID>
    <ID>ThrowsCount:JacksonSupport.kt$JacksonSupport.PartyDeserializer$private fun lookupByNameSegment(mapper: PartyObjectMapper, parser: JsonParser): Party</ID>
    <ID>ThrowsCount:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseVersion(versionStr: String?, attributeName: String): Int</ID>
    <ID>ThrowsCount:JshHelper.kt$ fun setupJSchWithSshAgent(): JSch</ID>
    <ID>ThrowsCount:LedgerDSLInterpreter.kt$Verifies$ fun failsWith(expectedMessage: String?): EnforceVerifyOrFail</ID>
    <ID>ThrowsCount:Main.kt$fun getMonitorable(proxy: CordaRPCOps, target: String?, notary: String?): Monitorable</ID>
    <ID>ThrowsCount:ManagedCryptoService.kt$ManagedCryptoService$ private fun &lt;A&gt; managedCall(func: () -&gt; A) : A</ID>
    <ID>ThrowsCount:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$private fun getInitiatedFlowFactory(message: InitialSessionMessage): InitiatedFlowFactory&lt;*&gt;</ID>
    <ID>ThrowsCount:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private fun validateCertificates(registeringPublicKey: PublicKey, certificates: List&lt;X509Certificate&gt;)</ID>
    <ID>ThrowsCount:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun atomicCopy(source: Path, destination: Path)</ID>
    <ID>ThrowsCount:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>ThrowsCount:NodeVaultService.kt$NodeVaultService$private fun makeUpdates(batch: Iterable&lt;CoreTransaction&gt;, statesToRecord: StatesToRecord, previouslySeen: Boolean): List&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>ThrowsCount:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$ private fun checkNotaryWhitelisted(notary: Party, attachedParameterHash: SecureHash?)</ID>
    <ID>ThrowsCount:PropertyDescriptor.kt$PropertyDescriptor$ fun validate()</ID>
    <ID>ThrowsCount:RPCApi.kt$RPCApi.ServerToClient.Companion$fun fromClientMessage(context: SerializationContext, message: ClientMessage): ServerToClient</ID>
    <ID>ThrowsCount:RPCServer.kt$RPCServer$private fun invokeRpc(context: RpcAuthContext, methodName: String, arguments: List&lt;Any?&gt;): Try&lt;Any&gt;</ID>
    <ID>ThrowsCount:SchemaMigration.kt$SchemaMigration$private fun doRunMigration( run: Boolean, outputWriter: Writer?, check: Boolean, existingCheckpoints: Boolean? = null, statusLogger: Logger? = null )</ID>
    <ID>ThrowsCount:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>ThrowsCount:SignedNodeInfo.kt$SignedNodeInfo$// TODO Add root cert param (or TrustAnchor) to make sure all the identities belong to the same root fun verified(): NodeInfo</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$@DeleteForDJVM private fun resolveAndCheckNetworkParameters(services: ServiceHub)</ID>
    <ID>ThrowsCount:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun getInitiatedFlowFactory(message: InitialSessionMessage): InitiatedFlowFactory&lt;*&gt;</ID>
    <ID>ThrowsCount:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>ThrowsCount:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parseArguments(methodNameHint: String, parameters: List&lt;Pair&lt;String, Type&gt;&gt;, args: String): Array&lt;Any?&gt;</ID>
    <ID>ThrowsCount:StructuresTests.kt$AttachmentTest$@Test fun `openAsJAR does not leak file handle if attachment has corrupted manifest`()</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun getUniqueContractAttachmentsByContract(): Map&lt;ContractClassName, ContractAttachment&gt;</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyContracts()</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction$private fun toLedgerTransactionInternal( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>TooGenericExceptionCaught:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:AMQPChannelHandler.kt$AMQPChannelHandler$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:AMQPExceptions.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:AMQPTestUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$AbstractNode$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$AbstractNode.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNodeTests.kt$ColdJVM.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:AbstractScenarioRunner.kt$AbstractScenarioRunner.Companion$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:AbstractZkLatch.kt$AbstractZkLatch$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Amount.kt$Amount.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentDemo.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentLoadingTests.kt$AttachmentLoadingTests.ConsumeAndBroadcastResponderFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentUploaderJob.kt$AttachmentUploaderJob$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AzureSmbVolume.kt$AzureSmbVolume$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BCCryptoService.kt$BCCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BankOfCordaWebApi.kt$BankOfCordaWebApi$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BaseFlowSampler.kt$BaseFlowSampler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlobInspector.kt$BlobInspector$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BootstrapperView.kt$BootstrapperView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeArtemisConnectionServiceImpl.kt$BridgeArtemisConnectionServiceImpl$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeControlListener.kt$BridgeControlListener$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeControlListener.kt$BridgeControlListener$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeDriver.kt$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeSmokeTest.kt$BridgeSmokeTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeTestHelper.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BullyLeader.kt$BullyLeaderClient.ArtemisMessageSession$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:CertRole.kt$CertRole.Companion$ex: ArrayIndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:CheckpointAgent.kt$CheckpointAgent.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckpointAgent.kt$CheckpointHook$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:CheckpointDumper.kt$CheckpointDumper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckpointVerifier.kt$CheckpointVerifier$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CollectSignaturesFlow.kt$SignTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConcurrencyUtils.kt$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ConfigUtilities.kt$e:Exception</ID>
    <ID>TooGenericExceptionCaught:Configuration.kt$Configuration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConnectionStateMachine.kt$ConnectionStateMachine$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaClassResolver.kt$LoggingWhitelist.Companion$ioEx: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$CordaFutureImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$ValueOrException$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaPersistence.kt$CordaPersistence$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCClientTest.kt$CordaRPCClientTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCProxyClient.kt$CordaRPCProxyClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRpcWorkerOps.kt$CordaRpcWorkerOps$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaSecurityProvider.kt$CordaSecurityProvider$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CreateMigrationSqlForCordappsCli.kt$CreateMigrationSqlForCordappsCli$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CrlFetcher.kt$CrlFetcher.Companion$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:CryptoServiceSigningService.kt$CryptoServiceSigningService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CryptoUtilsTest.kt$CryptoUtilsTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DBNetworkParametersStorage.kt$DBNetworkParametersStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DataUploadServlet.kt$DataUploadServlet$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:DatabaseTestContainers.kt$CockroachDBDataSourceFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DatabaseTestContainers.kt$MariaDBDataSourceFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DatabaseTestContainers.kt$MySQLDataSourceFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DatabaseTestContainers.kt$OracleDataSourceFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DatabaseTestContainers.kt$PostgreSQLDataSourceFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DatabaseTestContainers.kt$SQLServerDataSourceFactory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DbManagerConfiguration.kt$DbManagerConfiguration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DbMapDeadlockTest.kt$DbMapDeadlockTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DbScriptRunner.kt$ListPopulator$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:DbScriptRunner.kt$ListPopulator$ex: Throwable</ID>
    <ID>TooGenericExceptionCaught:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:DemoBenchView.kt$DemoBenchView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DeserializationInput.kt$DeserializationInput$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DockerInstantiator.kt$DockerInstantiator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DriverDSLImpl.kt$DriverDSLImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DriverDSLImpl.kt$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:DriverTests.kt$DriverTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ErrorCodeLoggingTests.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:EventProcessor.kt$EventProcessor$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Eventually.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Expect.kt$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Explorer.kt$Explorer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationChecker$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FinanceJSONSupport.kt$CalendarDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FirewallStartup.kt$FirewallStartup$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FloatControlListenerService.kt$FloatControlListenerService$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowHandle.kt$FlowProgressHandleImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowMessaging.kt$FlowMessagingImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStateMachineImpl.kt$FlowStateMachineImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStateMachineImpl.kt$FlowStateMachineImpl$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:FlowWorkerRegister.kt$FlowWorkerRegister$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowWorkerServiceHub.kt$FlowWorkerServiceHub$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FutureMatchers.kt$&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FutureXCryptoService.kt$FutureXCryptoService.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HibernateConfiguration.kt$HibernateConfiguration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Hooker.kt$Hooker$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:IRSDemo.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IRSDemoTest.kt$IRSDemoTest.InterestRateSwapStateDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InitialRegistrationCli.kt$InitialRegistration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InitialRegistrationCli.kt$InitialRegistration.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Injectors.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Injectors.kt$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:InteractiveShell.kt$InteractiveShell$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InteractiveShell.kt$InteractiveShell$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:InterestSwapRestAPI.kt$InterestRateSwapAPI$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalMockNetwork.kt$InternalMockNetwork$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:InternalTestUtils.kt$&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:IssueCash.kt$IssueCash$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JPANotaryService.kt$JPANotaryService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JPAUniquenessProvider.kt$JPAUniquenessProvider$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.PartyDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.PublicKeyDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.SecureHashDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JarScanningCordappLoader.kt$JarScanningCordappLoader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JvmStatsHelper.kt$JvmStatsHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Kryo.kt$ImmutableClassSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Launcher.kt$Launcher.Companion$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:Launcher.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LedgerDSLInterpreter.kt$Verifies$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:LoadTest.kt$LoadTest$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:LoggingFirewallAuditService.kt$LoggingFirewallAuditService$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:LoginView.kt$LoginView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Main.kt$HAToolBase$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:Main.kt$HAUtilities.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Main.kt$Main$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Main.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Main.kt$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:Main.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:Main.kt$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:ManagedCryptoService.kt$ManagedCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MerkleTransaction.kt$FilteredTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MessagingExecutor.kt$MessagingExecutor$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:MigrationServicesForResolution.kt$MigrationServicesForResolution$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockAttachmentStorage.kt$MockAttachmentStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockCryptoService.kt$MockCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockNodeMessagingService.kt$MockNodeMessagingService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:MyCustomNotaryService.kt$MyValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MySQLUniquenessProvider.kt$MySQLUniquenessProvider$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NamedCacheTest.kt$NamedCacheTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NettyTestHandler.kt$NettyTestHandler$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:NetworkBootstrapper.kt$NetworkBootstrapper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapSocksProxyTest.kt$NetworkMapSocksProxyTest.SocksServer$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapUpdater.kt$NetworkMapUpdater$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapUpdater.kt$NetworkMapUpdater.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkParametersReader.kt$NetworkParametersReader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Node.kt$Node$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeController.kt$NodeController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeInfoWatcher.kt$NodeInfoWatcher$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeInterestRates.kt$NodeInterestRates$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeJanitor.kt$NodeJanitor$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeMonitorModel.kt$NodeMonitorModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeProcess.kt$NodeProcess.Factory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeRPC.kt$NodeRPC$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeRPC.kt$NodeRPC.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeSchedulerService.kt$NodeSchedulerService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeStartup.kt$NodeStartup$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeTerminalView.kt$NodeTerminalView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeVaultService.kt$NodeVaultService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeVaultServiceTest.kt$NodeVaultServiceTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryRegistrationTool.kt$NotaryRegistrationTool$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryServiceFlow.kt$NotaryServiceFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ObjectDiffer.kt$ObjectDiffer$throwable: Exception</ID>
    <ID>TooGenericExceptionCaught:P2PMessagingClient.kt$P2PMessagingClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PlatformSecureRandom.kt$LinuxSecureRandomSpi$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PlatformSecureRandom.kt$PlatformSecureRandomService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PrimusXCryptoService.kt$PrimusXCryptoService.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch.ElectionWatcher$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PrioritizedLeaderLatchTest.kt$PrioritizedLeaderLatchTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ProfileController.kt$ProfileController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Program.kt$ConfigObfuscatorCli$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:PropertyValidationTest.kt$PropertyValidationTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:R3Pty.kt$R3Pty$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCApi.kt$RPCApi.ServerToClient.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClient.kt$RPCClient$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:RPCProxyServer.kt$RPCProxyServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCProxyServer.kt$RPCProxyServer.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCProxyWebService.kt$RPCProxyWebService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCStabilityTests.kt$RPCStabilityTests$e2: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCStabilityTests.kt$RPCStabilityTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RandomFailingProxy.kt$RandomFailingProxy$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingObservable.kt$ReconnectingObservable.ReconnectingSubscriber$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RegistrationTool.kt$RegistrationTool$ex: Throwable</ID>
    <ID>TooGenericExceptionCaught:RequestResponseServiceHelper.kt$RequestResponseServiceHelper$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SSLHelper.kt$LoggingImmediateExecutor$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SSLHelper.kt$LoggingTrustManagerWrapper$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ScheduledCheckFlow.kt$ScheduledCheckFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SerializationOutputTests.kt$SerializationOutputTests$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ShutdownManager.kt$ShutdownManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SimpleMQClient.kt$SimpleMQClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SimpleMessageFilterService.kt$SimpleMessageFilterService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SimpleMessageFilterService.kt$SimpleMessageFilterService$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SocksTests.kt$SocksTests.SocksServer$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StandaloneShell.kt$StandaloneShell$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StandardConfigValueParsers.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StringToMethodCallParser.kt$StringToMethodCallParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TLSAuthenticationTests.kt$TLSAuthenticationTests$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ThrowableSerializer.kt$ThrowableSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ToolConfig.kt$ToolConfig$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TrackedCollector.kt$TrackedCollector$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:TraderDemo.kt$TraderDemo$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionBuilder.kt$TransactionBuilder$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:TransactionSignatureTest.kt$TransactionSignatureTest$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:TransactionUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionVerifierServiceInternal.kt$Verifier$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransformTypes.kt$TransformTypes.Companion$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:TransitionExecutorImpl.kt$TransitionExecutorImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Try.kt$Try.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:TunnelExternalCrlSourceService.kt$TunnelExternalCrlSourceService.CrlCacheLoader$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:TunnelingBridgeReceiverService.kt$TunnelingBridgeReceiverService$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Utils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:UtimacoCryptoService.kt$UtimacoCryptoService.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ValidatingNotaryFlow.kt$ValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VaultStateMigration.kt$VaultStateIterator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VaultStateMigration.kt$VaultStateMigration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$WebServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:WithMockNet.kt$WithMockNet.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:X509EdDSAEngine.kt$X509EdDSAEngine$e: Exception</ID>
    <ID>TooGenericExceptionCaught:X509UtilitiesTest.kt$X509UtilitiesTest$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:main.kt$ex: Exception</ID>
    <ID>TooGenericExceptionThrown:AMQPExceptionsTests.kt$AMQPExceptionsTests$throw Exception("FAILED")</ID>
    <ID>TooGenericExceptionThrown:AbstractNode.kt$AbstractNode$throw Error("Unable to locate agent jar file")</ID>
    <ID>TooGenericExceptionThrown:AzureBackend.kt$AzureBackend.Companion$throw RuntimeException(e)</ID>
    <ID>TooGenericExceptionThrown:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService.Companion$throw Exception("Error in ${configFile.toFile().absolutePath} : ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:BackChainResolutionSampler.kt$BackChainResolutionSampler$throw Exception("Illegal operation code [$op.opCode]")</ID>
    <ID>TooGenericExceptionThrown:BridgeSSLKeyTool.kt$BridgeSSLKeyTool$throw Exception("Error encountered when processing the following keystore(s) : $skippedKeystore , please check the inputs and rerun the key importing tool if necessary.")</ID>
    <ID>TooGenericExceptionThrown:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$throw RuntimeException()</ID>
    <ID>TooGenericExceptionThrown:CommandParsers.kt$AzureParser.RegionConverter$throw Error("Unknown azure region: $value")</ID>
    <ID>TooGenericExceptionThrown:ConfigObfuscator.kt$ConfigObfuscator$throw Exception("Unable to find machine's hardware address")</ID>
    <ID>TooGenericExceptionThrown:ConfigTest.kt$ConfigTest$throw Exception("Invalid config $it", e)</ID>
    <ID>TooGenericExceptionThrown:ContractHierarchyTest.kt$ContractHierarchyTest.IndirectContractParent$throw RuntimeException("Boom!")</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated exit of ${request.amount} from $issuer, however there is no cash to exit!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from $issuer, " + "however they only have $issuerQuantity!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from ${node.mainIdentity}, " + "however there is no cash from $issuer!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from ${node.mainIdentity}, " + "however they only have $senderQuantity!" )</ID>
    <ID>TooGenericExceptionThrown:FlowAsyncOperationTests.kt$FlowAsyncOperationTests.ErroredExecute$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:FlowFrameworkTests.kt$FlowFrameworkTests$throw Exception("Error")</ID>
    <ID>TooGenericExceptionThrown:FutureXCryptoService.kt$FutureXCryptoService.Companion$throw Exception("Error in ${cryptoServiceConf.toFile().absolutePath} : ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService.Companion$throw Exception("Error in ${cryptoServiceConf.toFile().absolutePath} : ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:Generator.kt$Generator$throw Exception("Failed to generate", error)</ID>
    <ID>TooGenericExceptionThrown:Main.kt$throw Exception(HsmErrors.errors[crypto.ErrorCode], exception)</ID>
    <ID>TooGenericExceptionThrown:MerkleTransaction.kt$FilteredTransaction$throw Exception("Malformed transaction, signers at index $internalIndex cannot be deserialised", e)</ID>
    <ID>TooGenericExceptionThrown:NodeConnection.kt$NodeConnection.ShellCommandOutput$throw Exception(diagnostic)</ID>
    <ID>TooGenericExceptionThrown:PhysicalLocationStructures.kt$CityDatabase$throw Exception("Could not parse line: $line")</ID>
    <ID>TooGenericExceptionThrown:PlatformSecureRandom.kt$LinuxSecureRandomSpi$throw RuntimeException("/dev/urandom not readable?")</ID>
    <ID>TooGenericExceptionThrown:PlatformSecureRandom.kt$LinuxSecureRandomSpi$throw RuntimeException(e)</ID>
    <ID>TooGenericExceptionThrown:PlatformSecureRandom.kt$PlatformSecureRandomService$throw RuntimeException("Never reached, but calms the compiler.")</ID>
    <ID>TooGenericExceptionThrown:PrimusXCryptoService.kt$PrimusXCryptoService.Companion$throw Exception("Error in ${cryptoServiceConf.toFile().absolutePath} : ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:RPCDriver.kt$RandomRpcUser.Companion$throw Exception("No generator for ${it.type}")</ID>
    <ID>TooGenericExceptionThrown:RpcExceptionHandlingTest.kt$ClientRelevantErrorFlow$throw Exception(message, SQLException("Oops!"))</ID>
    <ID>TooGenericExceptionThrown:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$throw Error("Observable serializer must be registerable with factory, unexpected exception - ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$throw Error("Serialization of observable should not throw - ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:RunOnceService.kt$RunOnceService$throw RuntimeException("Configuration Error: Node must wait longer than update rate otherwise someone else might be running!" + " Wait interval: $waitInterval, Update interval: $updateInterval")</ID>
    <ID>TooGenericExceptionThrown:SelfIssueTest.kt$throw Exception( "Simulated state diverged from actual state" + "\nSimulated state:\n${previousState.vaultsSelfIssued}" + "\nActual state:\n$selfIssueVaults" + "\nDiff:\n$diffString" )</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${payload::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SerializationOutputTests.kt$SerializationOutputTests$throw Error("Deserializing serialized \$C should not throw")</ID>
    <ID>TooGenericExceptionThrown:SerializationOutputTests.kt$SerializationOutputTests.&lt;no name provided&gt;$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:Settings.kt$Settings$throw Error("Missing 'classpath' property from config")</ID>
    <ID>TooGenericExceptionThrown:StateMachineDataModel.kt$StateMachineDataModel$throw Exception("State machine removed with unknown id ${update.id}")</ID>
    <ID>TooGenericExceptionThrown:UniversalContract.kt$UniversalContract$throw Error("Unable to evaluate")</ID>
    <ID>TooGenericExceptionThrown:UtimacoCryptoService.kt$UtimacoCryptoService.Companion$throw Exception("Error in ${configFile.toFile().absolutePath} : ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:WebServerConfig.kt$WebServerConfig$throw Exception("Missing rpc address property. Either 'rpcSettings' or 'rpcAddress' must be specified.")</ID>
    <ID>TooManyFunctions:AMQPBridgeManager.kt$AMQPBridgeManager$AMQPBridge</ID>
    <ID>TooManyFunctions:AMQPChannelHandler.kt$AMQPChannelHandler : ChannelDuplexHandler</ID>
    <ID>TooManyFunctions:AMQPTestUtils.kt$net.corda.serialization.internal.amqp.testutils.AMQPTestUtils.kt</ID>
    <ID>TooManyFunctions:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests</ID>
    <ID>TooManyFunctions:ANSIProgressRenderer.kt$ANSIProgressRenderer</ID>
    <ID>TooManyFunctions:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:ActionExecutorImpl.kt$ActionExecutorImpl : ActionExecutor</ID>
    <ID>TooManyFunctions:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>TooManyFunctions:ArtemisMessagingTest.kt$ArtemisMessagingTest</ID>
    <ID>TooManyFunctions:ArtemisTcpTransport.kt$ArtemisTcpTransport$Companion</ID>
    <ID>TooManyFunctions:AttachmentTests.kt$AttachmentTests : WithMockNet</ID>
    <ID>TooManyFunctions:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest</ID>
    <ID>TooManyFunctions:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests</ID>
    <ID>TooManyFunctions:AzureKeyVaultCryptoService.kt$AzureKeyVaultCryptoService : CryptoService</ID>
    <ID>TooManyFunctions:AzureKeyVaultCryptoServiceTest.kt$AzureKeyVaultCryptoServiceTest</ID>
    <ID>TooManyFunctions:BCCryptoService.kt$BCCryptoService : CryptoService</ID>
    <ID>TooManyFunctions:BCCryptoServiceTests.kt$BCCryptoServiceTests</ID>
    <ID>TooManyFunctions:BFTSmart.kt$BFTSmart$Replica : DefaultRecoverable</ID>
    <ID>TooManyFunctions:BaseTransaction.kt$BaseTransaction : NamedByHash</ID>
    <ID>TooManyFunctions:BridgeDriver.kt$net.corda.bridge.BridgeDriver.kt</ID>
    <ID>TooManyFunctions:BridgeIntegrationTest.kt$BridgeIntegrationTest</ID>
    <ID>TooManyFunctions:BridgeSmokeTest.kt$BridgeSmokeTest</ID>
    <ID>TooManyFunctions:BullyLeader.kt$BullyLeaderClient : ZkLeader</ID>
    <ID>TooManyFunctions:BullyLeaderTest.kt$BullyLeaderTest</ID>
    <ID>TooManyFunctions:ByteArrays.kt$ByteSequence : Comparable</ID>
    <ID>TooManyFunctions:CashTests.kt$CashTests</ID>
    <ID>TooManyFunctions:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests</ID>
    <ID>TooManyFunctions:CertificateStore.kt$CertificateStore : Iterable</ID>
    <ID>TooManyFunctions:CheckTestFlows.kt$CheckAllTheTestFlows</ID>
    <ID>TooManyFunctions:CheckpointAgent.kt$CheckpointHook : ClassFileTransformer</ID>
    <ID>TooManyFunctions:CheckpointDumper.kt$CheckpointDumper</ID>
    <ID>TooManyFunctions:ClassCarpenter.kt$ClassCarpenterImpl : ClassCarpenter</ID>
    <ID>TooManyFunctions:ClassCarpenterTest.kt$ClassCarpenterTest</ID>
    <ID>TooManyFunctions:ClassCarpenterTestUtils.kt$AmqpCarpenterBase</ID>
    <ID>TooManyFunctions:ClockUtilsTest.kt$ClockUtilsTest</ID>
    <ID>TooManyFunctions:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker</ID>
    <ID>TooManyFunctions:CompositeKey.kt$CompositeKey : PublicKey</ID>
    <ID>TooManyFunctions:CompositeKeyTests.kt$CompositeKeyTests</ID>
    <ID>TooManyFunctions:ConfigObfuscatorTest.kt$ConfigObfuscatorTest</ID>
    <ID>TooManyFunctions:ConfigParsingTest.kt$ConfigParsingTest</ID>
    <ID>TooManyFunctions:ConfigTest.kt$ConfigTest</ID>
    <ID>TooManyFunctions:ConfigUtilities.kt$net.corda.nodeapi.internal.config.ConfigUtilities.kt</ID>
    <ID>TooManyFunctions:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>TooManyFunctions:Configuration.kt$Configuration.Property.Definition$Companion</ID>
    <ID>TooManyFunctions:ConnectionStateMachine.kt$ConnectionStateMachine : BaseHandler</ID>
    <ID>TooManyFunctions:ConstraintsPropagationTests.kt$ConstraintsPropagationTests</ID>
    <ID>TooManyFunctions:ContractUpgradeFlowRPCTest.kt$ContractUpgradeFlowRPCTest : WithContractsWithFinality</ID>
    <ID>TooManyFunctions:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest : WithContractsWithFinality</ID>
    <ID>TooManyFunctions:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:CordaClassResolverTests.kt$CordaClassResolverTests</ID>
    <ID>TooManyFunctions:CordaFutureImpl.kt$net.corda.core.internal.concurrent.CordaFutureImpl.kt</ID>
    <ID>TooManyFunctions:CordaPersistence.kt$CordaPersistence : Closeable</ID>
    <ID>TooManyFunctions:CordaRPCClientTest.kt$CordaRPCClientTest : NodeBasedTest</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$CordaRPCOps : RPCOps</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$net.corda.core.messaging.CordaRPCOps.kt</ID>
    <ID>TooManyFunctions:CordaRPCOpsImpl.kt$CordaRPCOpsImpl : InternalCordaRPCOpsAutoCloseable</ID>
    <ID>TooManyFunctions:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest</ID>
    <ID>TooManyFunctions:CordaRPCProxyClient.kt$CordaRPCProxyClient : CordaRPCOps</ID>
    <ID>TooManyFunctions:CordaRpcWorkerOps.kt$CordaRpcWorkerOps : CordaRPCOps</ID>
    <ID>TooManyFunctions:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>TooManyFunctions:CordaX500NameTest.kt$CordaX500NameTest</ID>
    <ID>TooManyFunctions:Crypto.kt$Crypto</ID>
    <ID>TooManyFunctions:CryptoServiceSpec.kt$CryptoServiceSpec</ID>
    <ID>TooManyFunctions:CryptoUtils.kt$net.corda.core.crypto.CryptoUtils.kt</ID>
    <ID>TooManyFunctions:CryptoUtilsTest.kt$CryptoUtilsTest</ID>
    <ID>TooManyFunctions:Currencies.kt$com.r3.corda.enterprise.perftestcordapp.Currencies.kt</ID>
    <ID>TooManyFunctions:Currencies.kt$net.corda.finance.Currencies.kt</ID>
    <ID>TooManyFunctions:DBTransactionStorage.kt$DBTransactionStorage : WritableTransactionStorageSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:DBTransactionStorageTests.kt$DBTransactionStorageTests</ID>
    <ID>TooManyFunctions:DelegatedKeystore.kt$DelegatedKeystore : KeyStoreSpi</ID>
    <ID>TooManyFunctions:DeserializeMapTests.kt$DeserializeMapTests</ID>
    <ID>TooManyFunctions:DeserializeNeedingCarpentrySimpleTypesTest.kt$DeserializeNeedingCarpentrySimpleTypesTest : AmqpCarpenterBase</ID>
    <ID>TooManyFunctions:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests</ID>
    <ID>TooManyFunctions:Driver.kt$DriverParameters</ID>
    <ID>TooManyFunctions:DriverDSLImpl.kt$DriverDSLImpl : InternalDriverDSL</ID>
    <ID>TooManyFunctions:DriverTests.kt$DriverTests : IntegrationTest</ID>
    <ID>TooManyFunctions:DualNodeBaseFlowSampler.kt$DualNodeBaseFlowSampler : AbstractJavaSamplerClient</ID>
    <ID>TooManyFunctions:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>TooManyFunctions:EnterpriseNode.kt$EnterpriseNode : Node</ID>
    <ID>TooManyFunctions:EnumEvolvabilityTests.kt$EnumEvolvabilityTests</ID>
    <ID>TooManyFunctions:EnumTests.kt$EnumTests</ID>
    <ID>TooManyFunctions:EventProcessor.kt$EventProcessor : BaseHandler</ID>
    <ID>TooManyFunctions:EvolvabilityTests.kt$EvolvabilityTests</ID>
    <ID>TooManyFunctions:Expect.kt$net.corda.testing.core.Expect.kt</ID>
    <ID>TooManyFunctions:FiberMonitor.kt$FiberMonitor</ID>
    <ID>TooManyFunctions:FloatControlListenerService.kt$FloatControlListenerService : FloatControlServiceServiceStateSupport</ID>
    <ID>TooManyFunctions:FlowFrameworkTests.kt$FlowFrameworkTests</ID>
    <ID>TooManyFunctions:FlowHookContainer.kt$FlowHookContainer</ID>
    <ID>TooManyFunctions:FlowLogic.kt$FlowLogic&lt;out T&gt;</ID>
    <ID>TooManyFunctions:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl : SingletonSerializeAsTokenFlowLogicRefFactory</ID>
    <ID>TooManyFunctions:FlowSessionImpl.kt$FlowSessionImpl : FlowSession</ID>
    <ID>TooManyFunctions:FlowStateMachineImpl.kt$FlowStateMachineImpl&lt;R&gt; : FiberFlowStateMachineFlowFiber</ID>
    <ID>TooManyFunctions:FlowWorkerServiceHub.kt$FlowWorkerServiceHub : ServiceHubInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:FlowWorkerStartStopTest.kt$FlowWorkerStartStopTest</ID>
    <ID>TooManyFunctions:FutureXCryptoService.kt$FutureXCryptoService : JCACryptoService</ID>
    <ID>TooManyFunctions:GemaltoLunaCryptoService.kt$GemaltoLunaCryptoService : JCACryptoService</ID>
    <ID>TooManyFunctions:Generator.kt$Generator$Companion</ID>
    <ID>TooManyFunctions:GenericsTests.kt$GenericsTests</ID>
    <ID>TooManyFunctions:HibernateConfigurationTest.kt$HibernateConfigurationTest</ID>
    <ID>TooManyFunctions:HibernateEntityManagerFactoryProvider.kt$PersistenceOptions : PersistenceUnitInfo</ID>
    <ID>TooManyFunctions:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser : AbstractQueryCriteriaParserIQueryCriteriaParser</ID>
    <ID>TooManyFunctions:HibernateStatistics.kt$DelegatingStatisticsService : StatisticsService</ID>
    <ID>TooManyFunctions:HsmSimulator.kt$HsmSimulator : ExternalResource</ID>
    <ID>TooManyFunctions:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>TooManyFunctions:IRSDemoTest.kt$IRSDemoTest : IntegrationTest</ID>
    <ID>TooManyFunctions:IRSTests.kt$IRSTests</ID>
    <ID>TooManyFunctions:IdentityService.kt$IdentityService</ID>
    <ID>TooManyFunctions:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests</ID>
    <ID>TooManyFunctions:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork : SingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest</ID>
    <ID>TooManyFunctions:InteractiveShell.kt$InteractiveShell</ID>
    <ID>TooManyFunctions:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest : IntegrationTest</ID>
    <ID>TooManyFunctions:InteractiveShellTest.kt$InteractiveShellTest</ID>
    <ID>TooManyFunctions:InternalMockNetwork.kt$InternalMockNetwork : AutoCloseable</ID>
    <ID>TooManyFunctions:InternalMockNetwork.kt$InternalMockNetwork$MockNode : AbstractNode</ID>
    <ID>TooManyFunctions:InternalTestUtils.kt$net.corda.testing.internal.InternalTestUtils.kt</ID>
    <ID>TooManyFunctions:InternalTestUtils.kt$net.corda.testing.node.internal.InternalTestUtils.kt</ID>
    <ID>TooManyFunctions:InternalUtils.kt$net.corda.core.internal.InternalUtils.kt</ID>
    <ID>TooManyFunctions:InternalUtilsTest.kt$InternalUtilsTest</ID>
    <ID>TooManyFunctions:JCACryptoService.kt$JCACryptoService : CryptoService</ID>
    <ID>TooManyFunctions:JPAUniquenessProvider.kt$JPAUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:JacksonSupportTest.kt$JacksonSupportTest</ID>
    <ID>TooManyFunctions:JarScanningCordappLoader.kt$JarScanningCordappLoader : CordappLoaderTemplate</ID>
    <ID>TooManyFunctions:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest</ID>
    <ID>TooManyFunctions:JarSignatureCollectorTest.kt$JarSignatureCollectorTest</ID>
    <ID>TooManyFunctions:KryoTests.kt$KryoTests</ID>
    <ID>TooManyFunctions:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>TooManyFunctions:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests</ID>
    <ID>TooManyFunctions:Literal.kt$ContractBuilder</ID>
    <ID>TooManyFunctions:LocalSerializerFactory.kt$DefaultLocalSerializerFactory : LocalSerializerFactory</ID>
    <ID>TooManyFunctions:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>TooManyFunctions:LogProcessor.kt$LogProcessor</ID>
    <ID>TooManyFunctions:LoggingFirewallAuditService.kt$LoggingFirewallAuditService : FirewallAuditServiceServiceStateSupport</ID>
    <ID>TooManyFunctions:MQSecurityTest.kt$MQSecurityTest : NodeBasedTest</ID>
    <ID>TooManyFunctions:Main.kt$Node</ID>
    <ID>TooManyFunctions:Matchers.kt$net.corda.testing.internal.matchers.Matchers.kt</ID>
    <ID>TooManyFunctions:MockAttachmentStorage.kt$MockAttachmentStorage : AttachmentStorageSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:MockCryptoService.kt$MockCryptoService : CryptoService</ID>
    <ID>TooManyFunctions:MockNodeMessagingService.kt$MockNodeMessagingService : SingletonSerializeAsTokenMessagingService</ID>
    <ID>TooManyFunctions:MockServices.kt$MockServices : ServiceHub</ID>
    <ID>TooManyFunctions:MultiThreadedStateMachineManager.kt$MultiThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>TooManyFunctions:MySQLNotaryServiceTests.kt$MySQLNotaryServiceTests : IntegrationTest</ID>
    <ID>TooManyFunctions:MySQLUniquenessProvider.kt$MySQLUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:NettyWritable.kt$NettyWritable : WritableBuffer</ID>
    <ID>TooManyFunctions:NetworkBootstrapper.kt$NetworkBootstrapper : NetworkBootstrapperWithOverridableParameters</ID>
    <ID>TooManyFunctions:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests</ID>
    <ID>TooManyFunctions:NetworkBootstrapperTest.kt$NetworkBootstrapperTest</ID>
    <ID>TooManyFunctions:NetworkBuilder.kt$NetworkBuilder</ID>
    <ID>TooManyFunctions:NetworkBuilder.kt$NetworkBuilderImpl : NetworkBuilder</ID>
    <ID>TooManyFunctions:NetworkMapCache.kt$NetworkMapCacheBase</ID>
    <ID>TooManyFunctions:NetworkMapHttpProxyTest.kt$NetworkMapHttpProxyTest</ID>
    <ID>TooManyFunctions:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest</ID>
    <ID>TooManyFunctions:NetworkRegistrationHelper.kt$NetworkRegistrationHelper</ID>
    <ID>TooManyFunctions:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest</ID>
    <ID>TooManyFunctions:Node.kt$Node : AbstractNode</ID>
    <ID>TooManyFunctions:NodeAttachmentService.kt$NodeAttachmentService : AttachmentStorageInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest</ID>
    <ID>TooManyFunctions:NodeConfigurationImplTest.kt$NodeConfigurationImplTest</ID>
    <ID>TooManyFunctions:NodeConnection.kt$NodeConnection : Closeable</ID>
    <ID>TooManyFunctions:NodeController.kt$NodeController : Controller</ID>
    <ID>TooManyFunctions:NodeControllerTest.kt$NodeControllerTest</ID>
    <ID>TooManyFunctions:NodeInterestRatesTest.kt$NodeInterestRatesTest</ID>
    <ID>TooManyFunctions:NodeParameters.kt$NodeParameters</ID>
    <ID>TooManyFunctions:NodeSchedulerServiceTest.kt$NodeSchedulerServiceTest : NodeSchedulerServiceTestBase</ID>
    <ID>TooManyFunctions:NodeStartup.kt$NodeStartup : NodeStartupLogging</ID>
    <ID>TooManyFunctions:NodeTerminalView.kt$NodeTerminalView : Fragment</ID>
    <ID>TooManyFunctions:NodeVaultService.kt$NodeVaultService : SingletonSerializeAsTokenVaultServiceInternal</ID>
    <ID>TooManyFunctions:NodeVaultServiceTest.kt$NodeVaultServiceTest</ID>
    <ID>TooManyFunctions:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests</ID>
    <ID>TooManyFunctions:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:NotaryWhitelistTests.kt$NotaryWhitelistTests</ID>
    <ID>TooManyFunctions:OGSwapPricingExample.kt$SwapPricingExample</ID>
    <ID>TooManyFunctions:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>TooManyFunctions:ObservablesTests.kt$ObservablesTests</ID>
    <ID>TooManyFunctions:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests</ID>
    <ID>TooManyFunctions:P2PMessageDeduplicatorTest.kt$P2PMessageDeduplicatorTest</ID>
    <ID>TooManyFunctions:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>TooManyFunctions:PartialMerkleTreeTest.kt$PartialMerkleTreeTest</ID>
    <ID>TooManyFunctions:PathUtils.kt$net.corda.core.internal.PathUtils.kt</ID>
    <ID>TooManyFunctions:Perceivable.kt$net.corda.finance.contracts.universal.Perceivable.kt</ID>
    <ID>TooManyFunctions:PersistentIdentityService.kt$PersistentIdentityService : SingletonSerializeAsTokenIdentityService</ID>
    <ID>TooManyFunctions:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests</ID>
    <ID>TooManyFunctions:PersistentNetworkMapCache.kt$PersistentNetworkMapCache : NetworkMapCacheInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:PortfolioApi.kt$PortfolioApi</ID>
    <ID>TooManyFunctions:PrimusXCryptoService.kt$PrimusXCryptoService : JCACryptoService</ID>
    <ID>TooManyFunctions:PrioritizedLeaderLatch.kt$PrioritizedLeaderLatch : Closeable</ID>
    <ID>TooManyFunctions:PrivatePropertyTests.kt$PrivatePropertyTests</ID>
    <ID>TooManyFunctions:Program.kt$net.corda.healthsurvey.Program.kt</ID>
    <ID>TooManyFunctions:ProgressTracker.kt$ProgressTracker</ID>
    <ID>TooManyFunctions:ProgressTrackerTest.kt$ProgressTrackerTest</ID>
    <ID>TooManyFunctions:PropertyDescriptor.kt$net.corda.serialization.internal.amqp.PropertyDescriptor.kt</ID>
    <ID>TooManyFunctions:PropertyTest.kt$PropertyTest</ID>
    <ID>TooManyFunctions:PropertyValidationTest.kt$PropertyValidationTest</ID>
    <ID>TooManyFunctions:ProtonWrapperTests.kt$ProtonWrapperTests</ID>
    <ID>TooManyFunctions:PublicKeyToOwningIdentityCacheImplTest.kt$PublicKeyToOwningIdentityCacheImplTest</ID>
    <ID>TooManyFunctions:QueryCriteria.kt$QueryCriteria$VaultQueryCriteria : CommonQueryCriteria</ID>
    <ID>TooManyFunctions:QueryCriteriaUtils.kt$Builder</ID>
    <ID>TooManyFunctions:RPCApi.kt$net.corda.nodeapi.RPCApi.kt</ID>
    <ID>TooManyFunctions:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>TooManyFunctions:RPCDriver.kt$RPCDriverDSL : InternalDriverDSL</ID>
    <ID>TooManyFunctions:RPCPermissionsTests.kt$RPCPermissionsTests : AbstractRPCTest</ID>
    <ID>TooManyFunctions:RPCProxyWebServiceTest.kt$RPCProxyWebServiceTest</ID>
    <ID>TooManyFunctions:RPCSecurityManagerTest.kt$RPCSecurityManagerTest</ID>
    <ID>TooManyFunctions:RPCServer.kt$RPCServer&lt;OPS : RPCOps&gt;</ID>
    <ID>TooManyFunctions:RPCStabilityTests.kt$RPCStabilityTests</ID>
    <ID>TooManyFunctions:ReadOnlyBackedObservableMapBase.kt$ReadOnlyBackedObservableMapBase&lt;K, A, B&gt; : ObservableMap</ID>
    <ID>TooManyFunctions:ResolveStatePointersTest.kt$ResolveStatePointersTest</ID>
    <ID>TooManyFunctions:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest</ID>
    <ID>TooManyFunctions:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL : InternalDriverDSL</ID>
    <ID>TooManyFunctions:RpcWorkerServiceHub.kt$RpcWorkerServiceHub : ServiceHubInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:RunOnceServiceTest.kt$RunOnceServiceTest</ID>
    <ID>TooManyFunctions:SSLHelper.kt$net.corda.nodeapi.internal.protonwrapper.netty.SSLHelper.kt</ID>
    <ID>TooManyFunctions:SerializationAPI.kt$SerializationContext</ID>
    <ID>TooManyFunctions:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>TooManyFunctions:SerializationOutput.kt$SerializationOutput</ID>
    <ID>TooManyFunctions:SerializationOutputTests.kt$SerializationOutputTests</ID>
    <ID>TooManyFunctions:SerializationScheme.kt$SerializationContextImpl : SerializationContext</ID>
    <ID>TooManyFunctions:ServiceHub.kt$ServiceHub : ServicesForResolution</ID>
    <ID>TooManyFunctions:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>TooManyFunctions:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>TooManyFunctions:SocksTests.kt$SocksTests</ID>
    <ID>TooManyFunctions:StandaloneCordaRPClientTest.kt$StandaloneCordaRPClientTest</ID>
    <ID>TooManyFunctions:StandaloneJPAUniquenessProvider.kt$StandaloneJPAUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:StandaloneJPAUniquenessProviderTests.kt$StandaloneJPAUniquenessProviderTests</ID>
    <ID>TooManyFunctions:StandardConfigValueParsers.kt$net.corda.node.services.config.schema.parsers.StandardConfigValueParsers.kt</ID>
    <ID>TooManyFunctions:StartedFlowTransition.kt$StartedFlowTransition : Transition</ID>
    <ID>TooManyFunctions:StatusTransitionsTest.kt$StatusTransitionsTest</ID>
    <ID>TooManyFunctions:TLSAuthenticationTests.kt$TLSAuthenticationTests</ID>
    <ID>TooManyFunctions:TestDSL.kt$TestLedgerDSLInterpreter : LedgerDSLInterpreter</ID>
    <ID>TooManyFunctions:TestDSL.kt$TestTransactionDSLInterpreter : TransactionDSLInterpreterOutputStateLookup</ID>
    <ID>TooManyFunctions:TestLauncherHelpers.kt$TestLauncherHelpers</ID>
    <ID>TooManyFunctions:TopLevelTransition.kt$TopLevelTransition : Transition</ID>
    <ID>TooManyFunctions:TransactionBuilder.kt$TransactionBuilder</ID>
    <ID>TooManyFunctions:TransactionDSLInterpreter.kt$TransactionDSL&lt;out T : TransactionDSLInterpreter&gt; : TransactionDSLInterpreter</ID>
    <ID>TooManyFunctions:TransactionVerificationExceptionSerialisationTests.kt$TransactionVerificationExceptionSerialisationTests</ID>
    <ID>TooManyFunctions:TransactionVerifierServiceInternal.kt$Verifier</ID>
    <ID>TooManyFunctions:TutorialTestDSL.kt$TutorialTestDSL</ID>
    <ID>TooManyFunctions:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests</ID>
    <ID>TooManyFunctions:TypeModellingFingerPrinter.kt$FingerPrintingState</ID>
    <ID>TooManyFunctions:UniquenessProviderTests.kt$UniquenessProviderTests</ID>
    <ID>TooManyFunctions:UniversalContract.kt$UniversalContract : Contract</ID>
    <ID>TooManyFunctions:Util.kt$net.corda.finance.contracts.universal.Util.kt</ID>
    <ID>TooManyFunctions:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>TooManyFunctions:UtimacoCryptoService.kt$UtimacoCryptoService : CryptoService</ID>
    <ID>TooManyFunctions:UtimacoCryptoServiceIntegrationTest.kt$UtimacoCryptoServiceIntegrationTest : CryptoServiceSpec</ID>
    <ID>TooManyFunctions:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests</ID>
    <ID>TooManyFunctions:VaultFiller.kt$VaultFiller</ID>
    <ID>TooManyFunctions:VaultQueryTests.kt$VaultQueryTestsBase : VaultQueryParties</ID>
    <ID>TooManyFunctions:VaultService.kt$VaultService</ID>
    <ID>TooManyFunctions:VaultService.kt$net.corda.core.node.services.VaultService.kt</ID>
    <ID>TooManyFunctions:VaultStateMigrationTest.kt$VaultStateMigrationTest</ID>
    <ID>TooManyFunctions:WhitelistGeneratorTest.kt$WhitelistGeneratorTest</ID>
    <ID>TooManyFunctions:WithContracts.kt$WithContracts : WithMockNet</ID>
    <ID>TooManyFunctions:X509EdDSAEngine.kt$X509EdDSAEngine : Signature</ID>
    <ID>TooManyFunctions:X509KeyStore.kt$X509KeyStore</ID>
    <ID>TooManyFunctions:X509Utilities.kt$X509Utilities</ID>
    <ID>TooManyFunctions:X509UtilitiesTest.kt$X509UtilitiesTest</ID>
    <ID>TooManyFunctions:ZkClientTest.kt$ZkClientTests</ID>
    <ID>TopLevelPropertyNaming:AMQPSerializationScheme.kt$val AMQP_ENABLED get() = SerializationDefaults.P2P_CONTEXT.preferredSerializationVersion == amqpMagic</ID>
    <ID>TopLevelPropertyNaming:AbstractAttachment.kt$// We whitelist sources of transaction JARs for now as a temporary state until the DJVM and other security sandboxes // have been integrated, at which point we'll be able to run untrusted code downloaded over the network and this mechanism // can be removed. Because we ARE downloading attachments over the P2P network in anticipation of this upgrade, we // track the source of each attachment in our store. TestDSL is used by LedgerDSLInterpreter when custom attachments // are added in unit test code. val TRUSTED_UPLOADERS = listOf(DEPLOYED_CORDAPP_UPLOADER, RPC_UPLOADER, TESTDSL_UPLOADER)</ID>
    <ID>TopLevelPropertyNaming:BlobWriter.kt$val BLOB_WRITER_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, AllWhitelist, emptyMap(), true, SerializationContext.UseCase.P2P, null )</ID>
    <ID>TopLevelPropertyNaming:Cap.kt$internal val DUMMY_NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 20).party</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** A dummy, randomly generated issuer party by the name of "Snake Oil Issuer" */ val DUMMY_CASH_ISSUER by lazy { Party(DUMMY_CASH_ISSUER_NAME, DUMMY_CASH_ISSUER_KEY.public).ref(1) }</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** A dummy, randomly generated issuer party by the name of "Snake Oil Issuer" */ val DUMMY_CASH_ISSUER_NAME = CordaX500Name(organisation = "Snake Oil Issuer", locality = "London", country = "GB")</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** A randomly generated key. */ val DUMMY_CASH_ISSUER_KEY by lazy { entropyToKeyPair(BigInteger.valueOf(10)) }</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** An extension property that lets you get a cash state from an issued token, under the [NULL_PARTY] */ val Amount&lt;Issued&lt;Currency&gt;&gt;.STATE: Cash.State get() = Cash.State(this, NULL_PARTY)</ID>
    <ID>TopLevelPropertyNaming:Cash.kt$/** An extension property that lets you write 100.DOLLARS.CASH */ val Amount&lt;Currency&gt;.CASH: Cash.State get() = Cash.State(Amount(quantity, Issued(DUMMY_CASH_ISSUER, token)), NULL_PARTY)</ID>
    <ID>TopLevelPropertyNaming:ClientContexts.kt$val AMQP_RPC_CLIENT_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.RPCClient, null, lenientCarpenterEnabled = true )</ID>
    <ID>TopLevelPropertyNaming:CommercialPaper.kt$/** * This is an ultra-trivial implementation of commercial paper, which is essentially a simpler version of a corporate * bond. It can be seen as a company-specific currency. A company issues CP with a particular face value, say $100, * but sells it for less, say $90. The paper can be redeemed for cash at a given date in the future. Thus this example * would have a 10% interest rate with a single repayment. Commercial paper is often rolled over (the maturity date * is adjusted as if the paper was redeemed and immediately repurchased, but without having to front the cash). * * This contract is not intended to realistically model CP. It is here only to act as a next step up above cash in * the prototyping phase. It is thus very incomplete. * * Open issues: * - In this model, you cannot merge or split CP. Can you do this normally? We could model CP as a specialised form * of cash, or reuse some of the cash code? Waiting on response from Ayoub and Rajar about whether CP can always * be split/merged or only in secondary markets. Even if current systems can't do this, would it be a desirable * feature to have anyway? * - The funding steps of CP is totally ignored in this model. * - No attention is paid to the existing roles of custodians, funding banks, etc. * - There are regional variations on the CP concept, for instance, American CP requires a special "CUSIP number" * which may need to be tracked. That, in turn, requires validation logic (there is a bean validator that knows how * to do this in the Apache BVal project). */ val CP_PROGRAM_ID = "com.r3.corda.enterprise.perftestcordapp.contracts.CommercialPaper"</ID>
    <ID>TopLevelPropertyNaming:CommercialPaperTests.kt$private val MEGA_CORP get() = megaCorp.party</ID>
    <ID>TopLevelPropertyNaming:CommercialPaperTests.kt$private val MEGA_CORP_PUBKEY get() = megaCorp.keyPair.public</ID>
    <ID>TopLevelPropertyNaming:ConcurrencyUtils.kt$@VisibleForTesting internal const val shortCircuitedTaskFailedMessage = "Short-circuited task failed:"</ID>
    <ID>TopLevelPropertyNaming:ContractDefinition.kt$// Currencies val USD: Currency = Currency.getInstance("USD")</ID>
    <ID>TopLevelPropertyNaming:ContractDefinition.kt$val EUR: Currency = Currency.getInstance("EUR")</ID>
    <ID>TopLevelPropertyNaming:ContractDefinition.kt$val GBP: Currency = Currency.getInstance("GBP")</ID>
    <ID>TopLevelPropertyNaming:ContractDefinition.kt$val KRW: Currency = Currency.getInstance("KRW")</ID>
    <ID>TopLevelPropertyNaming:CordaPersistence.kt$internal val _prohibitDatabaseAccess = ThreadLocal.withInitial { false }</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val CHF: Currency = Currency.getInstance("CHF")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val EUR: Currency = Currency.getInstance("EUR")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val GBP: Currency = Currency.getInstance("GBP")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val JPY: Currency = Currency.getInstance("JPY")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val RUB: Currency = Currency.getInstance("RUB")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$@JvmField val USD: Currency = Currency.getInstance("USD")</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Double.DOLLARS: Amount&lt;Currency&gt; get() = DOLLARS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Double.POUNDS: Amount&lt;Currency&gt; get() = POUNDS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Double.SWISS_FRANCS: Amount&lt;Currency&gt; get() = SWISS_FRANCS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Int.DOLLARS: Amount&lt;Currency&gt; get() = DOLLARS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Int.POUNDS: Amount&lt;Currency&gt; get() = POUNDS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Int.SWISS_FRANCS: Amount&lt;Currency&gt; get() = SWISS_FRANCS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Long.DOLLARS: Amount&lt;Currency&gt; get() = DOLLARS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Long.POUNDS: Amount&lt;Currency&gt; get() = POUNDS(this)</ID>
    <ID>TopLevelPropertyNaming:Currencies.kt$val Long.SWISS_FRANCS: Amount&lt;Currency&gt; get() = SWISS_FRANCS(this)</ID>
    <ID>TopLevelPropertyNaming:DatabaseTestContainers.kt$/** Password with complexity required by SQLServer */ const val strongPassword = "1Secure*Password1"</ID>
    <ID>TopLevelPropertyNaming:FinanceWorkflowsUtils.kt$val TEST_CALENDAR_NAMES = listOf("London", "NewYork")</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val DUMMY_NOTARY get() = dummyNotary.party</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val DUMMY_PARTY = Party(CordaX500Name("Dummy", "Madrid", "ES"), generateKeyPair().public)</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val MEGA_CORP get() = megaCorp.party</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val MEGA_CORP_PUBKEY get() = megaCorp.publicKey</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val MINI_CORP get() = miniCorp.party</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val ORACLE_PUBKEY = TestIdentity(CordaX500Name("Oracle", "London", "GB")).publicKey</ID>
    <ID>TopLevelPropertyNaming:IRSTests.kt$private val TEST_TX_TIME = Instant.parse("2015-04-17T12:00:00.00Z")</ID>
    <ID>TopLevelPropertyNaming:InternalMockNetwork.kt$val MOCK_VERSION_INFO = VersionInfo(PLATFORM_VERSION, "Mock release", "Mock revision", "Mock Vendor")</ID>
    <ID>TopLevelPropertyNaming:InternalTestConstants.kt$/** A dummy time at which we will be pretending test transactions are created. **/ @JvmField val TEST_TX_TIME: Instant = Instant.parse("2015-04-17T12:00:00.00Z")</ID>
    <ID>TopLevelPropertyNaming:InternalTestConstants.kt$val DEV_INTERMEDIATE_CA: CertificateAndKeyPair by lazy { net.corda.nodeapi.internal.DEV_INTERMEDIATE_CA }</ID>
    <ID>TopLevelPropertyNaming:InternalTestConstants.kt$val DEV_ROOT_CA: CertificateAndKeyPair by lazy { net.corda.nodeapi.internal.DEV_ROOT_CA }</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$/** * *Custom* CorDapp containing the contents of the `net.corda.testing.contracts` package, i.e. the dummy contracts. This is not a real CorDapp * in the way that [FINANCE_CONTRACTS_CORDAPP] and [FINANCE_WORKFLOWS_CORDAPP] are. */ @JvmField val DUMMY_CONTRACTS_CORDAPP: CustomCordapp = cordappWithPackages("net.corda.testing.contracts")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$/** * Reference to the finance-contracts CorDapp in this repo. The metadata is taken directly from finance/contracts/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.contracts")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the flows as well. */ @JvmField val FINANCE_CONTRACTS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.contracts")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$/** * Reference to the finance-workflows CorDapp in this repo. The metadata is taken directly from finance/workflows/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.flows")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the contract classes as well. */ @JvmField val FINANCE_WORKFLOWS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.workflows")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$@JvmField val BUSINESS_NETWORK_CORDAPP: TestCordappImpl = findCordapp("net.corda.sample.businessnetwork")</ID>
    <ID>TopLevelPropertyNaming:InternalTestUtils.kt$@JvmField val FINANCE_CORDAPPS: Set&lt;TestCordappImpl&gt; = setOf(FINANCE_CONTRACTS_CORDAPP, FINANCE_WORKFLOWS_CORDAPP)</ID>
    <ID>TopLevelPropertyNaming:InternalUtils.kt$val DEFAULT_HTTP_CONNECT_TIMEOUT = 30.seconds.toMillis()</ID>
    <ID>TopLevelPropertyNaming:InternalUtils.kt$val DEFAULT_HTTP_READ_TIMEOUT = 30.seconds.toMillis()</ID>
    <ID>TopLevelPropertyNaming:KeyStoreConfigHelpers.kt$val DEV_INTERMEDIATE_CA: CertificateAndKeyPair get() = DevCaHelper.loadDevCa(X509Utilities.CORDA_INTERMEDIATE_CA)</ID>
    <ID>TopLevelPropertyNaming:KeyStoreConfigHelpers.kt$val DEV_PUB_KEY_HASHES: List&lt;SecureHash.SHA256&gt; get() = listOf(DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate).map { it.publicKey.hash.sha256() } + SecureHash.parse(DEV_CORDAPP_CODE_SIGNING_STR).sha256()</ID>
    <ID>TopLevelPropertyNaming:KeyStoreConfigHelpers.kt$val DEV_ROOT_CA: CertificateAndKeyPair get() = DevCaHelper.loadDevCa(X509Utilities.CORDA_ROOT_CA)</ID>
    <ID>TopLevelPropertyNaming:KryoCheckpointSerializer.kt$val KRYO_CHECKPOINT_CONTEXT = CheckpointSerializationContextImpl( SerializationDefaults.javaClass.classLoader, QuasarWhitelist, emptyMap(), true, SNAPPY, AlwaysAcceptEncodingWhitelist )</ID>
    <ID>TopLevelPropertyNaming:Literal.kt$val Int.K: BigDecimal get() = BigDecimal(this) * BigDecimal(1000)</ID>
    <ID>TopLevelPropertyNaming:Literal.kt$val Int.M: BigDecimal get() = BigDecimal(this) * BigDecimal(1000000)</ID>
    <ID>TopLevelPropertyNaming:Metrics.kt$private val X500CleanUpRegex = Regex("[^a-zA-Z\\d]")</ID>
    <ID>TopLevelPropertyNaming:NodeConfiguration.kt$val Int.KB: Long get() = this * 1024L</ID>
    <ID>TopLevelPropertyNaming:NodeConfiguration.kt$val Int.MB: Long get() = this * 1024L * 1024L</ID>
    <ID>TopLevelPropertyNaming:Program.kt$private const val version = "1.0"</ID>
    <ID>TopLevelPropertyNaming:ProviderMap.kt$// OID taken from https://tools.ietf.org/html/draft-ietf-curdle-pkix-00 val `id-Curve25519ph` = ASN1ObjectIdentifier("1.3.101.112")</ID>
    <ID>TopLevelPropertyNaming:RPCServer.kt$// TODO replace this by creating a new CordaRPCImpl for each request, passing the context, after we fix Shell and WebServer @JvmField internal val CURRENT_RPC_CONTEXT: ThreadLocal&lt;RpcAuthContext&gt; = CurrentRpcContext()</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _allEnabledSerializationEnvs: List&lt;Pair&lt;String, SerializationEnvironment&gt;&gt; get() = serializationEnvFields.mapNotNull { it.get()?.let { env -&gt; Pair(it.name, env) } }</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _contextSerializationEnv = ThreadLocalToggleField&lt;SerializationEnvironment&gt;("contextSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _driverSerializationEnv = SimpleToggleField&lt;SerializationEnvironment&gt;("driverSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>TopLevelPropertyNaming:SerializationFormat.kt$const val encodingNotPermittedFormat = "Encoding not permitted: %s"</ID>
    <ID>TopLevelPropertyNaming:SerializationSchemaTests.kt$// Make sure all serialization calls in this test don't get stomped on by anything else val TESTING_CONTEXT = SerializationContextImpl(amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.Testing, null)</ID>
    <ID>TopLevelPropertyNaming:ServerContexts.kt$val AMQP_RPC_SERVER_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.RPCServer, null, lenientCarpenterEnabled = true )</ID>
    <ID>TopLevelPropertyNaming:ServerContexts.kt$val AMQP_STORAGE_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, AllButBlacklisted, emptyMap(), true, SerializationContext.UseCase.Storage, null, AlwaysAcceptEncodingWhitelist )</ID>
    <ID>TopLevelPropertyNaming:SharedContexts.kt$val AMQP_P2P_CONTEXT = SerializationContextImpl( amqpMagic, SerializationDefaults.javaClass.classLoader, GlobalTransientClassWhiteList(BuiltInExceptionsWhitelist()), emptyMap(), true, SerializationContext.UseCase.P2P, null )</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val ALICE = ALICE_ID.party</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val ALICE_ID = TestIdentity(CordaX500Name.parse("L=London,O=Alice Ltd,OU=Trade,C=GB"))</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val ALICE_PUBKEY = ALICE_ID.publicKey</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val BIGCORP_ID = TestIdentity(CordaX500Name.parse("L=New York,O=Bigcorp Ltd,OU=Trade,C=US"))</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val BIG_CORP = BIGCORP_ID.party</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val BIG_CORP_PUBKEY = BIGCORP_ID.publicKey</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val BOB = BOB_ID.party</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val BOB_ID = TestIdentity(CordaX500Name.parse("L=London,O=Bob Ltd,OU=Trade,C=GB"))</ID>
    <ID>TopLevelPropertyNaming:StatusTransitionsTest.kt$private val BOB_PUBKEY = BOB_ID.publicKey</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val ALICE_NAME = CordaX500Name("Alice Corp", "Madrid", "ES")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val BOB_NAME = CordaX500Name("Bob Plc", "Rome", "IT")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val BOC_NAME = CordaX500Name("BankOfCorda", "London", "GB")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val CHARLIE_NAME = CordaX500Name("Charlie Ltd", "Athens", "GR")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val DUMMY_BANK_A_NAME = CordaX500Name("Bank A", "London", "GB")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val DUMMY_BANK_B_NAME = CordaX500Name("Bank B", "New York", "US")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test node name **/ @JvmField val DUMMY_BANK_C_NAME = CordaX500Name("Bank C", "Tokyo", "JP")</ID>
    <ID>TopLevelPropertyNaming:TestConstants.kt$/** A test notary name **/ @JvmField val DUMMY_NOTARY_NAME = CordaX500Name("Notary Service", "Zurich", "CH")</ID>
    <ID>TopLevelPropertyNaming:main.kt$const val confInfo = """ Typical pinger.conf values: parallelFlows = 10 waitDoneTime = 60 nodeConnection = "localhost:10130" rpcUser = "user" rpcPassword = "password" targetPeers = ["O=Bank B, L=London, C=GB"] notary = "O=Notary, L=London, C=GB" """</ID>
    <ID>TopLevelPropertyNaming:main.kt$const val generalInfo = """ This tool is intended to be configured via a pinger.conf file, rather than command line options The intended operation of this tool is that it is run to push a set of parallel flows to one or more remote nodes. Testing should then commence in which the peer to peer communication is interrupted e.g kill bridge. The flow processing will become blocked during the interuption, but should restore once full connectivity re-establishes At this point the tester should issue a Ctrl-C command. No new flows will be submitted and a 60 second grace period is given for the flows to halt. Any flow still pending at the end of this will be logged by flow id. In its current implementation we do not handle RPC disconnects, or audit the resulting vault. """</ID>
    <ID>VariableNaming:AMQPBridgeTest.kt$AMQPBridgeTest$private val BOB = TestIdentity(BOB_NAME)</ID>
    <ID>VariableNaming:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val DUMMY_NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 20).party</ID>
    <ID>VariableNaming:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val MEGA_CORP = TestIdentity(CordaX500Name("MegaCorp", "London", "GB")).party</ID>
    <ID>VariableNaming:BootstrapperView.kt$BootstrapperView$val YAML_MAPPER = Constants.getContextMapper()</ID>
    <ID>VariableNaming:BullyLeaderTest.kt$BullyLeaderTest$val ACTIONS_NUMBER = 10</ID>
    <ID>VariableNaming:BullyLeaderTest.kt$BullyLeaderTest$val CLIENTS_NUMBER = 10</ID>
    <ID>VariableNaming:ByteArraysTest.kt$ByteArraysTest$val HEX_REGEX = "^[0-9A-F]+\$".toRegex()</ID>
    <ID>VariableNaming:Cap.kt$Cap$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:Caplet.kt$Caplet$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:CashTests.kt$CashTests$private lateinit var WALLET: List&lt;StateAndRef&lt;Cash.State&gt;&gt;</ID>
    <ID>VariableNaming:CashTests.kt$CashTests$private val CHARLIE_ANONYMISED = CHARLIE_IDENTITY.party.anonymise()</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private lateinit var INTERMEDIATE_CA: CertificateAndKeyPair</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private val ROOT_CA = DEV_ROOT_CA</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val ECDSA_ALGORITHM = "SHA256withECDSA"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val EC_ALGORITHM = "EC"</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val EdSignature = keyPairEd.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairEd.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val K1Signature = keyPairK1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairK1.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val R1Signature = keyPairR1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairR1.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val RSASignature = keyPairRSA.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairRSA.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val SPSignature = keyPairSP.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairSP.public).schemeNumberID)))</ID>
    <ID>VariableNaming:ContractDefinition.kt$ContractDefinition$val american_fx_option = arrange { actions { acmeCorp may { "exercise" anytime { highStreetBank.owes(acmeCorp, 1.M, USD) acmeCorp.owes(highStreetBank, 1070.K, EUR) } } highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } } }</ID>
    <ID>VariableNaming:ContractDefinition.kt$ContractDefinition$val cds_contract = arrange { actions { acmeCorp may { "payout".givenThat(acmeCorporationHasDefaulted and before("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } } }</ID>
    <ID>VariableNaming:ContractDefinition.kt$ContractDefinition$val european_fx_option = arrange { actions { acmeCorp may { "exercise" anytime { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) acmeCorp.owes(highStreetBank, 1070.K, EUR) } } } } } highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } } }</ID>
    <ID>VariableNaming:CrlFetcherTest.kt$CrlFetcherTest$private lateinit var INTERMEDIATE_CA: CertificateAndKeyPair</ID>
    <ID>VariableNaming:CrlFetcherTest.kt$CrlFetcherTest$private val ROOT_CA = DEV_ROOT_CA</ID>
    <ID>VariableNaming:CryptoUtilsTest.kt$CryptoUtilsTest$val MBbyte = ByteArray(1000000) // 1.000.000</ID>
    <ID>VariableNaming:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$val CIPHER_SUITES = arrayOf( "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256" )</ID>
    <ID>VariableNaming:DelegatedKeystoreProviderTest.kt$DelegatedKeystoreProviderTest$val MEGA_CORP = TestIdentity(CordaX500Name("MegaCorp", "London", "GB")).party</ID>
    <ID>VariableNaming:DummyContract.kt$DummyContract$val PROGRAM_ID = "net.corda.testing.contracts.DummyContract"</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj1_AA = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path1_AA.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj1_B = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path1_B.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj1_C = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path1_C.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj2_AA = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path2_AA.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj2_BB = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path2_BB.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj2_C = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path2_C.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj3_AA = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path3_AA.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj3_C = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path3_C.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj3_XX = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path3_XX.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path1_AA = EvolvabilityTests::class.java.getResource("$resource.1.AA")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path1_B = EvolvabilityTests::class.java.getResource("$resource.1.B")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path1_C = EvolvabilityTests::class.java.getResource("$resource.1.C")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path2_AA = EvolvabilityTests::class.java.getResource("$resource.2.AA")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path2_BB = EvolvabilityTests::class.java.getResource("$resource.2.BB")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path2_C = EvolvabilityTests::class.java.getResource("$resource.2.C")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path3_AA = EvolvabilityTests::class.java.getResource("$resource.3.AA")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path3_C = EvolvabilityTests::class.java.getResource("$resource.3.C")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path3_XX = EvolvabilityTests::class.java.getResource("$resource.3.XX")</ID>
    <ID>VariableNaming:EnumTests.kt$EnumTests$val schema_bras = schema.types.find { it.name == brasTestName } as RestrictedType</ID>
    <ID>VariableNaming:EnumTests.kt$EnumTests$val schema_c = schema.types.find { it.name == classTestName("C") } as CompositeType</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$@Suppress("UNUSED_VARIABLE") val A = 1</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$@Suppress("UNUSED_VARIABLE") val B = 100</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val A = 1</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val B = "two"</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val B = 100</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val B = 2</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val C = "This is not a banana"</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val C = "three"</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val D = 4</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val E = null</ID>
    <ID>VariableNaming:Examples.kt$Examples$// fx swap // both parties have the right to trigger the exchange of cash flows val an_fx_swap = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1070.K, EUR) acmeCorp.owes(highStreetBank, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$// maybe in the presence of negative interest rates you would want other side of contract to be able to take initiative as well val zero_coupon_bond_2 = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$// no touch // Party Receiver // Party Giver // // Giver has right to annul contract if barrier is breached // Receiver has right to receive money at/after expiry // // Assume observable is using FX fixing // val no_touch = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } highStreetBank may { "knock out".givenThat(EUR / USD gt 1.3) { zero } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val american_fx_option = arrange { actions { acmeCorp may { "exercise".givenThat(before("2017-09-01")) { highStreetBank.owes(acmeCorp, 1070.K, EUR) acmeCorp.owes(highStreetBank, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val cds_contract = arrange { actions { acmeCorp may { "claim".givenThat(acmeCorporationHasDefaulted and before("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val european_fx_option = arrange { actions { acmeCorp may { "exercise".givenThat(before("2017-09-01")) { fx_swap("2017-09-01", 1.M, 1.2.bd, EUR, USD, acmeCorp, highStreetBank) } } (acmeCorp or highStreetBank) may { "expire" anytime { zero } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val one_touch = arrange { actions { highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } acmeCorp may { "knock in".givenThat(EUR / USD gt 1.3) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:FXFwdTimeOption.kt$FXFwdTimeOption$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXFwdTimeOption.kt$FXFwdTimeOption$val TEST_TX_TIME_AFTER_MATURITY: Instant get() = Instant.parse("2018-06-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXFwdTimeOption.kt$FXFwdTimeOption$val TEST_TX_TIME_BEFORE_MATURITY: Instant get() = Instant.parse("2018-05-01T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXSwap.kt$FXSwap$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXSwap.kt$FXSwap$val TEST_TX_TIME_TOO_EARLY: Instant get() = Instant.parse("2017-08-31T12:00:00.00Z")</ID>
    <ID>VariableNaming:HibernateConfigurationTest.kt$HibernateConfigurationTest$val _dummyLinearStates = it[2] as DummyLinearStateSchemaV1.PersistentDummyLinearState</ID>
    <ID>VariableNaming:HibernateConfigurationTest.kt$HibernateConfigurationTest$val _vaultLinearStates = it[1] as VaultSchemaV1.VaultLinearStates</ID>
    <ID>VariableNaming:InternalMockNetwork.kt$MessagingServiceSpy$internal var _messagingService: MessagingService? = null set(value) { check(field == null) { "Spy has already been attached to a node" } field = value }</ID>
    <ID>VariableNaming:InternalUtilsTest.kt$InternalUtilsTest$val MAX_SIZE = 100</ID>
    <ID>VariableNaming:KotlinUtilsTest.kt$KotlinUtilsTest$private val KRYO_CHECKPOINT_NOWHITELIST_CONTEXT = CheckpointSerializationContextImpl( javaClass.classLoader, EmptyWhitelist, emptyMap(), true, null)</ID>
    <ID>VariableNaming:Literal.kt$ActionBuilder$val This = this</ID>
    <ID>VariableNaming:LoopbackBridgeTest.kt$LoopbackBridgeTest$private val BOB = TestIdentity(BOB_NAME)</ID>
    <ID>VariableNaming:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$// Default supported TLS schemes for Corda nodes. private val CORDA_TLS_CIPHER_SUITES = arrayOf( "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256" )</ID>
    <ID>VariableNaming:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$// Intermediate CA. private val INTERMEDIATE_X500 = X500Principal("CN=Intermediate_CA_1,O=R3CEV,L=London,C=GB")</ID>
    <ID>VariableNaming:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$// Password for keys and keystores. private val PASSWORD = "dummypassword"</ID>
    <ID>VariableNaming:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$// Root CA. private val ROOT_X500 = X500Principal("CN=Root_CA_1,O=R3CEV,L=London,C=GB")</ID>
    <ID>VariableNaming:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$// TLS client (client). private val CLIENT_2_X500 = CordaX500Name(commonName = "Client_2", organisation = "R3CEV", locality = "London", country = "GB")</ID>
    <ID>VariableNaming:NettyEngineBasedTlsAuthenticationTests.kt$NettyEngineBasedTlsAuthenticationTests$// TLS server (server). private val CLIENT_1_X500 = CordaX500Name(commonName = "Client_1", organisation = "R3CEV", locality = "London", country = "GB")</ID>
    <ID>VariableNaming:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$private val ALICE = TestIdentity(ALICE_NAME, 70)</ID>
    <ID>VariableNaming:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$private val BOB = TestIdentity(BOB_NAME, 80)</ID>
    <ID>VariableNaming:NodeInterestRatesTest.kt$NodeInterestRatesTest$private val TEST_DATA = NodeInterestRates.parseFile(""" LIBOR 2016-03-16 1M = 0.678 LIBOR 2016-03-16 2M = 0.685 LIBOR 2016-03-16 1Y = 0.890 LIBOR 2016-03-16 2Y = 0.962 EURIBOR 2016-03-15 1M = 0.123 EURIBOR 2016-03-15 2M = 0.111 """.trimIndent())</ID>
    <ID>VariableNaming:NodePerformanceTests.kt$NodePerformanceTests$val N = 10000</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPPS = listOf(FINANCE_CONTRACTS_CORDAPP, FINANCE_WORKFLOWS_CORDAPP)</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_CONTRACTS_NAME_REGEX = "corda-finance-contracts-$CORDA_VERSION_REGEX".toRegex()</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_LICENCE = "Open Source (Apache 2)"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_SHORT_NAME = "Corda Finance Demo"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_TYPES = setOf("Contract CorDapp", "Workflow CorDapp")</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_VENDOR = "R3"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDAPP_WORKFLOWS_NAME_REGEX = "corda-finance-workflows-$CORDA_VERSION_REGEX".toRegex()</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDA_VENDOR = "Corda Enterprise Edition"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val CORDA_VERSION_REGEX = "\\d+(\\.\\d+)?(-\\w+)?".toRegex() // e.g. "5.0-SNAPSHOT"</ID>
    <ID>VariableNaming:NodeRPCTests.kt$NodeRPCTests$private val HEXADECIMAL_REGEX = "[0-9a-fA-F]+".toRegex()</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _rawUpdatesPublisher = PublishSubject.create&lt;Vault.Update&lt;ContractState&gt;&gt;()!!</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _updatesInDbTx = _updatesPublisher.wrapWithDatabaseTransaction().asObservable()!!</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _updatesPublisher = PublishSubject.create&lt;Vault.Update&lt;ContractState&gt;&gt;()!!</ID>
    <ID>VariableNaming:Notarise.kt$NotaryDemoClientApi$/** A dummy identity. */ private val BOB_NAME = CordaX500Name("Bob Plc", "Rome", "IT")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The curve group name. */ private val CURVE_GROUP_NAME_CCP1 = CurveGroupName.of("USD-DSCON-LIBOR3M")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The first counterparty. */ private val CCP1_ID = StandardId.of("example", "CCP-1")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the curve calibration groups file for CCP1 and CCP2. */ private val GROUPS_RESOURCE_CCP1 = resourceLocator("example-calibration/curves/groups.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the curve calibration nodes file for CCP1 and CCP2. */ private val CALIBRATION_RESOURCE_CCP1 = resourceLocator("example-calibration/curves/calibrations.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the curve calibration settings file for CCP1 and CCP2. */ private val SETTINGS_RESOURCE_CCP1 = resourceLocator("example-calibration/curves/settings.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the historical fixing file. */ private val FIXINGS_RESOURCE = resourceLocator("example-marketdata/historical-fixings/usd-libor-3m.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The location of the market quotes file for CCP1 and CCP2. */ private val QUOTES_RESOURCE_CCP1 = resourceLocator("example-calibration/quotes/quotes.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The second counterparty. */ private val CCP2_ID = StandardId.of("example", "CCP-2")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$/** * The valuation date. */ private val VAL_DATE = LocalDate.of(2015, 7, 21)</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val CALIBRATION_RESOURCE_CCP2 = resourceLocator("example-calibration/curves/calibrations-ccp2.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val CURVE_GROUP_NAME_CCP2 = CurveGroupName.of("USD-DSCON-LIBOR3M-CCP2")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val GROUPS_RESOURCE_CCP2 = resourceLocator("example-calibration/curves/groups-ccp2.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val QUOTES_RESOURCE_CCP2 = resourceLocator("example-calibration/quotes/quotes-ccp2.csv")</ID>
    <ID>VariableNaming:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$private val SETTINGS_RESOURCE_CCP2 = resourceLocator("example-calibration/curves/settings-ccp2.csv")</ID>
    <ID>VariableNaming:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$private val TEST_DATA = NodeInterestRates.parseFile(""" LIBOR 2016-03-16 1M = 0.678 LIBOR 2016-03-16 2M = 0.685 LIBOR 2016-03-16 1Y = 0.890 LIBOR 2016-03-16 2Y = 0.962 EURIBOR 2016-03-15 1M = 0.123 EURIBOR 2016-03-15 2M = 0.111 """.trimIndent())</ID>
    <ID>VariableNaming:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$val DUMMY_NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 20).party</ID>
    <ID>VariableNaming:PersistentStateServiceTests.kt$PersistentStateServiceTests$val MEGA_CORP = TestIdentity(CordaX500Name("MegaCorp", "London", "GB")).party</ID>
    <ID>VariableNaming:PortfolioApi.kt$PortfolioApi$var IMs: Map&lt;String, InitialMarginTriple&gt;? = null</ID>
    <ID>VariableNaming:PortfolioApi.kt$PortfolioApi$var PVs: Map&lt;String, MultiCurrencyAmount&gt;? = null</ID>
    <ID>VariableNaming:RPCPerformanceTests.kt$RPCPerformanceTests$val N = 10000</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_action1 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_action2 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_and1 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } actions { acmeCorp may { "do it" anytime { acmeCorp.owes(momAndPop, 10.K, USD) } } } next() }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_and2 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } actions { acmeCorp may { "do it" anytime { acmeCorp.owes(momAndPop, 10.K, USD) } } } next() }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_transfer1 = arrange { highStreetBank.owes(acmeCorp, 10.K, USD) }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_transfer2 = arrange { highStreetBank.owes(acmeCorp, 10.K, USD) }</ID>
    <ID>VariableNaming:RpcFlowWorkerDriver.kt$RpcFlowWorkerDriverDSL$val RPC_WORKER_LEGAL_NAME = CordaX500Name("RpcWorker", "Kiev", "UA")</ID>
    <ID>VariableNaming:SSHServerTest.kt$FlowICanRun$private val HELLO_STEP = ProgressTracker.Step("Hello")</ID>
    <ID>VariableNaming:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val N = 23</ID>
    <ID>VariableNaming:ScheduledFlowTests.kt$ScheduledFlowTests$val N = 99</ID>
    <ID>VariableNaming:SchemaMigration.kt$SchemaMigration$val migrationFromV3_2 = existingDatabase &amp;&amp; !hasLiquibase &amp;&amp; it.metaData.getColumns(null, null, "NODE_INFO_HOSTS", "HOST_NAME").next()</ID>
    <ID>VariableNaming:SearchField.kt$SearchField$private val ALL = "All"</ID>
    <ID>VariableNaming:SerializationOutputTests.kt$SerializationOutputTests$private val FOO_PROGRAM_ID = "net.corda.serialization.internal.amqp.SerializationOutputTests.FooContract"</ID>
    <ID>VariableNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$private val CONFIG_FILE = StandaloneShellArgsParserTest::class.java.getResource("/config.conf").toPath()</ID>
    <ID>VariableNaming:SwapExample.kt$SwapExample$val VALUATION_DATE = LocalDate.of(2016, 6, 6)!!</ID>
    <ID>VariableNaming:Swaption.kt$Swaption$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:TLSAuthenticationTests.kt$TLSAuthenticationTests$// Default supported TLS schemes for Corda nodes. private val CORDA_TLS_CIPHER_SUITES = arrayOf( "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256" )</ID>
    <ID>VariableNaming:TLSAuthenticationTests.kt$TLSAuthenticationTests$// Intermediate CA. private val INTERMEDIATE_X500 = X500Principal("CN=Intermediate_CA_1,O=R3CEV,L=London,C=GB")</ID>
    <ID>VariableNaming:TLSAuthenticationTests.kt$TLSAuthenticationTests$// Password for keys and keystores. private val PASSWORD = "dummypassword"</ID>
    <ID>VariableNaming:TLSAuthenticationTests.kt$TLSAuthenticationTests$// Root CA. private val ROOT_X500 = X500Principal("CN=Root_CA_1,O=R3CEV,L=London,C=GB")</ID>
    <ID>VariableNaming:TLSAuthenticationTests.kt$TLSAuthenticationTests$// TLS client (client2). private val CLIENT_2_X500 = CordaX500Name(commonName = "Client_2", organisation = "R3CEV", locality = "London", country = "GB")</ID>
    <ID>VariableNaming:TLSAuthenticationTests.kt$TLSAuthenticationTests$// TLS server (client1). private val CLIENT_1_X500 = CordaX500Name(commonName = "Client_1", organisation = "R3CEV", locality = "London", country = "GB")</ID>
    <ID>VariableNaming:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$val ALICE = TestIdentity(ALICE_NAME, 70)</ID>
    <ID>VariableNaming:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$val DUMMY_BANK_A = TestIdentity(DUMMY_BANK_A_NAME, 3)</ID>
    <ID>VariableNaming:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$val NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 12)</ID>
    <ID>VariableNaming:TransactionSerializationTests.kt$TransactionSerializationTests$private val TEST_CASH_PROGRAM_ID = "net.corda.coretests.serialization.TransactionSerializationTests\$TestCash"</ID>
    <ID>VariableNaming:TransactionSerializationTests.kt$TransactionSerializationTests$val DUMMY_KEY_2 = generateKeyPair()</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val ALICE get() = alice.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val ALICE_IDENTITY get() = alice.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BIG_CORP get() = bigCorp.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BIG_CORP_IDENTITY get() = bigCorp.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOB get() = bob.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOB_IDENTITY get() = bob.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC get() = bankOfCorda.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC_IDENTITY get() = bankOfCorda.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC_KEY get() = bankOfCorda.keyPair</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC_PUBKEY get() = bankOfCorda.publicKey</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CASH_NOTARY get() = cashNotary.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CASH_NOTARY_IDENTITY get() = cashNotary.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CHARLIE get() = charlie.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CHARLIE_IDENTITY get() = charlie.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_CASH_ISSUER: PartyAndReference</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_NOTARY get() = dummyNotary.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_NOTARY_KEY get() = dummyNotary.keyPair</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_OBLIGATION_ISSUER: Party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP get() = megaCorp.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP_IDENTITY get() = megaCorp.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP_KEY get() = megaCorp.keyPair</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP_PUBKEY get() = megaCorp.publicKey</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MINI_CORP get() = miniCorp.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MINI_CORP_IDENTITY get() = miniCorp.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryTestsBase$// Beware: do not use `MyContractClass::class.qualifiedName` as this returns a fully qualified name using "dot" notation for enclosed class val MYCONTRACT_ID = "net.corda.node.services.vault.VaultQueryTestsBase\$MyContractClass"</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryTestsBase$private val TODAY = LocalDate.now().atStartOfDay().toInstant(ZoneOffset.UTC)</ID>
    <ID>VariableNaming:ZeroCouponBond.kt$ZeroCouponBond$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:ZkClientTest.kt$ZkClientTests$val ACTIONS_NUMBER = 100</ID>
    <ID>VariableNaming:ZkClientTest.kt$ZkClientTests$val CLIENTS_NUMBER = 4</ID>
    <ID>VariableNaming:ZkClientTest.kt$ZkClientTests$val CLIENT_TIMEOUT = 60L</ID>
    <ID>WildcardImport:AMQPBridgeTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:AMQPBridgeTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:AMQPClient.kt$import io.netty.channel.*</ID>
    <ID>WildcardImport:AMQPClientSerializationScheme.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:AMQPClientSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPFirewallSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPRemoteTypeModel.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:AMQPSerializationScheme.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AMQPSerializationScheme.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:AMQPServer.kt$import io.netty.channel.*</ID>
    <ID>WildcardImport:AMQPServerSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTestSerialiationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTestUtils.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AMQPTestUtils.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTypeIdentifierParser.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:AMQPTypeIdentifiers.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:ANSIProgressRendererTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:AbstractCashFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AbstractCashSelection.kt$import java.sql.*</ID>
    <ID>WildcardImport:AbstractCashSelection.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.node.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.internal.cordapp.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.services.api.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.node.utilities.*</ID>
    <ID>WildcardImport:AbstractNode.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:ActionExecutorImpl.kt$import com.codahale.metrics.*</ID>
    <ID>WildcardImport:AdditionP2PAddressModeTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:AdvancedExceptionDialog.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:AffinityExecutorTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:AliasPrivateKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:AllButBlacklisted.kt$import java.io.*</ID>
    <ID>WildcardImport:AllButBlacklisted.kt$import java.lang.invoke.*</ID>
    <ID>WildcardImport:AmountTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:AnotherDummyContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AppendOnlyPersistentMapTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:ArtemisConfigurationTool.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ArtemisMessagingClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:ArtemisMessagingServer.kt$import net.corda.node.internal.artemis.*</ID>
    <ID>WildcardImport:ArtemisMessagingTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:ArtemisRpcBroker.kt$import net.corda.node.internal.artemis.*</ID>
    <ID>WildcardImport:ArtemisRpcTests.kt$import net.corda.nodeapi.internal.config.*</ID>
    <ID>WildcardImport:AttachmentDemoFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:AttachmentTests.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:AttachmentTrustCalculatorTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import java.net.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:AttachmentsClassLoaderStaticContractTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AutoOfferFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AzureKeyVaultCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:AzureKeyVaultCryptoServiceTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:BCCryptoService.kt$import java.security.*</ID>
    <ID>WildcardImport:BCCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:BCCryptoServiceTests.kt$import java.security.*</ID>
    <ID>WildcardImport:BFTNotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BFTNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:BFTSmart.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BFTSmartNotaryService.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:BackChainResolutionSampler.kt$import com.r3.corda.enterprise.perftestcordapp.flows.*</ID>
    <ID>WildcardImport:BackpressureHandlingTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:BankOfCordaWebApi.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:BaseTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:BasicHSMKeyManagementService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:BasicHSMKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BlobInspector.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:BlobWriter.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:BootTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import net.corda.networkbuilder.nodes.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:BridgeAMQPListenerServiceImpl.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:BridgeAMQPListenerServiceImpl.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:BridgeArtemisConnectionServiceImpl.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:BridgeConfigHelper.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:BridgeConfigHelper.kt$import net.corda.nodeapi.internal.config.*</ID>
    <ID>WildcardImport:BridgeDriver.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:BridgeHSMTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:BridgeIntegrationDiffSslTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:BridgeIntegrationTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:BridgeSmokeTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:BridgeSmokeTest.kt$import net.corda.nodeapi.internal.*</ID>
    <ID>WildcardImport:BridgeSmokeTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:BridgeSupervisorServiceImpl.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:BullyLeader.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:CarpenterExceptionTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CarpenterExceptionTests.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:Cash.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashExitFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashIssueAndDoublePayment.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashIssueAndDoublePayment.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashIssueAndDuplicatePayment.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashIssueAndDuplicatePayment.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashIssueAndPaymentFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CashIssueAndPaymentNoSelection.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashIssueAndPaymentNoSelection.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashIssueAndPaymentNoSelectionFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CashPaymentFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashPaymentFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CashPaymentFromKnownStatesFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:CashSelectionH2Impl.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:CashSelectionPostgreSQLImpl.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:CashTests.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:CashTests.kt$import com.r3.corda.enterprise.perftestcordapp.*</ID>
    <ID>WildcardImport:CashTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CashTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CashUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashViewer.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.explorer.ui.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.explorer.views.*</ID>
    <ID>WildcardImport:CashViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CertHoldingKeyManagerFactoryWrapper.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:CertRoleTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CertificateRevocationListNodeTests.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:CertificatesUtils.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:CheatingSecurityProvider.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:CheckpointSerializationAPI.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:ClassCarpenter.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:ClassCarpenterTestUtils.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:ClassCarpenterTestUtils.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:CloseableTab.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CollectSignaturesFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CollectSignaturesFlowTests.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:CollectSignaturesFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CommandLineCompatibilityCheckerTest.kt$import org.hamcrest.CoreMatchers.*</ID>
    <ID>WildcardImport:CommercialPaper.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommercialPaperIssueFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CommercialPaperTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommercialPaperTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CommercialPaperUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommonSchema.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:ComposableTypePropertySerializer.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:CompositeKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:CompositeKeyFactory.kt$import java.security.*</ID>
    <ID>WildcardImport:CompositeKeyTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CompositeSignature.kt$import java.security.*</ID>
    <ID>WildcardImport:ConcurrencyUtilsTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:ConfigParsingTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:ConfigSections.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:ConfigSections.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:ConfigSections.kt$import net.corda.node.services.config.schema.parsers.*</ID>
    <ID>WildcardImport:ConfigUtilities.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:ConfigUtilities.kt$import net.corda.nodeapi.internal.*</ID>
    <ID>WildcardImport:Configuration.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:ConfigurationCollector.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:ConnectionStateMachine.kt$import org.apache.qpid.proton.amqp.messaging.*</ID>
    <ID>WildcardImport:ConnectionStateMachine.kt$import org.apache.qpid.proton.engine.*</ID>
    <ID>WildcardImport:Constants.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:ConstraintsPropagationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ConstraintsPropagationTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:ConstraintsUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractAttachmentSerializerTest.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:ContractHierarchyTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractHierarchyTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ContractUpgradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowRPCTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowTest.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.transactions.ContractUpgradeWireTransaction.Component.*</ID>
    <ID>WildcardImport:ContractUpgradeUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractsDSLTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractsScanning.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CorDappInfoServlet.kt$import kotlinx.html.*</ID>
    <ID>WildcardImport:CorDappSerializerTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:CordaClassResolver.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:CordaClassResolver.kt$import java.nio.file.StandardOpenOption.*</ID>
    <ID>WildcardImport:CordaClassResolverTests.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:CordaCliWrapper.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:CordaExceptionTest.kt$import net.corda.core.contracts.TransactionVerificationException.*</ID>
    <ID>WildcardImport:CordaExceptionTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:CordaFlowToolWindow.kt$import java.awt.*</ID>
    <ID>WildcardImport:CordaFlowToolWindow.kt$import javax.swing.*</ID>
    <ID>WildcardImport:CordaFlowToolWindow.kt$import javax.swing.tree.*</ID>
    <ID>WildcardImport:CordaFutureImplTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:CordaInternal.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:CordaMigration.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:CordaModule.kt$import com.fasterxml.jackson.annotation.*</ID>
    <ID>WildcardImport:CordaModule.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:CordaModuleBuilder.kt$import com.intellij.ide.util.projectWizard.*</ID>
    <ID>WildcardImport:CordaModuleWizardStep.kt$import javax.swing.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.core.context.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CordaRPCOps.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaRPCOpsImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CordaRPCOpsImpl.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCOpsImpl.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaRPCOpsImplTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCOpsImplTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:CordaRPCProxyClient.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCProxyClient.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaRpcWorkerOps.kt$import net.corda.core.context.*</ID>
    <ID>WildcardImport:CordaRpcWorkerOps.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRpcWorkerOps.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaRpcWorkerOps.kt$import net.corda.flowworker.*</ID>
    <ID>WildcardImport:CordaServiceTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CordaViewModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Cordapp.kt$import net.corda.core.cordapp.Cordapp.Info.*</ID>
    <ID>WildcardImport:CordappConstraintsTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CordappConstraintsTests.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:CordappController.kt$import java.nio.file.StandardCopyOption.*</ID>
    <ID>WildcardImport:CordappController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CordappController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CordappProviderImplTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:CordappScanningDriverTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CordappSmokeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CordappSmokeTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CoreFlowHandlers.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CreateMigrationSqlForCordappsCli.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:CrlFetcher.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:CrlServer.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:CrlServer.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:CrlServer.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:Crypto.kt$import java.security.*</ID>
    <ID>WildcardImport:Crypto.kt$import net.corda.core.crypto.internal.*</ID>
    <ID>WildcardImport:Crypto.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:CryptoServiceSigningServiceUnitTest.kt$import net.corda.nodeapi.internal.config.*</ID>
    <ID>WildcardImport:CryptoServiceSigningServiceUnitTest.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:CryptoSignUtils.kt$import java.security.*</ID>
    <ID>WildcardImport:CryptoSignUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CryptoUtils.kt$import java.security.*</ID>
    <ID>WildcardImport:CryptoUtilsTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CustomCordapp.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CustomVaultQuery.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CustomVaultQuery.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:CustomVaultQueryTest.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CustomVaultQueryTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:DBNetworkParametersStorage.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DBRunnerExtension.kt$import org.junit.jupiter.api.extension.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:DBTransactionStorageTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:DatabaseTestContainers.kt$import org.testcontainers.containers.*</ID>
    <ID>WildcardImport:DbScriptRunner.kt$import org.springframework.jdbc.datasource.init.*</ID>
    <ID>WildcardImport:DefaultKryoCustomizer.kt$import de.javakaffee.kryoserializers.guava.*</ID>
    <ID>WildcardImport:DefaultKryoCustomizer.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:DelegatedKeystore.kt$import java.security.*</ID>
    <ID>WildcardImport:DelegatedKeystoreProviderTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:DelegatedSignatureProvider.kt$import java.security.*</ID>
    <ID>WildcardImport:DeleteForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:DemoBench.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DemoBenchNodeInfoFilesCopier.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DemoBenchView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DeserializationInput.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryOfEnumsTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryOfEnumsTest.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryOfEnumsTest.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentrySimpleTypesTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentrySimpleTypesTest.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentrySimpleTypesTest.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryTests.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:DeserializeSimpleTypesTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DigitalSignatureWithCert.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:DirectBridgeSenderService.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:DistributedServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:DoRemainingWorkTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:DockerInstantiator.kt$import com.github.dockerjava.api.model.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.core.internal.concurrent.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:DriverTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:DriverTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:DummyContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyContractV2.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyContractV3.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyDealStateSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DummyFungibleContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyLinearStateSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DummyLinearStateSchemaV2.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:E2ETestKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:EnterpriseNode.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:EnterpriseNode.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:EnterpriseNodeTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:EnumEvolvabilityTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:EnumEvolvabilityTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:ErrorFlowTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:EventProcessor.kt$import org.apache.qpid.proton.engine.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactoryTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactoryTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:EvolvabilityTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:Explorer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:ExternalBrokerTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:ExternalMasterElectionService.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:ExternalSourceRevocationChecker.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:FiberDeserializationCheckingInterceptor.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:FilterServiceTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:FilterServiceTest.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:FinalityFlowMigration.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FinalityFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:FinalityFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FinalityHandlerTest.kt$import net.corda.node.services.statemachine.StaffedFlowHospital.*</ID>
    <ID>WildcardImport:FinalityHandlerTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FinanceJSONSupport.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:FirewallConfigurationImpl.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:FirewallConfigurationImpl.kt$import net.corda.nodeapi.internal.config.*</ID>
    <ID>WildcardImport:FirewallInstance.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:FloatControlListenerService.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:FloatControlListenerService.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:FloatSupervisorServiceImpl.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:FlowAsyncOperationTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowCheckpointCordapp.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowCheckpointVersionNodeStartupCheckTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowCheckpointVersionNodeStartupCheckTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowCookbook.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FlowCookbook.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowFrameworkPersistenceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowFrameworkTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowFrameworkTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowFrameworkTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:FlowFrameworkTripartyTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowHospitalTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowLogic.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowLogicRefFactoryImpl.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowMatchers.kt$import net.corda.testing.internal.matchers.*</ID>
    <ID>WildcardImport:FlowOverrideTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowRetryTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStackSnapshotTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachine.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineComparatorTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineImpl.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowTreeDataManager.kt$import java.nio.file.*</ID>
    <ID>WildcardImport:FlowWorkerServiceHub.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FlowWorkerServiceHub.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowWorkerServiceHub.kt$import net.corda.node.internal.*</ID>
    <ID>WildcardImport:FlowWorkerServiceHub.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:FlowWorkerServiceHub.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:FlowWorkerServiceHub.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:FlowWorkerStartStopTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:FlowWorkerStartStopTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:FlowWorkerTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:FlowWorkerTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:FlowsDrainingModeContentionTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FutureXCryptoService.kt$import java.security.*</ID>
    <ID>WildcardImport:FutureXCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorial.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorial.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorialTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:GemaltoLunaCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:GenericsTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:Gui.kt$import tornadofx.*</ID>
    <ID>WildcardImport:GuiUtilities.kt$import tornadofx.*</ID>
    <ID>WildcardImport:HTTPNetworkRegistrationService.kt$import java.net.HttpURLConnection.*</ID>
    <ID>WildcardImport:HardRestartTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:HealthCheckFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:HealthCheckFlow.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import javax.persistence.criteria.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.BinaryComparisonOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:HibernateStatistics.kt$import org.hibernate.stat.*</ID>
    <ID>WildcardImport:HttpTests.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:IOUContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IOUFlowResponder.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IRS.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IRS.kt$import net.corda.finance.contracts.*</ID>
    <ID>WildcardImport:IRSState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IRSTests.kt$import net.corda.finance.contracts.*</ID>
    <ID>WildcardImport:IRSTests.kt$import net.corda.testing.dsl.*</ID>
    <ID>WildcardImport:IRSTradeFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IdempotentFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:IdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:IdentityService.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:IdentityServiceToStringShortMigrationTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:IdentityServiceToStringShortMigrationTest.kt$import org.hamcrest.Matchers.*</ID>
    <ID>WildcardImport:InMemoryIdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InMemoryIdentityServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:InProcessBridgeReceiverService.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:InheritanceSchemaToClassCarpenterTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:InitialRegistrationCli.kt$import net.corda.node.internal.*</ID>
    <ID>WildcardImport:InputStreamSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:InstallFactory.kt$import tornadofx.*</ID>
    <ID>WildcardImport:InstallShellExtensionsParser.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InstrumentationTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:InteractiveShell.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:InteractiveShell.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InteractiveShell.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:InteractiveShellIntegrationTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:InteractiveShellIntegrationTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:InterestRatesSwapDemoAPI.kt$import org.springframework.web.bind.annotation.*</ID>
    <ID>WildcardImport:InterestSwapRestAPI.kt$import org.springframework.web.bind.annotation.*</ID>
    <ID>WildcardImport:InternalAccessTestHelpers.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:InternalKeystoreGeneratorTest.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.testing.node.*</ID>
    <ID>WildcardImport:InternalSerializationTestHelpers.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:InternalTestUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:InternalTestUtils.kt$import net.corda.testing.internal.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:IssuerModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:JCACryptoService.kt$import java.security.*</ID>
    <ID>WildcardImport:JPANotaryEntities.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:JPAUniquenessProvider.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:JPAUniquenessProvider.kt$import net.corda.core.internal.notary.*</ID>
    <ID>WildcardImport:JVMConfig.kt$import tornadofx.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import com.fasterxml.jackson.core.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:JacksonUtils.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:JarScanningCordappLoader.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:JarScanningCordappLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:JarScanningCordappLoaderTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:JarSignatureCollectorTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:KeyStoreUtilities.kt$import java.security.*</ID>
    <ID>WildcardImport:KeyStoreUtilities.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:KotlinIntegrationTestingTutorial.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:Kryo.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:Kryo.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:KryoCheckpointSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:KryoCheckpointSerializer.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:KryoStreamsTest.kt$import java.io.*</ID>
    <ID>WildcardImport:KryoTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:KryoTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:KryoTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:KryoTests.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:KryoTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:LargeTransactionsTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:LargeTransactionsTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:Launcher.kt$import net.corda.cliutils.*</ID>
    <ID>WildcardImport:LazyMappedListTest.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:LedgerTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:LedgerTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:LedgerTransactionQueryTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:LedgerTransactionQueryTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:LegacyConfigurations.kt$import net.corda.bridge.services.config.*</ID>
    <ID>WildcardImport:LinearStateBatchNotariseContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:LinearStateBatchNotariseFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ListsSerializationTest.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:LocalSerializationRule.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:LocalSerializationRule.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LocalSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:LocalSerializerFactory.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:LocalTypeInformation.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:LocalTypeInformationBuilder.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LocalTypeModel.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:LocalTypeModelTests.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LogTracer.kt$import io.jaegertracing.Configuration.*</ID>
    <ID>WildcardImport:LoginView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:LoginView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Main.kt$import java.security.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.cliutils.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.explorer.views.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:MainView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:MainView.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:MainView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:MappedSchemasCrossReferenceDetectionTests.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:Matchers.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:MaxTransactionSizeTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:MessageChainState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MessageState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MessagingExecutor.kt$import org.apache.activemq.artemis.api.core.Message.*</ID>
    <ID>WildcardImport:MigrationServicesForResolution.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MockAttachmentStorage.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:MockCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:MockKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:MockNetworkTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:MockNodeMessagingService.kt$import net.corda.node.services.messaging.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.core.node.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.node.services.api.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:MultiCurrencyAmountSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:MultiThreadedStateMachineManager.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:MultiThreadedStateMachineManager.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:MultiThreadedStateMachineManager.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:MultiThreadedStateMachineManager.kt$import net.corda.node.services.statemachine.interceptors.*</ID>
    <ID>WildcardImport:MySQLNotaryServiceTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:MySQLNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:MySQLUniquenessProvider.kt$import java.sql.*</ID>
    <ID>WildcardImport:MySQLUniquenessProvider.kt$import net.corda.core.internal.notary.*</ID>
    <ID>WildcardImport:NettyEngineBasedTlsAuthenticationTests.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:Network.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:Network.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:Network.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NetworkBootstrapper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapper.kt$import net.corda.nodeapi.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapperRunnerTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:NetworkBootstrapperTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapperTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkBuilder.kt$import net.corda.networkbuilder.nodes.*</ID>
    <ID>WildcardImport:NetworkIdentityModel.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NetworkMapServer.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NetworkMapUpdater.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdater.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NetworkParameterOverridesSpec.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:NetworkParametersReader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkParametersReaderTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkParametersReaderTest.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:NetworkParametersTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkParametersTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:NetworkProxyTests.kt$import java.net.*</ID>
    <ID>WildcardImport:NetworkRegistrationHelper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkRegistrationHelper.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:NetworkRegistrationHelperTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.node.utilities.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.nodeapi.internal.config.*</ID>
    <ID>WildcardImport:Node.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:NodeAttachmentServiceTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:NodeAttachmentServiceTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentServiceTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:NodeAttachmentTrustCalculator.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeBasedTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:NodeConfig.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:NodeConfigurationImplTest.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:NodeController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeControllerTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:NodeData.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeInfoFilesCopier.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInfoSchema.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeInfoWatcher.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInterestRates.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NodeInterestRatesTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NodeInterestRatesTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:NodeMonitorModel.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:NodePerformanceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NodeProcess.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeRegistrationTest.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:NodeRegistrationTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NodeSchedulerService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeSchedulerServiceTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:NodeSchedulerServiceTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeSchedulerServiceTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NodeSchemaService.kt$import net.corda.core.schemas.*</ID>
    <ID>WildcardImport:NodeSchemaService.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:NodeSchemaServiceTest.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.node.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.node.internal.subcommands.*</ID>
    <ID>WildcardImport:NodeStatePersistenceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import net.corda.demobench.model.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeTerminalView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:NodeTestUtils.kt$import net.corda.testing.dsl.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.node.services.vault.QueryCriteria.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.testing.internal.vault.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NodeVersioningTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeWebServer.kt$import net.corda.webserver.servlets.*</ID>
    <ID>WildcardImport:NodeWebServer.kt$import org.eclipse.jetty.server.*</ID>
    <ID>WildcardImport:NonValidatingNotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NonValidatingNotaryServiceTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NonValidatingNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NotaryChangeTests.kt$import net.corda.testing.node.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.transactions.NotaryChangeWireTransaction.Component.*</ID>
    <ID>WildcardImport:NotaryEntities.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NotaryServiceFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NotaryUtils.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NotaryWhitelistTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NotaryWhitelistTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:OGSwapPricingExample.kt$import com.opengamma.strata.product.swap.*</ID>
    <ID>WildcardImport:OGTrade.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObjectBuilder.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ObjectSerializer.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ObligationUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObservablesTests.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:ObserverNodeTransactionTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ObserverNodeTransactionTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:OnLedgerAsset.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:OracleNodeTearOffTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:P2PFlowsDrainingModeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:PackageOwnershipVerificationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PartialMerkleTreeTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:PartialMerkleTreeTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PartialMerkleTreeTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:PartyAndCertificate.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.io.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.nio.file.*</ID>
    <ID>WildcardImport:PersistentIdentityMigrationNewTableTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentIdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:PersistentIdentityService.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:PersistentIdentityServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentNetworkMapCacheTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentNetworkMapCacheTest.kt$import net.corda.testing.internal.*</ID>
    <ID>WildcardImport:PersistentNetworkMapCacheTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:PersistentStateServiceTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PingPongFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:PlatformSecureRandom.kt$import java.io.*</ID>
    <ID>WildcardImport:Portfolio.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PortfolioApi.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:PortfolioState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PortfolioSwap.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PrimusXCryptoService.kt$import com.securosys.primus.jce.*</ID>
    <ID>WildcardImport:PrimusXCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:PrivacySaltTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:PrivateKeySerializationTest.kt$import net.corda.core.serialization.SerializationContext.UseCase.*</ID>
    <ID>WildcardImport:PrivateKeySerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:PrivatePropertyTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:ProfileController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ProfileController.kt$import net.corda.demobench.model.*</ID>
    <ID>WildcardImport:ProfileController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Program.kt$import net.corda.healthsurvey.collectors.*</ID>
    <ID>WildcardImport:Program.kt$import org.apache.commons.cli.*</ID>
    <ID>WildcardImport:Properties.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:PropertyDescriptor.kt$import net.corda.serialization.internal.amqp.MethodClassifier.*</ID>
    <ID>WildcardImport:ProtonWrapperTests.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:ProtonWrapperTests.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:ProtonWrapperTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PublicKeyHashToExternalId.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:PublicKeySerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:RPCClientProxyHandler.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:RPCClientProxyHandler.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:RPCSecurityManagerImpl.kt$import org.apache.shiro.authc.*</ID>
    <ID>WildcardImport:RPCServer.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RPCServer.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:RPCStabilityTests.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RPCStabilityTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:RPCStabilityTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:RaftUniquenessProvider.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:ReceiveFinalityFlowTest.kt$import net.corda.node.services.statemachine.StaffedFlowHospital.*</ID>
    <ID>WildcardImport:ReceiveFinalityFlowTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ReceiveTransactionFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReconnectingCordaRPCOps.kt$import net.corda.client.rpc.*</ID>
    <ID>WildcardImport:ReconnectingCordaRPCOps.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:ReferenceInputStateTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReferencedStatesFlowTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReferencedStatesFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ReferencedStatesFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:RegistrationServer.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:RemoteSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:RemoteTypeCarpenter.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:ResolveStatePointersTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ResolveTransactionsFlowTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ResolveTransactionsFlowTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:RetryFlowMockTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:RetryFlowMockTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:RigorousMockTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:RoundTripObservableSerializerTests.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:RpcClientObservableDeSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:RpcFlowWorkerDriver.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:RpcFlowWorkerDriver.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:RpcReconnectTests.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RpcServerObservableSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:RpcWorkerMultiIdentityTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:RpcWorkerServiceHub.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:RpcWorkerServiceHub.kt$import net.corda.node.internal.*</ID>
    <ID>WildcardImport:RpcWorkerServiceHub.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:RpcWorkerServiceHub.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:RunOnceService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:SNIBridgeTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:SNIKeyManager.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import io.netty.handler.ssl.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import sun.security.x509.*</ID>
    <ID>WildcardImport:SampleCashSchemaV2.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:SampleCashSchemaV3.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:Samplers.kt$import com.r3.corda.enterprise.perftestcordapp.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowIntegrationTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:ScheduledFlowsDrainingModeTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledFlowsDrainingModeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowsDrainingModeTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ScheduledState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledState.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:SchedulingContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:Schema.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:Schema.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:SchemaFields.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:SchemaMigrationTest.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:SearchField.kt$import tornadofx.*</ID>
    <ID>WildcardImport:SecureHashTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:SendTransactionFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SerializationEnvironmentRule.kt$import net.corda.testing.internal.*</ID>
    <ID>WildcardImport:SerializationHelper.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:SerializationHelper.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import java.time.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:SerializationPropertyOrdering.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:SerializationSchemaTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationScheme.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationTokenTest.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializeAsTokenContextImpl.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializerFactoryBuilder.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:ServiceHubInternal.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ServicesForResolutionImpl.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SettingsModel.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SettingsModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:SharedContexts.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SignatureConstraintVersioningTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignatureConstraintVersioningTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:SimpleMQClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:SimpleMessageFilterService.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:SingleThreadedStateMachineManager.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SingleThreadedStateMachineManager.kt$import net.corda.node.services.statemachine.interceptors.*</ID>
    <ID>WildcardImport:SocksTests.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:SpringDriver.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:StaffedFlowHospital.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:StandaloneJPAUniquenessProvider.kt$import net.corda.core.internal.notary.*</ID>
    <ID>WildcardImport:StandaloneJPAUniquenessProviderTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:StandaloneJPAUniquenessProviderTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:StartedFlowTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:StateMachineViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:StateMachineViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:StatePointerSearchTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:StubOutForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:SubFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:SwapIdentitiesFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:TendermintAdapter.kt$import com.github.jtendermint.jabci.api.*</ID>
    <ID>WildcardImport:TendermintAdapter.kt$import com.github.jtendermint.jabci.types.*</ID>
    <ID>WildcardImport:TenorDateParameterMetadataSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TenorSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TestCommsFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TestCordappImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TestDSL.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TestDSL.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TestKeyManagerFactoryWrapper.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:TestNotaryTypes.kt$import net.corda.notaryhealthcheck.cordapp.SchedulingContract.*</ID>
    <ID>WildcardImport:TestResponseFlowInIsolation.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ThrowableSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:TimedFlowMultiThreadedSMMTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TimedFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TimedFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:TlsDiffAlgorithmsTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TlsDiffProtocolsTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TopLevelTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:TraderDemoTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TransactionBuilderTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionBuilderTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TransactionDSLInterpreter.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionDataModel.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionEncumbranceTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionOrderingTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TransactionSerializationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import java.security.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:TransactionTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:TransactionTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:TransactionVerifierServiceInternal.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:TransitionBuilder.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:TrustManagerFactoryWrapper.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TunnelControlTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:TunnelControlTest.kt$import net.corda.bridge.*</ID>
    <ID>WildcardImport:TunnelingBridgeReceiverService.kt$import net.corda.bridge.services.api.*</ID>
    <ID>WildcardImport:TunnelingBridgeReceiverService.kt$import net.corda.nodeapi.internal.protonwrapper.netty.*</ID>
    <ID>WildcardImport:TutorialContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TutorialTestDSL.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TwoPartyDealFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:TypeIdentifier.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:TypeIdentifierTests.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:TypeLoader.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:TypeModellingFingerPrinter.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:TypeModellingFingerPrinter.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:TypeParameterUtils.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:UniqueDummyFungibleContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:UniqueIdentifierTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:UniversalContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:UpdateBusinessDayFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Utils.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:UtilsTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:UtimacoCryptoService.kt$import java.security.*</ID>
    <ID>WildcardImport:UtimacoCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.node.services.config.schema.parsers.*</ID>
    <ID>WildcardImport:ValidatingNotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ValidatingNotaryServiceTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ValidatingNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:VaultFiller.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultFlowTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.core.node.services.vault.QueryCriteria.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.Vault.ConstraintInfo.Type.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.vault.QueryCriteria.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.testing.internal.vault.*</ID>
    <ID>WildcardImport:VaultSchema.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:VaultSchema.kt$import net.corda.core.schemas.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.Vault.RelevancyStatus.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultSoftLockManagerTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:VaultSoftLockManagerTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:VaultUpdateTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultWithCashTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:VaultWithCashTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultWithCashTest.kt$import net.corda.testing.internal.vault.*</ID>
    <ID>WildcardImport:VerifyTransactionTest.kt$import net.corda.finance.contracts.asset.Cash.Commands.*</ID>
    <ID>WildcardImport:VersionedParsingExampleTest.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:WebServerController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:WhitelistBasedTypeModelConfiguration.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:WhitelistGenerator.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:WithFinality.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:WithMockNet.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:WorkflowTransactionBuildTutorial.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WorkflowTransactionBuildTutorial.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:X509CRLSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:X509CertificateSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:X509EdDSAEngine.kt$import java.security.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:X509UtilitiesTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:X509UtilitiesTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:X509UtilitiesTest.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:internalAccessTestHelpers.kt$import net.corda.core.contracts.*</ID>
  </Whitelist>
</SmellBaseline>
