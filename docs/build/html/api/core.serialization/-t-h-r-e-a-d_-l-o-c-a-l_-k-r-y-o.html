<HTML>
<HEAD>
<title>THREAD_LOCAL_KRYO - </title>
<link rel="stylesheet" href="../style.css">
</HEAD>
<BODY>
<a href="index.html">core.serialization</a>&nbsp;/&nbsp;<a href=".">THREAD_LOCAL_KRYO</a><br/>
<br/>
<h1>THREAD_LOCAL_KRYO</h1>
<a name="core.serialization$THREAD_LOCAL_KRYO"></a>
<code><span class="keyword">val </span><span class="identifier">THREAD_LOCAL_KRYO</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code><br/>
<p>Serialization utilities, using the Kryo framework with a custom serialiser for immutable data classes and a dead
simple, totally non-extensible binary (sub)format.</p>
<p>This is NOT what should be used in any final platform product, rather, the final state should be a precisely
specified and standardised binary format with attention paid to anti-malleability, versioning and performance.
FIX SBE is a potential candidate: it prioritises performance over convenience and was designed for HFT. Google
Protocol Buffers with a minor tightening to make field reordering illegal is another possibility.</p>
<p>FIX SBE:
https://real-logic.github.io/simple-binary-encoding/
http://mechanical-sympathy.blogspot.co.at/2014/05/simple-binary-encoding.html
Protocol buffers:
https://developers.google.com/protocol-buffers/</p>
<p>But for now we use Kryo to maximise prototyping speed.</p>
<p>Note that this code ignores <emph>ALL</emph> concerns beyond convenience, in particular it ignores:</p>
<ul><li><p>Performance</p>
</li><li><p>Security</p>
</li></ul><p>This code will happily deserialise literally anything, including malicious streams that would reconstruct classes
in invalid states, thus violating system invariants. It isnt designed to handle malicious streams and therefore,
isnt usable beyond the prototyping stage. But thats fine: we can revisit serialisation technologies later after
a formal evaluation process.</p>
<br/>
<br/>
<br/>
<br/>
</BODY>
</HTML>
