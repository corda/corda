<HTML>
<HEAD>
<title>net.corda.node.services.messaging - </title>
<link rel="stylesheet" href="../style.css">
</HEAD>
<BODY>
<a href=".">net.corda.node.services.messaging</a><br/>
<br/>
<h2>Package net.corda.node.services.messaging</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="-artemis-messaging-component/index.html">ArtemisMessagingComponent</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">ArtemisMessagingComponent</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.serialization/-singleton-serialize-as-token/index.html"><span class="identifier">SingletonSerializeAsToken</span></a></code><p>The base class for Artemis services that defines shared data structures and transport configuration</p>
</td>
</tr>
<tr>
<td>
<a href="-artemis-messaging-server/index.html">ArtemisMessagingServer</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ArtemisMessagingServer</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-artemis-messaging-component/index.html"><span class="identifier">ArtemisMessagingComponent</span></a></code><p>This class configures and manages an Apache Artemis message queue broker.</p>
</td>
</tr>
<tr>
<td>
<a href="-client-r-p-c-request-message/index.html">ClientRPCRequestMessage</a></td>
<td>
<code><span class="keyword">data</span> <span class="keyword">class </span><span class="identifier">ClientRPCRequestMessage</span></code><p>The contents of an RPC request message, separated from the MQ layer.</p>
</td>
</tr>
<tr>
<td>
<a href="-corda-r-p-c-ops/index.html">CordaRPCOps</a></td>
<td>
<code><span class="keyword">interface </span><span class="identifier">CordaRPCOps</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-r-p-c-ops/index.html"><span class="identifier">RPCOps</span></a></code><p>RPC operations that the node exposes to clients using the Java client library. These can be called from
client apps and are implemented by the node in the <a href="#">CordaRPCOpsImpl</a> class.</p>
</td>
</tr>
<tr>
<td>
<a href="-flow-handle/index.html">FlowHandle</a></td>
<td>
<code><span class="keyword">data</span> <span class="keyword">class </span><span class="identifier">FlowHandle</span><span class="symbol">&lt;</span><span class="identifier">A</span><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<a href="-marshalled-observation/index.html">MarshalledObservation</a></td>
<td>
<code><span class="keyword">data</span> <span class="keyword">class </span><span class="identifier">MarshalledObservation</span></code><p>Used in the RPC wire protocol to wrap an observation with the handle of the observable its intended for.</p>
</td>
</tr>
<tr>
<td>
<a href="-node-messaging-client/index.html">NodeMessagingClient</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">NodeMessagingClient</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-artemis-messaging-component/index.html"><span class="identifier">ArtemisMessagingComponent</span></a><span class="symbol">, </span><a href="../net.corda.node.services.api/-messaging-service-internal/index.html"><span class="identifier">MessagingServiceInternal</span></a></code><p>This class implements the <a href="../net.corda.core.messaging/-messaging-service/index.html">MessagingService</a> API using Apache Artemis, the successor to their ActiveMQ product.
Artemis is a message queue broker and here we run a client connecting to the specified broker instance
<a href="-artemis-messaging-server/index.html">ArtemisMessagingServer</a>. Its primarily concerned with peer-to-peer messaging.</p>
</td>
</tr>
<tr>
<td>
<a href="-r-p-c-dispatcher/index.html">RPCDispatcher</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">RPCDispatcher</span></code><p>Intended to service transient clients only (not p2p nodes) for short-lived, transient request/response pairs.
If you need robustness, this is the wrong system. If you dont want a response, this is probably the
wrong system (you could just send a message). If you want complex customisation of how requests/responses
are handled, this is probably the wrong system.</p>
</td>
</tr>
<tr>
<td>
<a href="-r-p-c-ops/index.html">RPCOps</a></td>
<td>
<code><span class="keyword">interface </span><span class="identifier">RPCOps</span></code><p>Base interface that all RPC servers must implement. Note: in Corda theres only one RPC interface. This base
interface is here in case we split the RPC system out into a separate library one day.</p>
</td>
</tr>
<tr>
<td>
<a href="-state-machine-info/index.html">StateMachineInfo</a></td>
<td>
<code><span class="keyword">data</span> <span class="keyword">class </span><span class="identifier">StateMachineInfo</span></code></td>
</tr>
<tr>
<td>
<a href="-state-machine-update/index.html">StateMachineUpdate</a></td>
<td>
<code><span class="keyword">sealed</span> <span class="keyword">class </span><span class="identifier">StateMachineUpdate</span></code></td>
</tr>
</tbody>
</table>
<h3>Annotations</h3>
<table>
<tbody>
<tr>
<td>
<a href="-r-p-c-returns-observables/index.html">RPCReturnsObservables</a></td>
<td>
<code><span class="keyword">annotation</span> <span class="keyword">class </span><span class="identifier">RPCReturnsObservables</span></code><p>If an RPC is tagged with this annotation it may return one or more observables anywhere in its response graph.
Calling such a method comes with consequences: its slower, and consumes server side resources as observations
will buffer up on the server until theyre consumed by the client.</p>
</td>
</tr>
<tr>
<td>
<a href="-r-p-c-since-version/index.html">RPCSinceVersion</a></td>
<td>
<code><span class="keyword">annotation</span> <span class="keyword">class </span><span class="identifier">RPCSinceVersion</span></code><p>Records the protocol version in which this RPC was added.</p>
</td>
</tr>
</tbody>
</table>
<h3>Exceptions</h3>
<table>
<tbody>
<tr>
<td>
<a href="-permission-exception/index.html">PermissionException</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">PermissionException</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html"><span class="identifier">RuntimeException</span></a></code></td>
</tr>
<tr>
<td>
<a href="-r-p-c-exception/index.html">RPCException</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">RPCException</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/RuntimeException.html"><span class="identifier">RuntimeException</span></a></code><p>Thrown to indicate a fatal error in the RPC system itself, as opposed to an error generated by the invoked
method.</p>
</td>
</tr>
</tbody>
</table>
<h3>Properties</h3>
<table>
<tbody>
<tr>
<td>
<a href="-c-u-r-r-e-n-t_-r-p-c_-u-s-e-r.html">CURRENT_RPC_USER</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">CURRENT_RPC_USER</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html"><span class="identifier">ThreadLocal</span></a><span class="symbol">&lt;</span><a href="../net.corda.node.services/-user/index.html"><span class="identifier">User</span></a><span class="symbol">&gt;</span></code><p>This is available to RPC implementations to query the validated <a href="../net.corda.node.services/-user/index.html">User</a> that is calling it. Each user has a set of
permissions theyre entitled to which can be used to control access.</p>
</td>
</tr>
<tr>
<td>
<a href="rpc-log.html">rpcLog</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">rpcLog</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code><p>Global RPC logger</p>
</td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="create-r-p-c-kryo.html">createRPCKryo</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">createRPCKryo</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$createRPCKryo(((((kotlin.Any)))))/observableSerializer">observableSerializer</span><span class="symbol">:</span>&nbsp;<span class="identifier">&lt;ERROR CLASS&gt;</span><span class="symbol">&lt;</span><span class="identifier">&lt;ERROR CLASS&gt;</span><span class="symbol">&lt;</span><span class="identifier">Any</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">?</span>&nbsp;<span class="symbol">=</span>&nbsp;null<span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code></td>
</tr>
<tr>
<td>
<a href="require-permission.html">requirePermission</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">requirePermission</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$requirePermission(kotlin.String)/permission">permission</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Helper method which checks that the current RPC user is entitled for the given permission. Throws a <a href="-permission-exception/index.html">PermissionException</a> otherwise.</p>
</td>
</tr>
<tr>
<td>
<a href="start-flow.html">startFlow</a></td>
<td>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">, </span><span class="identifier">R</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.flows/-flow-logic/index.html"><span class="identifier">FlowLogic</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span> <a href="-corda-r-p-c-ops/index.html"><span class="identifier">CordaRPCOps</span></a><span class="symbol">.</span><span class="identifier">startFlow</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function0((net.corda.node.services.messaging.startFlow.R)))/flowConstructor">flowConstructor</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">R</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code><p>These allow type safe invocations of flows from Kotlin, e.g.:</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">, </span><span class="identifier">A</span><span class="symbol">, </span><span class="identifier">R</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.flows/-flow-logic/index.html"><span class="identifier">FlowLogic</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span> <a href="-corda-r-p-c-ops/index.html"><span class="identifier">CordaRPCOps</span></a><span class="symbol">.</span><span class="identifier">startFlow</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function1((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A)/flowConstructor">flowConstructor</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">A</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">R</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function1((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A)/arg0">arg0</span><span class="symbol">:</span>&nbsp;<span class="identifier">A</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code><br/>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">, </span><span class="identifier">A</span><span class="symbol">, </span><span class="identifier">B</span><span class="symbol">, </span><span class="identifier">R</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.flows/-flow-logic/index.html"><span class="identifier">FlowLogic</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span> <a href="-corda-r-p-c-ops/index.html"><span class="identifier">CordaRPCOps</span></a><span class="symbol">.</span><span class="identifier">startFlow</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function2((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B)/flowConstructor">flowConstructor</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">A</span><span class="symbol">,</span>&nbsp;<span class="identifier">B</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">R</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function2((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B)/arg0">arg0</span><span class="symbol">:</span>&nbsp;<span class="identifier">A</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function2((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B)/arg1">arg1</span><span class="symbol">:</span>&nbsp;<span class="identifier">B</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code><br/>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">, </span><span class="identifier">A</span><span class="symbol">, </span><span class="identifier">B</span><span class="symbol">, </span><span class="identifier">C</span><span class="symbol">, </span><span class="identifier">R</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.flows/-flow-logic/index.html"><span class="identifier">FlowLogic</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span> <a href="-corda-r-p-c-ops/index.html"><span class="identifier">CordaRPCOps</span></a><span class="symbol">.</span><span class="identifier">startFlow</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function3((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C)/flowConstructor">flowConstructor</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">A</span><span class="symbol">,</span>&nbsp;<span class="identifier">B</span><span class="symbol">,</span>&nbsp;<span class="identifier">C</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">R</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function3((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C)/arg0">arg0</span><span class="symbol">:</span>&nbsp;<span class="identifier">A</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function3((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C)/arg1">arg1</span><span class="symbol">:</span>&nbsp;<span class="identifier">B</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function3((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C)/arg2">arg2</span><span class="symbol">:</span>&nbsp;<span class="identifier">C</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code><br/>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">, </span><span class="identifier">A</span><span class="symbol">, </span><span class="identifier">B</span><span class="symbol">, </span><span class="identifier">C</span><span class="symbol">, </span><span class="identifier">D</span><span class="symbol">, </span><span class="identifier">R</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.flows/-flow-logic/index.html"><span class="identifier">FlowLogic</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span> <a href="-corda-r-p-c-ops/index.html"><span class="identifier">CordaRPCOps</span></a><span class="symbol">.</span><span class="identifier">startFlow</span><span class="symbol">(</span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function4((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D)/flowConstructor">flowConstructor</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">A</span><span class="symbol">,</span>&nbsp;<span class="identifier">B</span><span class="symbol">,</span>&nbsp;<span class="identifier">C</span><span class="symbol">,</span>&nbsp;<span class="identifier">D</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">R</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function4((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D)/arg0">arg0</span><span class="symbol">:</span>&nbsp;<span class="identifier">A</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function4((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D)/arg1">arg1</span><span class="symbol">:</span>&nbsp;<span class="identifier">B</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function4((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D)/arg2">arg2</span><span class="symbol">:</span>&nbsp;<span class="identifier">C</span><span class="symbol">, </span><span class="identifier" id="net.corda.node.services.messaging$startFlow(net.corda.node.services.messaging.CordaRPCOps, kotlin.Function4((net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D, net.corda.node.services.messaging.startFlow.R)), net.corda.node.services.messaging.startFlow.A, net.corda.node.services.messaging.startFlow.B, net.corda.node.services.messaging.startFlow.C, net.corda.node.services.messaging.startFlow.D)/arg3">arg3</span><span class="symbol">:</span>&nbsp;<span class="identifier">D</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
