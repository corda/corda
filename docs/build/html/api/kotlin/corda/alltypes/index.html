<HTML>
<HEAD>
<meta charset="UTF-8">
<title>alltypes - corda</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<h3>All Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="../net.corda.node.utilities/-a-n-s-i-progress-observer/index.html">net.corda.node.utilities.ANSIProgressObserver</a></td>
<td>
<p>This observes the <a href="../net.corda.node.services.statemachine/-state-machine-manager/index.html">StateMachineManager</a> and follows the progress of <a href="../net.corda.core.flows/-flow-logic/index.html">FlowLogic</a>s until they complete in the order
they are added to the <a href="../net.corda.node.services.statemachine/-state-machine-manager/index.html">StateMachineManager</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-a-n-s-i-progress-renderer/index.html">net.corda.node.utilities.ANSIProgressRenderer</a></td>
<td>
<p>Knows how to render a <a href="../net.corda.core.utilities/-progress-tracker/index.html">ProgressTracker</a> to the terminal using coloured, emoji-fied output. Useful when writing small
command line tools, demos, tests etc. Just set the <a href="../net.corda.node.utilities/-a-n-s-i-progress-renderer/progress-tracker.html">progressTracker</a> field and it will go ahead and start drawing
if the terminal supports it. Otherwise it just prints out the name of the step whenever it changes.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-abstract-cash-flow/index.html">net.corda.flows.AbstractCashFlow</a></td>
<td>
<p>Initiates a flow that produces an Issue/Move or Exit Cash transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-abstract-conserve-amount/index.html">net.corda.contracts.clause.AbstractConserveAmount</a></td>
<td>
<p>Standardised clause for checking input/output balances of fungible assets. Requires that a
Move command is provided, and errors if absent. Must be the last clause under a grouping clause;
errors on no-match, ends on match.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-abstract-issue/index.html">net.corda.contracts.clause.AbstractIssue</a></td>
<td>
<p>Standard issue clause for contracts that issue fungible assets.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-abstract-j-d-b-c-hash-map/index.html">net.corda.node.utilities.AbstractJDBCHashMap</a></td>
<td>
<p>A base class for a JDBC table backed hash map that iterates in insertion order by using
an ever increasing sequence number on entries.  Iterators supports remove() but entries are not really mutable and
do not support setValue() method from <a href="#">MutableMap.MutableEntry</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-abstract-j-d-b-c-hash-set/index.html">net.corda.node.utilities.AbstractJDBCHashSet</a></td>
<td>
<p>Base class for JDBC backed hash set that delegates to a JDBC backed hash map where the values are all
<a href="#">Unit</a> and not actually persisted.  Iteration order is order of insertion.  Iterators can remove().</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-abstract-network-map-service/index.html">net.corda.node.services.network.AbstractNetworkMapService</a></td>
<td>
<p>Abstracted out core functionality as the basis for a persistent implementation, as well as existing in-memory implementation.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.internal/-abstract-node/index.html">net.corda.node.internal.AbstractNode</a></td>
<td>
<p>A base node implementation that can be customised either for production (with real implementations that do real
I/O), or a mock implementation suitable for unit test environments.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-abstract-node-service/index.html">net.corda.node.services.api.AbstractNodeService</a></td>
<td>
<p>Abstract superclass for services that a node can host, which provides helper functions.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-abstract-party/index.html">net.corda.core.crypto.AbstractParty</a></td>
<td>
<p>An <a href="../net.corda.core.crypto/-abstract-party/index.html">AbstractParty</a> contains the common elements of <a href="../net.corda.core.crypto/-party/index.html">Party</a> and <a href="../net.corda.core.crypto/-anonymous-party/index.html">AnonymousParty</a>, specifically the owning key of
the party. In most cases <a href="../net.corda.core.crypto/-party/index.html">Party</a> or <a href="../net.corda.core.crypto/-anonymous-party/index.html">AnonymousParty</a> should be used, depending on use-case.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-abstract-state-replacement-flow/index.html">net.corda.flows.AbstractStateReplacementFlow</a></td>
<td>
<p>Abstract flow to be used for replacing one state with another, for example when changing the notary of a state.
Notably this requires a one to one replacement of states, states cannot be split, merged or issued as part of these
flows.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-accepts-file-upload/index.html">net.corda.node.services.api.AcceptsFileUpload</a></td>
<td>
<p>A service that implements AcceptsFileUpload can have new binary data provided to it via an HTTP upload.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-accrual-adjustment/index.html">net.corda.core.contracts.AccrualAdjustment</a></td>
<td>
<p>Simple enum for returning accurals adjusted or unadjusted.
We don't actually do anything with this yet though, so it's ignored for now.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-ack.html">net.corda.core.messaging.Ack</a></td>
<td>
<p>A general Ack message that conveys no content other than it's presence for use when you want an acknowledgement
from a recipient.  Using <a href="#">Unit</a> can be ambiguous as it is similar to <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Void.html">Void</a> and so could mean no response.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-add-or-remove/index.html">net.corda.node.utilities.AddOrRemove</a></td>
<td>
<p>Enum for when adding/removing something, for example adding or removing an entry in a directory.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-affinity-executor/index.html">net.corda.node.utilities.AffinityExecutor</a></td>
<td>
<p>An extended executor interface that supports thread affinity assertions and short circuiting. This can be useful
for ensuring code runs on the right thread, and also for unit testing.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-aggregated-list/index.html">net.corda.client.fxutils.AggregatedList</a></td>
<td>
<p>Given an <a href="#">ObservableList</a>&lt;<a href="#">E</a>&gt; and a grouping key <a href="#">K</a>, <a href="../net.corda.client.fxutils/-aggregated-list/index.html">AggregatedList</a> groups the elements by the key into a fresh
<a href="#">ObservableList</a>&lt;<a href="#">E</a>&gt; for each group and exposes the groups as an observable list of <a href="#">A</a>s by calling <a href="../net.corda.client.fxutils/-aggregated-list/assemble.html">assemble</a> on each.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-all-composition/index.html">net.corda.core.contracts.clauses.AllComposition</a></td>
<td>
<p>Compose a number of clauses, such that all of the clauses must run for verification to pass.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-all-of/index.html">net.corda.core.contracts.clauses.AllOf</a></td>
<td>
<p>Compose a number of clauses, such that all of the clauses must run for verification to pass.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-all-possible-recipients.html">net.corda.core.messaging.AllPossibleRecipients</a></td>
<td>
<p>A special base class for the set of all possible recipients, without having to identify who they all are.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-all-whitelist/index.html">net.corda.core.serialization.AllWhitelist</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-amount/index.html">net.corda.core.contracts.Amount</a></td>
<td>
<p>Amount represents a positive quantity of some token (currency, asset, etc.), measured in quantity of the smallest
representable units. Note that quantity is not necessarily 1/100ths of a currency unit, but are the actual smallest
amount used in whatever underlying thing the amount represents.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-amount-bindings/index.html">net.corda.client.fxutils.AmountBindings</a></td>
<td>
<p>Utility bindings for the <a href="../net.corda.core.contracts/-amount/index.html">Amount</a> type, similar in spirit to <a href="#">Bindings</a></p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-amount-generator/index.html">net.corda.core.testing.AmountGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-anonymous-party/index.html">net.corda.core.crypto.AnonymousParty</a></td>
<td>
<p>The <a href="../net.corda.core.crypto/-anonymous-party/index.html">AnonymousParty</a> class contains enough information to uniquely identify a <a href="../net.corda.core.crypto/-party/index.html">Party</a> while excluding private
information such as name. It is intended to represent a party on the distributed ledger.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-anonymous-party-generator/index.html">net.corda.core.testing.AnonymousPartyGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-any-composition/index.html">net.corda.core.contracts.clauses.AnyComposition</a></td>
<td>
<p>Compose a number of clauses, such that any number of the clauses can run.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-any-of/index.html">net.corda.core.contracts.clauses.AnyOf</a></td>
<td>
<p>Compose a number of clauses, such that one or more of the clauses can run.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-api-utils/index.html">net.corda.core.utilities.ApiUtils</a></td>
<td>
<p>Utility functions to reduce boilerplate when developing HTTP APIs</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-app-context/index.html">net.corda.core.flows.AppContext</a></td>
<td>
<p>This is just some way to track what attachments need to be in the class loader, but may later include some app
properties loaded from the attachments.  And perhaps the authenticated user for an API call?</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node/-args-parser/index.html">net.corda.node.ArgsParser</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-artemis-messaging-component/index.html">net.corda.node.services.messaging.ArtemisMessagingComponent</a></td>
<td>
<p>The base class for Artemis services that defines shared data structures and SSL transport configuration.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-artemis-messaging-server/index.html">net.corda.node.services.messaging.ArtemisMessagingServer</a></td>
<td>
<p>This class configures and manages an Apache Artemis message queue broker.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-associated-list/index.html">net.corda.client.fxutils.AssociatedList</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-associated-list/index.html">AssociatedList</a> creates an <a href="#">ObservableMap</a> from an <a href="#">ObservableList</a> by associating each list element with a unique key.
It is <emph>not</emph> allowed to have several elements map to the same value!</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-attachment/index.html">net.corda.core.contracts.Attachment</a></td>
<td>
<p>An attachment is a ZIP (or an optionally signed JAR) that contains one or more files. Attachments are meant to
contain public static data which can be referenced from transactions and utilised from contracts. Good examples
of how attachments are meant to be used include:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-attachment-resolution-exception/index.html">net.corda.core.contracts.AttachmentResolutionException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-attachment-storage/index.html">net.corda.core.node.services.AttachmentStorage</a></td>
<td>
<p>An attachment store records potentially large binary objects, identified by their hash.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-attachments-class-loader/index.html">net.corda.core.node.AttachmentsClassLoader</a></td>
<td>
<p>A custom ClassLoader that knows how to load classes from a set of attachments. The attachments themselves only
need to provide JAR streams, and so could be fetched from a database, local disk, etc. Constructing an
AttachmentsClassLoader is somewhat expensive, as every attachment is scanned to ensure that there are no overlapping
file paths.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-attachments-storage-service/index.html">net.corda.core.node.services.AttachmentsStorageService</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-authenticated-object/index.html">net.corda.core.contracts.AuthenticatedObject</a></td>
<td>
<p>Wraps an object that was signed by a public key, which may be a well known/recognised institutional key.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-b-f-t-smart-client/index.html">net.corda.node.services.transactions.BFTSmartClient</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-b-f-t-smart-server/index.html">net.corda.node.services.transactions.BFTSmartServer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-b-f-t-smart-uniqueness-provider/index.html">net.corda.node.services.transactions.BFTSmartUniquenessProvider</a></td>
<td>
<p>A <a href="../net.corda.core.node.services/-uniqueness-provider/index.html">UniquenessProvider</a> based on the <a href="https://github.com/bft-smart/library">bft-smart library</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-b-f-t-validating-notary-service/index.html">net.corda.node.services.transactions.BFTValidatingNotaryService</a></td>
<td>
<p>A validating notary service operated by a group of parties that don't necessarily trust each other.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-base-transaction/index.html">net.corda.core.transactions.BaseTransaction</a></td>
<td>
<p>An abstract class defining fields shared by all transaction types in the system.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-bilateral-net-state/index.html">net.corda.contracts.clause.BilateralNetState</a></td>
<td>
<p>Subset of state, containing the elements which must match for two obligation transactions to be nettable.
If two obligation state objects produce equal bilateral net states, they are considered safe to net directly.
Bilateral states are used in close-out netting.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-bilateral-nettable-state/index.html">net.corda.core.contracts.BilateralNettableState</a></td>
<td>
<p>Interface for state objects that support being netted with other state objects.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-broadcast-transaction-flow/index.html">net.corda.flows.BroadcastTransactionFlow</a></td>
<td>
<p>Notify the specified parties about a transaction. The remote peers will download this transaction and its
dependency graph, verifying them all. The flow returns when all peers have acknowledged the transactions
as valid. Normally you wouldn't use this directly, it would be called via <a href="../net.corda.flows/-finality-flow/index.html">FinalityFlow</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-built-in-exceptions-whitelist/index.html">net.corda.core.serialization.BuiltInExceptionsWhitelist</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-business-calendar/index.html">net.corda.core.contracts.BusinessCalendar</a></td>
<td>
<p>A business calendar performs date calculations that take into account national holidays and weekends. This is a
typical feature of financial contracts, in which a business may not want a payment event to fall on a day when
no staff are around to handle problems.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/kotlin.-byte-array/index.html">kotlin.ByteArray</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/kotlin.-byte-array/index.html">kotlin.ByteArray</a> (extensions in package net.corda.core.serialization)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.asset/-cash/index.html">net.corda.contracts.asset.Cash</a></td>
<td>
<p>A cash transaction may split and merge money represented by a set of (issuer, depositRef) pairs, across multiple
input and output states. Imagine a Bitcoin transaction but in which all UTXOs had a colour
(a blend of issuer+depositRef) and you couldn't merge outputs of two colours together, but you COULD put them in
the same transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.vault/-cash-balance-as-metrics-observer/index.html">net.corda.node.services.vault.CashBalanceAsMetricsObserver</a></td>
<td>
<p>This class observes the vault and reflect current cash balances as exposed metrics in the monitoring service.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-cash-exception/index.html">net.corda.flows.CashException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-cash-exit-flow/index.html">net.corda.flows.CashExitFlow</a></td>
<td>
<p>Initiates a flow that produces an cash exit transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-cash-flow-command/index.html">net.corda.flows.CashFlowCommand</a></td>
<td>
<p>A command to initiate the Cash flow with.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-cash-issue-flow/index.html">net.corda.flows.CashIssueFlow</a></td>
<td>
<p>Initiates a flow that produces cash issuance transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-cash-payment-flow/index.html">net.corda.flows.CashPaymentFlow</a></td>
<td>
<p>Initiates a flow that produces an cash move transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.schemas/-cash-schema.html">net.corda.schemas.CashSchema</a></td>
<td>
<p>An object used to fully qualify the <a href="../net.corda.schemas/-cash-schema.html">CashSchema</a> family name (i.e. independent of version).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.schemas/-cash-schema-v1/index.html">net.corda.schemas.CashSchemaV1</a></td>
<td>
<p>First version of a cash contract ORM schema that maps all fields of the <a href="#">Cash</a> contract state as it stood
at the time of writing.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities.registration/-certificate-request-exception/index.html">net.corda.node.utilities.registration.CertificateRequestException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-certificate-stream/index.html">net.corda.core.crypto.CertificateStream</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-checkpoint/index.html">net.corda.node.services.api.Checkpoint</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-checkpoint-storage/index.html">net.corda.node.services.api.CheckpointStorage</a></td>
<td>
<p>Thread-safe storage of fiber checkpoints.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-chosen-list/index.html">net.corda.client.fxutils.ChosenList</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-chosen-list/index.html">ChosenList</a> manages an <a href="#">ObservableList</a> that may be changed by the wrapping <a href="#">ObservableValue</a>. Whenever the underlying
<a href="#">ObservableValue</a> changes the exposed list changes to the new value. Changes to the list are simply propagated.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-city-database/index.html">net.corda.core.node.CityDatabase</a></td>
<td>
<p>A simple lookup table of city names to their coordinates. Lookups are case insensitive.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-class-serializer/index.html">net.corda.node.services.messaging.ClassSerializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-class-whitelist/index.html">net.corda.core.serialization.ClassWhitelist</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-clause/index.html">net.corda.core.contracts.clauses.Clause</a></td>
<td>
<p>A clause of a contract, containing a chunk of verification logic. That logic may be delegated to other clauses, or
provided directly by this clause.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-client-r-p-c-request-message/index.html">net.corda.node.services.messaging.ClientRPCRequestMessage</a></td>
<td>
<p>The contents of an RPC request message, separated from the MQ layer.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/java.time.-clock/index.html">java.time.Clock</a> (extensions in package net.corda.node.utilities)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node/-cmd-line-options/index.html">net.corda.node.CmdLineOptions</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/kotlin.collections.-collection/index.html">kotlin.collections.Collection</a> (extensions in package net.corda.core.contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/kotlin.collections.-collection/index.html">kotlin.collections.Collection</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-command/index.html">net.corda.core.contracts.Command</a></td>
<td>
<p>Command data/content plus pubkey pair: the signature is stored at the end of the serialized bytes</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-command-data.html">net.corda.core.contracts.CommandData</a></td>
<td>
<p>Marker interface for classes that represent commands</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-command-data-generator/index.html">net.corda.contracts.testing.CommandDataGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-command-generator/index.html">net.corda.contracts.testing.CommandGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts/-commercial-paper/index.html">net.corda.contracts.CommercialPaper</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts/-commercial-paper-legacy/index.html">net.corda.contracts.CommercialPaperLegacy</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.schemas/-commercial-paper-schema.html">net.corda.schemas.CommercialPaperSchema</a></td>
<td>
<p>An object used to fully qualify the <a href="../net.corda.schemas/-commercial-paper-schema.html">CommercialPaperSchema</a> family name (i.e. independent of version).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.schemas/-commercial-paper-schema-v1/index.html">net.corda.schemas.CommercialPaperSchemaV1</a></td>
<td>
<p>First version of a commercial paper contract ORM schema that maps all fields of the <a href="#">CommercialPaper</a> contract state
as it stood at the time of writing.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-commodity/index.html">net.corda.core.contracts.Commodity</a></td>
<td>
<p>Class representing a commodity, as an equivalent to the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Currency.html">Currency</a> class. This exists purely to enable the
<a href="#">CommodityContract</a> contract, and is likely to change in future.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.asset/-commodity-contract/index.html">net.corda.contracts.asset.CommodityContract</a></td>
<td>
<p>A commodity contract represents an amount of some commodity, tracked on a distributed ledger. The design of this
contract is intentionally similar to the <a href="../net.corda.contracts.asset/-cash/index.html">Cash</a> contract, and the same commands (issue, move, exit) apply, the
differences are in representation of the underlying commodity. Issuer in this context means the party who has the
commodity, or is otherwise responsible for delivering the commodity on demand, and the deposit reference is use for
internal accounting by the issuer (it might be, for example, a warehouse and/or location within a warehouse).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-composite-clause/index.html">net.corda.core.contracts.clauses.CompositeClause</a></td>
<td>
<p>Abstract supertype for clauses which compose other clauses together in some logical manner.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-composite-key/index.html">net.corda.core.crypto.CompositeKey</a></td>
<td>
<p>A tree data structure that enables the representation of composite public keys.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-composite-key-column-type/index.html">net.corda.node.utilities.CompositeKeyColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="../net.corda.core.crypto/-composite-key/index.html">CompositeKey</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-composite-key-generator/index.html">net.corda.core.testing.CompositeKeyGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-composite-key-leaf-serializer/index.html">net.corda.core.serialization.CompositeKeyLeafSerializer</a></td>
<td>
<p>For serialising composite keys</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-composite-key-node-serializer/index.html">net.corda.core.serialization.CompositeKeyNodeSerializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-concatenated-list/index.html">net.corda.client.fxutils.ConcatenatedList</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-concatenated-list/index.html">ConcatenatedList</a> takes a list of lists and concatenates them. Any change to the underlying lists or the outer list
is propagated as expected.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.config/com.typesafe.config.-config/index.html">com.typesafe.config.Config</a> (extensions in package net.corda.node.services.config)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/com.typesafe.config.-config/index.html">com.typesafe.config.Config</a> (extensions in package net.corda.node.utilities)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.config/-config-helper/index.html">net.corda.node.services.config.ConfigHelper</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.internal/-configuration-exception/index.html">net.corda.node.internal.ConfigurationException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-contract/index.html">net.corda.core.contracts.Contract</a></td>
<td>
<p>Implemented by a program that implements business logic on the shared ledger. All participants run this code for
every <a href="#">LedgerTransaction</a> they see on the network, for every input and output state. All contracts must accept the
transaction for it to be accepted: failure of any aborts the entire thing. The time is taken from a trusted
timestamp attached to the transaction itself i.e. it is NOT necessarily the current time.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-contract-state/index.html">net.corda.core.contracts.ContractState</a></td>
<td>
<p>A contract state (or just "state") contains opaque data used by a contract program. It can be thought of as a disk
file that the program can use to persist data across transactions. States are immutable: once created they are never
updated, instead, any changes must generate a new successor state. States can be updated (consumed) only once: the
notary is responsible for ensuring there is no "double spending" by only signing a transaction if the input states
are all free.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-contract-state-generator/index.html">net.corda.contracts.testing.ContractStateGenerator</a></td>
<td>
<p>This file contains generators for quickcheck style testing. The idea is that we can write random instance generators
for each type we have in the code and test against those instead of predefined mock data. This style of testing can
catch corner case bugs and test algebraic properties of the code, for example deserialize(serialize(generatedThing)) == generatedThing</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-contract-state-model/index.html">net.corda.client.model.ContractStateModel</a></td>
<td>
<p>This model exposes the list of owned contract states.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-contract-upgrade-flow/index.html">net.corda.flows.ContractUpgradeFlow</a></td>
<td>
<p>A flow to be used for upgrading state objects of an old contract to a new contract.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-corda-class-resolver/index.html">net.corda.core.serialization.CordaClassResolver</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-corda-kryo/index.html">net.corda.core.serialization.CordaKryo</a></td>
<td>
<p>We need to disable whitelist checking during calls from our Kryo code to register a serializer, since it checks
for existing registrations and then will enter our <a href="../net.corda.core.serialization/-corda-class-resolver/get-registration.html">CordaClassResolver.getRegistration</a> method.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-corda-plugin-registry/index.html">net.corda.core.node.CordaPluginRegistry</a></td>
<td>
<p>Implement this interface on a class advertised in a META-INF/services/net.corda.core.node.CordaPluginRegistry file
to extend a Corda node with additional application services.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-corda-r-p-c-client/index.html">net.corda.node.services.messaging.CordaRPCClient</a></td>
<td>
<p>An RPC client connects to the specified server and allows you to make calls to the server that perform various
useful tasks. See the documentation for <a href="../net.corda.node.services.messaging/-corda-r-p-c-client/proxy.html">proxy</a> or review the docsite to learn more about how this API works.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-corda-r-p-c-client-impl/index.html">net.corda.node.services.messaging.CordaRPCClientImpl</a></td>
<td>
<p>Core RPC engine implementation, to learn how to use RPC you should be looking at <a href="../net.corda.node.services.messaging/-corda-r-p-c-client/index.html">CordaRPCClient</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-corda-r-p-c-ops/index.html">net.corda.core.messaging.CordaRPCOps</a></td>
<td>
<p>RPC operations that the node exposes to clients using the Java client library. These can be called from
client apps and are implemented by the node in the <a href="#">CordaRPCOpsImpl</a> class.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.internal/-corda-r-p-c-ops-impl/index.html">net.corda.node.internal.CordaRPCOpsImpl</a></td>
<td>
<p>Server side implementations of RPCs available to MQ based client tools. Execution takes place on the server
thread (i.e. serially). Arguments are serialised and deserialised automatically.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-corda-serializable/index.html">net.corda.core.serialization.CordaSerializable</a></td>
<td>
<p>This annotation is a marker to indicate that a class is permitted and intended to be serialized as part of Node messaging.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.math/-cubic-spline-interpolator/index.html">net.corda.core.math.CubicSplineInterpolator</a></td>
<td>
<p>Interpolates values between the given data points using a <a href="../net.corda.core.math/-spline-function/index.html">SplineFunction</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/java.util.-currency/index.html">java.util.Currency</a> (extensions in package net.corda.core.contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-currency-generator/index.html">net.corda.core.testing.CurrencyGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-d-b-checkpoint-storage/index.html">net.corda.node.services.persistence.DBCheckpointStorage</a></td>
<td>
<p>Simple checkpoint key value storage in DB using the underlying JDBCHashMap and transactional context of the call sites.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-d-b-transaction-mapping-storage/index.html">net.corda.node.services.persistence.DBTransactionMappingStorage</a></td>
<td>
<p>Database storage of a txhash -&gt; state machine id mapping.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-d-b-transaction-storage/index.html">net.corda.node.services.persistence.DBTransactionStorage</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-data-vending/index.html">net.corda.node.services.persistence.DataVending</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-date-roll-convention/index.html">net.corda.core.contracts.DateRollConvention</a></td>
<td>
<p>This reflects what happens if a date on which a business event is supposed to happen actually falls upon a non-working day.
Depending on the accounting requirement, we can move forward until we get to a business day, or backwards.
There are some additional rules which are explained in the individual cases below.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-date-roll-direction/index.html">net.corda.core.contracts.DateRollDirection</a></td>
<td>
<p>This is utilised in the <a href="../net.corda.core.contracts/-date-roll-convention/index.html">DateRollConvention</a> class to determine which way we should initially step when
finding a business day.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-day-count-basis-day/index.html">net.corda.core.contracts.DayCountBasisDay</a></td>
<td>
<p>This forms the day part of the "Day Count Basis" used for interest calculation.
Note that the first character cannot be a number (enum naming constraints), so we drop that
in the toString lest some people get confused.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-day-count-basis-year/index.html">net.corda.core.contracts.DayCountBasisYear</a></td>
<td>
<p>This forms the year part of the "Day Count Basis" used for interest calculation.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-deal-state/index.html">net.corda.core.contracts.DealState</a></td>
<td>
<p>Interface representing an agreement that exposes various attributes that are common. Implementing it simplifies
implementation of general flows that manipulate many agreement types.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-default-kryo-customizer/index.html">net.corda.core.serialization.DefaultKryoCustomizer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.serialization/-default-whitelist/index.html">net.corda.node.serialization.DefaultWhitelist</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-deserialize-as-kotlin-object-def.html">net.corda.core.serialization.DeserializeAsKotlinObjectDef</a></td>
<td>
<p>Marker interface for kotlin object definitions so that they are deserialized as the singleton instance.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-diff/index.html">net.corda.client.model.Diff</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-digital-signature/index.html">net.corda.core.crypto.DigitalSignature</a></td>
<td>
<p>A wrapper around a digital signature. The covering field is a generic tag usable by whatever is interpreting the
signature. It isn't used currently, but experience from Bitcoin suggests such a feature is useful, especially when
building partially signed transactions.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-distributed-immutable-map/index.html">net.corda.node.services.transactions.DistributedImmutableMap</a></td>
<td>
<p>A distributed map state machine that doesn't allow overriding values. The state machine is replicated
across a Copycat Raft cluster.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/kotlin.-double/index.html">kotlin.Double</a> (extensions in package net.corda.core.contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.-double/index.html">kotlin.Double</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.driver/-driver-based-test/index.html">net.corda.node.driver.DriverBasedTest</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.driver/-driver-d-s-l/index.html">net.corda.node.driver.DriverDSL</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.driver/-driver-d-s-l-exposed-interface/index.html">net.corda.node.driver.DriverDSLExposedInterface</a></td>
<td>
<p>This is the interface that's exposed to DSL users.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.driver/-driver-d-s-l-internal-interface/index.html">net.corda.node.driver.DriverDSLInternalInterface</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-dummy-contract/index.html">net.corda.core.contracts.DummyContract</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-dummy-contract-v2/index.html">net.corda.core.contracts.DummyContractV2</a></td>
<td>
<p>Dummy contract state for testing of the upgrade process.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-dummy-deal-contract/index.html">net.corda.contracts.testing.DummyDealContract</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-dummy-linear-contract/index.html">net.corda.contracts.testing.DummyLinearContract</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-dummy-public-key/index.html">net.corda.core.crypto.DummyPublicKey</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-dummy-state/index.html">net.corda.core.contracts.DummyState</a></td>
<td>
<p>Dummy state for use in testing. Not part of any contract, not even the <a href="../net.corda.core.contracts/-dummy-contract/index.html">DummyContract</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-duration-generator/index.html">net.corda.core.testing.DurationGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.keys/-e2-e-test-key-management-service/index.html">net.corda.node.services.keys.E2ETestKeyManagementService</a></td>
<td>
<p>A simple in-memory KMS that doesn't bother saving keys to disk. A real implementation would:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-ed25519-private-key-serializer/index.html">net.corda.core.serialization.Ed25519PrivateKeySerializer</a></td>
<td>
<p>For serialising an ed25519 private key</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-ed25519-public-key-serializer/index.html">net.corda.core.serialization.Ed25519PublicKeySerializer</a></td>
<td>
<p>For serialising an ed25519 public key</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-emoji/index.html">net.corda.core.utilities.Emoji</a></td>
<td>
<p>A simple wrapper class that contains icons and support for printing them only when we're connected to a terminal.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-empty-whitelist/index.html">net.corda.core.serialization.EmptyWhitelist</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/-error-or/index.html">net.corda.core.ErrorOr</a></td>
<td>
<p>Representation of an operation that may have thrown an error.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-error-session-end/index.html">net.corda.node.services.statemachine.ErrorSessionEnd</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.mock/-event-generator/index.html">net.corda.client.mock.EventGenerator</a></td>
<td>
<p><a href="../net.corda.client.mock/-generator/index.html">Generator</a>s for incoming/outgoing events to/from the <a href="#">WalletMonitorService</a>. Internally it keeps track of owned
state/ref pairs, but it doesn't necessarily generate "correct" events!</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-exchange-rate/index.html">net.corda.client.model.ExchangeRate</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-exchange-rate-model/index.html">net.corda.client.model.ExchangeRateModel</a></td>
<td>
<p>This model provides an exchange rate from arbitrary currency to arbitrary currency.
TODO hook up an actual oracle</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-existing-session-message/index.html">net.corda.node.services.statemachine.ExistingSessionMessage</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-exit-generator/index.html">net.corda.contracts.testing.ExitGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-expression/index.html">net.corda.core.contracts.Expression</a></td>
<td>
<p>Represents a textual expression of e.g. a formula</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-expression-deserializer/index.html">net.corda.core.contracts.ExpressionDeserializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-expression-serializer/index.html">net.corda.core.contracts.ExpressionSerializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-fetch-attachments-flow/index.html">net.corda.flows.FetchAttachmentsFlow</a></td>
<td>
<p>Given a set of hashes either loads from from local storage  or requests them from the other peer. Downloaded
attachments are saved to local storage automatically.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-fetch-data-flow/index.html">net.corda.flows.FetchDataFlow</a></td>
<td>
<p>An abstract flow for fetching typed data from a remote peer.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-fetch-transactions-flow/index.html">net.corda.flows.FetchTransactionsFlow</a></td>
<td>
<p>Given a set of tx hashes (IDs), either loads them from local disk or asks the remote peer to provide them.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-fiber-box/index.html">net.corda.node.utilities.FiberBox</a></td>
<td>
<p>Modelled on <a href="#">ThreadBox</a>, but with support for waiting that is compatible with Quasar <a href="#">Fiber</a>s and <a href="../net.corda.node.utilities/-mutable-clock/index.html">MutableClock</a>s.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-file-uploader/index.html">net.corda.core.node.services.FileUploader</a></td>
<td>
<p>An interface that denotes a service that can accept file uploads.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-filter-on/index.html">net.corda.core.contracts.clauses.FilterOn</a></td>
<td>
<p>Filter the states that are passed through to the wrapped clause, to restrict them to a specific type.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-filtered-leaves/index.html">net.corda.core.transactions.FilteredLeaves</a></td>
<td>
<p>Class that holds filtered leaves for a partial Merkle transaction. We assume mixed leaf types, notice that every
field from <a href="../net.corda.core.transactions/-wire-transaction/index.html">WireTransaction</a> can be used in <a href="../net.corda.core.crypto/-partial-merkle-tree/index.html">PartialMerkleTree</a> calculation.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-filtered-transaction/index.html">net.corda.core.transactions.FilteredTransaction</a></td>
<td>
<p>Class representing merkleized filtered transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-finality-flow/index.html">net.corda.flows.FinalityFlow</a></td>
<td>
<p>Verifies the given transactions, then sends them to the named notaries. If the notary agrees that the transactions
are acceptable then they are from that point onwards committed to the ledger, and will be written through to the
vault. Additionally they will be distributed to the parties reflected in the participants list of the states.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-first-composition/index.html">net.corda.core.contracts.clauses.FirstComposition</a></td>
<td>
<p>Compose a number of clauses, such that the first match is run, and it errors if none is run.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-first-of/index.html">net.corda.core.contracts.clauses.FirstOf</a></td>
<td>
<p>Compose a number of clauses, such that the first match is run, and it errors if none is run.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-fix/index.html">net.corda.core.contracts.Fix</a></td>
<td>
<p>A <a href="../net.corda.core.contracts/-fix/index.html">Fix</a> represents a named interest rate, on a given day, for a given duration. It can be embedded in a tx.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-fix-of/index.html">net.corda.core.contracts.FixOf</a></td>
<td>
<p>A <a href="../net.corda.core.contracts/-fix-of/index.html">FixOf</a> identifies the question side of a fix: what day, tenor and type of fix ("LIBOR", "EURIBOR" etc)</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-fixable-deal-state/index.html">net.corda.core.contracts.FixableDealState</a></td>
<td>
<p>Interface adding fixing specific methods.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-flattened-list/index.html">net.corda.client.fxutils.FlattenedList</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-flattened-list/index.html">FlattenedList</a> flattens the passed in list of <a href="#">ObservableValue</a>s so that changes in individual updates to the values
are reflected in the exposed list as expected.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-flow-exception/index.html">net.corda.core.flows.FlowException</a></td>
<td>
<p>Exception which can be thrown by a <a href="../net.corda.core.flows/-flow-logic/index.html">FlowLogic</a> at any point in its logic to unexpectedly bring it to a permanent end.
The exception will propagate to all counterparty flows and will be thrown on their end the next time they wait on a
<a href="../net.corda.core.flows/-flow-logic/receive.html">FlowLogic.receive</a> or <a href="../net.corda.core.flows/-flow-logic/send-and-receive.html">FlowLogic.sendAndReceive</a>. Any flow which no longer needs to do a receive, or has already ended,
will not receive the exception (if this is required then have them wait for a confirmation message).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-flow-handle/index.html">net.corda.core.messaging.FlowHandle</a></td>
<td>
<p><a href="../net.corda.core.messaging/-flow-handle/index.html">FlowHandle</a> is a serialisable handle for the started flow, parameterised by the type of the flow's return value.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-flow-i-o-request/index.html">net.corda.node.services.statemachine.FlowIORequest</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-flow-logic/index.html">net.corda.core.flows.FlowLogic</a></td>
<td>
<p>A sub-class of <a href="../net.corda.core.flows/-flow-logic/index.html">FlowLogic</a> implements a flow using direct, straight line blocking code. Thus you
can write complex flow logic in an ordinary fashion, without having to think about callbacks, restarting after
a node crash, how many instances of your flow there are running and so on.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-flow-logic-ref/index.html">net.corda.core.flows.FlowLogicRef</a></td>
<td>
<p>A class representing a <a href="../net.corda.core.flows/-flow-logic/index.html">FlowLogic</a> instance which would be possible to safely pass out of the contract sandbox.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-flow-logic-ref-factory/index.html">net.corda.core.flows.FlowLogicRefFactory</a></td>
<td>
<p>A class for conversion to and from <a href="../net.corda.core.flows/-flow-logic/index.html">FlowLogic</a> and <a href="../net.corda.core.flows/-flow-logic-ref/index.html">FlowLogicRef</a> instances.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-flow-session/index.html">net.corda.node.services.statemachine.FlowSession</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-flow-session-exception/index.html">net.corda.node.services.statemachine.FlowSessionException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-flow-session-state/index.html">net.corda.node.services.statemachine.FlowSessionState</a></td>
<td>
<p><a href="../net.corda.node.services.statemachine/-flow-session-state/index.html">FlowSessionState</a> describes the session's state.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-flow-state-machine/index.html">net.corda.core.flows.FlowStateMachine</a></td>
<td>
<p>This is an internal interface that is implemented by code in the node module. You should look at <a href="../net.corda.core.flows/-flow-logic/index.html">FlowLogic</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-flow-state-machine-impl/index.html">net.corda.node.services.statemachine.FlowStateMachineImpl</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-flow-status/index.html">net.corda.client.model.FlowStatus</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-frequency/index.html">net.corda.core.contracts.Frequency</a></td>
<td>
<p>Frequency at which an event occurs - the enumerator also casts to an integer specifying the number of times per year
that would divide into (eg annually = 1, semiannual = 2, monthly = 12 etc).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.config/-full-node-configuration/index.html">net.corda.node.services.config.FullNodeConfiguration</a></td>
<td>
<p><a href="../net.corda.node.services.config/-full-node-configuration/base-directory.html">baseDirectory</a> is not retrieved from the config file but rather from a command line argument.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/kotlin.-function1/index.html">kotlin.Function1</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/kotlin.-function2/index.html">kotlin.Function2</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/kotlin.-function3/index.html">kotlin.Function3</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/kotlin.-function4/index.html">kotlin.Function4</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-fungible-asset/index.html">net.corda.core.contracts.FungibleAsset</a></td>
<td>
<p>Interface for contract states representing assets which are fungible, countable and issued by a
specific party. States contain assets which are equivalent (such as cash of the same currency),
so records of their existence can be merged or split as needed where the issuer is the same. For
instance, dollars issued by the Fed are fungible and countable (in cents), barrels of West Texas
crude are fungible and countable (oil from two small containers can be poured into one large
container), shares of the same class in a specific company are fungible and countable, and so on.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/java.util.concurrent.-future/index.html">java.util.concurrent.Future</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-gathered-transaction-data/index.html">net.corda.client.model.GatheredTransactionData</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/com.pholser.junit.quickcheck.generator.-generator/index.html">com.pholser.junit.quickcheck.generator.Generator</a> (extensions in package net.corda.core.testing)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.mock/-generator/index.html">net.corda.client.mock.Generator</a></td>
<td>
<p>This file defines a basic <a href="../net.corda.client.mock/-generator/index.html">Generator</a> library for composing random generators of objects.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-global-transient-class-white-list/index.html">net.corda.core.serialization.GlobalTransientClassWhiteList</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts.clauses/-group-clause-verifier/index.html">net.corda.core.contracts.clauses.GroupClauseVerifier</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities.registration/-h-t-t-p-network-registration-service/index.html">net.corda.node.utilities.registration.HTTPNetworkRegistrationService</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.schema/-hibernate-observer/index.html">net.corda.node.services.schema.HibernateObserver</a></td>
<td>
<p>A vault observer that extracts Object Relational Mappings for contract states that support it, and persists them with Hibernate.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-identity-service/index.html">net.corda.core.node.services.IdentityService</a></td>
<td>
<p>An identity service maintains an bidirectional map of <a href="../net.corda.core.crypto/-party/index.html">Party</a>s to their associated public keys and thus supports
lookup of a party given its key. This is obviously very incomplete and does not reflect everything a real identity
service would provide.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-illegal-flow-logic-exception/index.html">net.corda.core.flows.IllegalFlowLogicException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-immutable-class-serializer/index.html">net.corda.core.serialization.ImmutableClassSerializer</a></td>
<td>
<p>Serializes properties and deserializes by using the constructor. This assumes that all backed properties are
set via the constructor and the class is immutable.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.identity/-in-memory-identity-service/index.html">net.corda.node.services.identity.InMemoryIdentityService</a></td>
<td>
<p>Simple identity service which caches parties and provides functionality for efficient lookup.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-in-memory-network-map-cache/index.html">net.corda.node.services.network.InMemoryNetworkMapCache</a></td>
<td>
<p>Extremely simple in-memory cache of the network map.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-in-memory-network-map-service/index.html">net.corda.node.services.network.InMemoryNetworkMapService</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-in-memory-state-machine-recorded-transaction-mapping-storage/index.html">net.corda.node.services.persistence.InMemoryStateMachineRecordedTransactionMappingStorage</a></td>
<td>
<p>This is a temporary in-memory storage of a state machine id -&gt; txhash mapping</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-in-memory-uniqueness-provider/index.html">net.corda.node.services.transactions.InMemoryUniquenessProvider</a></td>
<td>
<p>A dummy Uniqueness provider that stores the whole history of consumed states in memory</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/com.esotericsoftware.kryo.io.-input/index.html">com.esotericsoftware.kryo.io.Input</a> (extensions in package net.corda.core.serialization)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/java.io.-input-stream/index.html">java.io.InputStream</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-input-stream-serializer/index.html">net.corda.core.serialization.InputStreamSerializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-instant-column-type/index.html">net.corda.node.utilities.InstantColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="http://docs.oracle.com/javase/6/docs/api/java/time/Instant.html">java.time.Instant</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas.requery.converters/-instant-converter/index.html">net.corda.core.schemas.requery.converters.InstantConverter</a></td>
<td>
<p>Converts from a <a href="http://docs.oracle.com/javase/6/docs/api/java/time/Instant.html">Instant</a> to a <a href="http://docs.oracle.com/javase/6/docs/api/java/sql/Timestamp.html">java.sql.Timestamp</a> for Java 8. Note that
when converting between the time type and the database type all times will be converted to the
UTC zone offset.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-instant-generator/index.html">net.corda.core.testing.InstantGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-insufficient-balance-exception/index.html">net.corda.core.contracts.InsufficientBalanceException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/kotlin.-int/index.html">kotlin.Int</a> (extensions in package net.corda.core.contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.-int/index.html">kotlin.Int</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.math/-interpolator/index.html">net.corda.core.math.Interpolator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.math/-interpolator-factory/index.html">net.corda.core.math.InterpolatorFactory</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-issuance-definition.html">net.corda.core.contracts.IssuanceDefinition</a></td>
<td>
<p>Marker interface for data classes that represent the issuance state for a contract. These are intended as templates
from which the state object is initialised.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-issue-command/index.html">net.corda.core.contracts.IssueCommand</a></td>
<td>
<p>A common issue command, to enforce that issue commands have a nonce value.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-issue-generator/index.html">net.corda.contracts.testing.IssueGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-issued/index.html">net.corda.core.contracts.Issued</a></td>
<td>
<p>Definition for an issued product, which can be cash, a cash-like thing, assets, or generally anything else that's
quantifiable with integer quantities.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-issued-generator/index.html">net.corda.core.testing.IssuedGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-issuer-flow/index.html">net.corda.flows.IssuerFlow</a></td>
<td>
<p>This flow enables a client to request issuance of some <a href="../net.corda.core.contracts/-fungible-asset/index.html">FungibleAsset</a> from a
server acting as an issuer (see <a href="../net.corda.core.contracts/-issued/index.html">Issued</a>) of FungibleAssets.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package net.corda.core.contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package net.corda.core.node.services)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.asset/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package net.corda.contracts.asset)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-j-d-b-c-hash-map/index.html">net.corda.node.utilities.JDBCHashMap</a></td>
<td>
<p>A convenient JDBC table backed hash map with iteration order based on insertion order.
See <a href="../net.corda.node.utilities/-abstract-j-d-b-c-hash-map/index.html">AbstractJDBCHashMap</a> for further implementation details.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-j-d-b-c-hash-set/index.html">net.corda.node.utilities.JDBCHashSet</a></td>
<td>
<p>A convenient JDBC table backed hash set with iteration order based on insertion order.
See <a href="../net.corda.node.utilities/-abstract-j-d-b-c-hash-set/index.html">AbstractJDBCHashSet</a> and <a href="../net.corda.node.utilities/-abstract-j-d-b-c-hash-map/index.html">AbstractJDBCHashMap</a> for further implementation details.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-j-d-b-c-hashed-table/index.html">net.corda.node.utilities.JDBCHashedTable</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-key-management-service/index.html">net.corda.core.node.services.KeyManagementService</a></td>
<td>
<p>The KMS is responsible for storing and using private keys to sign things. An implementation of this may, for example,
call out to a hardware security module that enforces various auditing and frequency-of-use requirements.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/java.security.-key-pair/index.html">java.security.KeyPair</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.database/-kotlin-configuration-transaction-wrapper/index.html">net.corda.node.services.database.KotlinConfigurationTransactionWrapper</a></td>
<td>
<p>Requery KotlinConfiguration wrapper class to enable us to pass in an existing database connection and
associated transaction context.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-kotlin-object-serializer/index.html">net.corda.core.serialization.KotlinObjectSerializer</a></td>
<td>
<p>Serializer to deserialize kotlin object definitions marked with <a href="../net.corda.core.serialization/-deserialize-as-kotlin-object-def.html">DeserializeAsKotlinObjectDef</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/com.esotericsoftware.kryo.-kryo/index.html">com.esotericsoftware.kryo.Kryo</a> (extensions in package net.corda.core.serialization)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-kryo-serialization-customization/index.html">net.corda.core.serialization.KryoSerializationCustomization</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-last-acknowledge-info/index.html">net.corda.node.services.network.LastAcknowledgeInfo</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-ledger-transaction/index.html">net.corda.core.transactions.LedgerTransaction</a></td>
<td>
<p>A LedgerTransaction is derived from a <a href="../net.corda.core.transactions/-wire-transaction/index.html">WireTransaction</a>. It is the result of doing the following operations:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-left-outer-joined-map/index.html">net.corda.client.fxutils.LeftOuterJoinedMap</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-left-outer-joined-map/index.html">LeftOuterJoinedMap</a> implements a special case of a left outer join where we're matching on primary keys of both
tables.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.math/-linear-interpolator/index.html">net.corda.core.math.LinearInterpolator</a></td>
<td>
<p>Interpolates values between the given data points using straight lines.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-linear-state/index.html">net.corda.core.contracts.LinearState</a></td>
<td>
<p>A state that evolves by superseding itself, all of which share the common "linearId".</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.collections.-list/index.html">kotlin.collections.List</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/com.google.common.util.concurrent.-listenable-future/index.html">com.google.common.util.concurrent.ListenableFuture</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/java.time.-local-date/index.html">java.time.LocalDate</a> (extensions in package net.corda.core.contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-local-date-column-type/index.html">net.corda.node.utilities.LocalDateColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="http://docs.oracle.com/javase/6/docs/api/java/time/LocalDate.html">java.time.LocalDate</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-local-date-time-column-type/index.html">net.corda.node.utilities.LocalDateTimeColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="http://docs.oracle.com/javase/6/docs/api/java/time/LocalDateTime.html">java.time.LocalDateTime</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-log-helper/index.html">net.corda.core.utilities.LogHelper</a></td>
<td>
<p>A configuration helper that allows modifying the log level for specific loggers</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/org.slf4j.-logger/index.html">org.slf4j.Logger</a> (extensions in package net.corda.core.utilities)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/org.slf4j.-logger/index.html">org.slf4j.Logger</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-logging-whitelist/index.html">net.corda.core.serialization.LoggingWhitelist</a></td>
<td>
<p>This class is not currently used, but can be installed to log a large number of missing entries from the whitelist
and was used to track down the initial set.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.-long/index.html">kotlin.Long</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-map-values-list/index.html">net.corda.client.fxutils.MapValuesList</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-map-values-list/index.html">MapValuesList</a> takes an <a href="#">ObservableMap</a> and returns its values as an <a href="#">ObservableList</a>.
The order of returned elements is deterministic but unspecified.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-mapped-list/index.html">net.corda.client.fxutils.MappedList</a></td>
<td>
<p>This is a variant of <a href="#">EasyBind.map</a> where the mapped list is backed, therefore the mapping function will only be run
when an element is inserted or updated.
Use this instead of <a href="#">EasyBind.map</a> to trade off memory vs CPU, or if (god forbid) the mapped function is side-effecting.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas/-mapped-schema/index.html">net.corda.core.schemas.MappedSchema</a></td>
<td>
<p>A database schema that might be configured for this node.  As well as a name and version for identifying the schema,
also list the classes that may be used in the generated object graph in order to configure the ORM tool.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-marshalled-observation/index.html">net.corda.node.services.messaging.MarshalledObservation</a></td>
<td>
<p>Used in the RPC wire protocol to wrap an observation with the handle of the observable it's intended for.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-merkle-tree/index.html">net.corda.core.crypto.MerkleTree</a></td>
<td>
<p>Creation and verification of a Merkle Tree for a Wire Transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-merkle-tree-exception/index.html">net.corda.core.crypto.MerkleTreeException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-message/index.html">net.corda.core.messaging.Message</a></td>
<td>
<p>A message is defined, at this level, to be a (topic, timestamp, byte arrays) triple, where the topic is a string in
Java-style reverse dns form, with "platform." being a prefix reserved by the platform for its own use. Vendor
specific messages can be defined, but use your domain name as the prefix e.g. "uk.co.bigbank.messages.SomeMessage".</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-message-handler-registration.html">net.corda.core.messaging.MessageHandlerRegistration</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-message-recipient-group.html">net.corda.core.messaging.MessageRecipientGroup</a></td>
<td>
<p>A base class for a set of recipients specifically identified by the sender.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-message-recipients.html">net.corda.core.messaging.MessageRecipients</a></td>
<td>
<p>The interface for a group of message recipients (which may contain only one recipient)</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-messaging-service/index.html">net.corda.core.messaging.MessagingService</a></td>
<td>
<p>A <a href="../net.corda.core.messaging/-messaging-service/index.html">MessagingService</a> sits at the boundary between a message routing / networking layer and the core platform code.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-messaging-service-builder/index.html">net.corda.node.services.api.MessagingServiceBuilder</a></td>
<td>
<p>This class lets you start up a <a href="../net.corda.core.messaging/-messaging-service/index.html">MessagingService</a>. Its purpose is to stop you from getting access to the methods
on the messaging service interface until you have successfully started up the system. One of these objects should
be the only way to obtain a reference to a <a href="../net.corda.core.messaging/-messaging-service/index.html">MessagingService</a>. Startup may be a slow process: some implementations
may let you cast the returned future to an object that lets you get status info.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-messaging-service-internal/index.html">net.corda.node.services.api.MessagingServiceInternal</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-missing-attachments-exception/index.html">net.corda.core.serialization.MissingAttachmentsException</a></td>
<td>
<p>Thrown during deserialisation to indicate that an attachment needed to construct the <a href="../net.corda.core.transactions/-wire-transaction/index.html">WireTransaction</a> is not found</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-models/index.html">net.corda.client.model.Models</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-monitoring-service/index.html">net.corda.node.services.api.MonitoringService</a></td>
<td>
<p>Provides access to various metrics and ways to notify monitoring services of things, for sysadmin purposes.
This is not an interface because it is too lightweight to bother mocking out.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-move-command/index.html">net.corda.core.contracts.MoveCommand</a></td>
<td>
<p>A common move command for contract states which can change owner.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-move-generator/index.html">net.corda.contracts.testing.MoveGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-multilateral-net-state/index.html">net.corda.contracts.clause.MultilateralNetState</a></td>
<td>
<p>Subset of state, containing the elements which must match for two or more obligation transactions to be candidates
for netting (this does not include the checks to enforce that everyone's amounts received are the same at the end,
which is handled under the verify() function).
In comparison to <a href="../net.corda.contracts.clause/-bilateral-net-state/index.html">BilateralNetState</a>, this doesn't include the parties' keys, as ensuring balances match on
input and output is handled elsewhere.
Used in cases where all parties (or their proxies) are signing, such as central clearing.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-multilateral-nettable-state/index.html">net.corda.core.contracts.MultilateralNettableState</a></td>
<td>
<p>Interface for state objects that support being netted with other state objects.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-mutable-class-whitelist/index.html">net.corda.core.serialization.MutableClassWhitelist</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-mutable-clock/index.html">net.corda.node.utilities.MutableClock</a></td>
<td>
<p>An abstract class with helper methods for a type of Clock that might have it's concept of "now"
adjusted externally.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-named-by-hash/index.html">net.corda.core.contracts.NamedByHash</a></td>
<td>
<p>Implemented by anything that can be named by a secure hash value (e.g. transactions, attachments).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-net-clause/index.html">net.corda.contracts.clause.NetClause</a></td>
<td>
<p>Clause for netting contract states. Currently only supports obligation contract.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-net-command/index.html">net.corda.core.contracts.NetCommand</a></td>
<td>
<p>A common netting command for contracts whose states can be netted.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-net-state/index.html">net.corda.contracts.clause.NetState</a></td>
<td>
<p>Common interface for the state subsets used when determining nettability of two or more states. Exposes the
underlying issued thing.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-net-type/index.html">net.corda.core.contracts.NetType</a></td>
<td>
<p>Enum for the types of netting that can be applied to state objects. Exact behaviour
for each type of netting is left to the contract to determine.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-nettable-state.html">net.corda.core.contracts.NettableState</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-network-cache-error/index.html">net.corda.core.node.services.NetworkCacheError</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-network-identity-model/index.html">net.corda.client.model.NetworkIdentityModel</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-network-map-cache/index.html">net.corda.core.node.services.NetworkMapCache</a></td>
<td>
<p>A network map contains lists of nodes on the network along with information about their identity keys, services
they provide and host names or IP addresses where they can be connected to. The cache wraps around a map fetched
from an authoritative service, and adds easy lookup of the data stored within it. Generally it would be initialised
with a specified network map service, which it fetches data from and then subscribes to updates of.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.internal/-network-map-info/index.html">net.corda.node.internal.NetworkMapInfo</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-network-map-service/index.html">net.corda.node.services.network.NetworkMapService</a></td>
<td>
<p>A network map contains lists of nodes on the network along with information about their identity keys, services
they provide and host names or IP addresses where they can be connected to. This information is cached locally within
nodes, by the <a href="../net.corda.core.node.services/-network-map-cache/index.html">NetworkMapCache</a>. Currently very basic consensus controls are applied, using signed changes which
replace each other based on a serial number present in the change.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities.registration/-network-registration-helper/index.html">net.corda.node.utilities.registration.NetworkRegistrationHelper</a></td>
<td>
<p>This checks the <a href="#">config.certificatesDirectory</a> for certificates required to connect to a Corda network.
If the certificates are not found, a <a href="#">PKCS10CertificationRequest</a> will be submitted to Corda network permissioning server using <a href="../net.corda.node.utilities.registration/-network-registration-service/index.html">NetworkRegistrationService</a>.
This process will enter a polling loop until the request has been approved, and then
the certificate chain will be downloaded and stored in <a href="#">Keystore</a> reside in <a href="#">config.certificatesDirectory</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities.registration/-network-registration-service/index.html">net.corda.node.utilities.registration.NetworkRegistrationService</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-no-references-serializer/index.html">net.corda.core.serialization.NoReferencesSerializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.clause/-no-zero-sized-outputs/index.html">net.corda.contracts.clause.NoZeroSizedOutputs</a></td>
<td>
<p>Clause for fungible asset contracts, which enforces that no output state should have
a balance of zero.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.internal/-node/index.html">net.corda.node.internal.Node</a></td>
<td>
<p>A Node manages a standalone server that takes part in the P2P network. It creates the services found in <a href="../net.corda.core.node/-service-hub/index.html">ServiceHub</a>,
loads important data off disk and starts listening for connections.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-node-attachment-service/index.html">net.corda.node.services.persistence.NodeAttachmentService</a></td>
<td>
<p>Stores attachments in the specified local directory, which must exist. Doesn't allow new attachments to be uploaded.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.serialization/-node-clock/index.html">net.corda.node.serialization.NodeClock</a></td>
<td>
<p>A <a href="http://docs.oracle.com/javase/6/docs/api/java/time/Clock.html">Clock</a> that tokenizes itself when serialized, and delegates to an underlying <a href="http://docs.oracle.com/javase/6/docs/api/java/time/Clock.html">Clock</a> implementation.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.config/-node-configuration/index.html">net.corda.node.services.config.NodeConfiguration</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.driver/-node-handle/index.html">net.corda.node.driver.NodeHandle</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-node-info/index.html">net.corda.core.node.NodeInfo</a></td>
<td>
<p>Info about a network node that acts on behalf of some form of contract party.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-node-login-module/index.html">net.corda.node.services.messaging.NodeLoginModule</a></td>
<td>
<p>Clients must connect to us with a username and password and must use TLS. If a someone connects with
<a href="../net.corda.node.services.messaging/-artemis-messaging-component/-n-o-d-e_-u-s-e-r.html">ArtemisMessagingComponent.NODE_USER</a> then we confirm it's just us as the node by checking their TLS certificate
is the same as our one in our key store. Then they're given full access to all valid queues. If they connect with
<a href="../net.corda.node.services.messaging/-artemis-messaging-component/-p-e-e-r_-u-s-e-r.html">ArtemisMessagingComponent.PEER_USER</a> then we confirm they belong on our P2P network by checking their root CA is
the same as our root CA. If that's the case the only access they're given is the ablility send to our P2P address.
In both cases the messages these authenticated nodes send to us are tagged with their subject DN and we assume
the CN within that is their legal name.
Otherwise if the username is neither of the above we assume it's an RPC user and authenticate against our list of
valid RPC users. RPC clients are given permission to perform RPC and nothing else.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-node-map-error/index.html">net.corda.node.services.network.NodeMapError</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-node-messaging-client/index.html">net.corda.node.services.messaging.NodeMessagingClient</a></td>
<td>
<p>This class implements the <a href="../net.corda.core.messaging/-messaging-service/index.html">MessagingService</a> API using Apache Artemis, the successor to their ActiveMQ product.
Artemis is a message queue broker and here we run a client connecting to the specified broker instance
<a href="../net.corda.node.services.messaging/-artemis-messaging-server/index.html">ArtemisMessagingServer</a>. It's primarily concerned with peer-to-peer messaging.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-node-monitor-model/index.html">net.corda.client.model.NodeMonitorModel</a></td>
<td>
<p>This model exposes raw event streams to and from the node.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-node-registration/index.html">net.corda.node.services.network.NodeRegistration</a></td>
<td>
<p>A node registration state in the network map.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-node-registration-info/index.html">net.corda.node.services.network.NodeRegistrationInfo</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.events/-node-scheduler-service/index.html">net.corda.node.services.events.NodeSchedulerService</a></td>
<td>
<p>A first pass of a simple <a href="../net.corda.core.node.services/-scheduler-service/index.html">SchedulerService</a> that works with <a href="../net.corda.node.utilities/-mutable-clock/index.html">MutableClock</a>s for testing, demonstrations and simulations
that also encompasses the <a href="#">Vault</a> observer for processing transactions.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.schema/-node-schema-service/index.html">net.corda.node.services.schema.NodeSchemaService</a></td>
<td>
<p>Most basic implementation of <a href="../net.corda.node.services.api/-schema-service/index.html">SchemaService</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.vault/-node-vault-service/index.html">net.corda.node.services.vault.NodeVaultService</a></td>
<td>
<p>Currently, the node vault service is a very simple RDBMS backed implementation.  It will change significantly when
we add further functionality as the design for the vault and vault service matures.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-non-empty-set/index.html">net.corda.core.utilities.NonEmptySet</a></td>
<td>
<p>A set which is constrained to ensure it can never be empty. An initial value must be provided at
construction, and attempting to remove the last element will cause an IllegalStateException.
The underlying set is exposed for Kryo to access, but should not be accessed directly.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-non-empty-set-serializer/index.html">net.corda.core.utilities.NonEmptySetSerializer</a></td>
<td>
<p>Custom serializer which understands it has to read in an item before
trying to construct the set.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-non-validating-notary-flow/index.html">net.corda.flows.NonValidatingNotaryFlow</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-normal-session-end/index.html">net.corda.node.services.statemachine.NormalSessionEnd</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services/-notary-change/index.html">net.corda.node.services.NotaryChange</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-notary-change-flow/index.html">net.corda.flows.NotaryChangeFlow</a></td>
<td>
<p>A flow to be used for changing a state's Notary. This is required since all input states to a transaction
must point to the same notary.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-notary-error/index.html">net.corda.flows.NotaryError</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-notary-exception/index.html">net.corda.flows.NotaryException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-notary-flow/index.html">net.corda.flows.NotaryFlow</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-notary-service/index.html">net.corda.node.services.transactions.NotaryService</a></td>
<td>
<p>A Notary service acts as the final signer of a transaction ensuring two things:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-null-public-key/index.html">net.corda.core.crypto.NullPublicKey</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-null-signature.html">net.corda.core.crypto.NullSignature</a></td>
<td>
<p>A signature with a key and value of zero. Useful when you want a signature object that you know won't ever be used.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.asset/-obligation/index.html">net.corda.contracts.asset.Obligation</a></td>
<td>
<p>An obligation contract commits the obligor to delivering a specified amount of a fungible asset (for example the
<a href="../net.corda.contracts.asset/-cash/index.html">Cash</a> contract) at a specified future point in time. Settlement transactions may split and merge contracts across
multiple input and output states. The goal of this design is to handle amounts owed, and these contracts are expected
to be netted/merged, with settlement only for any remainder amount.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/rx.-observable/index.html">rx.Observable</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/rx.-observable/index.html">rx.Observable</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/rx.-observable/index.html">rx.Observable</a> (extensions in package net.corda.node.utilities)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/javafx.collections.-observable-list/index.html">javafx.collections.ObservableList</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/javafx.collections.-observable-map/index.html">javafx.collections.ObservableMap</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/javafx.beans.value.-observable-value/index.html">javafx.beans.value.ObservableValue</a> (extensions in package net.corda.client.fxutils)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/rx.-observer/index.html">rx.Observer</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/rx.-observer/index.html">rx.Observer</a> (extensions in package net.corda.node.utilities)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.asset/-on-ledger-asset/index.html">net.corda.contracts.asset.OnLedgerAsset</a></td>
<td>
<p>An asset transaction may split and merge assets represented by a set of (issuer, depositRef) pairs, across multiple
input and output states. Imagine a Bitcoin transaction but in which all UTXOs had a colour (a blend of
issuer+depositRef) and you couldn't merge outputs of two colours together, but you COULD put them in the same
transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-opaque-bytes/index.html">net.corda.core.serialization.OpaqueBytes</a></td>
<td>
<p>A simple class that wraps a byte array and makes the equals/hashCode/toString methods work as you actually expect.
In an ideal JVM this would be a value type and be completely overhead free. Project Valhalla is adding such
functionality to Java, but it won't arrive for a few years yet!</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.config/-optional-config/index.html">net.corda.node.services.config.OptionalConfig</a></td>
<td>
<p>Helper class for optional configurations</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-ordered-serializer/index.html">net.corda.core.serialization.OrderedSerializer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/com.esotericsoftware.kryo.io.-output/index.html">com.esotericsoftware.kryo.io.Output</a> (extensions in package net.corda.core.serialization)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-ownable-state/index.html">net.corda.core.contracts.OwnableState</a></td>
<td>
<p>A contract state that can have a single owner.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-partial-merkle-tree/index.html">net.corda.core.crypto.PartialMerkleTree</a></td>
<td>
<p>Building and verification of Partial Merkle Tree.
Partial Merkle Tree is a minimal tree needed to check that a given set of leaves belongs to a full Merkle Tree.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-partially-resolved-transaction/index.html">net.corda.client.model.PartiallyResolvedTransaction</a></td>
<td>
<p><a href="../net.corda.client.model/-partially-resolved-transaction/index.html">PartiallyResolvedTransaction</a> holds a <a href="../net.corda.core.transactions/-signed-transaction/index.html">SignedTransaction</a> that has zero or more inputs resolved. The intent is
to prepare clients for cases where an input can only be resolved in the future/cannot be resolved at all (for example
because of permissioning)</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-party/index.html">net.corda.core.crypto.Party</a></td>
<td>
<p>The <a href="../net.corda.core.crypto/-party/index.html">Party</a> class represents an entity on the network, which is typically identified by a legal <a href="../net.corda.core.crypto/-party/name.html">name</a> and public key
that it can sign transactions under. As parties may use multiple keys for signing and, for example, have offline backup
keys, the "public key" of a party is represented by a composite construct  a <a href="../net.corda.core.crypto/-composite-key/index.html">CompositeKey</a>, which combines multiple
cryptographic public key primitives into a tree structure.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-party-and-reference/index.html">net.corda.core.contracts.PartyAndReference</a></td>
<td>
<p>Reference to something being stored or issued by a party e.g. in a vault or (more likely) on their normal
ledger. The reference is intended to be encrypted so it's meaningless to anyone other than the party.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-party-and-reference-generator/index.html">net.corda.core.testing.PartyAndReferenceGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-party-columns/index.html">net.corda.node.utilities.PartyColumns</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-party-generator/index.html">net.corda.core.testing.PartyGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-party-info/index.html">net.corda.core.node.services.PartyInfo</a></td>
<td>
<p>Holds information about a <a href="../net.corda.core.crypto/-party/index.html">Party</a>, which may refer to either a specific node or a service.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/java.nio.file.-path/index.html">java.nio.file.Path</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-payment-rule/index.html">net.corda.core.contracts.PaymentRule</a></td>
<td>
<p>Whether the payment should be made before the due date, or after it.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-permission-exception/index.html">net.corda.node.services.messaging.PermissionException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.keys/-persistent-key-management-service/index.html">net.corda.node.services.keys.PersistentKeyManagementService</a></td>
<td>
<p>A persistent re-implementation of <a href="../net.corda.node.services.keys/-e2-e-test-key-management-service/index.html">E2ETestKeyManagementService</a> to support node re-start.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-persistent-network-map-service/index.html">net.corda.node.services.network.PersistentNetworkMapService</a></td>
<td>
<p>A network map service backed by a database to survive restarts of the node hosting it.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas/-persistent-state/index.html">net.corda.core.schemas.PersistentState</a></td>
<td>
<p>A super class for all mapped states exported to a schema that ensures the <a href="../net.corda.core.contracts/-state-ref/index.html">StateRef</a> appears on the database row.  The
<a href="../net.corda.core.contracts/-state-ref/index.html">StateRef</a> will be set to the correct value by the framework (there's no need to set during mapping generation by the state itself).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas/-persistent-state-ref/index.html">net.corda.core.schemas.PersistentStateRef</a></td>
<td>
<p>Embedded <a href="../net.corda.core.contracts/-state-ref/index.html">StateRef</a> representation used in state mapping.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-persistent-uniqueness-provider/index.html">net.corda.node.services.transactions.PersistentUniquenessProvider</a></td>
<td>
<p>A RDBMS backed Uniqueness provider</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-physical-location/index.html">net.corda.core.node.PhysicalLocation</a></td>
<td>
<p>A labelled <a href="../net.corda.core.node/-world-coordinate/index.html">WorldCoordinate</a>, where the label is human meaningful. For example, the name of the nearest city.
Labels should not refer to non-landmarks, for example, they should not contain the names of organisations.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-plugin-service-hub/index.html">net.corda.core.node.PluginServiceHub</a></td>
<td>
<p>A service hub to be used by the <a href="../net.corda.core.node/-corda-plugin-registry/index.html">CordaPluginRegistry</a></p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.math/-polynomial/index.html">net.corda.core.math.Polynomial</a></td>
<td>
<p>Represents a polynomial function of arbitrary degree.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.driver/-port-allocation/index.html">net.corda.node.driver.PortAllocation</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/java.security.-private-key/index.html">java.security.PrivateKey</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-private-key-generator/index.html">net.corda.core.testing.PrivateKeyGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-progress-tracker/index.html">net.corda.core.utilities.ProgressTracker</a></td>
<td>
<p>A progress tracker helps surface information about the progress of an operation to a user interface or API of some
kind. It lets you define a set of <emph>steps</emph> that represent an operation. A step is represented by an object (typically
a singleton).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-progress-tracking-event/index.html">net.corda.client.model.ProgressTrackingEvent</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/java.security.-public-key/index.html">java.security.PublicKey</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-public-key-column-type/index.html">net.corda.node.utilities.PublicKeyColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="http://docs.oracle.com/javase/6/docs/api/java/security/PublicKey.html">PublicKey</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-public-key-generator/index.html">net.corda.core.testing.PublicKeyGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas/-queryable-state/index.html">net.corda.core.schemas.QueryableState</a></td>
<td>
<p>A contract state that may be mapped to database schemas configured for this node to support querying for,
or filtering of, states.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-r-p-c-dispatcher/index.html">net.corda.node.services.messaging.RPCDispatcher</a></td>
<td>
<p>Intended to service transient clients only (not p2p nodes) for short-lived, transient request/response pairs.
If you need robustness, this is the wrong system. If you don't want a response, this is probably the
wrong system (you could just send a message). If you want complex customisation of how requests/responses
are handled, this is probably the wrong system.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-r-p-c-exception/index.html">net.corda.node.services.messaging.RPCException</a></td>
<td>
<p>Thrown to indicate a fatal error in the RPC system itself, as opposed to an error generated by the invoked
method.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-r-p-c-ops/index.html">net.corda.core.messaging.RPCOps</a></td>
<td>
<p>Base interface that all RPC servers must implement. Note: in Corda there's only one RPC interface. This base
interface is here in case we split the RPC system out into a separate library one day.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-r-p-c-returns-observables/index.html">net.corda.core.messaging.RPCReturnsObservables</a></td>
<td>
<p>If an RPC is tagged with this annotation it may return one or more observables anywhere in its response graph.
Calling such a method comes with consequences: it's slower, and consumes server side resources as observations
will buffer up on the server until they're consumed by the client.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-r-p-c-since-version/index.html">net.corda.node.services.messaging.RPCSinceVersion</a></td>
<td>
<p>Records the protocol version in which this RPC was added.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services/-r-p-c-user-service/index.html">net.corda.node.services.RPCUserService</a></td>
<td>
<p>Service for retrieving <a href="../net.corda.node.services/-user/index.html">User</a> objects representing RPC users who are authorised to use the RPC system. A <a href="../net.corda.node.services/-user/index.html">User</a>
contains their login username and password along with a set of permissions for RPC services they are allowed access
to. These permissions are represented as <a href="#">String</a>s to allow RPC implementations to add their own permissioning.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services/-r-p-c-user-service-impl/index.html">net.corda.node.services.RPCUserServiceImpl</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-raft-uniqueness-provider/index.html">net.corda.node.services.transactions.RaftUniquenessProvider</a></td>
<td>
<p>A uniqueness provider that records committed input states in a distributed collection replicated and
persisted in a Raft cluster, using the Copycat framework (http://atomix.io/copycat/).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-raft-validating-notary-service/index.html">net.corda.node.services.transactions.RaftValidatingNotaryService</a></td>
<td>
<p>A validating notary service operated by a group of mutually trusting parties, uses the Raft algorithm to achieve consensus.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-read-only-backed-observable-map-base/index.html">net.corda.client.fxutils.ReadOnlyBackedObservableMapBase</a></td>
<td>
<p><a href="../net.corda.client.fxutils/-read-only-backed-observable-map-base/index.html">ReadOnlyBackedObservableMapBase</a> is a base class implementing all abstract functions required for an <a href="#">ObservableMap</a>
using a backing HashMap that subclasses should modify.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-read-only-transaction-storage/index.html">net.corda.core.node.services.ReadOnlyTransactionStorage</a></td>
<td>
<p>Thread-safe storage of transactions.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-receive-only/index.html">net.corda.node.services.statemachine.ReceiveOnly</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-receive-request/index.html">net.corda.node.services.statemachine.ReceiveRequest</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-received-message/index.html">net.corda.core.messaging.ReceivedMessage</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-received-session-message/index.html">net.corda.node.services.statemachine.ReceivedSessionMessage</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-references-aware-java-serializer/index.html">net.corda.core.serialization.ReferencesAwareJavaSerializer</a></td>
<td>
<p>Improvement to the builtin JavaSerializer by honouring the <a href="#">Kryo.getReferences</a> setting.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-regulator-service/index.html">net.corda.node.services.api.RegulatorService</a></td>
<td>
<p>Placeholder interface for regulator services.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.fxutils/-replayed-list/index.html">net.corda.client.fxutils.ReplayedList</a></td>
<td>
<p>This list type just replays changes propagated from the underlying source list. Used for testing changes and backing a
non-backed observable</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas.requery/-requery/index.html">net.corda.core.schemas.requery.Requery</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.database/-requery-configuration/index.html">net.corda.node.services.database.RequeryConfiguration</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-request/index.html">net.corda.node.services.transactions.Request</a></td>
<td>
<p>Sent from <a href="../net.corda.node.services.transactions/-b-f-t-smart-client/index.html">BFTSmartClient</a> to <a href="../net.corda.node.services.transactions/-b-f-t-smart-server/index.html">BFTSmartServer</a></p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-request-type/index.html">net.corda.node.services.transactions.RequestType</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-requirements/index.html">net.corda.core.contracts.Requirements</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-resolve-transactions-flow/index.html">net.corda.flows.ResolveTransactionsFlow</a></td>
<td>
<p>This flow is used to verify the validity of a transaction by recursively checking the validity of all the
dependencies. Once a transaction is checked it's inserted into local storage so it can be relayed and won't be
checked again.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/-retryable-exception/index.html">net.corda.core.RetryableException</a></td>
<td>
<p>This represents a transient exception or condition that might no longer be thrown if the operation is re-run or called
again.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.config/-s-s-l-configuration/index.html">net.corda.node.services.config.SSLConfiguration</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-schedulable-state/index.html">net.corda.core.contracts.SchedulableState</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-scheduled/index.html">net.corda.core.contracts.Scheduled</a></td>
<td>
<p>Something which is scheduled to happen at a point in time</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-scheduled-activity/index.html">net.corda.core.contracts.ScheduledActivity</a></td>
<td>
<p>This class represents the lifecycle activity that a contract state of type <a href="../net.corda.core.contracts/-linear-state/index.html">LinearState</a> would like to perform at a given point in time.
e.g. run a fixing flow.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.events/-scheduled-activity-observer/index.html">net.corda.node.services.events.ScheduledActivityObserver</a></td>
<td>
<p>This observes the vault and schedules and unschedules activities appropriately based on state production and
consumption.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-scheduled-state-ref/index.html">net.corda.core.contracts.ScheduledStateRef</a></td>
<td>
<p>Represents a contract state (unconsumed output) of type <a href="../net.corda.core.contracts/-linear-state/index.html">LinearState</a> and a point in time that a lifecycle event is expected to take place
for that contract state.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-scheduler-service/index.html">net.corda.core.node.services.SchedulerService</a></td>
<td>
<p>Provides access to schedule activity at some point in time.  This interface might well be expanded to
increase the feature set in the future.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-schema-service/index.html">net.corda.node.services.api.SchemaService</a></td>
<td>
<p>A configuration and customisation point for Object Relational Mapping of contract state objects.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-secure-hash/index.html">net.corda.core.crypto.SecureHash</a></td>
<td>
<p>Container for a cryptographically secure hash value.
Provides utilities for generating a cryptographic hash using different algorithms (currently only SHA-256 supported).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-secure-hash-column-type/index.html">net.corda.node.utilities.SecureHashColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="../net.corda.core.crypto/-secure-hash/index.html">SecureHash</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-secure-hash-generator/index.html">net.corda.core.testing.SecureHashGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-send-and-receive/index.html">net.corda.node.services.statemachine.SendAndReceive</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-send-only/index.html">net.corda.node.services.statemachine.SendOnly</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-send-request/index.html">net.corda.node.services.statemachine.SendRequest</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialization-customization/index.html">net.corda.core.serialization.SerializationCustomization</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialization-token/index.html">net.corda.core.serialization.SerializationToken</a></td>
<td>
<p>This represents a token in the serialized stream for an instance of a type that implements <a href="../net.corda.core.serialization/-serialize-as-token/index.html">SerializeAsToken</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialize-as-token/index.html">net.corda.core.serialization.SerializeAsToken</a></td>
<td>
<p>This interface should be implemented by classes that want to substitute a token representation of themselves if
they are serialized because they have a lot of internal state that does not serialize (well).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialize-as-token-context/index.html">net.corda.core.serialization.SerializeAsTokenContext</a></td>
<td>
<p>A context for mapping SerializationTokens to/from SerializeAsTokens.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialize-as-token-serializer/index.html">net.corda.core.serialization.SerializeAsTokenSerializer</a></td>
<td>
<p>A Kryo serializer for <a href="../net.corda.core.serialization/-serialize-as-token/index.html">SerializeAsToken</a> implementations.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialized-bytes/index.html">net.corda.core.serialization.SerializedBytes</a></td>
<td>
<p>A type safe wrapper around a byte array that contains a serialised object. You can call <a href="../net.corda.core.serialization/kotlin.-byte-array/deserialize.html">SerializedBytes.deserialize</a>
to get the original object back.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-serialized-bytes-serializer/index.html">net.corda.core.serialization.SerializedBytesSerializer</a></td>
<td>
<p>A serialiser that avoids writing the wrapper class to the byte stream, thus ensuring <a href="../net.corda.core.serialization/-serialized-bytes/index.html">SerializedBytes</a> is a pure
type safety hack.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-service-entry/index.html">net.corda.core.node.ServiceEntry</a></td>
<td>
<p>Information for an advertised service including the service specific identity information.
The identity can be used in flows and is distinct from the Node's legalIdentity</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-service-hub/index.html">net.corda.core.node.ServiceHub</a></td>
<td>
<p>A service hub simply vends references to the other services a node has. Some of those services may be missing or
mocked out. This class is useful to pass to chunks of pluggable code that might have need of many different kinds of
functionality and you don't want to hard-code which types in the interface.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.api/-service-hub-internal/index.html">net.corda.node.services.api.ServiceHubInternal</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-service-identity-generator/index.html">net.corda.node.utilities.ServiceIdentityGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-service-info/index.html">net.corda.core.node.services.ServiceInfo</a></td>
<td>
<p>A container for additional information for an advertised service.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-service-request-message/index.html">net.corda.flows.ServiceRequestMessage</a></td>
<td>
<p>Abstract superclass for request messages sent to services which expect a reply.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-service-type/index.html">net.corda.core.node.services.ServiceType</a></td>
<td>
<p>Identifier for service types a node can expose over the network to other peers. These types are placed into network
map advertisements. Services that are purely local and are not providing functionality to other parts of the network
don't need a declared service type.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-services-for-resolution/index.html">net.corda.core.node.ServicesForResolution</a></td>
<td>
<p>Subset of node services that are used for loading transactions from the wire into fully resolved, looked up
forms ready for verification.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-confirm/index.html">net.corda.node.services.statemachine.SessionConfirm</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-data/index.html">net.corda.node.services.statemachine.SessionData</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-end.html">net.corda.node.services.statemachine.SessionEnd</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-init/index.html">net.corda.node.services.statemachine.SessionInit</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-init-response/index.html">net.corda.node.services.statemachine.SessionInitResponse</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-message.html">net.corda.node.services.statemachine.SessionMessage</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-session-reject/index.html">net.corda.node.services.statemachine.SessionReject</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-sessioned-flow-i-o-request/index.html">net.corda.node.services.statemachine.SessionedFlowIORequest</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/com.google.common.util.concurrent.-settable-future/index.html">com.google.common.util.concurrent.SettableFuture</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-signed-data/index.html">net.corda.core.crypto.SignedData</a></td>
<td>
<p>A serialized piece of data and its signature. Enforces signature validity in order to deserialize the data
contained within.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-signed-transaction/index.html">net.corda.core.transactions.SignedTransaction</a></td>
<td>
<p>SignedTransaction wraps a serialized WireTransaction. It contains one or more signatures, each one for
a public key that is mentioned inside a transaction command. SignedTransaction is the top level transaction type
and the type most frequently passed around the network and stored. The identity of a transaction is the hash
of a WireTransaction, therefore if you are storing data keyed by WT hash be aware that multiple different STs may
map to the same key (and they could be different in important ways, like validity!). The signatures on a
SignedTransaction might be invalid or missing: the type does not imply validity.
A transaction ID should be the hash of the <a href="../net.corda.core.transactions/-wire-transaction/index.html">WireTransaction</a> Merkle tree root. Thus adding or removing a signature does not change it.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-signed-transaction-generator/index.html">net.corda.contracts.testing.SignedTransactionGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-simple-notary-service/index.html">net.corda.node.services.transactions.SimpleNotaryService</a></td>
<td>
<p>A simple Notary service that does not perform transaction validation</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-single-message-recipient.html">net.corda.core.messaging.SingleMessageRecipient</a></td>
<td>
<p>A base class for the case of point-to-point messages</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-singleton-serialization-token/index.html">net.corda.core.serialization.SingletonSerializationToken</a></td>
<td>
<p>A class representing a <a href="../net.corda.core.serialization/-serialization-token/index.html">SerializationToken</a> for some object that is not serializable but can be looked up
(when deserialized) via just the class name.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-singleton-serialize-as-token/index.html">net.corda.core.serialization.SingletonSerializeAsToken</a></td>
<td>
<p>A base class for implementing large objects / components / services that need to serialize themselves to a string token
to indicate which instance the token is a serialized form of.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.math/-spline-function/index.html">net.corda.core.math.SplineFunction</a></td>
<td>
<p>A <emph>spline</emph> is function piecewise-defined by polynomial functions.
Points at which polynomial pieces connect are known as <emph>knots</emph>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-stack-snapshot/index.html">net.corda.node.services.statemachine.StackSnapshot</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-state-and-ref/index.html">net.corda.core.contracts.StateAndRef</a></td>
<td>
<p>A StateAndRef is simply a (state, ref) pair. For instance, a vault (which holds available assets) contains these.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-state-machine-data/index.html">net.corda.client.model.StateMachineData</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-state-machine-info/index.html">net.corda.core.messaging.StateMachineInfo</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-state-machine-manager/index.html">net.corda.node.services.statemachine.StateMachineManager</a></td>
<td>
<p>A StateMachineManager is responsible for coordination and persistence of multiple <a href="../net.corda.core.flows/-flow-state-machine/index.html">FlowStateMachine</a> objects.
Each such object represents an instantiation of a (two-party) flow that has reached a particular point.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-state-machine-recorded-transaction-mapping-storage/index.html">net.corda.core.node.services.StateMachineRecordedTransactionMappingStorage</a></td>
<td>
<p>This is the interface to storage storing state machine -&gt; recorded tx mappings. Any time a transaction is recorded
during a flow run <a href="../net.corda.core.node.services/-state-machine-recorded-transaction-mapping-storage/add-mapping.html">addMapping</a> should be called.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.flows/-state-machine-run-id/index.html">net.corda.core.flows.StateMachineRunId</a></td>
<td>
<p>A unique identifier for a single state machine run, valid across node restarts. Note that a single run always
has at least one flow, but that flow may also invoke sub-flows: they all share the same run id.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-state-machine-status/index.html">net.corda.client.model.StateMachineStatus</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-state-machine-transaction-mapping/index.html">net.corda.core.node.services.StateMachineTransactionMapping</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-state-machine-update/index.html">net.corda.core.messaging.StateMachineUpdate</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-state-ref/index.html">net.corda.core.contracts.StateRef</a></td>
<td>
<p>A stateref is a pointer (reference) to a state, this is an equivalent of an "outpoint" in Bitcoin. It records which
transaction defined the state and where in that transaction it was.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-state-ref-columns/index.html">net.corda.node.utilities.StateRefColumns</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas.requery.converters/-state-ref-converter/index.html">net.corda.core.schemas.requery.converters.StateRefConverter</a></td>
<td>
<p>Converts from a <a href="../net.corda.core.contracts/-state-ref/index.html">StateRef</a> to a Composite Key defined by a <a href="#">String</a> txnHash and an <a href="#">Int</a> index</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-state-ref-generator/index.html">net.corda.core.testing.StateRefGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-state-replacement-exception/index.html">net.corda.flows.StateReplacementException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-storage-service/index.html">net.corda.core.node.services.StorageService</a></td>
<td>
<p>A sketch of an interface to a simple key/value storage system. Intended for persistence of simple blobs like
transactions, serialised flow state machines and so on. Again, this isn't intended to imply lack of SQL or
anything like that, this interface is only big enough to support the prototyping work.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.persistence/-storage-service-impl/index.html">net.corda.node.services.persistence.StorageServiceImpl</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-strand-local-transaction-manager/index.html">net.corda.node.utilities.StrandLocalTransactionManager</a></td>
<td>
<p>A relatively close copy of the <a href="#">ThreadLocalTransactionManager</a> in Exposed but with the following adjustments to suit
our environment:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/kotlin.-string/index.html">kotlin.String</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/kotlin.-string/index.html">kotlin.String</a> (extensions in package net.corda.core.serialization)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.-string/index.html">kotlin.String</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/org.jetbrains.exposed.sql.-table/index.html">org.jetbrains.exposed.sql.Table</a> (extensions in package net.corda.node.utilities)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/java.time.temporal.-temporal/index.html">java.time.temporal.Temporal</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-tenor/index.html">net.corda.core.contracts.Tenor</a></td>
<td>
<p>Placeholder class for the Tenor datatype - which is a standardised duration of time until maturity</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-test-clock/index.html">net.corda.node.utilities.TestClock</a></td>
<td>
<p>A <a href="http://docs.oracle.com/javase/6/docs/api/java/time/Clock.html">Clock</a> that can have the date advanced for use in demos.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/-thread-box/index.html">net.corda.core.ThreadBox</a></td>
<td>
<p>A threadbox is a simple utility that makes it harder to forget to take a lock before accessing some shared state.
Simply define a private class to hold the data that must be grouped under the same lock, and then pass the only
instance to the ThreadBox constructor. You can now use the <a href="../net.corda.core/-thread-box/locked.html">locked</a> method with a lambda to take the lock in a
way that ensures it'll be released if there's an exception.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/kotlin.-throwable/index.html">kotlin.Throwable</a> (extensions in package net.corda.core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-time-window/index.html">net.corda.core.utilities.TimeWindow</a></td>
<td>
<p>A class representing a window in time from a particular instant, lasting a specified duration.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-timestamp/index.html">net.corda.core.contracts.Timestamp</a></td>
<td>
<p>If present in a transaction, contains a time that was verified by the uniqueness service. The true time must be
between (after, before).</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-timestamp-checker/index.html">net.corda.core.node.services.TimestampChecker</a></td>
<td>
<p>Checks if the given timestamp falls within the allowed tolerance interval.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-timestamp-generator/index.html">net.corda.core.testing.TimestampGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-topic-session/index.html">net.corda.core.messaging.TopicSession</a></td>
<td>
<p>An identifier for the endpoint <a href="../net.corda.core.messaging/-messaging-service/index.html">MessagingService</a> message handlers listen at.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.messaging/-topic-string-validator/index.html">net.corda.core.messaging.TopicStringValidator</a></td>
<td>
<p>A singleton that's useful for validating topic strings</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-tracked-delegate/index.html">net.corda.client.model.TrackedDelegate</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-transaction-builder/index.html">net.corda.core.transactions.TransactionBuilder</a></td>
<td>
<p>A TransactionBuilder is a transaction class that's mutable (unlike the others which are all immutable). It is
intended to be passed around contracts that may edit it by adding new states/commands. Then once the states
and commands are right, this class can be used as a holding bucket to gather signatures from multiple parties.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-conflict-exception/index.html">net.corda.core.contracts.TransactionConflictException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-transaction-create-status/index.html">net.corda.client.model.TransactionCreateStatus</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.client.model/-transaction-data-model/index.html">net.corda.client.model.TransactionDataModel</a></td>
<td>
<p>This model provides an observable list of transactions and what state machines/flows recorded them</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-for-contract/index.html">net.corda.core.contracts.TransactionForContract</a></td>
<td>
<p>A transaction to be passed as input to a contract verification function. Defines helper methods to
simplify verification logic in contracts.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-graph-search/index.html">net.corda.core.contracts.TransactionGraphSearch</a></td>
<td>
<p>Given a map of transaction id to <a href="../net.corda.core.transactions/-signed-transaction/index.html">SignedTransaction</a>, performs a breadth first search of the dependency graph from
the starting point down in order to find transactions that match the given query criteria.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-resolution-exception/index.html">net.corda.core.contracts.TransactionResolutionException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-state/index.html">net.corda.core.contracts.TransactionState</a></td>
<td>
<p>A wrapper for <a href="../net.corda.core.contracts/-contract-state/index.html">ContractState</a> containing additional platform-level state information.
This is the definitive state that is stored on the ledger and used in transaction outputs.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.testing/-transaction-state-generator/index.html">net.corda.core.testing.TransactionStateGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-transaction-storage/index.html">net.corda.core.node.services.TransactionStorage</a></td>
<td>
<p>Thread-safe storage of transactions.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-type/index.html">net.corda.core.contracts.TransactionType</a></td>
<td>
<p>Defines transaction build &amp; validation logic for a specific transaction type</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-transaction-verification-exception/index.html">net.corda.core.contracts.TransactionVerificationException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core/-transient-property/index.html">net.corda.core.TransientProperty</a></td>
<td>
<p>A simple wrapper that enables the use of Kotlin's "val x by TransientProperty { ... }" syntax. Such a property
will not be serialized to disk, and if it's missing (or the first time it's accessed), the initializer will be
used to set it up. Note that the initializer will be called with the TransientProperty object locked.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-traversable-transaction/index.html">net.corda.core.transactions.TraversableTransaction</a></td>
<td>
<p>Implemented by <a href="../net.corda.core.transactions/-wire-transaction/index.html">WireTransaction</a> and <a href="../net.corda.core.transactions/-filtered-leaves/index.html">FilteredLeaves</a>. A TraversableTransaction allows you to iterate
over the flattened components of the underlying transaction structure, taking into account that some
may be missing in the case of this representing a "torn" transaction. Please see the user guide section
"Transaction tear-offs" to learn more about this feature.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-two-party-deal-flow/index.html">net.corda.flows.TwoPartyDealFlow</a></td>
<td>
<p>Classes for manipulating a two party deal or agreement.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-two-party-trade-flow/index.html">net.corda.flows.TwoPartyTradeFlow</a></td>
<td>
<p>This asset trading flow implements a "delivery vs payment" type swap. It has two parties (B and S for buyer
and seller) and the following steps:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-tx-writable-storage-service/index.html">net.corda.core.node.services.TxWritableStorageService</a></td>
<td>
<p>Storage service, with extensions to allow validated transactions to be added to. For use only within <a href="#">ServiceHub</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-txn-note-columns/index.html">net.corda.node.utilities.TxnNoteColumns</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-type-only-command-data/index.html">net.corda.core.contracts.TypeOnlyCommandData</a></td>
<td>
<p>Commands that inherit from this are intended to have no data items: it's only their presence that matters.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.utilities/-u-u-i-d-string-column-type/index.html">net.corda.node.utilities.UUIDStringColumnType</a></td>
<td>
<p><a href="#">ColumnType</a> for marshalling to/from database on behalf of <a href="http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html">UUID</a>, always using a string representation.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-unique-identifier/index.html">net.corda.core.contracts.UniqueIdentifier</a></td>
<td>
<p>This class provides a truly unique identifier of a trade, state, or other business object, bound to any existing
external ID. Equality and comparison are based on the unique ID only; if two states somehow have the same UUID but
different external IDs, it would indicate a problem with handling of IDs.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-uniqueness-exception/index.html">net.corda.core.node.services.UniquenessException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-uniqueness-provider/index.html">net.corda.core.node.services.UniquenessProvider</a></td>
<td>
<p>A service that records input states of the given transaction and provides conflict information
if any of the inputs have already been used in another transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.utilities/-untrustworthy-data/index.html">net.corda.core.utilities.UntrustworthyData</a></td>
<td>
<p>A small utility to approximate taint tracking: if a method gives you back one of these, it means the data came from
a remote source that may be incentivised to pass us junk that violates basic assumptions and thus must be checked
first. The wrapper helps you to avoid forgetting this vital step. Things you might want to check are:</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-upgrade-command/index.html">net.corda.core.contracts.UpgradeCommand</a></td>
<td>
<p>Indicates that this transaction replaces the inputs contract state to another contract state</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.contracts/-upgraded-contract/index.html">net.corda.core.contracts.UpgradedContract</a></td>
<td>
<p>Interface which can upgrade state objects issued by a contract to a new state object issued by a different contract.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services/-user/index.html">net.corda.node.services.User</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.flows/-validating-notary-flow/index.html">net.corda.flows.ValidatingNotaryFlow</a></td>
<td>
<p>A notary commit flow that makes sure a given transaction is valid before committing it. This does mean that the calling
party has to reveal the whole transaction history; however, we avoid complex conflict resolution logic where a party
has its input states "blocked" by a transaction from another party, and needs to establish whether that transaction was
indeed valid.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.transactions/-validating-notary-service/index.html">net.corda.node.services.transactions.ValidatingNotaryService</a></td>
<td>
<p>A Notary service that validates the transaction chain of the submitted transaction before committing it</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-vault/index.html">net.corda.core.node.services.Vault</a></td>
<td>
<p>A vault (name may be temporary) wraps a set of states that are useful for us to keep track of, for instance,
because we own them. This class represents an immutable, stable state of a vault: it is guaranteed not to
change out from underneath you, even though the canonical currently-best-known vault may change as we learn
about new transactions from our peers and generate new transactions that consume states ourselves.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node.services/-vault-service/index.html">net.corda.core.node.services.VaultService</a></td>
<td>
<p>A <a href="../net.corda.core.node.services/-vault-service/index.html">VaultService</a> is responsible for securely and safely persisting the current state of a vault to storage. The
vault service vends immutable snapshots of the current vault for working with: if you build a transaction based
on a vault that isn't current, be aware that it may end up being invalid if the states that were used have been
consumed by someone else first!</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.schemas.requery.converters/-vault-state-status-converter/index.html">net.corda.core.schemas.requery.converters.VaultStateStatusConverter</a></td>
<td>
<p>Converter which persists a <a href="../net.corda.core.node.services/-vault/-state-status/index.html">Vault.StateStatus</a> enum using its enum ordinal representation</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.messaging/-verifying-netty-connector-factory/index.html">net.corda.node.services.messaging.VerifyingNettyConnectorFactory</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-wait-for-ledger-commit/index.html">net.corda.node.services.statemachine.WaitForLedgerCommit</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.statemachine/-waiting-request.html">net.corda.node.services.statemachine.WaitingRequest</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.node.services.network/-wire-node-registration/index.html">net.corda.node.services.network.WireNodeRegistration</a></td>
<td>
<p>A node registration and its signature as a pair.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.transactions/-wire-transaction/index.html">net.corda.core.transactions.WireTransaction</a></td>
<td>
<p>A transaction ready for serialisation, without any signatures attached. A WireTransaction is usually wrapped
by a <a href="../net.corda.core.transactions/-signed-transaction/index.html">SignedTransaction</a> that carries the signatures over this payload. The hash of the wire transaction is
the identity of the transaction, that is, it's possible for two <a href="../net.corda.core.transactions/-signed-transaction/index.html">SignedTransaction</a>s with different sets of
signatures to have the same identity hash.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.serialization/-wire-transaction-serializer/index.html">net.corda.core.serialization.WireTransactionSerializer</a></td>
<td>
<p>A serialisation engine that knows how to deserialise code inside a sandbox</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.contracts.testing/-wired-transaction-generator/index.html">net.corda.contracts.testing.WiredTransactionGenerator</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.node/-world-coordinate/index.html">net.corda.core.node.WorldCoordinate</a></td>
<td>
<p>A latitude/longitude pair.</p>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/org.bouncycastle.asn1.x500.-x500-name/index.html">org.bouncycastle.asn1.x500.X500Name</a> (extensions in package net.corda.core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../net.corda.core.crypto/-x509-utilities/index.html">net.corda.core.crypto.X509Utilities</a></td>
<td>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
