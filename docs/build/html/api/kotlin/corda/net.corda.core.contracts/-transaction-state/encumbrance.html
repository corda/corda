<HTML>
<HEAD>
<meta charset="UTF-8">
<title>TransactionState.encumbrance - corda</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">corda</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.core.contracts</a>&nbsp;/&nbsp;<a href="index.html">TransactionState</a>&nbsp;/&nbsp;<a href=".">encumbrance</a><br/>
<br/>
<h1>encumbrance</h1>
<a name="net.corda.core.contracts.TransactionState$encumbrance"></a>
<code><span class="keyword">val </span><span class="identifier">encumbrance</span><span class="symbol">: </span><span class="identifier">Int</span><span class="symbol">?</span></code>
<p>All contract states may be <emph>encumbered</emph> by up to one other state.</p>
<p>The encumbrance state, if present, forces additional controls over the encumbered state, since the platform checks
that the encumbrance state is present as an input in the same transaction that consumes the encumbered state, and
the contract code and rules of the encumbrance state will also be verified during the execution of the transaction.
For example, a cash contract state could be encumbered with a time-lock contract state; the cash state is then only
processable in a transaction that verifies that the time specified in the encumbrance time-lock has passed.</p>
<p>The encumbered state refers to another by index, and the referred encumbrance state
is an output state in a particular position on the same transaction that created the encumbered state. An alternative
implementation would be encumbering by reference to a <a href="../-state-ref/index.html">StateRef</a>, which would allow the specification of encumbrance
by a state created in a prior transaction.</p>
<p>Note that an encumbered state that is being consumed must have its encumbrance consumed in the same transaction,
otherwise the transaction is not valid.</p>
</BODY>
</HTML>
