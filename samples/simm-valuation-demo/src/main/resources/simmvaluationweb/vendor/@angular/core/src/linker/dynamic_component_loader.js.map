{"version":3,"file":"dynamic_component_loader.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/linker/dynamic_component_loader.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;;;;;AAEH,2BAAyB,kBAAkB,CAAC,CAAA;AAE5C,oCAAiC,2BAA2B,CAAC,CAAA;AAE7D,qBAA8B,gBAAgB,CAAC,CAAA;AAG/C,mCAAgC,sBAAsB,CAAC,CAAA;AAIvD;;;;GAIG;AACH;IAAA;IAiGA,CAAC;IAAD,6BAAC;AAAD,CAAC,AAjGD,IAiGC;AAjGqB,8BAAsB,yBAiG3C,CAAA;AACD;IAA6C,2CAAsB;IACjE,iCAAoB,SAA4B;QAAI,iBAAO,CAAC;QAAxC,cAAS,GAAT,SAAS,CAAmB;IAAa,CAAC;IAE9D,4CAAU,GAAV,UACI,IAAU,EAAE,sBAAkC,EAAE,QAAkB,EAAE,SAAsB,EAC1F,gBAA0B;QAC5B,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAA,gBAAgB;YAChE,IAAI,YAAY,GAAG,gBAAgB,CAAC,MAAM,CACtC,QAAQ,EAAE,gBAAgB,EAC1B,gBAAS,CAAC,sBAAsB,CAAC,GAAG,sBAAsB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YAC5F,EAAE,CAAC,CAAC,gBAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACzB,YAAY,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;YACpC,CAAC;YACD,MAAM,CAAC,YAAY,CAAC;QACtB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,oDAAkB,GAAlB,UACI,IAAU,EAAE,QAA0B,EAAE,SAA8C,EACtF,gBAAgC;QADQ,yBAA8C,GAA9C,gBAA8C;QACtF,gCAAgC,GAAhC,uBAAgC;QAClC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAA,gBAAgB;YAChE,IAAI,eAAe,GAAG,QAAQ,CAAC,cAAc,CAAC;YAC9C,IAAI,aAAa,GAAG,gBAAS,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC;gBAC5D,wCAAkB,CAAC,qBAAqB,CAAC,SAAS,EAAE,eAAe,CAAC;gBACpE,eAAe,CAAC;YACpB,MAAM,CAAC,QAAQ,CAAC,eAAe,CAC3B,gBAAgB,EAAE,QAAQ,CAAC,MAAM,EAAE,aAAa,EAAE,gBAAgB,CAAC,CAAC;QAC1E,CAAC,CAAC,CAAC;IACL,CAAC;IACH,kBAAkB;IACX,kCAAU,GAA0B;QAC3C,EAAE,IAAI,EAAE,uBAAU,EAAE;KACnB,CAAC;IACF,kBAAkB;IACX,sCAAc,GAA2D;QAChF,EAAC,IAAI,EAAE,sCAAiB,GAAG;KAC1B,CAAC;IACF,8BAAC;AAAD,CAAC,AArCD,CAA6C,sBAAsB,GAqClE;AArCY,+BAAuB,0BAqCnC,CAAA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di/decorators';\nimport {Injector} from '../di/injector';\nimport {ReflectiveInjector} from '../di/reflective_injector';\nimport {ResolvedReflectiveProvider} from '../di/reflective_provider';\nimport {Type, isPresent} from '../facade/lang';\n\nimport {ComponentRef} from './component_factory';\nimport {ComponentResolver} from './component_resolver';\nimport {ViewContainerRef} from './view_container_ref';\n\n\n/**\n * Use ComponentResolver and ViewContainerRef directly.\n *\n * @deprecated\n */\nexport abstract class DynamicComponentLoader {\n  /**\n   * Creates an instance of a Component `type` and attaches it to the first element in the\n   * platform-specific global view that matches the component's selector.\n   *\n   * In a browser the platform-specific global view is the main DOM Document.\n   *\n   * If needed, the component's selector can be overridden via `overrideSelector`.\n   *\n   * A provided {@link Injector} will be used to instantiate the Component.\n   *\n   * To be notified when this Component instance is destroyed, you can also optionally provide\n   * `onDispose` callback.\n   *\n   * Returns a promise for the {@link ComponentRef} representing the newly created Component.\n   *\n   * ### Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'child-component',\n   *   template: 'Child'\n   * })\n   * class ChildComponent {\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   template: 'Parent (<child id=\"child\"></child>)'\n   * })\n   * class MyApp {\n   *   constructor(dcl: DynamicComponentLoader, injector: Injector) {\n   *     dcl.loadAsRoot(ChildComponent, '#child', injector);\n   *   }\n   * }\n   *\n   * bootstrap(MyApp);\n   * ```\n   *\n   * Resulting DOM:\n   *\n   * ```\n   * <my-app>\n   *   Parent (\n   *     <child id=\"child\">Child</child>\n   *   )\n   * </my-app>\n   * ```\n   */\n  abstract loadAsRoot(\n      type: Type, overrideSelectorOrNode: string|any, injector: Injector, onDispose?: () => void,\n      projectableNodes?: any[][]): Promise<ComponentRef<any>>;\n\n\n  /**\n   * Creates an instance of a Component and attaches it to the View Container found at the\n   * `location` specified as {@link ViewContainerRef}.\n   *\n   * You can optionally provide `providers` to configure the {@link Injector} provisioned for this\n   * Component Instance.\n   *\n   * Returns a promise for the {@link ComponentRef} representing the newly created Component.\n   *\n   *\n   * ### Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'child-component',\n   *   template: 'Child'\n   * })\n   * class ChildComponent {\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   template: 'Parent'\n   * })\n   * class MyApp {\n   *   constructor(dcl: DynamicComponentLoader, viewContainerRef: ViewContainerRef) {\n   *     dcl.loadNextToLocation(ChildComponent, viewContainerRef);\n   *   }\n   * }\n   *\n   * bootstrap(MyApp);\n   * ```\n   *\n   * Resulting DOM:\n   *\n   * ```\n   * <my-app>Parent</my-app>\n   * <child-component>Child</child-component>\n   * ```\n   */\n  abstract loadNextToLocation(\n      type: Type, location: ViewContainerRef, providers?: ResolvedReflectiveProvider[],\n      projectableNodes?: any[][]): Promise<ComponentRef<any>>;\n}\nexport class DynamicComponentLoader_ extends DynamicComponentLoader {\n  constructor(private _compiler: ComponentResolver) { super(); }\n\n  loadAsRoot(\n      type: Type, overrideSelectorOrNode: string|any, injector: Injector, onDispose?: () => void,\n      projectableNodes?: any[][]): Promise<ComponentRef<any>> {\n    return this._compiler.resolveComponent(type).then(componentFactory => {\n      var componentRef = componentFactory.create(\n          injector, projectableNodes,\n          isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);\n      if (isPresent(onDispose)) {\n        componentRef.onDestroy(onDispose);\n      }\n      return componentRef;\n    });\n  }\n\n  loadNextToLocation(\n      type: Type, location: ViewContainerRef, providers: ResolvedReflectiveProvider[] = null,\n      projectableNodes: any[][] = null): Promise<ComponentRef<any>> {\n    return this._compiler.resolveComponent(type).then(componentFactory => {\n      var contextInjector = location.parentInjector;\n      var childInjector = isPresent(providers) && providers.length > 0 ?\n          ReflectiveInjector.fromResolvedProviders(providers, contextInjector) :\n          contextInjector;\n      return location.createComponent(\n          componentFactory, location.length, childInjector, projectableNodes);\n    });\n  }\n/** @nocollapse */\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n{type: ComponentResolver, },\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}