{"version":3,"file":"view_container_ref.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/linker/view_container_ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {ListWrapper} from '../facade/collection';\nimport {unimplemented} from '../facade/exceptions';\nimport {isPresent} from '../facade/lang';\nimport {WtfScopeFn, wtfCreateScope, wtfLeave} from '../profile/profile';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {AppElement} from './element';\nimport {ElementRef} from './element_ref';\nimport {TemplateRef} from './template_ref';\nimport {EmbeddedViewRef, ViewRef, ViewRef_} from './view_ref';\n\n\n/**\n * Represents a container where one or more Views can be attached.\n *\n * The container can contain two kinds of Views. Host Views, created by instantiating a\n * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an\n * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.\n *\n * The location of the View Container within the containing View is specified by the Anchor\n * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only\n * have a single View Container.\n *\n * Root elements of Views attached to this container become siblings of the Anchor Element in\n * the Rendered View.\n *\n * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected\n * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.\n * @stable\n */\nexport abstract class ViewContainerRef {\n  /**\n   * Anchor element that specifies the location of this container in the containing View.\n   * <!-- TODO: rename to anchorElement -->\n   */\n  get element(): ElementRef { return <ElementRef>unimplemented(); }\n\n  get injector(): Injector { return <Injector>unimplemented(); }\n\n  get parentInjector(): Injector { return <Injector>unimplemented(); }\n\n  /**\n   * Destroys all Views in this container.\n   */\n  abstract clear(): void;\n\n  /**\n   * Returns the {@link ViewRef} for the View located in this container at the specified index.\n   */\n  abstract get(index: number): ViewRef;\n\n  /**\n   * Returns the number of Views currently attached to this container.\n   */\n  get length(): number { return <number>unimplemented(); };\n\n  /**\n   * Instantiates an Embedded View based on the {@link TemplateRef `templateRef`} and inserts it\n   * into this container at the specified `index`.\n   *\n   * If `index` is not specified, the new View will be inserted as the last View in the container.\n   *\n   * Returns the {@link ViewRef} for the newly created View.\n   */\n  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n      EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates a single {@link Component} and inserts its Host View into this container at the\n   * specified `index`.\n   *\n   * The component is instantiated using its {@link ComponentFactory} which can be\n   * obtained via {@link ComponentResolver#resolveComponent}.\n   *\n   * If `index` is not specified, the new View will be inserted as the last View in the container.\n   *\n   * You can optionally specify the {@link Injector} that will be used as parent for the Component.\n   *\n   * Returns the {@link ComponentRef} of the Host View created for the newly instantiated Component.\n   */\n  abstract createComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][]): ComponentRef<C>;\n\n  /**\n   * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.\n   *\n   * If `index` is not specified, the new View will be inserted as the last View in the container.\n   *\n   * Returns the inserted {@link ViewRef}.\n   */\n  abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n\n  /**\n   * Returns the index of the View, specified via {@link ViewRef}, within the current container or\n   * `-1` if this container doesn't contain the View.\n   */\n  abstract indexOf(viewRef: ViewRef): number;\n\n  /**\n   * Destroys a View attached to this container at the specified `index`.\n   *\n   * If `index` is not specified, the last View in the container will be removed.\n   */\n  abstract remove(index?: number): void;\n\n  /**\n   * Use along with {@link #insert} to move a View within the current container.\n   *\n   * If the `index` param is omitted, the last {@link ViewRef} is detached.\n   */\n  abstract detach(index?: number): ViewRef;\n}\n\nexport class ViewContainerRef_ implements ViewContainerRef {\n  constructor(private _element: AppElement) {}\n\n  get(index: number): ViewRef { return this._element.nestedViews[index].ref; }\n  get length(): number {\n    var views = this._element.nestedViews;\n    return isPresent(views) ? views.length : 0;\n  }\n\n  get element(): ElementRef { return this._element.elementRef; }\n\n  get injector(): Injector { return this._element.injector; }\n\n  get parentInjector(): Injector { return this._element.parentInjector; }\n\n  // TODO(rado): profile and decide whether bounds checks should be added\n  // to the methods below.\n  createEmbeddedView<C>(templateRef: TemplateRef<C>, context: C = null, index: number = -1):\n      EmbeddedViewRef<C> {\n    var viewRef: EmbeddedViewRef<any> = templateRef.createEmbeddedView(context);\n    this.insert(viewRef, index);\n    return viewRef;\n  }\n\n  /** @internal */\n  _createComponentInContainerScope: WtfScopeFn =\n      wtfCreateScope('ViewContainerRef#createComponent()');\n\n  createComponent<C>(\n      componentFactory: ComponentFactory<C>, index: number = -1, injector: Injector = null,\n      projectableNodes: any[][] = null): ComponentRef<C> {\n    var s = this._createComponentInContainerScope();\n    var contextInjector = isPresent(injector) ? injector : this._element.parentInjector;\n    var componentRef = componentFactory.create(contextInjector, projectableNodes);\n    this.insert(componentRef.hostView, index);\n    return wtfLeave(s, componentRef);\n  }\n\n  /** @internal */\n  _insertScope = wtfCreateScope('ViewContainerRef#insert()');\n\n  // TODO(i): refactor insert+remove into move\n  insert(viewRef: ViewRef, index: number = -1): ViewRef {\n    var s = this._insertScope();\n    if (index == -1) index = this.length;\n    var viewRef_ = <ViewRef_<any>>viewRef;\n    this._element.attachView(viewRef_.internalView, index);\n    return wtfLeave(s, viewRef_);\n  }\n\n  indexOf(viewRef: ViewRef): number {\n    return ListWrapper.indexOf(this._element.nestedViews, (<ViewRef_<any>>viewRef).internalView);\n  }\n\n  /** @internal */\n  _removeScope = wtfCreateScope('ViewContainerRef#remove()');\n\n  // TODO(i): rename to destroy\n  remove(index: number = -1): void {\n    var s = this._removeScope();\n    if (index == -1) index = this.length - 1;\n    var view = this._element.detachView(index);\n    view.destroy();\n    // view is intentionally not returned to the client.\n    wtfLeave(s);\n  }\n\n  /** @internal */\n  _detachScope = wtfCreateScope('ViewContainerRef#detach()');\n\n  // TODO(i): refactor insert+remove into move\n  detach(index: number = -1): ViewRef {\n    var s = this._detachScope();\n    if (index == -1) index = this.length - 1;\n    var view = this._element.detachView(index);\n    return wtfLeave(s, view.ref);\n  }\n\n  clear() {\n    for (var i = this.length - 1; i >= 0; i--) {\n      this.remove(i);\n    }\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}