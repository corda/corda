{"version":3,"file":"validators.js","sourceRoot":"","sources":["../../../../../../modules/@angular/common/src/forms-deprecated/validators.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAEI,EAAC,WAAW,EAAC,MAAM,eAAe;OAClC,EAAC,iBAAiB,EAAC,MAAM,iBAAiB;OAC1C,EAAC,gBAAgB,EAAC,MAAM,sBAAsB;OAC9C,EAAC,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAC,MAAM,gBAAgB;OAC/D,EAAC,cAAc,EAAC,MAAM,mBAAmB;AAIhD;;;;;;;;;GASG;AACH,OAAO,MAAM,aAAa,GAAmC,IAAI,WAAW,CAAC,cAAc,CAAC,CAAC;AAE7F;;;;;;;;;GASG;AACH,OAAO,MAAM,mBAAmB;AAC5B,kBAAkB,CAAC,IAAI,WAAW,CAAC,mBAAmB,CAAC,CAAC;AAE5D;;;;;;;;;;;;;GAaG;AACH;IACE;;OAEG;IACH,OAAO,QAAQ,CAAC,OAAwB;QACtC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC;YAC7E,EAAC,UAAU,EAAE,IAAI,EAAC;YAClB,IAAI,CAAC;IACX,CAAC;IAED;;OAEG;IACH,OAAO,SAAS,CAAC,SAAiB;QAChC,MAAM,CAAC,CAAC,OAAwB;YAC9B,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC,IAAI,CAAC;YACzD,IAAI,CAAC,GAAW,OAAO,CAAC,KAAK,CAAC;YAC9B,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,SAAS;gBACvB,EAAC,WAAW,EAAE,EAAC,gBAAgB,EAAE,SAAS,EAAE,cAAc,EAAE,CAAC,CAAC,MAAM,EAAC,EAAC;gBACtE,IAAI,CAAC;QACX,CAAC,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,OAAO,SAAS,CAAC,SAAiB;QAChC,MAAM,CAAC,CAAC,OAAwB;YAC9B,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC,IAAI,CAAC;YACzD,IAAI,CAAC,GAAW,OAAO,CAAC,KAAK,CAAC;YAC9B,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,SAAS;gBACvB,EAAC,WAAW,EAAE,EAAC,gBAAgB,EAAE,SAAS,EAAE,cAAc,EAAE,CAAC,CAAC,MAAM,EAAC,EAAC;gBACtE,IAAI,CAAC;QACX,CAAC,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,OAAO,OAAO,CAAC,OAAe;QAC5B,MAAM,CAAC,CAAC,OAAwB;YAC9B,EAAE,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC,IAAI,CAAC;YACzD,IAAI,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,OAAO,GAAG,CAAC,CAAC;YACvC,IAAI,CAAC,GAAW,OAAO,CAAC,KAAK,CAAC;YAC9B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI;gBACJ,EAAC,SAAS,EAAE,EAAC,iBAAiB,EAAE,IAAI,OAAO,GAAG,EAAE,aAAa,EAAE,CAAC,EAAC,EAAC,CAAC;QAC5F,CAAC,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,OAAO,aAAa,CAAC,CAAkB,IAA8B,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAEnF;;;OAGG;IACH,OAAO,OAAO,CAAC,UAAyB;QACtC,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QACrC,IAAI,iBAAiB,GAAG,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACrD,EAAE,CAAC,CAAC,iBAAiB,CAAC,MAAM,IAAI,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAE/C,MAAM,CAAC,UAAS,OAAwB;YACtC,MAAM,CAAC,YAAY,CAAC,kBAAkB,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC,CAAC;QACtE,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,YAAY,CAAC,UAA8B;QAChD,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QACrC,IAAI,iBAAiB,GAAG,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACrD,EAAE,CAAC,CAAC,iBAAiB,CAAC,MAAM,IAAI,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAE/C,MAAM,CAAC,UAAS,OAAwB;YACtC,IAAI,QAAQ,GAAG,uBAAuB,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;YAC1F,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACzD,CAAC,CAAC;IACJ,CAAC;AACH,CAAC;AAED,2BAA2B,GAAQ;IACjC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,iBAAiB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AACjE,CAAC;AAED,4BAA4B,OAAwB,EAAE,UAAyB;IAC7E,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;AACzC,CAAC;AAED,iCAAiC,OAAwB,EAAE,UAA8B;IACvF,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;AACzC,CAAC;AAED,sBAAsB,aAAoB;IACxC,IAAI,GAAG,GACH,aAAa,CAAC,MAAM,CAAC,CAAC,GAAyB,EAAE,MAA4B;QAC3E,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,GAAG,CAAC;IACvE,CAAC,EAAE,EAAE,CAAC,CAAC;IACX,MAAM,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,GAAG,CAAC;AACpD,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OpaqueToken} from '@angular/core';\nimport {ObservableWrapper} from '../facade/async';\nimport {StringMapWrapper} from '../facade/collection';\nimport {isBlank, isPresent, isPromise, isString} from '../facade/lang';\nimport {PromiseWrapper} from '../facade/promise';\nimport {AsyncValidatorFn, ValidatorFn} from './directives/validators';\nimport {AbstractControl} from './model';\n\n/**\n * Providers for validators to be used for {@link Control}s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n * @experimental\n */\nexport const NG_VALIDATORS: OpaqueToken = /*@ts2dart_const*/ new OpaqueToken('NgValidators');\n\n/**\n * Providers for asynchronous validators to be used for {@link Control}s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See {@link NG_VALIDATORS} for more details.\n *\n * @experimental\n */\nexport const NG_ASYNC_VALIDATORS: OpaqueToken =\n    /*@ts2dart_const*/ new OpaqueToken('NgAsyncValidators');\n\n/**\n * Provides a set of validators used by form controls.\n *\n * A validator is a function that processes a {@link Control} or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n *\n * ### Example\n *\n * ```typescript\n * var loginControl = new Control(\"\", Validators.required)\n * ```\n *\n * @experimental\n */\nexport class Validators {\n  /**\n   * Validator that requires controls to have a non-empty value.\n   */\n  static required(control: AbstractControl): {[key: string]: boolean} {\n    return isBlank(control.value) || (isString(control.value) && control.value == '') ?\n        {'required': true} :\n        null;\n  }\n\n  /**\n   * Validator that requires controls to have a value of a minimum length.\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isPresent(Validators.required(control))) return null;\n      var v: string = control.value;\n      return v.length < minLength ?\n          {'minlength': {'requiredLength': minLength, 'actualLength': v.length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value of a maximum length.\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isPresent(Validators.required(control))) return null;\n      var v: string = control.value;\n      return v.length > maxLength ?\n          {'maxlength': {'requiredLength': maxLength, 'actualLength': v.length}} :\n          null;\n    };\n  }\n\n  /**\n   * Validator that requires a control to match a regex to its value.\n   */\n  static pattern(pattern: string): ValidatorFn {\n    return (control: AbstractControl): {[key: string]: any} => {\n      if (isPresent(Validators.required(control))) return null;\n      let regex = new RegExp(`^${pattern}$`);\n      let v: string = control.value;\n      return regex.test(v) ? null :\n                             {'pattern': {'requiredPattern': `^${pattern}$`, 'actualValue': v}};\n    };\n  }\n\n  /**\n   * No-op validator.\n   */\n  static nullValidator(c: AbstractControl): {[key: string]: boolean} { return null; }\n\n  /**\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps.\n   */\n  static compose(validators: ValidatorFn[]): ValidatorFn {\n    if (isBlank(validators)) return null;\n    var presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n\n  static composeAsync(validators: AsyncValidatorFn[]): AsyncValidatorFn {\n    if (isBlank(validators)) return null;\n    var presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      let promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n      return PromiseWrapper.all(promises).then(_mergeErrors);\n    };\n  }\n}\n\nfunction _convertToPromise(obj: any): Promise<any> {\n  return isPromise(obj) ? obj : ObservableWrapper.toPromise(obj);\n}\n\nfunction _executeValidators(control: AbstractControl, validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _executeAsyncValidators(control: AbstractControl, validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _mergeErrors(arrayOfErrors: any[]): {[key: string]: any} {\n  var res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: {[key: string]: any}, errors: {[key: string]: any}) => {\n        return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n      }, {});\n  return StringMapWrapper.isEmpty(res) ? null : res;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}