{"version":3,"file":"ng_zone.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/zone/ng_zone.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '../facade/async';\nimport {BaseException} from '../facade/exceptions';\n\nimport {NgZoneError, NgZoneImpl} from './ng_zone_impl';\n\nexport {NgZoneError} from './ng_zone_impl';\n\n\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\n * ```\n * import {Component, View, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo'.\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n *   directives: [NgIf]\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *       // reenter the Angular zone and display done\n *       this._ngZone.run(() => {console.log('Outside Done!') });\n *     }}));\n *   }\n *\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n * @experimental\n */\nexport class NgZone {\n  static isInAngularZone(): boolean { return NgZoneImpl.isInAngularZone(); }\n  static assertInAngularZone(): void {\n    if (!NgZoneImpl.isInAngularZone()) {\n      throw new BaseException('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n  static assertNotInAngularZone(): void {\n    if (NgZoneImpl.isInAngularZone()) {\n      throw new BaseException('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  private _zoneImpl: NgZoneImpl;\n\n  private _hasPendingMicrotasks: boolean = false;\n  private _hasPendingMacrotasks: boolean = false;\n\n  /** @internal */\n  private _isStable = true;\n  /** @internal */\n  private _nesting = 0;\n  /** @internal */\n  private _onUnstable: EventEmitter<any> = new EventEmitter(false);\n  /** @internal */\n  private _onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n  /** @internal */\n  private _onStable: EventEmitter<any> = new EventEmitter(false);\n  /** @internal */\n  private _onErrorEvents: EventEmitter<any> = new EventEmitter(false);\n\n  constructor({enableLongStackTrace = false}) {\n    this._zoneImpl = new NgZoneImpl({\n      trace: enableLongStackTrace,\n      onEnter: () => {\n        // console.log('ZONE.enter', this._nesting, this._isStable);\n        this._nesting++;\n        if (this._isStable) {\n          this._isStable = false;\n          this._onUnstable.emit(null);\n        }\n      },\n      onLeave: () => {\n        this._nesting--;\n        // console.log('ZONE.leave', this._nesting, this._isStable);\n        this._checkStable();\n      },\n      setMicrotask: (hasMicrotasks: boolean) => {\n        this._hasPendingMicrotasks = hasMicrotasks;\n        this._checkStable();\n      },\n      setMacrotask: (hasMacrotasks: boolean) => { this._hasPendingMacrotasks = hasMacrotasks; },\n      onError: (error: NgZoneError) => this._onErrorEvents.emit(error)\n    });\n  }\n\n  private _checkStable() {\n    if (this._nesting == 0) {\n      if (!this._hasPendingMicrotasks && !this._isStable) {\n        try {\n          // console.log('ZONE.microtaskEmpty');\n          this._nesting++;\n          this._onMicrotaskEmpty.emit(null);\n        } finally {\n          this._nesting--;\n          if (!this._hasPendingMicrotasks) {\n            try {\n              // console.log('ZONE.stable', this._nesting, this._isStable);\n              this.runOutsideAngular(() => this._onStable.emit(null));\n            } finally {\n              this._isStable = true;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  get onUnstable(): EventEmitter<any> { return this._onUnstable; }\n\n  /**\n   * Notifies when there is no more microtasks enqueue in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  get onMicrotaskEmpty(): EventEmitter<any> { return this._onMicrotaskEmpty; }\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  get onStable(): EventEmitter<any> { return this._onStable; }\n\n  /**\n   * Notify that an error has been delivered.\n   */\n  get onError(): EventEmitter<any> { return this._onErrorEvents; }\n\n  /**\n   * Whether there are no outstanding microtasks or microtasks.\n   */\n  get isStable(): boolean { return this._isStable; }\n\n  /**\n   * Whether there are any outstanding microtasks.\n   */\n  get hasPendingMicrotasks(): boolean { return this._hasPendingMicrotasks; }\n\n  /**\n   * Whether there are any outstanding microtasks.\n   */\n  get hasPendingMacrotasks(): boolean { return this._hasPendingMacrotasks; }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run(fn: () => any): any { return this._zoneImpl.runInner(fn); }\n\n  /**\n   * Same as #run, except that synchronous errors are caught and forwarded\n   * via `onError` and not rethrown.\n   */\n  runGuarded(fn: () => any): any { return this._zoneImpl.runInnerGuarded(fn); }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular(fn: () => any): any { return this._zoneImpl.runOuter(fn); }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}