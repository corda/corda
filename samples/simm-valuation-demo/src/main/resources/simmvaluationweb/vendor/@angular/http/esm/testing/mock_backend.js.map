{"version":3,"file":"mock_backend.js","sourceRoot":"","sources":["../../../../../modules/@angular/http/testing/mock_backend.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAEI,EAAC,UAAU,EAAC,MAAM,eAAe;OACjC,EAAC,aAAa,EAAC,MAAM,oBAAoB;OACzC,EAAC,OAAO,EAAC,MAAM,cAAc;OAC7B,EAAC,IAAI,EAAC,MAAM,oBAAoB;OAEhC,EAAC,UAAU,EAAC,MAAM,cAAc;OAChC,EAAC,aAAa,EAAC,MAAM,0BAA0B;OAC/C,EAAC,SAAS,EAAC,MAAM,oBAAoB;OAErC,EAAC,OAAO,EAAC,MAAM,uBAAuB;AAI7C;;;;;GAKG;AACH;IAoBE,YAAY,GAAY;QACtB,IAAI,CAAC,QAAQ,GAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACxD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;QAClC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;IACrB,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,WAAW,CAAC,GAAa;QACvB,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,KAAK,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,KAAK,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;YACpF,MAAM,IAAI,aAAa,CAAC,sCAAsC,CAAC,CAAC;QAClE,CAAC;QACD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACxB,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;IAC3B,CAAC;IAED;;;;;OAKG;IACH,YAAY,CAAC,GAAa;QACxB,6CAA6C;QAC7C,4CAA4C;QAC5C,iDAAiD;QACjD,IAAI;IACN,CAAC;IAED,iDAAiD;IACjD;;;;;;;;;;;;;;OAcG;IACH,SAAS,CAAC,GAAW;QACnB,wBAAwB;QACxB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;AACH,CAAC;AACD;IAoDE;QACE,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;QACjC,IAAI,CAAC,WAAW,CAAC,SAAS,CACtB,CAAC,UAA0B,KAAK,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAC5E,IAAI,CAAC,kBAAkB,GAAG,IAAI,OAAO,EAAE,CAAC;IAC1C,CAAC;IAED;;;;OAIG;IACH,uBAAuB;QACrB,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAiB,KAAK,OAAO,EAAE,CAAC,CAAC;QACpE,EAAE,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC;YAAC,MAAM,IAAI,aAAa,CAAC,GAAG,OAAO,qCAAqC,CAAC,CAAC;IAC5F,CAAC;IAED;;;;;OAKG;IACH,qBAAqB,KAAK,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAiB,KAAK,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAEhG;;;;;OAKG;IACH,gBAAgB,CAAC,GAAY;QAC3B,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,YAAY,OAAO,CAAC,CAAC,CAAC,CAAC;YACjD,MAAM,IAAI,aAAa,CAAC,yDAAyD,GAAG,EAAE,CAAC,CAAC;QAC1F,CAAC;QACD,IAAI,UAAU,GAAG,IAAI,cAAc,CAAC,GAAG,CAAC,CAAC;QACzC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAClC,MAAM,CAAC,UAAU,CAAC;IACpB,CAAC;AAQH,CAAC;AAPD,kBAAkB;AACX,sBAAU,GAA0B;IAC3C,EAAE,IAAI,EAAE,UAAU,EAAE;CACnB,CAAC;AACF,kBAAkB;AACX,0BAAc,GAA2D,EAC/E,CACA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {ReplaySubject} from 'rxjs/ReplaySubject';\nimport {Subject} from 'rxjs/Subject';\nimport {take} from 'rxjs/operator/take';\n\nimport {ReadyState} from '../src/enums';\nimport {BaseException} from '../src/facade/exceptions';\nimport {isPresent} from '../src/facade/lang';\nimport {Connection, ConnectionBackend} from '../src/interfaces';\nimport {Request} from '../src/static_request';\nimport {Response} from '../src/static_response';\n\n\n/**\n *\n * Mock Connection to represent a {@link Connection} for tests.\n *\n * @experimental\n */\nexport class MockConnection implements Connection {\n  // TODO Name `readyState` should change to be more generic, and states could be made to be more\n  // descriptive than XHR states.\n  /**\n   * Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with\n   * additional states. For example, state 5 indicates an aborted connection.\n   */\n  readyState: ReadyState;\n\n  /**\n   * {@link Request} instance used to create the connection.\n   */\n  request: Request;\n\n  /**\n   * {@link EventEmitter} of {@link Response}. Can be subscribed to in order to be notified when a\n   * response is available.\n   */\n  response: ReplaySubject<Response>;\n\n  constructor(req: Request) {\n    this.response = <any>take.call(new ReplaySubject(1), 1);\n    this.readyState = ReadyState.Open;\n    this.request = req;\n  }\n\n  /**\n   * Sends a mock response to the connection. This response is the value that is emitted to the\n   * {@link EventEmitter} returned by {@link Http}.\n   *\n   * ### Example\n   *\n   * ```\n   * var connection;\n   * backend.connections.subscribe(c => connection = c);\n   * http.request('data.json').subscribe(res => console.log(res.text()));\n   * connection.mockRespond(new Response(new ResponseOptions({ body: 'fake response' }))); //logs\n   * 'fake response'\n   * ```\n   *\n   */\n  mockRespond(res: Response) {\n    if (this.readyState === ReadyState.Done || this.readyState === ReadyState.Cancelled) {\n      throw new BaseException('Connection has already been resolved');\n    }\n    this.readyState = ReadyState.Done;\n    this.response.next(res);\n    this.response.complete();\n  }\n\n  /**\n   * Not yet implemented!\n   *\n   * Sends the provided {@link Response} to the `downloadObserver` of the `Request`\n   * associated with this connection.\n   */\n  mockDownload(res: Response) {\n    // this.request.downloadObserver.onNext(res);\n    // if (res.bytesLoaded === res.totalBytes) {\n    //   this.request.downloadObserver.onCompleted();\n    // }\n  }\n\n  // TODO(jeffbcross): consider using Response type\n  /**\n   * Emits the provided error object as an error to the {@link Response} {@link EventEmitter}\n   * returned\n   * from {@link Http}.\n   *\n   * ### Example\n   *\n   * ```\n   * var connection;\n   * backend.connections.subscribe(c => connection = c);\n   * http.request('data.json').subscribe(res => res, err => console.log(err)));\n   * connection.mockError(new Error('error'));\n   * ```\n   *\n   */\n  mockError(err?: Error) {\n    // Matches XHR semantics\n    this.readyState = ReadyState.Done;\n    this.response.error(err);\n  }\n}\nexport class MockBackend implements ConnectionBackend {\n  /**\n   * {@link EventEmitter}\n   * of {@link MockConnection} instances that have been created by this backend. Can be subscribed\n   * to in order to respond to connections.\n   *\n   * ### Example\n   *\n   * ```\n   * import {Http, BaseRequestOptions, Response} from '@angular/http';\n   * import {MockBackend} from '@angular/http/testing';\n   * import {Injector, provide} from '@angular/core';\n   *\n   * it('should get a response', () => {\n   *   var connection; //this will be set when a new connection is emitted from the backend.\n   *   var text; //this will be set from mock response\n   *   var injector = Injector.resolveAndCreate([\n   *     MockBackend,\n   *     {provide: Http, useFactory: (backend, options) => {\n   *       return new Http(backend, options);\n   *     }, deps: [MockBackend, BaseRequestOptions]}]);\n   *   var backend = injector.get(MockBackend);\n   *   var http = injector.get(Http);\n   *   backend.connections.subscribe(c => connection = c);\n   *   http.request('something.json').subscribe(res => {\n   *     text = res.text();\n   *   });\n   *   connection.mockRespond(new Response({body: 'Something'}));\n   *   expect(text).toBe('Something');\n   * });\n   * ```\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  connections: any;  //<MockConnection>\n\n  /**\n   * An array representation of `connections`. This array will be updated with each connection that\n   * is created by this backend.\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  connectionsArray: MockConnection[];\n  /**\n   * {@link EventEmitter} of {@link MockConnection} instances that haven't yet been resolved (i.e.\n   * with a `readyState`\n   * less than 4). Used internally to verify that no connections are pending via the\n   * `verifyNoPendingRequests` method.\n   *\n   * This property only exists in the mock implementation, not in real Backends.\n   */\n  pendingConnections: any;  // Subject<MockConnection>\n  constructor() {\n    this.connectionsArray = [];\n    this.connections = new Subject();\n    this.connections.subscribe(\n        (connection: MockConnection) => this.connectionsArray.push(connection));\n    this.pendingConnections = new Subject();\n  }\n\n  /**\n   * Checks all connections, and raises an exception if any connection has not received a response.\n   *\n   * This method only exists in the mock implementation, not in real Backends.\n   */\n  verifyNoPendingRequests() {\n    let pending = 0;\n    this.pendingConnections.subscribe((c: MockConnection) => pending++);\n    if (pending > 0) throw new BaseException(`${pending} pending connections to be resolved`);\n  }\n\n  /**\n   * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n   * connections, if it's expected that there are connections that have not yet received a response.\n   *\n   * This method only exists in the mock implementation, not in real Backends.\n   */\n  resolveAllConnections() { this.connections.subscribe((c: MockConnection) => c.readyState = 4); }\n\n  /**\n   * Creates a new {@link MockConnection}. This is equivalent to calling `new\n   * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n   * emitter of this `MockBackend` instance. This method will usually only be used by tests\n   * against the framework itself, not by end-users.\n   */\n  createConnection(req: Request): MockConnection {\n    if (!isPresent(req) || !(req instanceof Request)) {\n      throw new BaseException(`createConnection requires an instance of Request, got ${req}`);\n    }\n    let connection = new MockConnection(req);\n    this.connections.next(connection);\n    return connection;\n  }\n/** @nocollapse */\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}