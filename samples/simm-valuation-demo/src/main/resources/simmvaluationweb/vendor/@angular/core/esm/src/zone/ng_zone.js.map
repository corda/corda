{"version":3,"file":"ng_zone.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/zone/ng_zone.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '../facade/async';\nimport {BaseException} from '../facade/exceptions';\n\nimport {NgZoneError, NgZoneImpl} from './ng_zone_impl';\n\nexport {NgZoneError} from './ng_zone_impl';\n\n\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))\n * ```\n * import {Component, View, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo'.\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n *   directives: [NgIf]\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *       // reenter the Angular zone and display done\n *       this._ngZone.run(() => {console.log('Outside Done!') });\n *     }}));\n *   }\n *\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n * @experimental\n */\nexport class NgZone {\n  static isInAngularZone(): boolean { return NgZoneImpl.isInAngularZone(); }\n  static assertInAngularZone(): void {\n    if (!NgZoneImpl.isInAngularZone()) {\n      throw new BaseException('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n  static assertNotInAngularZone(): void {\n    if (NgZoneImpl.isInAngularZone()) {\n      throw new BaseException('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  private _zoneImpl: NgZoneImpl;\n\n  private _hasPendingMicrotasks: boolean = false;\n  private _hasPendingMacrotasks: boolean = false;\n\n  /** @internal */\n  private _isStable = true;\n  /** @internal */\n  private _nesting = 0;\n  /** @internal */\n  private _onUnstable: EventEmitter<any> = new EventEmitter(false);\n  /** @internal */\n  private _onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n  /** @internal */\n  private _onStable: EventEmitter<any> = new EventEmitter(false);\n  /** @internal */\n  private _onErrorEvents: EventEmitter<any> = new EventEmitter(false);\n\n  constructor({enableLongStackTrace = false}) {\n    this._zoneImpl = new NgZoneImpl({\n      trace: enableLongStackTrace,\n      onEnter: () => {\n        // console.log('ZONE.enter', this._nesting, this._isStable);\n        this._nesting++;\n        if (this._isStable) {\n          this._isStable = false;\n          this._onUnstable.emit(null);\n        }\n      },\n      onLeave: () => {\n        this._nesting--;\n        // console.log('ZONE.leave', this._nesting, this._isStable);\n        this._checkStable();\n      },\n      setMicrotask: (hasMicrotasks: boolean) => {\n        this._hasPendingMicrotasks = hasMicrotasks;\n        this._checkStable();\n      },\n      setMacrotask: (hasMacrotasks: boolean) => { this._hasPendingMacrotasks = hasMacrotasks; },\n      onError: (error: NgZoneError) => this._onErrorEvents.emit(error)\n    });\n  }\n\n  private _checkStable() {\n    if (this._nesting == 0) {\n      if (!this._hasPendingMicrotasks && !this._isStable) {\n        try {\n          // console.log('ZONE.microtaskEmpty');\n          this._nesting++;\n          this._onMicrotaskEmpty.emit(null);\n        } finally {\n          this._nesting--;\n          if (!this._hasPendingMicrotasks) {\n            try {\n              // console.log('ZONE.stable', this._nesting, this._isStable);\n              this.runOutsideAngular(() => this._onStable.emit(null));\n            } finally {\n              this._isStable = true;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  get onUnstable(): EventEmitter<any> { return this._onUnstable; }\n\n  /**\n   * Notifies when there is no more microtasks enqueue in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  get onMicrotaskEmpty(): EventEmitter<any> { return this._onMicrotaskEmpty; }\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  get onStable(): EventEmitter<any> { return this._onStable; }\n\n  /**\n   * Notify that an error has been delivered.\n   */\n  get onError(): EventEmitter<any> { return this._onErrorEvents; }\n\n  /**\n   * Whether there are no outstanding microtasks or microtasks.\n   */\n  get isStable(): boolean { return this._isStable; }\n\n  /**\n   * Whether there are any outstanding microtasks.\n   */\n  get hasPendingMicrotasks(): boolean { return this._hasPendingMicrotasks; }\n\n  /**\n   * Whether there are any outstanding microtasks.\n   */\n  get hasPendingMacrotasks(): boolean { return this._hasPendingMacrotasks; }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run(fn: () => any): any { return this._zoneImpl.runInner(fn); }\n\n  /**\n   * Same as #run, except that synchronous errors are caught and forwarded\n   * via `onError` and not rethrown.\n   */\n  runGuarded(fn: () => any): any { return this._zoneImpl.runInnerGuarded(fn); }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular(fn: () => any): any { return this._zoneImpl.runOuter(fn); }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}